From 9afa855f7109c548b19c8432a181d007ac31fe31 Mon Sep 17 00:00:00 2001
From: Bhasker Neti <bneti@codeaurora.org>
Date: Mon, 3 Dec 2012 17:18:47 +0530
Subject: [PATCH 10/10] settings: add support for bluez stack

This is a combination of 5 commits.

Bluetooth: Add JB tip Bluetooth code to build with bluez based solution

Add JB tip Bluetooth Settings code to build with bluez based solution and
existing Bluetooth Settings code to support bluedroid based solution.
Android.mk file contains the change to toggle between the solution
as needed.

Change-Id: I06244e05419b799bc232e52712a5a171b7f57ee9

Conflicts:

	res/layout/bluetooth_mas_access.xml

Bluetooth: Introduce BluetoothProgressCategory class

Replace ProgressCategory class with BluetoothProgressCategory class
for making use of common settings resources

Change-Id: Icabddba794336232af4211ca32319f37b4a45167

Merge commit 'android-4.2.2_r1' into Upgrade_branch

Change-Id: I3a7b737e7331d11f6d41dce76465af60c5cb841f

Bluetooth: Proper update of the profile list on SDP updates

Updates the profile cache with new UUIDs arrived as part of
SDP results without clearing the existing profiles. This
fixes the IOT issue of few carkits with improper intermediate
UUID updates

Change-Id: I37b2eaf8e873b2798b3b838d15383811b4093c38
CRs-fixed: 450068

Bluetooth: Proper Enable/Disable of Pairing dialogue's OK button

Disable the OK button when there is no suffecient char/keys
entereted on the Pairng dailog's text bx. This would block the
user from trying to pair without having the right PIN key length

CRs-fixed: 455063

Change-Id: Ia9c0d1bfb1f202dadaa82ad9e4de059b90aea044
---
 Android.mk                                         |   17 +
 res/layout/bluetooth_dun_access.xml                |   49 ++
 res/layout/bluetooth_ftp_access.xml                |   49 ++
 res/layout/bluetooth_mas_access.xml                |    2 +-
 res/layout/bluetooth_sap_access.xml                |   49 ++
 res/values/strings.xml                             |   67 +-
 .../settings/bluetooth_msm/A2dpProfile.java        |  165 ++++
 .../settings/bluetooth_msm/BluetoothCallback.java  |   29 +
 .../bluetooth_msm/BluetoothDeviceFilter.java       |  169 ++++
 .../bluetooth_msm/BluetoothDevicePreference.java   |  307 +++++++
 .../BluetoothDiscoverableEnabler.java              |  281 +++++++
 .../bluetooth_msm/BluetoothDiscoveryReceiver.java  |   47 ++
 .../settings/bluetooth_msm/BluetoothEnabler.java   |  142 ++++
 .../bluetooth_msm/BluetoothEventManager.java       |  410 +++++++++
 .../bluetooth_msm/BluetoothNameDialogFragment.java |  208 +++++
 .../bluetooth_msm/BluetoothPairingDialog.java      |  411 +++++++++
 .../bluetooth_msm/BluetoothPairingRequest.java     |  120 +++
 .../bluetooth_msm/BluetoothPermissionActivity.java |  463 +++++++++++
 .../bluetooth_msm/BluetoothPermissionRequest.java  |  240 ++++++
 .../bluetooth_msm/BluetoothProgressCategory.java   |   29 +
 .../settings/bluetooth_msm/BluetoothSettings.java  |  388 +++++++++
 .../BluetoothVisibilityTimeoutFragment.java        |   68 ++
 .../bluetooth_msm/CachedBluetoothDevice.java       |  691 ++++++++++++++++
 .../CachedBluetoothDeviceManager.java              |  155 ++++
 .../android/settings/bluetooth_msm/DUNProfile.java |  125 +++
 .../DeviceListPreferenceFragment.java              |  227 +++++
 .../bluetooth_msm/DevicePickerActivity.java        |   35 +
 .../bluetooth_msm/DevicePickerFragment.java        |  109 +++
 .../bluetooth_msm/DeviceProfilesSettings.java      |  428 ++++++++++
 .../settings/bluetooth_msm/DockEventReceiver.java  |  152 ++++
 .../settings/bluetooth_msm/DockService.java        |  871 ++++++++++++++++++++
 .../settings/bluetooth_msm/HeadsetProfile.java     |  195 +++++
 .../android/settings/bluetooth_msm/HidProfile.java |  152 ++++
 .../bluetooth_msm/LocalBluetoothAdapter.java       |  228 +++++
 .../bluetooth_msm/LocalBluetoothManager.java       |  123 +++
 .../bluetooth_msm/LocalBluetoothPreferences.java   |  157 ++++
 .../bluetooth_msm/LocalBluetoothProfile.java       |   71 ++
 .../LocalBluetoothProfileManager.java              |  476 +++++++++++
 .../android/settings/bluetooth_msm/OppProfile.java |   89 ++
 .../android/settings/bluetooth_msm/PanProfile.java |  157 ++++
 .../bluetooth_msm/RequestPermissionActivity.java   |  300 +++++++
 .../RequestPermissionHelperActivity.java           |  165 ++++
 .../android/settings/bluetooth_msm/SapProfile.java |  125 +++
 .../bluetooth_msm/Utf8ByteLengthFilter.java        |   84 ++
 src/com/android/settings/bluetooth_msm/Utils.java  |  131 +++
 45 files changed, 8954 insertions(+), 2 deletions(-)
 create mode 100644 res/layout/bluetooth_dun_access.xml
 create mode 100644 res/layout/bluetooth_ftp_access.xml
 create mode 100644 res/layout/bluetooth_sap_access.xml
 create mode 100644 src/com/android/settings/bluetooth_msm/A2dpProfile.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothCallback.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothDeviceFilter.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothDevicePreference.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothDiscoverableEnabler.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothDiscoveryReceiver.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothEnabler.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothEventManager.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothNameDialogFragment.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothPairingDialog.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothPairingRequest.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothPermissionActivity.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothPermissionRequest.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothProgressCategory.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothSettings.java
 create mode 100644 src/com/android/settings/bluetooth_msm/BluetoothVisibilityTimeoutFragment.java
 create mode 100644 src/com/android/settings/bluetooth_msm/CachedBluetoothDevice.java
 create mode 100644 src/com/android/settings/bluetooth_msm/CachedBluetoothDeviceManager.java
 create mode 100644 src/com/android/settings/bluetooth_msm/DUNProfile.java
 create mode 100644 src/com/android/settings/bluetooth_msm/DeviceListPreferenceFragment.java
 create mode 100644 src/com/android/settings/bluetooth_msm/DevicePickerActivity.java
 create mode 100644 src/com/android/settings/bluetooth_msm/DevicePickerFragment.java
 create mode 100644 src/com/android/settings/bluetooth_msm/DeviceProfilesSettings.java
 create mode 100644 src/com/android/settings/bluetooth_msm/DockEventReceiver.java
 create mode 100644 src/com/android/settings/bluetooth_msm/DockService.java
 create mode 100644 src/com/android/settings/bluetooth_msm/HeadsetProfile.java
 create mode 100644 src/com/android/settings/bluetooth_msm/HidProfile.java
 create mode 100644 src/com/android/settings/bluetooth_msm/LocalBluetoothAdapter.java
 create mode 100644 src/com/android/settings/bluetooth_msm/LocalBluetoothManager.java
 create mode 100644 src/com/android/settings/bluetooth_msm/LocalBluetoothPreferences.java
 create mode 100644 src/com/android/settings/bluetooth_msm/LocalBluetoothProfile.java
 create mode 100644 src/com/android/settings/bluetooth_msm/LocalBluetoothProfileManager.java
 create mode 100644 src/com/android/settings/bluetooth_msm/OppProfile.java
 create mode 100644 src/com/android/settings/bluetooth_msm/PanProfile.java
 create mode 100644 src/com/android/settings/bluetooth_msm/RequestPermissionActivity.java
 create mode 100644 src/com/android/settings/bluetooth_msm/RequestPermissionHelperActivity.java
 create mode 100644 src/com/android/settings/bluetooth_msm/SapProfile.java
 create mode 100644 src/com/android/settings/bluetooth_msm/Utf8ByteLengthFilter.java
 create mode 100644 src/com/android/settings/bluetooth_msm/Utils.java

diff --git a/Android.mk b/Android.mk
index 37604c6..783360e 100644
--- a/Android.mk
+++ b/Android.mk
@@ -8,6 +8,23 @@ LOCAL_MODULE_TAGS := optional
 
 LOCAL_SRC_FILES := $(call all-java-files-under, src)
 
+BLUETOOTH_SRC := \
+        src/com/android/settings/bluetooth \
+
+BLUETOOTH_MSM_SRC := \
+        src/com/android/settings/bluetooth_msm \
+
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ), true)
+    LOCAL_SRC_FILES := $(filter-out \
+                        $(call find-other-java-files, $(BLUETOOTH_SRC)) \
+                        ,$(LOCAL_SRC_FILES))
+else
+    LOCAL_SRC_FILES := $(filter-out \
+                        $(call find-other-java-files, $(BLUETOOTH_MSM_SRC)) \
+                        ,$(LOCAL_SRC_FILES))
+endif
+
+
 LOCAL_PACKAGE_NAME := Settings
 LOCAL_CERTIFICATE := platform
 
diff --git a/res/layout/bluetooth_dun_access.xml b/res/layout/bluetooth_dun_access.xml
new file mode 100644
index 0000000..47cba82
--- /dev/null
+++ b/res/layout/bluetooth_dun_access.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+ ** Copyright 2008, The Android Open Source Project
+ ** Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+-->
+
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_height="match_parent"
+    android:layout_width="match_parent">
+
+    <LinearLayout
+        android:layout_height="match_parent"
+        android:layout_width="match_parent"
+        android:orientation="vertical">
+
+        <TextView
+            android:id="@+id/message"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="20dip"
+            android:layout_marginRight="20dip"
+            android:gravity="center_horizontal"
+            android:textAppearance="?android:attr/textAppearanceMedium" />
+
+        <CheckBox android:id="@+id/bluetooth_dun_remember_choice"
+            style="?android:attr/textAppearanceMedium"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="2dip"
+            android:text="@string/bluetooth_dun_remember_choice" />
+
+    </LinearLayout>
+
+</ScrollView>
diff --git a/res/layout/bluetooth_ftp_access.xml b/res/layout/bluetooth_ftp_access.xml
new file mode 100644
index 0000000..385c4a8
--- /dev/null
+++ b/res/layout/bluetooth_ftp_access.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+** Copyright (c) 2011, The Linux Foundation. All rights reserved.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_height="match_parent"
+    android:layout_width="match_parent">
+
+    <LinearLayout
+        android:layout_height="match_parent"
+        android:layout_width="match_parent"
+        android:orientation="vertical">
+
+        <TextView
+            android:id="@+id/message"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="20dip"
+            android:layout_marginRight="20dip"
+            android:gravity="center_horizontal"
+            android:textAppearance="?android:attr/textAppearanceMedium" />
+
+        <CheckBox android:id="@+id/bluetooth_ftp_remember_choice"
+            style="?android:attr/textAppearanceMedium"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="2dip"
+            android:text="@string/bluetooth_ftp_remember_choice" />
+
+    </LinearLayout>
+
+</ScrollView>
diff --git a/res/layout/bluetooth_mas_access.xml b/res/layout/bluetooth_mas_access.xml
index dc7c2d5..11fb614 100644
--- a/res/layout/bluetooth_mas_access.xml
+++ b/res/layout/bluetooth_mas_access.xml
@@ -2,7 +2,7 @@
 <!--
 /*
 ** Copyright 2009, The Android Open Source Project
-** Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+** Copyright (c) 2011, The Linux Foundation. All rights reserved.
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
diff --git a/res/layout/bluetooth_sap_access.xml b/res/layout/bluetooth_sap_access.xml
new file mode 100644
index 0000000..d9c1685
--- /dev/null
+++ b/res/layout/bluetooth_sap_access.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+ ** Copyright 2008, The Android Open Source Project
+ ** Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+-->
+
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_height="match_parent"
+    android:layout_width="match_parent">
+
+    <LinearLayout
+        android:layout_height="match_parent"
+        android:layout_width="match_parent"
+        android:orientation="vertical">
+
+        <TextView
+            android:id="@+id/message"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="20dip"
+            android:layout_marginRight="20dip"
+            android:gravity="center_horizontal"
+            android:textAppearance="?android:attr/textAppearanceMedium" />
+
+        <CheckBox android:id="@+id/bluetooth_sap_remember_choice"
+            style="?android:attr/textAppearanceMedium"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="2dip"
+            android:text="@string/bluetooth_sap_remember_choice" />
+
+    </LinearLayout>
+
+</ScrollView>
diff --git a/res/values/strings.xml b/res/values/strings.xml
index 912782d..e948794 100644
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -229,6 +229,8 @@
     <string name="bluetooth_is_discoverable">Visible to all nearby Bluetooth devices (<xliff:g id="discoverable_time_period">%1$s</xliff:g>)</string>
     <!-- Bluetooth settings screen, summary when Discoverable duration is set to "forever" [CHAR LIMIT=50] -->
     <string name="bluetooth_is_discoverable_always">Visible to all nearby Bluetooth devices</string>
+	<!-- Bluetooth devices settings. Text that appears when scanning for devices is finished and no nearby device was found [CHAR LIMIT=40]-->
+    <string name="bluetooth_devices_no_devices_found">No nearby Bluetooth devices were found.</string>
     <!-- Bluetooth settings screen, summary text when not discoverable and no paired devices [CHAR LIMIT=50] -->
     <string name="bluetooth_not_visible_to_other_devices">Not visible to other Bluetooth devices</string>
     <!-- Bluetooth settings screen, summary text when not discoverable with paired devices [CHAR LIMIT=50] -->
@@ -342,6 +344,20 @@
     <!-- Activity label of BluetoothPermissionActivity [CHAR LIMIT=none]-->
     <string name="bluetooth_connection_permission_request">"Bluetooth connection request"</string>
 
+    <!-- Activity label of BluetoothPermissionActivity for PBAP [CHAR LIMIT=none]-->
+    <string name="bluetooth_pbap_connection_permission_request">"Pbap connection request"</string>
+
+    <!-- Activity label of BluetoothPermissionActivity for FTP [CHAR LIMIT=none]-->
+    <string name="bluetooth_ftp_connection_permission_request">"Ftp connection request"</string>
+
+    <!-- Activity label of BluetoothPermissionActivity for MAP [CHAR LIMIT=none]-->
+    <string name="bluetooth_map_connection_permission_request">"Map connection request"</string>
+
+    <!-- Activity label of BluetoothPermissionActivity for SAP [CHAR LIMIT=none]-->
+    <string name="bluetooth_sap_connection_permission_request">"Sap connection request"</string>
+
+    <string name="bluetooth_dun_connection_permission_request">"Dun connection request"</string>
+
     <!-- Notification message when a remote Bluetooth device wants to connect to a Bluetooth profile [CHAR LIMIT=none]-->
     <string name="bluetooth_connection_notif_message">"Touch to connect to \u0022<xliff:g id="device_name">%1$s</xliff:g>\u0022."</string>
 
@@ -357,6 +373,37 @@
     <!-- Bluetooth phone book permission Alert Activity checkbox text [CHAR LIMIT=none] -->
     <string name="bluetooth_pb_remember_choice">Don\'t ask again</string>
 
+    <!-- Activity label of BluetoothFtpPermissionActivity, also used as Strings in the permission dialog [CHAR LIMIT=none] -->
+    <string name="bluetooth_ftp_request">"Ftp request"</string>
+
+    <!-- Bluetooth FTP permission Alert Activity text [CHAR LIMIT=none] -->
+    <string name="bluetooth_ftp_acceptance_dialog_text">%1$s would like to access your files and folders. Give access to %2$s?</string>
+
+    <!-- Bluetooth FTP permission Alert Activity checkbox text [CHAR LIMIT=none] -->
+    <string name="bluetooth_ftp_remember_choice">Don\'t ask again</string>
+
+    <!-- Activity label of BluetoothMasPermissionActivity, also used as Strings in the permission dialog [CHAR LIMIT=none] -->
+    <string name="bluetooth_mas_request">"Message Access request"</string>
+
+    <!-- Bluetooth MAS permission Alert Activity text [CHAR LIMIT=none] -->
+    <string name="bluetooth_mas_acceptance_dialog_text">%1$s would like to access your messages. Give access to %2$s?</string>
+
+    <!-- Bluetooth MAS permission Alert Activity checkbox text [CHAR LIMIT=none] -->
+    <string name="bluetooth_mas_remember_choice">Don\'t ask again</string>
+    <!-- Activity label of BluetoothSapPermissionActivity, also used as Strings in the permission di
+alog [CHAR LIMIT=none] -->
+    <string name="bluetooth_sap_request">"SAP request"</string>
+    <!-- Bluetooth SAP permission Alert Activity text [CHAR LIMIT=none] -->
+    <string name="bluetooth_sap_acceptance_dialog_text">%1$s would like to access your SIM. Give access to %2$s?</string>
+    <!-- Bluetooth SAP permission Alert Activity checkbox text [CHAR LIMIT=none] -->
+    <string name="bluetooth_sap_remember_choice">Don\'t ask again</string>
+
+    <string name="bluetooth_dun_request">"DUN request"</string>
+    <!-- Bluetooth DUN permission Alert Activity text [CHAR LIMIT=none] -->
+    <string name="bluetooth_dun_acceptance_dialog_text">%1$s would like to use DUN. Give access to %2$s?</string>
+    <!-- Bluetooth DUN permission Alert Activity checkbox text [CHAR LIMIT=none] -->
+    <string name="bluetooth_dun_remember_choice">Don\'t ask again</string>
+
     <!-- Date & time settings screen title -->
     <string name="date_and_time">Date &amp; time settings</string>
     <!-- The title of the activity to pick a time zone. -->
@@ -1007,6 +1054,9 @@
     <!-- Message when bluetooth dialog for pin entry is showing. [CHAR LIMIT=NONE] -->
     <string name="bluetooth_enter_pin_msg">To pair with:<xliff:g id="bold">&lt;br>&lt;b></xliff:g><xliff:g id="device_name">%1$s</xliff:g><xliff:g id="end_bold">&lt;/b>&lt;br>&lt;br></xliff:g>Type the device\'s required PIN:</string>
 
+    <!-- Message when bluetooth dialog for pin entry is showing  when HIGH security enabled-->
+    <string name="bluetooth_enter_pin_msg_hs">\nType PIN to pair with \u0022<xliff:g id="device_name">%1$s</xliff:g>\u0022. [High Security Enabled: Needs 16 character key] </string>
+
     <!-- Message when bluetooth dialog for passkey entry is showing. [CHAR LIMIT=NONE] -->
     <string name="bluetooth_enter_passkey_msg">To pair with:<xliff:g id="bold">&lt;br>&lt;b></xliff:g><xliff:g id="device_name">%1$s</xliff:g><xliff:g id="end_bold">&lt;/b>&lt;br>&lt;br></xliff:g>Type the device\'s required passkey:</string>
 
@@ -1097,7 +1147,10 @@
     <string name="bluetooth_profile_pan">Internet access</string>
     <!-- Bluetooth settings. The user-visible string that is used whenever referring to the PAN profile (sharing this device's Internet connection). [CHAR LIMIT=40]-->
     <string name="bluetooth_profile_pan_nap">Internet connection sharing</string>
-
+    <!-- Bluetooth settings.  The user-visible string that is used whenever referring to the SAP profile. -->
+    <string name="bluetooth_profile_sap">SIM Access</string>
+    <!-- Bluetooth settings.  The user-visible string that is used whenever referring to the DUN profile. -->
+    <string name="bluetooth_profile_dun">Dial-up Network Access</string>
     <!-- Bluetooth settings.  Message for disconnecting from the A2DP profile. [CHAR LIMIT=80] -->
     <string name="bluetooth_disconnect_a2dp_profile"><xliff:g id="device_name">%1$s</xliff:g> will be disconnected from media audio.</string>
     <!-- Bluetooth settings.  Message for disconnecting from the headset profile. [CHAR LIMIT=80] -->
@@ -1129,8 +1182,16 @@
     <string name="bluetooth_headset_profile_summary_connected">Connected to phone audio</string>
     <!-- Bluetooth settings.  Connection options screen.  The summary for the OPP checkbox preference when OPP is connected. -->
     <string name="bluetooth_opp_profile_summary_connected">Connected to file transfer server</string>
+    <!-- Bluetooth settings.  Connection options screen.  The summary for the SAP checkbox preference when SAP is connected. -->
+    <string name="bluetooth_sap_profile_summary_connected">Connected to SIM Access Server</string>
+    <!-- Bluetooth settings.  Connection options screen.  The summary for the DUN checkbox preference when DUN is connected. -->
+    <string name="bluetooth_dun_profile_summary_connected">Connected to DUN Server</string>
     <!-- Bluetooth settings.  Connection options screen.  The summary for the OPP checkbox preference when OPP is not connected. -->
     <string name="bluetooth_opp_profile_summary_not_connected">Not connected to file transfer server</string>
+    <!-- Bluetooth settings.  Connection options screen.  The summary for the SAP checkbox preference when SAP is not connected. -->
+    <string name="bluetooth_sap_profile_summary_not_connected">Not connected to SIM Access Server</string>
+    <!-- Bluetooth settings.  Connection options screen.  The summary for the DUN checkbox preference when DUN is not connected. -->
+    <string name="bluetooth_dun_profile_summary_not_connected">Not connected to DUN Server</string>
     <!-- Bluetooth settings. Connection options screen. The summary for the HID checkbox preference when HID is connected. -->
     <string name="bluetooth_hid_profile_summary_connected">Connected to input device</string>
     <!-- Bluetooth settings. Connection options screen. The summary for the checkbox preference when PAN is connected (user role). [CHAR LIMIT=25]-->
@@ -1144,6 +1205,10 @@
     <string name="bluetooth_headset_profile_summary_use_for">Use for phone audio</string>
     <!-- Bluetooth settings.  Connection options screen.  The summary for the OPP checkbox preference that describes how checking it will set the OPP profile as preferred. -->
     <string name="bluetooth_opp_profile_summary_use_for">Use for file transfer</string>
+    <!-- Bluetooth settings.  Connection options screen.  The summary for the SAP checkbox preference that describes how checking it will set the SAP profile as preferred. -->
+    <string name="bluetooth_sap_profile_summary_use_for">Use for SIM Access</string>
+    <!-- Bluetooth settings.  Connection options screen.  The summary for the DUN checkbox preference that describes how checking it will set the DUN profile as preferred. -->
+    <string name="bluetooth_dun_profile_summary_use_for">Use for Dial-up Network Access</string>
     <!-- Bluetooth settings. Connection options screen. The summary
          for the HID checkbox preference that describes how checking it
          will set the HID profile as preferred. -->
diff --git a/src/com/android/settings/bluetooth_msm/A2dpProfile.java b/src/com/android/settings/bluetooth_msm/A2dpProfile.java
new file mode 100644
index 0000000..8fca4c7
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/A2dpProfile.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothUuid;
+import android.content.Context;
+import android.os.ParcelUuid;
+
+import com.android.settings.R;
+
+import java.util.List;
+
+/**
+ * A2dpProfile handles Bluetooth A2DP.
+ * TODO: add null checks around calls to mService object.
+ */
+final class A2dpProfile implements LocalBluetoothProfile {
+    private BluetoothA2dp mService;
+
+    static final ParcelUuid[] SINK_UUIDS = {
+        BluetoothUuid.AudioSink,
+        BluetoothUuid.AdvAudioDist,
+    };
+
+    static final String NAME = "A2DP";
+
+    // Order of this profile in device profiles list
+    private static final int ORDINAL = 1;
+
+    // These callbacks run on the main thread.
+    private final class A2dpServiceListener
+            implements BluetoothProfile.ServiceListener {
+
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            mService = (BluetoothA2dp) proxy;
+        }
+
+        public void onServiceDisconnected(int profile) {
+            mService = null;
+        }
+    }
+
+    A2dpProfile(Context context) {
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        adapter.getProfileProxy(context, new A2dpServiceListener(),
+                BluetoothProfile.A2DP);
+    }
+
+    public boolean isConnectable() {
+        return true;
+    }
+
+    public boolean isAutoConnectable() {
+        return true;
+    }
+
+    private List<BluetoothDevice> getConnectedDevices() {
+        return mService.getDevicesMatchingConnectionStates(
+              new int[] {BluetoothProfile.STATE_CONNECTED,
+                         BluetoothProfile.STATE_CONNECTING,
+                         BluetoothProfile.STATE_DISCONNECTING});
+    }
+
+    public boolean connect(BluetoothDevice device) {
+        if (mService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED)
+            return true;
+
+        List<BluetoothDevice> sinks = getConnectedDevices();
+        if (sinks != null) {
+            for (BluetoothDevice sink : sinks) {
+                mService.disconnect(sink);
+            }
+        }
+        return mService.connect(device);
+    }
+
+    public boolean disconnect(BluetoothDevice device) {
+        return mService.disconnect(device);
+    }
+
+    public int getConnectionStatus(BluetoothDevice device) {
+        return mService.getConnectionState(device);
+    }
+
+    public boolean isPreferred(BluetoothDevice device) {
+        return mService.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
+    }
+
+    public int getPreferred(BluetoothDevice device) {
+        return mService.getPriority(device);
+    }
+
+    public void setPreferred(BluetoothDevice device, boolean preferred) {
+        if (preferred) {
+            if (mService.getPriority(device) < BluetoothProfile.PRIORITY_ON) {
+                mService.setPriority(device, BluetoothProfile.PRIORITY_ON);
+            }
+        } else {
+            mService.setPriority(device, BluetoothProfile.PRIORITY_OFF);
+        }
+    }
+
+    boolean isA2dpPlaying() {
+        List<BluetoothDevice> sinks = mService.getConnectedDevices();
+        if (!sinks.isEmpty()) {
+            if (mService.isA2dpPlaying(sinks.get(0))) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean isProfileReady() {
+        return mService != null;
+    }
+
+    public String toString() {
+        return NAME;
+    }
+
+    public int getOrdinal() {
+        return ORDINAL;
+    }
+
+    public int getNameResource(BluetoothDevice device) {
+        return R.string.bluetooth_profile_a2dp;
+    }
+
+    public int getSummaryResourceForDevice(BluetoothDevice device) {
+        int state = mService.getConnectionState(device);
+        switch (state) {
+            case BluetoothProfile.STATE_DISCONNECTED:
+                return R.string.bluetooth_a2dp_profile_summary_use_for;
+
+            case BluetoothProfile.STATE_CONNECTED:
+                return R.string.bluetooth_a2dp_profile_summary_connected;
+
+            default:
+                return Utils.getConnectionStateSummary(state);
+        }
+    }
+
+    public int getDrawableResource(BluetoothClass btClass) {
+        return R.drawable.ic_bt_headphones_a2dp;
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothCallback.java b/src/com/android/settings/bluetooth_msm/BluetoothCallback.java
new file mode 100644
index 0000000..3ce9adf
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothCallback.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+/**
+ * BluetoothCallback provides a callback interface for the settings
+ * UI to receive events from {@link BluetoothEventManager}.
+ */
+interface BluetoothCallback {
+    void onBluetoothStateChanged(int bluetoothState);
+    void onScanningStateChanged(boolean started);
+    void onDeviceAdded(CachedBluetoothDevice cachedDevice);
+    void onDeviceDeleted(CachedBluetoothDevice cachedDevice);
+    void onDeviceBondStateChanged(CachedBluetoothDevice cachedDevice, int bondState);
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothDeviceFilter.java b/src/com/android/settings/bluetooth_msm/BluetoothDeviceFilter.java
new file mode 100644
index 0000000..e4f11a2
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothDeviceFilter.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothUuid;
+import android.os.ParcelUuid;
+import android.util.Log;
+
+/**
+ * BluetoothDeviceFilter contains a static method that returns a
+ * Filter object that returns whether or not the BluetoothDevice
+ * passed to it matches the specified filter type constant from
+ * {@link android.bluetooth.BluetoothDevicePicker}.
+ */
+final class BluetoothDeviceFilter {
+    private static final String TAG = "BluetoothDeviceFilter";
+
+    /** The filter interface to external classes. */
+    interface Filter {
+        boolean matches(BluetoothDevice device);
+    }
+
+    /** All filter singleton (referenced directly). */
+    static final Filter ALL_FILTER = new AllFilter();
+
+    /** Bonded devices only filter (referenced directly). */
+    static final Filter BONDED_DEVICE_FILTER = new BondedDeviceFilter();
+
+    /** Unbonded devices only filter (referenced directly). */
+    static final Filter UNBONDED_DEVICE_FILTER = new UnbondedDeviceFilter();
+
+    /** Table of singleton filter objects. */
+    private static final Filter[] FILTERS = {
+            ALL_FILTER,             // FILTER_TYPE_ALL
+            new AudioFilter(),      // FILTER_TYPE_AUDIO
+            new TransferFilter(),   // FILTER_TYPE_TRANSFER
+            new PanuFilter(),       // FILTER_TYPE_PANU
+            new NapFilter()         // FILTER_TYPE_NAP
+    };
+
+    /** Private constructor. */
+    private BluetoothDeviceFilter() {
+    }
+
+    /**
+     * Returns the singleton {@link Filter} object for the specified type,
+     * or {@link #ALL_FILTER} if the type value is out of range.
+     *
+     * @param filterType a constant from BluetoothDevicePicker
+     * @return a singleton object implementing the {@link Filter} interface.
+     */
+    static Filter getFilter(int filterType) {
+        if (filterType >= 0 && filterType < FILTERS.length) {
+            return FILTERS[filterType];
+        } else {
+            Log.w(TAG, "Invalid filter type " + filterType + " for device picker");
+            return ALL_FILTER;
+        }
+    }
+
+    /** Filter that matches all devices. */
+    private static final class AllFilter implements Filter {
+        public boolean matches(BluetoothDevice device) {
+            return true;
+        }
+    }
+
+    /** Filter that matches only bonded devices. */
+    private static final class BondedDeviceFilter implements Filter {
+        public boolean matches(BluetoothDevice device) {
+            return device.getBondState() == BluetoothDevice.BOND_BONDED;
+        }
+    }
+
+    /** Filter that matches only unbonded devices. */
+    private static final class UnbondedDeviceFilter implements Filter {
+        public boolean matches(BluetoothDevice device) {
+            return device.getBondState() != BluetoothDevice.BOND_BONDED;
+        }
+    }
+
+    /** Parent class of filters based on UUID and/or Bluetooth class. */
+    private abstract static class ClassUuidFilter implements Filter {
+        abstract boolean matches(ParcelUuid[] uuids, BluetoothClass btClass);
+
+        public boolean matches(BluetoothDevice device) {
+            return matches(device.getUuids(), device.getBluetoothClass());
+        }
+    }
+
+    /** Filter that matches devices that support AUDIO profiles. */
+    private static final class AudioFilter extends ClassUuidFilter {
+        @Override
+        boolean matches(ParcelUuid[] uuids, BluetoothClass btClass) {
+            if (uuids != null) {
+                if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SINK_UUIDS)) {
+                    return true;
+                }
+                if (BluetoothUuid.containsAnyUuid(uuids, HeadsetProfile.UUIDS)) {
+                    return true;
+                }
+            } else if (btClass != null) {
+                if (btClass.doesClassMatch(BluetoothClass.PROFILE_A2DP) ||
+                        btClass.doesClassMatch(BluetoothClass.PROFILE_HEADSET)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+
+    /** Filter that matches devices that support Object Transfer. */
+    private static final class TransferFilter extends ClassUuidFilter {
+        @Override
+        boolean matches(ParcelUuid[] uuids, BluetoothClass btClass) {
+            if (uuids != null) {
+                if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.ObexObjectPush)) {
+                    return true;
+                }
+            }
+            return btClass != null
+                    && btClass.doesClassMatch(BluetoothClass.PROFILE_OPP);
+        }
+    }
+
+    /** Filter that matches devices that support PAN User (PANU) profile. */
+    private static final class PanuFilter extends ClassUuidFilter {
+        @Override
+        boolean matches(ParcelUuid[] uuids, BluetoothClass btClass) {
+            if (uuids != null) {
+                if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.PANU)) {
+                    return true;
+                }
+            }
+            return btClass != null
+                    && btClass.doesClassMatch(BluetoothClass.PROFILE_PANU);
+        }
+    }
+
+    /** Filter that matches devices that support NAP profile. */
+    private static final class NapFilter extends ClassUuidFilter {
+        @Override
+        boolean matches(ParcelUuid[] uuids, BluetoothClass btClass) {
+            if (uuids != null) {
+                if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.NAP)) {
+                    return true;
+                }
+            }
+            return btClass != null
+                    && btClass.doesClassMatch(BluetoothClass.PROFILE_NAP);
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothDevicePreference.java b/src/com/android/settings/bluetooth_msm/BluetoothDevicePreference.java
new file mode 100644
index 0000000..a443f5a
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothDevicePreference.java
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.app.AlertDialog;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothProfile;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.graphics.drawable.Drawable;
+import android.preference.Preference;
+import android.text.Html;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.TypedValue;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+
+import com.android.settings.R;
+
+import java.util.List;
+
+/**
+ * BluetoothDevicePreference is the preference type used to display each remote
+ * Bluetooth device in the Bluetooth Settings screen.
+ */
+public final class BluetoothDevicePreference extends Preference implements
+        CachedBluetoothDevice.Callback, OnClickListener {
+    private static final String TAG = "BluetoothDevicePreference";
+
+    private static int sDimAlpha = Integer.MIN_VALUE;
+
+    private final CachedBluetoothDevice mCachedDevice;
+
+    private OnClickListener mOnSettingsClickListener;
+
+    private AlertDialog mDisconnectDialog;
+
+    public BluetoothDevicePreference(Context context, CachedBluetoothDevice cachedDevice) {
+        super(context);
+
+        if (sDimAlpha == Integer.MIN_VALUE) {
+            TypedValue outValue = new TypedValue();
+            context.getTheme().resolveAttribute(android.R.attr.disabledAlpha, outValue, true);
+            sDimAlpha = (int) (outValue.getFloat() * 255);
+        }
+
+        mCachedDevice = cachedDevice;
+
+        if (cachedDevice.getBondState() == BluetoothDevice.BOND_BONDED) {
+            setWidgetLayoutResource(R.layout.preference_bluetooth);
+        }
+
+        mCachedDevice.registerCallback(this);
+
+        onDeviceAttributesChanged();
+    }
+
+    CachedBluetoothDevice getCachedDevice() {
+        return mCachedDevice;
+    }
+
+    public void setOnSettingsClickListener(OnClickListener listener) {
+        mOnSettingsClickListener = listener;
+    }
+
+    @Override
+    protected void onPrepareForRemoval() {
+        super.onPrepareForRemoval();
+        mCachedDevice.unregisterCallback(this);
+        if (mDisconnectDialog != null) {
+            mDisconnectDialog.dismiss();
+            mDisconnectDialog = null;
+        }
+    }
+
+    public void onDeviceAttributesChanged() {
+        /*
+         * The preference framework takes care of making sure the value has
+         * changed before proceeding. It will also call notifyChanged() if
+         * any preference info has changed from the previous value.
+         */
+        setTitle(mCachedDevice.getName());
+
+        int summaryResId = getConnectionSummary();
+        if (summaryResId != 0) {
+            setSummary(summaryResId);
+        } else {
+            setSummary(null);   // empty summary for unpaired devices
+        }
+
+        int iconResId = getBtClassDrawable();
+        if (iconResId != 0) {
+            setIcon(iconResId);
+        }
+
+        // Used to gray out the item
+        setEnabled(!mCachedDevice.isBusy());
+
+        // This could affect ordering, so notify that
+        notifyHierarchyChanged();
+    }
+
+    @Override
+    protected void onBindView(View view) {
+        // Disable this view if the bluetooth enable/disable preference view is off
+        if (null != findPreferenceInHierarchy("bt_checkbox")) {
+            setDependency("bt_checkbox");
+        }
+
+        if (mCachedDevice.getBondState() == BluetoothDevice.BOND_BONDED) {
+            ImageView deviceDetails = (ImageView) view.findViewById(R.id.deviceDetails);
+            if (deviceDetails != null) {
+                deviceDetails.setOnClickListener(this);
+                deviceDetails.setTag(mCachedDevice);
+                deviceDetails.setAlpha(isEnabled() ? 255 : sDimAlpha);
+            }
+        }
+
+        super.onBindView(view);
+    }
+
+    public void onClick(View v) {
+        // Should never be null by construction
+        if (mOnSettingsClickListener != null) {
+            mOnSettingsClickListener.onClick(v);
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if ((o == null) || !(o instanceof BluetoothDevicePreference)) {
+            return false;
+        }
+        return mCachedDevice.equals(
+                ((BluetoothDevicePreference) o).mCachedDevice);
+    }
+
+    @Override
+    public int hashCode() {
+        return mCachedDevice.hashCode();
+    }
+
+    @Override
+    public int compareTo(Preference another) {
+        if (!(another instanceof BluetoothDevicePreference)) {
+            // Rely on default sort
+            return super.compareTo(another);
+        }
+
+        return mCachedDevice
+                .compareTo(((BluetoothDevicePreference) another).mCachedDevice);
+    }
+
+    void onClicked() {
+        int bondState = mCachedDevice.getBondState();
+
+        if (mCachedDevice.isConnected()) {
+            askDisconnect();
+        } else if (bondState == BluetoothDevice.BOND_BONDED) {
+            mCachedDevice.connect(true);
+        } else if (bondState == BluetoothDevice.BOND_NONE) {
+            pair();
+        }
+    }
+
+    // Show disconnect confirmation dialog for a device.
+    private void askDisconnect() {
+        Context context = getContext();
+        String name = mCachedDevice.getName();
+        if (TextUtils.isEmpty(name)) {
+            name = context.getString(R.string.bluetooth_device);
+        }
+        String message = context.getString(R.string.bluetooth_disconnect_all_profiles, name);
+        String title = context.getString(R.string.bluetooth_disconnect_title);
+
+        DialogInterface.OnClickListener disconnectListener = new DialogInterface.OnClickListener() {
+            public void onClick(DialogInterface dialog, int which) {
+                mCachedDevice.disconnect();
+            }
+        };
+
+        mDisconnectDialog = Utils.showDisconnectDialog(context,
+                mDisconnectDialog, disconnectListener, title, Html.fromHtml(message));
+    }
+
+    private void pair() {
+        if (!mCachedDevice.startPairing()) {
+            Utils.showError(getContext(), mCachedDevice.getName(),
+                    R.string.bluetooth_pairing_error_message);
+        }
+    }
+
+    private int getConnectionSummary() {
+        final CachedBluetoothDevice cachedDevice = mCachedDevice;
+
+        boolean profileConnected = false;       // at least one profile is connected
+        boolean a2dpNotConnected = false;       // A2DP is preferred but not connected
+        boolean headsetNotConnected = false;    // Headset is preferred but not connected
+
+        for (LocalBluetoothProfile profile : cachedDevice.getProfiles()) {
+            int connectionStatus = cachedDevice.getProfileConnectionState(profile);
+
+            switch (connectionStatus) {
+                case BluetoothProfile.STATE_CONNECTING:
+                case BluetoothProfile.STATE_DISCONNECTING:
+                    return Utils.getConnectionStateSummary(connectionStatus);
+
+                case BluetoothProfile.STATE_CONNECTED:
+                    profileConnected = true;
+                    break;
+
+                case BluetoothProfile.STATE_DISCONNECTED:
+                    if (profile.isProfileReady()) {
+                        if (profile instanceof A2dpProfile) {
+                            a2dpNotConnected = true;
+                        } else if (profile instanceof HeadsetProfile) {
+                            headsetNotConnected = true;
+                        }
+                    }
+                    break;
+            }
+        }
+
+        if (profileConnected) {
+            if (a2dpNotConnected && headsetNotConnected) {
+                return R.string.bluetooth_connected_no_headset_no_a2dp;
+            } else if (a2dpNotConnected) {
+                return R.string.bluetooth_connected_no_a2dp;
+            } else if (headsetNotConnected) {
+                return R.string.bluetooth_connected_no_headset;
+            } else {
+                return R.string.bluetooth_connected;
+            }
+        }
+
+        switch (cachedDevice.getBondState()) {
+            case BluetoothDevice.BOND_BONDING:
+                return R.string.bluetooth_pairing;
+
+            case BluetoothDevice.BOND_BONDED:
+            case BluetoothDevice.BOND_NONE:
+            default:
+                return 0;
+        }
+    }
+
+    private int getBtClassDrawable() {
+        BluetoothClass btClass = mCachedDevice.getBtClass();
+        if (btClass != null) {
+            switch (btClass.getMajorDeviceClass()) {
+                case BluetoothClass.Device.Major.COMPUTER:
+                    return R.drawable.ic_bt_laptop;
+
+                case BluetoothClass.Device.Major.PHONE:
+                    return R.drawable.ic_bt_cellphone;
+
+                case BluetoothClass.Device.Major.PERIPHERAL:
+                    return HidProfile.getHidClassDrawable(btClass);
+
+                case BluetoothClass.Device.Major.IMAGING:
+                    return R.drawable.ic_bt_imaging;
+
+                default:
+                    // unrecognized device class; continue
+            }
+        } else {
+            Log.w(TAG, "mBtClass is null");
+        }
+
+        List<LocalBluetoothProfile> profiles = mCachedDevice.getProfiles();
+        for (LocalBluetoothProfile profile : profiles) {
+            int resId = profile.getDrawableResource(btClass);
+            if (resId != 0) {
+                return resId;
+            }
+        }
+        if (btClass != null) {
+            if (btClass.doesClassMatch(BluetoothClass.PROFILE_A2DP)) {
+                return R.drawable.ic_bt_headphones_a2dp;
+
+            }
+            if (btClass.doesClassMatch(BluetoothClass.PROFILE_HEADSET)) {
+                return R.drawable.ic_bt_headset_hfp;
+            }
+        }
+        return 0;
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothDiscoverableEnabler.java b/src/com/android/settings/bluetooth_msm/BluetoothDiscoverableEnabler.java
new file mode 100644
index 0000000..babf1e2
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothDiscoverableEnabler.java
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.os.Handler;
+import android.os.SystemProperties;
+import android.preference.Preference;
+import android.text.format.DateUtils;
+
+import com.android.settings.R;
+
+/**
+ * BluetoothDiscoverableEnabler is a helper to manage the "Discoverable"
+ * checkbox. It sets/unsets discoverability and keeps track of how much time
+ * until the the discoverability is automatically turned off.
+ */
+final class BluetoothDiscoverableEnabler implements Preference.OnPreferenceClickListener {
+
+    private static final String SYSTEM_PROPERTY_DISCOVERABLE_TIMEOUT =
+            "debug.bt.discoverable_time";
+
+    private static final int DISCOVERABLE_TIMEOUT_TWO_MINUTES = 120;
+    private static final int DISCOVERABLE_TIMEOUT_FIVE_MINUTES = 300;
+    private static final int DISCOVERABLE_TIMEOUT_ONE_HOUR = 3600;
+    static final int DISCOVERABLE_TIMEOUT_NEVER = 0;
+
+    // Bluetooth advanced settings screen was replaced with action bar items.
+    // Use the same preference key for discoverable timeout as the old ListPreference.
+    private static final String KEY_DISCOVERABLE_TIMEOUT = "bt_discoverable_timeout";
+
+    private static final String VALUE_DISCOVERABLE_TIMEOUT_TWO_MINUTES = "twomin";
+    private static final String VALUE_DISCOVERABLE_TIMEOUT_FIVE_MINUTES = "fivemin";
+    private static final String VALUE_DISCOVERABLE_TIMEOUT_ONE_HOUR = "onehour";
+    private static final String VALUE_DISCOVERABLE_TIMEOUT_NEVER = "never";
+
+    static final int DEFAULT_DISCOVERABLE_TIMEOUT = DISCOVERABLE_TIMEOUT_TWO_MINUTES;
+
+    private final Context mContext;
+    private final Handler mUiHandler;
+    private final Preference mDiscoveryPreference;
+
+    private final LocalBluetoothAdapter mLocalAdapter;
+
+    private final SharedPreferences mSharedPreferences;
+
+    private boolean mDiscoverable;
+    private int mNumberOfPairedDevices;
+
+    private int mTimeoutSecs = -1;
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (BluetoothAdapter.ACTION_SCAN_MODE_CHANGED.equals(intent.getAction())) {
+                int mode = intent.getIntExtra(BluetoothAdapter.EXTRA_SCAN_MODE,
+                        BluetoothAdapter.ERROR);
+                if (mode != BluetoothAdapter.ERROR) {
+                    handleModeChanged(mode);
+                }
+            }
+        }
+    };
+
+    private final Runnable mUpdateCountdownSummaryRunnable = new Runnable() {
+        public void run() {
+            updateCountdownSummary();
+        }
+    };
+
+    BluetoothDiscoverableEnabler(Context context, LocalBluetoothAdapter adapter,
+            Preference discoveryPreference) {
+        mContext = context;
+        mUiHandler = new Handler();
+        mLocalAdapter = adapter;
+        mDiscoveryPreference = discoveryPreference;
+        mSharedPreferences = discoveryPreference.getSharedPreferences();
+        discoveryPreference.setPersistent(false);
+    }
+
+    public void resume() {
+        if (mLocalAdapter == null) {
+            return;
+        }
+
+        IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
+        mContext.registerReceiver(mReceiver, filter);
+        mDiscoveryPreference.setOnPreferenceClickListener(this);
+        handleModeChanged(mLocalAdapter.getScanMode());
+    }
+
+    public void pause() {
+        if (mLocalAdapter == null) {
+            return;
+        }
+
+        mUiHandler.removeCallbacks(mUpdateCountdownSummaryRunnable);
+        mContext.unregisterReceiver(mReceiver);
+        mDiscoveryPreference.setOnPreferenceClickListener(null);
+    }
+
+    public boolean onPreferenceClick(Preference preference) {
+        // toggle discoverability
+        mDiscoverable = !mDiscoverable;
+        setEnabled(mDiscoverable);
+        return true;
+    }
+
+    private void setEnabled(boolean enable) {
+        if (enable) {
+            int timeout = getDiscoverableTimeout();
+            mLocalAdapter.setDiscoverableTimeout(timeout);
+
+            long endTimestamp = System.currentTimeMillis() + timeout * 1000L;
+            LocalBluetoothPreferences.persistDiscoverableEndTimestamp(mContext, endTimestamp);
+
+            mLocalAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE, timeout);
+            updateCountdownSummary();
+        } else {
+            mLocalAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE);
+        }
+    }
+
+    private void updateTimerDisplay(int timeout) {
+        if (getDiscoverableTimeout() == DISCOVERABLE_TIMEOUT_NEVER) {
+            mDiscoveryPreference.setSummary(R.string.bluetooth_is_discoverable_always);
+        } else {
+            String textTimeout = formatTimeRemaining(timeout);
+            mDiscoveryPreference.setSummary(mContext.getString(R.string.bluetooth_is_discoverable,
+                    textTimeout));
+        }
+    }
+
+    private static String formatTimeRemaining(int timeout) {
+        StringBuilder sb = new StringBuilder(6);    // "mmm:ss"
+        int min = timeout / 60;
+        sb.append(min).append(':');
+        int sec = timeout - (min * 60);
+        if (sec < 10) {
+            sb.append('0');
+        }
+        sb.append(sec);
+        return sb.toString();
+    }
+
+    void setDiscoverableTimeout(int index) {
+        String timeoutValue;
+        switch (index) {
+            case 0:
+            default:
+                mTimeoutSecs = DISCOVERABLE_TIMEOUT_TWO_MINUTES;
+                timeoutValue = VALUE_DISCOVERABLE_TIMEOUT_TWO_MINUTES;
+                break;
+
+            case 1:
+                mTimeoutSecs = DISCOVERABLE_TIMEOUT_FIVE_MINUTES;
+                timeoutValue = VALUE_DISCOVERABLE_TIMEOUT_FIVE_MINUTES;
+                break;
+
+            case 2:
+                mTimeoutSecs = DISCOVERABLE_TIMEOUT_ONE_HOUR;
+                timeoutValue = VALUE_DISCOVERABLE_TIMEOUT_ONE_HOUR;
+                break;
+
+            case 3:
+                mTimeoutSecs = DISCOVERABLE_TIMEOUT_NEVER;
+                timeoutValue = VALUE_DISCOVERABLE_TIMEOUT_NEVER;
+                break;
+        }
+        mSharedPreferences.edit().putString(KEY_DISCOVERABLE_TIMEOUT, timeoutValue).apply();
+        setEnabled(true);   // enable discovery and reset timer
+    }
+
+    private int getDiscoverableTimeout() {
+        if (mTimeoutSecs != -1) {
+            return mTimeoutSecs;
+        }
+
+        int timeout = SystemProperties.getInt(SYSTEM_PROPERTY_DISCOVERABLE_TIMEOUT, -1);
+        if (timeout < 0) {
+            String timeoutValue = mSharedPreferences.getString(KEY_DISCOVERABLE_TIMEOUT,
+                    VALUE_DISCOVERABLE_TIMEOUT_TWO_MINUTES);
+
+            if (timeoutValue.equals(VALUE_DISCOVERABLE_TIMEOUT_NEVER)) {
+                timeout = DISCOVERABLE_TIMEOUT_NEVER;
+            } else if (timeoutValue.equals(VALUE_DISCOVERABLE_TIMEOUT_ONE_HOUR)) {
+                timeout = DISCOVERABLE_TIMEOUT_ONE_HOUR;
+            } else if (timeoutValue.equals(VALUE_DISCOVERABLE_TIMEOUT_FIVE_MINUTES)) {
+                timeout = DISCOVERABLE_TIMEOUT_FIVE_MINUTES;
+            } else {
+                timeout = DISCOVERABLE_TIMEOUT_TWO_MINUTES;
+            }
+        }
+        mTimeoutSecs = timeout;
+        return timeout;
+    }
+
+    int getDiscoverableTimeoutIndex() {
+        int timeout = getDiscoverableTimeout();
+        switch (timeout) {
+            case DISCOVERABLE_TIMEOUT_TWO_MINUTES:
+            default:
+                return 0;
+
+            case DISCOVERABLE_TIMEOUT_FIVE_MINUTES:
+                return 1;
+
+            case DISCOVERABLE_TIMEOUT_ONE_HOUR:
+                return 2;
+
+            case DISCOVERABLE_TIMEOUT_NEVER:
+                return 3;
+        }
+    }
+
+    void setNumberOfPairedDevices(int pairedDevices) {
+        mNumberOfPairedDevices = pairedDevices;
+        handleModeChanged(mLocalAdapter.getScanMode());
+    }
+
+    void handleModeChanged(int mode) {
+        if (mode == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
+            mDiscoverable = true;
+            updateCountdownSummary();
+        } else {
+            mDiscoverable = false;
+            setSummaryNotDiscoverable();
+        }
+    }
+
+    private void setSummaryNotDiscoverable() {
+        if (mNumberOfPairedDevices != 0) {
+            mDiscoveryPreference.setSummary(R.string.bluetooth_only_visible_to_paired_devices);
+        } else {
+            mDiscoveryPreference.setSummary(R.string.bluetooth_not_visible_to_other_devices);
+        }
+    }
+
+    private void updateCountdownSummary() {
+        int mode = mLocalAdapter.getScanMode();
+        if (mode != BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
+            return;
+        }
+
+        long currentTimestamp = System.currentTimeMillis();
+        long endTimestamp = LocalBluetoothPreferences.getDiscoverableEndTimestamp(mContext);
+
+        if (currentTimestamp > endTimestamp) {
+            // We're still in discoverable mode, but maybe there isn't a timeout.
+            updateTimerDisplay(0);
+            return;
+        }
+
+        int timeLeft = (int) ((endTimestamp - currentTimestamp) / 1000L);
+        updateTimerDisplay(timeLeft);
+
+        synchronized (this) {
+            mUiHandler.removeCallbacks(mUpdateCountdownSummaryRunnable);
+            mUiHandler.postDelayed(mUpdateCountdownSummaryRunnable, 1000);
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothDiscoveryReceiver.java b/src/com/android/settings/bluetooth_msm/BluetoothDiscoveryReceiver.java
new file mode 100644
index 0000000..fbb6827
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothDiscoveryReceiver.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+
+/**
+ * BluetoothDiscoveryReceiver updates a timestamp when the
+ * Bluetooth adapter starts or finishes discovery mode. This
+ * is used to decide whether to open an alert dialog or
+ * create a notification when we receive a pairing request.
+ *
+ * <p>Note that the discovery start/finish intents are also handled
+ * by {@link BluetoothEventManager} to update the UI, if visible.
+ */
+public final class BluetoothDiscoveryReceiver extends BroadcastReceiver {
+    private static final String TAG = "BluetoothDiscoveryReceiver";
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        String action = intent.getAction();
+        Log.v(TAG, "Received: " + action);
+
+        if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_STARTED) ||
+                action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) {
+            LocalBluetoothPreferences.persistDiscoveringTimestamp(context);
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothEnabler.java b/src/com/android/settings/bluetooth_msm/BluetoothEnabler.java
new file mode 100644
index 0000000..f668088
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothEnabler.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.provider.Settings;
+import android.widget.CompoundButton;
+import android.widget.Switch;
+import android.widget.Toast;
+import android.os.SystemProperties;
+
+import com.android.settings.R;
+import com.android.settings.WirelessSettings;
+
+/**
+ * BluetoothEnabler is a helper to manage the Bluetooth on/off checkbox
+ * preference. It turns on/off Bluetooth and ensures the summary of the
+ * preference reflects the current state.
+ */
+public final class BluetoothEnabler implements CompoundButton.OnCheckedChangeListener {
+    private final Context mContext;
+    private Switch mSwitch;
+
+    private final LocalBluetoothAdapter mLocalAdapter;
+    private final IntentFilter mIntentFilter;
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
+            handleStateChanged(state);
+        }
+    };
+
+    public BluetoothEnabler(Context context, Switch switch_) {
+        mContext = context;
+        mSwitch = switch_;
+
+        LocalBluetoothManager manager = LocalBluetoothManager.getInstance(context);
+        if (manager == null) {
+            // Bluetooth is not supported
+            mLocalAdapter = null;
+            mSwitch.setEnabled(false);
+        } else {
+            mLocalAdapter = manager.getBluetoothAdapter();
+        }
+        mIntentFilter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
+    }
+
+    public void resume() {
+        if (mLocalAdapter == null) {
+            mSwitch.setEnabled(false);
+            return;
+        }
+
+        // Bluetooth state is not sticky, so set it manually
+        handleStateChanged(mLocalAdapter.getBluetoothState());
+
+        mContext.registerReceiver(mReceiver, mIntentFilter);
+        mSwitch.setOnCheckedChangeListener(this);
+    }
+
+    public void pause() {
+        if (mLocalAdapter == null) {
+            return;
+        }
+
+        mContext.unregisterReceiver(mReceiver);
+        mSwitch.setOnCheckedChangeListener(null);
+    }
+
+    public void setSwitch(Switch switch_) {
+        if (mSwitch == switch_) return;
+        mSwitch.setOnCheckedChangeListener(null);
+        mSwitch = switch_;
+        mSwitch.setOnCheckedChangeListener(this);
+
+        int bluetoothState = BluetoothAdapter.STATE_OFF;
+        if (mLocalAdapter != null) bluetoothState = mLocalAdapter.getBluetoothState();
+        boolean isOn = bluetoothState == BluetoothAdapter.STATE_ON;
+        boolean isOff = bluetoothState == BluetoothAdapter.STATE_OFF;
+        mSwitch.setChecked(isOn);
+        mSwitch.setEnabled(isOn || isOff);
+    }
+
+    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        // Show toast message if Bluetooth is not allowed in airplane mode
+        if (isChecked &&
+                !WirelessSettings.isRadioAllowed(mContext, Settings.System.RADIO_BLUETOOTH)) {
+            Toast.makeText(mContext, R.string.wifi_in_airplane_mode, Toast.LENGTH_SHORT).show();
+            // Reset switch to off
+            buttonView.setChecked(false);
+        }
+
+        if (mLocalAdapter != null) {
+            mLocalAdapter.setBluetoothEnabled(isChecked);
+        }
+        mSwitch.setEnabled(false);
+    }
+
+    void handleStateChanged(int state) {
+        switch (state) {
+            case BluetoothAdapter.STATE_TURNING_ON:
+                mSwitch.setEnabled(false);
+                break;
+            case BluetoothAdapter.STATE_ON:
+                SystemProperties.set("bluetooth.isEnabled","true");
+                mSwitch.setChecked(true);
+                mSwitch.setEnabled(true);
+                break;
+            case BluetoothAdapter.STATE_TURNING_OFF:
+                mSwitch.setEnabled(false);
+                break;
+            case BluetoothAdapter.STATE_OFF:
+                SystemProperties.set("bluetooth.isEnabled","false");
+                mSwitch.setChecked(false);
+                mSwitch.setEnabled(true);
+                break;
+            default:
+                mSwitch.setChecked(false);
+                mSwitch.setEnabled(true);
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothEventManager.java b/src/com/android/settings/bluetooth_msm/BluetoothEventManager.java
new file mode 100644
index 0000000..e865cac
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothEventManager.java
@@ -0,0 +1,410 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import com.android.settings.R;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.List;
+
+/**
+ * BluetoothEventManager receives broadcasts and callbacks from the Bluetooth
+ * API and dispatches the event on the UI thread to the right class in the
+ * Settings.
+ */
+final class BluetoothEventManager {
+    private static final String TAG = "BluetoothEventManager";
+
+    private final LocalBluetoothAdapter mLocalAdapter;
+    private final CachedBluetoothDeviceManager mDeviceManager;
+    private LocalBluetoothProfileManager mProfileManager;
+    private final IntentFilter mAdapterIntentFilter, mProfileIntentFilter;
+    private final Map<String, Handler> mHandlerMap;
+    private Context mContext;
+
+    private final Collection<BluetoothCallback> mCallbacks =
+            new ArrayList<BluetoothCallback>();
+
+    interface Handler {
+        void onReceive(Context context, Intent intent, BluetoothDevice device);
+    }
+
+    void addHandler(String action, Handler handler) {
+        mHandlerMap.put(action, handler);
+        mAdapterIntentFilter.addAction(action);
+    }
+
+    void addProfileHandler(String action, Handler handler) {
+        mHandlerMap.put(action, handler);
+        mProfileIntentFilter.addAction(action);
+    }
+
+    // Set profile manager after construction due to circular dependency
+    void setProfileManager(LocalBluetoothProfileManager manager) {
+        mProfileManager = manager;
+    }
+
+    BluetoothEventManager(LocalBluetoothAdapter adapter,
+            CachedBluetoothDeviceManager deviceManager, Context context) {
+        mLocalAdapter = adapter;
+        mDeviceManager = deviceManager;
+        mAdapterIntentFilter = new IntentFilter();
+        mProfileIntentFilter = new IntentFilter();
+        mHandlerMap = new HashMap<String, Handler>();
+        mContext = context;
+
+        // Bluetooth on/off broadcasts
+        addHandler(BluetoothAdapter.ACTION_STATE_CHANGED, new AdapterStateChangedHandler());
+
+        // Discovery broadcasts
+        addHandler(BluetoothAdapter.ACTION_DISCOVERY_STARTED, new ScanningStateChangedHandler(true));
+        addHandler(BluetoothAdapter.ACTION_DISCOVERY_FINISHED, new ScanningStateChangedHandler(false));
+        addHandler(BluetoothDevice.ACTION_FOUND, new DeviceFoundHandler());
+        addHandler(BluetoothDevice.ACTION_DISAPPEARED, new DeviceDisappearedHandler());
+        addHandler(BluetoothDevice.ACTION_NAME_CHANGED, new NameChangedHandler());
+
+        // Pairing broadcasts
+        addHandler(BluetoothDevice.ACTION_BOND_STATE_CHANGED, new BondStateChangedHandler());
+        addHandler(BluetoothDevice.ACTION_PAIRING_CANCEL, new PairingCancelHandler());
+
+        // Fine-grained state broadcasts
+        addHandler(BluetoothDevice.ACTION_CLASS_CHANGED, new ClassChangedHandler());
+        addHandler(BluetoothDevice.ACTION_UUID, new UuidChangedHandler());
+
+        // Dock event broadcasts
+        addHandler(Intent.ACTION_DOCK_EVENT, new DockEventHandler());
+        mContext.registerReceiver(mBroadcastReceiver, mAdapterIntentFilter);
+    }
+
+    void registerProfileIntentReceiver() {
+        mContext.registerReceiver(mBroadcastReceiver, mProfileIntentFilter);
+    }
+
+    /** Register to start receiving callbacks for Bluetooth events. */
+    void registerCallback(BluetoothCallback callback) {
+        synchronized (mCallbacks) {
+            mCallbacks.add(callback);
+        }
+    }
+
+    /** Unregister to stop receiving callbacks for Bluetooth events. */
+    void unregisterCallback(BluetoothCallback callback) {
+        synchronized (mCallbacks) {
+            mCallbacks.remove(callback);
+        }
+    }
+
+    // This can't be called from a broadcast receiver where the filter is set in the Manifest.
+    private static String getDockedDeviceAddress(Context context) {
+        // This works only because these broadcast intents are "sticky"
+        Intent i = context.registerReceiver(null, new IntentFilter(Intent.ACTION_DOCK_EVENT));
+        if (i != null) {
+            int state = i.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
+            if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
+                BluetoothDevice device = i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                if (device != null) {
+                    return device.getAddress();
+                }
+            }
+        }
+        return null;
+    }
+
+    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            BluetoothDevice device = intent
+                    .getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+
+            Handler handler = mHandlerMap.get(action);
+            if (handler != null) {
+                handler.onReceive(context, intent, device);
+            }
+        }
+    };
+
+    private class AdapterStateChangedHandler implements Handler {
+        public void onReceive(Context context, Intent intent,
+                BluetoothDevice device) {
+            int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
+                                    BluetoothAdapter.ERROR);
+            // update local profiles and get paired devices
+            mLocalAdapter.setBluetoothStateInt(state);
+            // send callback to update UI and possibly start scanning
+            synchronized (mCallbacks) {
+                for (BluetoothCallback callback : mCallbacks) {
+                    callback.onBluetoothStateChanged(state);
+                }
+            }
+
+            /*Reset the connection state of all server role based
+            profiles*/
+            if (state == BluetoothAdapter.STATE_TURNING_OFF) {
+                resetAllServerRoles();
+            }
+        }
+    }
+
+    private class ScanningStateChangedHandler implements Handler {
+        private final boolean mStarted;
+
+        ScanningStateChangedHandler(boolean started) {
+            mStarted = started;
+        }
+        public void onReceive(Context context, Intent intent,
+                BluetoothDevice device) {
+            synchronized (mCallbacks) {
+                for (BluetoothCallback callback : mCallbacks) {
+                    callback.onScanningStateChanged(mStarted);
+                }
+            }
+            mDeviceManager.onScanningStateChanged(mStarted);
+            LocalBluetoothPreferences.persistDiscoveringTimestamp(context);
+        }
+    }
+
+    private class DeviceFoundHandler implements Handler {
+        public void onReceive(Context context, Intent intent,
+                BluetoothDevice device) {
+            short rssi = intent.getShortExtra(BluetoothDevice.EXTRA_RSSI, Short.MIN_VALUE);
+            BluetoothClass btClass = intent.getParcelableExtra(BluetoothDevice.EXTRA_CLASS);
+            String name = intent.getStringExtra(BluetoothDevice.EXTRA_NAME);
+            // TODO Pick up UUID. They should be available for 2.1 devices.
+            // Skip for now, there's a bluez problem and we are not getting uuids even for 2.1.
+            CachedBluetoothDevice cachedDevice = mDeviceManager.findDevice(device);
+            if (cachedDevice == null) {
+                cachedDevice = mDeviceManager.addDevice(mLocalAdapter, mProfileManager, device);
+                Log.d(TAG, "DeviceFoundHandler created new CachedBluetoothDevice: "
+                        + cachedDevice);
+                // callback to UI to create Preference for new device
+                dispatchDeviceAdded(cachedDevice);
+            }
+            cachedDevice.setRssi(rssi);
+            cachedDevice.setBtClass(btClass);
+            cachedDevice.setName(name);
+            cachedDevice.setVisible(true);
+        }
+    }
+
+    private void dispatchDeviceAdded(CachedBluetoothDevice cachedDevice) {
+        synchronized (mCallbacks) {
+            for (BluetoothCallback callback : mCallbacks) {
+                callback.onDeviceAdded(cachedDevice);
+            }
+        }
+    }
+
+    private class DeviceDisappearedHandler implements Handler {
+        public void onReceive(Context context, Intent intent,
+                BluetoothDevice device) {
+            CachedBluetoothDevice cachedDevice = mDeviceManager.findDevice(device);
+            if (cachedDevice == null) {
+                Log.w(TAG, "received ACTION_DISAPPEARED for an unknown device: " + device);
+                return;
+            }
+            if (CachedBluetoothDeviceManager.onDeviceDisappeared(cachedDevice)) {
+                synchronized (mCallbacks) {
+                    for (BluetoothCallback callback : mCallbacks) {
+                        callback.onDeviceDeleted(cachedDevice);
+                    }
+                }
+            }
+        }
+    }
+
+    private class NameChangedHandler implements Handler {
+        public void onReceive(Context context, Intent intent,
+                BluetoothDevice device) {
+            mDeviceManager.onDeviceNameUpdated(device);
+        }
+    }
+
+    private class BondStateChangedHandler implements Handler {
+        public void onReceive(Context context, Intent intent,
+                BluetoothDevice device) {
+            if (device == null) {
+                Log.e(TAG, "ACTION_BOND_STATE_CHANGED with no EXTRA_DEVICE");
+                return;
+            }
+            int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,
+                                               BluetoothDevice.ERROR);
+            CachedBluetoothDevice cachedDevice = mDeviceManager.findDevice(device);
+            if (cachedDevice == null) {
+                Log.w(TAG, "CachedBluetoothDevice for device " + device +
+                        " not found, calling readPairedDevices().");
+                if (!readPairedDevices()) {
+                    Log.e(TAG, "Got bonding state changed for " + device +
+                            ", but we have no record of that device.");
+                    return;
+                }
+                cachedDevice = mDeviceManager.findDevice(device);
+                if (cachedDevice == null) {
+                    Log.e(TAG, "Got bonding state changed for " + device +
+                            ", but device not added in cache.");
+                    return;
+                }
+            }
+
+            synchronized (mCallbacks) {
+                for (BluetoothCallback callback : mCallbacks) {
+                    callback.onDeviceBondStateChanged(cachedDevice, bondState);
+                }
+            }
+            cachedDevice.onBondingStateChanged(bondState);
+
+            if (bondState == BluetoothDevice.BOND_NONE) {
+                if (device.isBluetoothDock()) {
+                    // After a dock is unpaired, we will forget the settings
+                    LocalBluetoothPreferences
+                            .removeDockAutoConnectSetting(context, device.getAddress());
+
+                    // if the device is undocked, remove it from the list as well
+                    if (!device.getAddress().equals(getDockedDeviceAddress(context))) {
+                        cachedDevice.setVisible(false);
+                    }
+                }
+                if (cachedDevice.isRemovable()) {
+                    synchronized (mCallbacks) {
+                        for (BluetoothCallback callback : mCallbacks) {
+                            callback.onDeviceDeleted(cachedDevice);
+                        }
+                    }
+                    mDeviceManager.onDeviceDeleted(cachedDevice);
+                }
+                int reason = intent.getIntExtra(BluetoothDevice.EXTRA_REASON,
+                        BluetoothDevice.ERROR);
+
+                showUnbondMessage(context, cachedDevice.getName(), reason);
+            }
+        }
+
+        /**
+         * Called when we have reached the unbonded state.
+         *
+         * @param reason one of the error reasons from
+         *            BluetoothDevice.UNBOND_REASON_*
+         */
+        private void showUnbondMessage(Context context, String name, int reason) {
+            int errorMsg;
+
+            switch(reason) {
+            case BluetoothDevice.UNBOND_REASON_AUTH_FAILED:
+                errorMsg = R.string.bluetooth_pairing_pin_error_message;
+                break;
+            case BluetoothDevice.UNBOND_REASON_AUTH_REJECTED:
+                errorMsg = R.string.bluetooth_pairing_rejected_error_message;
+                break;
+            case BluetoothDevice.UNBOND_REASON_REMOTE_DEVICE_DOWN:
+                errorMsg = R.string.bluetooth_pairing_device_down_error_message;
+                break;
+            case BluetoothDevice.UNBOND_REASON_DISCOVERY_IN_PROGRESS:
+            case BluetoothDevice.UNBOND_REASON_AUTH_TIMEOUT:
+            case BluetoothDevice.UNBOND_REASON_REPEATED_ATTEMPTS:
+            case BluetoothDevice.UNBOND_REASON_REMOTE_AUTH_CANCELED:
+                errorMsg = R.string.bluetooth_pairing_error_message;
+                break;
+            default:
+                Log.w(TAG, "showUnbondMessage: Not displaying any message for reason: " + reason);
+                return;
+            }
+            Utils.showError(context, name, errorMsg);
+        }
+    }
+
+    private class ClassChangedHandler implements Handler {
+        public void onReceive(Context context, Intent intent,
+                BluetoothDevice device) {
+            mDeviceManager.onBtClassChanged(device);
+        }
+    }
+
+    private class UuidChangedHandler implements Handler {
+        public void onReceive(Context context, Intent intent,
+                BluetoothDevice device) {
+            mDeviceManager.onUuidChanged(device);
+        }
+    }
+
+    private class PairingCancelHandler implements Handler {
+        public void onReceive(Context context, Intent intent, BluetoothDevice device) {
+            if (device == null) {
+                Log.e(TAG, "ACTION_PAIRING_CANCEL with no EXTRA_DEVICE");
+                return;
+            }
+            int errorMsg = R.string.bluetooth_pairing_error_message;
+            CachedBluetoothDevice cachedDevice = mDeviceManager.findDevice(device);
+            Utils.showError(context, cachedDevice.getName(), errorMsg);
+        }
+    }
+
+    private class DockEventHandler implements Handler {
+        public void onReceive(Context context, Intent intent, BluetoothDevice device) {
+            // Remove if unpair device upon undocking
+            int anythingButUnDocked = Intent.EXTRA_DOCK_STATE_UNDOCKED + 1;
+            int state = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, anythingButUnDocked);
+            if (state == Intent.EXTRA_DOCK_STATE_UNDOCKED) {
+                if (device != null && device.getBondState() == BluetoothDevice.BOND_NONE) {
+                    CachedBluetoothDevice cachedDevice = mDeviceManager.findDevice(device);
+                    if (cachedDevice != null) {
+                        cachedDevice.setVisible(false);
+                    }
+                }
+            }
+        }
+    }
+
+    boolean readPairedDevices() {
+        Set<BluetoothDevice> bondedDevices = mLocalAdapter.getBondedDevices();
+        if (bondedDevices == null) {
+            return false;
+        }
+
+        boolean deviceAdded = false;
+        for (BluetoothDevice device : bondedDevices) {
+            CachedBluetoothDevice cachedDevice = mDeviceManager.findDevice(device);
+            if (cachedDevice == null) {
+                cachedDevice = mDeviceManager.addDevice(mLocalAdapter, mProfileManager, device);
+                dispatchDeviceAdded(cachedDevice);
+                deviceAdded = true;
+            }
+        }
+
+        return deviceAdded;
+    }
+
+    private void resetAllServerRoles() {
+        Collection<CachedBluetoothDevice> cachedDevices =
+                mDeviceManager.getCachedDevicesCopy();
+        for (CachedBluetoothDevice cachedDevice : cachedDevices) {
+               cachedDevice.resetAllServerProfiles();
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothNameDialogFragment.java b/src/com/android/settings/bluetooth_msm/BluetoothNameDialogFragment.java
new file mode 100644
index 0000000..7e7fe87
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothNameDialogFragment.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.app.DialogFragment;
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.text.Editable;
+import android.text.InputFilter;
+import android.text.TextWatcher;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.WindowManager;
+import android.view.inputmethod.EditorInfo;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.TextView;
+
+import com.android.settings.R;
+
+/**
+ * Dialog fragment for renaming the local Bluetooth device.
+ */
+public final class BluetoothNameDialogFragment extends DialogFragment implements TextWatcher {
+    private static final int BLUETOOTH_NAME_MAX_LENGTH_BYTES = 248;
+
+    private AlertDialog mAlertDialog;
+    private Button mOkButton;
+
+    // accessed from inner class (not private to avoid thunks)
+    static final String TAG = "BluetoothNameDialogFragment";
+    final LocalBluetoothAdapter mLocalAdapter;
+    EditText mDeviceNameView;
+
+    // This flag is set when the name is updated by code, to distinguish from user changes
+    private boolean mDeviceNameUpdated;
+
+    // This flag is set when the user edits the name (preserved on rotation)
+    private boolean mDeviceNameEdited;
+
+    // Key to save the edited name and edit status for restoring after rotation
+    private static final String KEY_NAME = "device_name";
+    private static final String KEY_NAME_EDITED = "device_name_edited";
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED)) {
+                updateDeviceName();
+            } else if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED) &&
+                    (intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR) ==
+                            BluetoothAdapter.STATE_ON)) {
+                updateDeviceName();
+            }
+        }
+    };
+
+    public BluetoothNameDialogFragment() {
+        LocalBluetoothManager localManager = LocalBluetoothManager.getInstance(getActivity());
+        mLocalAdapter = localManager.getBluetoothAdapter();
+    }
+
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        String deviceName = mLocalAdapter.getName();
+        if (savedInstanceState != null) {
+            deviceName = savedInstanceState.getString(KEY_NAME, deviceName);
+            mDeviceNameEdited = savedInstanceState.getBoolean(KEY_NAME_EDITED, false);
+        }
+        mAlertDialog = new AlertDialog.Builder(getActivity())
+                .setIcon(android.R.drawable.ic_dialog_info)
+                .setTitle(R.string.bluetooth_rename_device)
+                .setView(createDialogView(deviceName))
+                .setPositiveButton(R.string.bluetooth_rename_button,
+                        new DialogInterface.OnClickListener() {
+                            public void onClick(DialogInterface dialog, int which) {
+                                String deviceName = mDeviceNameView.getText().toString();
+                                if (deviceName.length() > 0)
+                                    setDeviceName(deviceName);
+                            }
+                        })
+                .setNegativeButton(android.R.string.cancel, null)
+                .create();
+        mAlertDialog.getWindow().setSoftInputMode(
+                WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
+
+        return mAlertDialog;
+    }
+
+    private void setDeviceName(String deviceName) {
+        Log.d(TAG, "Setting device name to " + deviceName);
+        mLocalAdapter.setName(deviceName);
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        outState.putString(KEY_NAME, mDeviceNameView.getText().toString());
+        outState.putBoolean(KEY_NAME_EDITED, mDeviceNameEdited);
+    }
+
+    private View createDialogView(String deviceName) {
+        final LayoutInflater layoutInflater = (LayoutInflater)getActivity()
+            .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        View view = layoutInflater.inflate(R.layout.dialog_edittext, null);
+        mDeviceNameView = (EditText) view.findViewById(R.id.edittext);
+        mDeviceNameView.setFilters(new InputFilter[] {
+                new Utf8ByteLengthFilter(BLUETOOTH_NAME_MAX_LENGTH_BYTES)
+        });
+        mDeviceNameView.setText(deviceName);    // set initial value before adding listener
+        mDeviceNameView.addTextChangedListener(this);
+        mDeviceNameView.setOnEditorActionListener(new TextView.OnEditorActionListener() {
+            @Override
+            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
+                if (actionId == EditorInfo.IME_ACTION_DONE &&
+                    v.getText().toString().length() > 0) {
+                    setDeviceName(v.getText().toString());
+                    mAlertDialog.dismiss();
+                    return true;    // action handled
+                } else {
+                    return false;   // not handled
+                }
+            }
+        });
+        return view;
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        mAlertDialog = null;
+        mDeviceNameView = null;
+        mOkButton = null;
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (mOkButton == null) {
+            mOkButton = mAlertDialog.getButton(DialogInterface.BUTTON_POSITIVE);
+            mOkButton.setEnabled(mDeviceNameEdited);    // Ok button enabled after user edits
+        }
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
+        filter.addAction(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
+        getActivity().registerReceiver(mReceiver, filter);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        getActivity().unregisterReceiver(mReceiver);
+    }
+
+    void updateDeviceName() {
+        if (mLocalAdapter != null && mLocalAdapter.isEnabled()) {
+            mDeviceNameUpdated = true;
+            mDeviceNameEdited = false;
+            mDeviceNameView.setText(mLocalAdapter.getName());
+        }
+    }
+
+    public void afterTextChanged(Editable s) {
+        if (mDeviceNameUpdated) {
+            // Device name changed by code; disable Ok button until edited by user
+            mDeviceNameUpdated = false;
+            mOkButton.setEnabled(false);
+        } else {
+            mDeviceNameEdited = true;
+            if (mOkButton != null) {
+                mOkButton.setEnabled(s.length() != 0);
+                if (s.length() == 0) mDeviceNameEdited = false;
+            }
+        }
+    }
+
+    /* Not used */
+    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+    }
+
+    /* Not used */
+    public void onTextChanged(CharSequence s, int start, int before, int count) {
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothPairingDialog.java b/src/com/android/settings/bluetooth_msm/BluetoothPairingDialog.java
new file mode 100644
index 0000000..5ea0e53
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothPairingDialog.java
@@ -0,0 +1,411 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.text.Editable;
+import android.text.Html;
+import android.text.InputFilter;
+import android.text.InputType;
+import android.text.Spanned;
+import android.text.TextWatcher;
+import android.text.InputFilter.LengthFilter;
+import android.util.Log;
+import android.view.View;
+import android.widget.Button;
+import android.widget.CheckBox;
+import android.widget.CompoundButton;
+import android.widget.EditText;
+import android.widget.TextView;
+
+import com.android.internal.app.AlertActivity;
+import com.android.internal.app.AlertController;
+import com.android.settings.R;
+import android.view.KeyEvent;
+
+/**
+ * BluetoothPairingDialog asks the user to enter a PIN / Passkey / simple confirmation
+ * for pairing with a remote Bluetooth device. It is an activity that appears as a dialog.
+ */
+public final class BluetoothPairingDialog extends AlertActivity implements
+        CompoundButton.OnCheckedChangeListener, DialogInterface.OnClickListener, TextWatcher {
+    private static final String TAG = "BluetoothPairingDialog";
+
+    private static final int BLUETOOTH_PIN_MAX_LENGTH = 16;
+    private static final int BLUETOOTH_PASSKEY_MAX_LENGTH = 6;
+    private BluetoothDevice mDevice;
+    private int mType;
+    private String mPairingKey;
+    private EditText mPairingView;
+    private Button mOkButton;
+    private boolean mIsSecurityHigh;
+
+    /**
+     * Dismiss the dialog if the bond state changes to bonded or none,
+     * or if pairing was canceled for {@link #mDevice}.
+     */
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) {
+                int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,
+                                                   BluetoothDevice.ERROR);
+                if (bondState == BluetoothDevice.BOND_BONDED ||
+                        bondState == BluetoothDevice.BOND_NONE) {
+                    dismiss();
+                }
+            } else if (BluetoothDevice.ACTION_PAIRING_CANCEL.equals(action)) {
+                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                if (device == null || device.equals(mDevice)) {
+                    dismiss();
+                }
+            }
+        }
+    };
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        Intent intent = getIntent();
+        if (intent == null || !BluetoothDevice.ACTION_PAIRING_REQUEST.equals(intent.getAction()))
+        {
+            Log.e(TAG, "Error: this activity may be started only with intent " +
+                  BluetoothDevice.ACTION_PAIRING_REQUEST);
+            finish();
+            return;
+        }
+
+        LocalBluetoothManager manager = LocalBluetoothManager.getInstance(this);
+        if (manager == null) {
+            Log.e(TAG, "Error: BluetoothAdapter not supported by system");
+            finish();
+            return;
+        }
+        CachedBluetoothDeviceManager deviceManager = manager.getCachedDeviceManager();
+
+        mDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+        mType = intent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, BluetoothDevice.ERROR);
+        mIsSecurityHigh = intent.getBooleanExtra(BluetoothDevice.EXTRA_SECURE_PAIRING, false);
+        Log.i(TAG, "Secure is " + mIsSecurityHigh);
+
+        switch (mType) {
+            case BluetoothDevice.PAIRING_VARIANT_PIN:
+            case BluetoothDevice.PAIRING_VARIANT_PASSKEY:
+                createUserEntryDialog(deviceManager);
+                break;
+
+            case BluetoothDevice.PAIRING_VARIANT_PASSKEY_CONFIRMATION:
+                int passkey =
+                    intent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_KEY, BluetoothDevice.ERROR);
+                if (passkey == BluetoothDevice.ERROR) {
+                    Log.e(TAG, "Invalid Confirmation Passkey received, not showing any dialog");
+                    return;
+                }
+                mPairingKey = String.format("%06d", passkey);
+                createConfirmationDialog(deviceManager);
+                break;
+
+            case BluetoothDevice.PAIRING_VARIANT_CONSENT:
+            case BluetoothDevice.PAIRING_VARIANT_OOB_CONSENT:
+                createConsentDialog(deviceManager);
+                break;
+
+            case BluetoothDevice.PAIRING_VARIANT_DISPLAY_PASSKEY:
+            case BluetoothDevice.PAIRING_VARIANT_DISPLAY_PIN:
+                int pairingKey =
+                    intent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_KEY, BluetoothDevice.ERROR);
+                if (pairingKey == BluetoothDevice.ERROR) {
+                    Log.e(TAG, "Invalid Confirmation Passkey or PIN received, not showing any dialog");
+                    return;
+                }
+                if (mType == BluetoothDevice.PAIRING_VARIANT_DISPLAY_PASSKEY) {
+                    mPairingKey = String.format("%06d", pairingKey);
+                } else {
+                    mPairingKey = String.format("%04d", pairingKey);
+                }
+                createDisplayPasskeyOrPinDialog(deviceManager);
+                break;
+
+            default:
+                Log.e(TAG, "Incorrect pairing type received, not showing any dialog");
+        }
+
+        /*
+         * Leave this registered through pause/resume since we still want to
+         * finish the activity in the background if pairing is canceled.
+         */
+        registerReceiver(mReceiver, new IntentFilter(BluetoothDevice.ACTION_PAIRING_CANCEL));
+        registerReceiver(mReceiver, new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED));
+    }
+
+    private void createUserEntryDialog(CachedBluetoothDeviceManager deviceManager) {
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_info;
+        p.mTitle = getString(R.string.bluetooth_pairing_request);
+        p.mView = createPinEntryView(deviceManager.getName(mDevice));
+        p.mPositiveButtonText = getString(android.R.string.ok);
+        p.mPositiveButtonListener = this;
+        p.mNegativeButtonText = getString(android.R.string.cancel);
+        p.mNegativeButtonListener = this;
+        setupAlert();
+
+        mOkButton = mAlert.getButton(BUTTON_POSITIVE);
+        mOkButton.setEnabled(false);
+    }
+
+    private View createPinEntryView(String deviceName) {
+        View view = getLayoutInflater().inflate(R.layout.bluetooth_pin_entry, null);
+        TextView messageView = (TextView) view.findViewById(R.id.message);
+        TextView messageView2 = (TextView) view.findViewById(R.id.message_below_pin);
+        CheckBox alphanumericPin = (CheckBox) view.findViewById(R.id.alphanumeric_pin);
+        mPairingView = (EditText) view.findViewById(R.id.text);
+        mPairingView.addTextChangedListener(this);
+        alphanumericPin.setOnCheckedChangeListener(this);
+
+        int messageId1;
+        int messageId2;
+        int maxLength;
+        switch (mType) {
+            case BluetoothDevice.PAIRING_VARIANT_PIN:
+                if (mIsSecurityHigh)
+                    messageId1 = R.string.bluetooth_enter_pin_msg_hs;
+                else
+                    messageId1 = R.string.bluetooth_enter_pin_msg;
+
+                messageId2 = R.string.bluetooth_enter_pin_other_device;
+                // Maximum of 16 characters in a PIN
+                maxLength = BLUETOOTH_PIN_MAX_LENGTH;
+                break;
+
+            case BluetoothDevice.PAIRING_VARIANT_PASSKEY:
+                messageId1 = R.string.bluetooth_enter_passkey_msg;
+                messageId2 = R.string.bluetooth_enter_passkey_other_device;
+                // Maximum of 6 digits for passkey
+                maxLength = BLUETOOTH_PASSKEY_MAX_LENGTH;
+                alphanumericPin.setVisibility(View.GONE);
+                break;
+
+            default:
+                Log.e(TAG, "Incorrect pairing type for createPinEntryView: " + mType);
+                return null;
+        }
+
+        // Format the message string, then parse HTML style tags
+        String messageText = getString(messageId1, deviceName);
+        messageView.setText(Html.fromHtml(messageText));
+        messageView2.setText(messageId2);
+        mPairingView.setInputType(InputType.TYPE_CLASS_NUMBER);
+        mPairingView.setFilters(new InputFilter[] {
+                new LengthFilter(maxLength) });
+
+        return view;
+    }
+
+    private View createView(CachedBluetoothDeviceManager deviceManager) {
+        View view = getLayoutInflater().inflate(R.layout.bluetooth_pin_confirm, null);
+        String name = deviceManager.getName(mDevice);
+        TextView messageView = (TextView) view.findViewById(R.id.message);
+
+        String messageText; // formatted string containing HTML style tags
+        switch (mType) {
+            case BluetoothDevice.PAIRING_VARIANT_PASSKEY_CONFIRMATION:
+                messageText = getString(R.string.bluetooth_confirm_passkey_msg,
+                        name, mPairingKey);
+                break;
+
+            case BluetoothDevice.PAIRING_VARIANT_CONSENT:
+            case BluetoothDevice.PAIRING_VARIANT_OOB_CONSENT:
+                messageText = getString(R.string.bluetooth_incoming_pairing_msg, name);
+                break;
+
+            case BluetoothDevice.PAIRING_VARIANT_DISPLAY_PASSKEY:
+            case BluetoothDevice.PAIRING_VARIANT_DISPLAY_PIN:
+                messageText = getString(R.string.bluetooth_display_passkey_pin_msg, name,
+                        mPairingKey);
+                break;
+
+            default:
+                Log.e(TAG, "Incorrect pairing type received, not creating view");
+                return null;
+        }
+        messageView.setText(Html.fromHtml(messageText));
+        return view;
+    }
+
+    private void createConfirmationDialog(CachedBluetoothDeviceManager deviceManager) {
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_info;
+        p.mTitle = getString(R.string.bluetooth_pairing_request);
+        p.mView = createView(deviceManager);
+        p.mPositiveButtonText = getString(R.string.bluetooth_pairing_accept);
+        p.mPositiveButtonListener = this;
+        p.mNegativeButtonText = getString(R.string.bluetooth_pairing_decline);
+        p.mNegativeButtonListener = this;
+        setupAlert();
+    }
+
+    private void createConsentDialog(CachedBluetoothDeviceManager deviceManager) {
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_info;
+        p.mTitle = getString(R.string.bluetooth_pairing_request);
+        p.mView = createView(deviceManager);
+        p.mPositiveButtonText = getString(R.string.bluetooth_pairing_accept);
+        p.mPositiveButtonListener = this;
+        p.mNegativeButtonText = getString(R.string.bluetooth_pairing_decline);
+        p.mNegativeButtonListener = this;
+        setupAlert();
+    }
+
+    private void createDisplayPasskeyOrPinDialog(
+            CachedBluetoothDeviceManager deviceManager) {
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_info;
+        p.mTitle = getString(R.string.bluetooth_pairing_request);
+        p.mView = createView(deviceManager);
+        p.mNegativeButtonText = getString(android.R.string.cancel);
+        p.mNegativeButtonListener = this;
+        setupAlert();
+
+        // Since its only a notification, send an OK to the framework,
+        // indicating that the dialog has been displayed.
+        if (mType == BluetoothDevice.PAIRING_VARIANT_DISPLAY_PASSKEY) {
+            mDevice.setPairingConfirmation(true);
+        } else if (mType == BluetoothDevice.PAIRING_VARIANT_DISPLAY_PIN) {
+            byte[] pinBytes = BluetoothDevice.convertPinToBytes(mPairingKey);
+            mDevice.setPin(pinBytes);
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        unregisterReceiver(mReceiver);
+    }
+
+    @Override
+    protected void onUserLeaveHint() {
+        Log.i(TAG, "User pressed Home key, Destroying the pairing process");
+        onCancel();
+        super.onUserLeaveHint();
+    }
+
+    @Override
+    public void onBackPressed() {
+        Log.i(TAG, "User pressed Back Key. Destroying the pairing process");
+        onCancel();
+        finish();
+    }
+
+    public void afterTextChanged(Editable s) {
+        if (mOkButton != null) {
+            if (s.length() > 0 && !mIsSecurityHigh) {
+                mOkButton.setEnabled(true);
+            } else if (mIsSecurityHigh && s.length() == BLUETOOTH_PIN_MAX_LENGTH) {
+                mOkButton.setEnabled(true);
+            } else {
+                mOkButton.setEnabled(false);
+            }
+        }
+    }
+
+    private void onPair(String value) {
+        switch (mType) {
+            case BluetoothDevice.PAIRING_VARIANT_PIN:
+                byte[] pinBytes = BluetoothDevice.convertPinToBytes(value);
+                if (pinBytes == null) {
+                    return;
+                }
+                mDevice.setPin(pinBytes);
+                break;
+
+            case BluetoothDevice.PAIRING_VARIANT_PASSKEY:
+                int passkey = Integer.parseInt(value);
+                mDevice.setPasskey(passkey);
+                break;
+
+            case BluetoothDevice.PAIRING_VARIANT_PASSKEY_CONFIRMATION:
+            case BluetoothDevice.PAIRING_VARIANT_CONSENT:
+                mDevice.setPairingConfirmation(true);
+                break;
+
+            case BluetoothDevice.PAIRING_VARIANT_DISPLAY_PASSKEY:
+            case BluetoothDevice.PAIRING_VARIANT_DISPLAY_PIN:
+                // Do nothing.
+                break;
+
+            case BluetoothDevice.PAIRING_VARIANT_OOB_CONSENT:
+                mDevice.setRemoteOutOfBandData();
+                break;
+
+            default:
+                Log.e(TAG, "Incorrect pairing type received");
+        }
+    }
+
+    private void onCancel() {
+        mDevice.cancelPairingUserInput();
+    }
+
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        if (keyCode == KeyEvent.KEYCODE_BACK) {
+            onCancel();
+        }
+        return super.onKeyDown(keyCode,event);
+    }
+
+    public void onClick(DialogInterface dialog, int which) {
+        switch (which) {
+            case BUTTON_POSITIVE:
+                if (mPairingView != null) {
+                    onPair(mPairingView.getText().toString());
+                } else {
+                    onPair(null);
+                }
+                break;
+
+            case BUTTON_NEGATIVE:
+            default:
+                onCancel();
+                break;
+        }
+    }
+
+    /* Not used */
+    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+    }
+
+    /* Not used */
+    public void onTextChanged(CharSequence s, int start, int before, int count) {
+    }
+
+    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        // change input type for soft keyboard to numeric or alphanumeric
+        if (isChecked) {
+            mPairingView.setInputType(InputType.TYPE_CLASS_TEXT);
+        } else {
+            mPairingView.setInputType(InputType.TYPE_CLASS_NUMBER);
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothPairingRequest.java b/src/com/android/settings/bluetooth_msm/BluetoothPairingRequest.java
new file mode 100644
index 0000000..db520d7
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothPairingRequest.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import com.android.settings.R;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.Resources;
+import android.text.TextUtils;
+import android.os.PowerManager;
+
+/**
+ * BluetoothPairingRequest is a receiver for any Bluetooth pairing request. It
+ * checks if the Bluetooth Settings is currently visible and brings up the PIN, the passkey or a
+ * confirmation entry dialog. Otherwise it puts a Notification in the status bar, which can
+ * be clicked to bring up the Pairing entry dialog.
+ */
+public final class BluetoothPairingRequest extends BroadcastReceiver {
+
+    private static final int NOTIFICATION_ID = android.R.drawable.stat_sys_data_bluetooth;
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        String action = intent.getAction();
+        if (action.equals(BluetoothDevice.ACTION_PAIRING_REQUEST)) {
+            // convert broadcast intent into activity intent (same action string)
+            BluetoothDevice device =
+                    intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            int type = intent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                    BluetoothDevice.ERROR);
+            boolean secure = intent.getBooleanExtra(BluetoothDevice.EXTRA_SECURE_PAIRING, false);
+            Intent pairingIntent = new Intent();
+            pairingIntent.setClass(context, BluetoothPairingDialog.class);
+            pairingIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            pairingIntent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, type);
+            pairingIntent.putExtra(BluetoothDevice.EXTRA_SECURE_PAIRING, secure);
+            if (type == BluetoothDevice.PAIRING_VARIANT_PASSKEY_CONFIRMATION ||
+                    type == BluetoothDevice.PAIRING_VARIANT_DISPLAY_PASSKEY ||
+                    type == BluetoothDevice.PAIRING_VARIANT_DISPLAY_PIN) {
+                int pairingKey = intent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_KEY,
+                        BluetoothDevice.ERROR);
+                pairingIntent.putExtra(BluetoothDevice.EXTRA_PAIRING_KEY, pairingKey);
+            }
+            pairingIntent.setAction(BluetoothDevice.ACTION_PAIRING_REQUEST);
+            pairingIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+            PowerManager powerManager =
+                    (PowerManager)context.getSystemService(Context.POWER_SERVICE);
+            String deviceAddress = device != null ? device.getAddress() : null;
+            if (powerManager.isScreenOn() &&
+                    LocalBluetoothPreferences.shouldShowDialogInForeground(context, deviceAddress)) {
+                // Since the screen is on and the BT-related activity is in the foreground,
+                // just open the dialog
+                context.startActivity(pairingIntent);
+            } else {
+                // Put up a notification that leads to the dialog
+                Resources res = context.getResources();
+                Notification.Builder builder = new Notification.Builder(context)
+                        .setSmallIcon(android.R.drawable.stat_sys_data_bluetooth)
+                        .setTicker(res.getString(R.string.bluetooth_notif_ticker));
+
+                PendingIntent pending = PendingIntent.getActivity(context, 0,
+                        pairingIntent, PendingIntent.FLAG_UPDATE_CURRENT);
+
+                String name = intent.getStringExtra(BluetoothDevice.EXTRA_NAME);
+                if (TextUtils.isEmpty(name)) {
+                    name = device != null ? device.getAliasName() :
+                            context.getString(android.R.string.unknownName);
+                }
+
+                builder.setContentTitle(res.getString(R.string.bluetooth_notif_title))
+                        .setContentText(res.getString(R.string.bluetooth_notif_message, name))
+                        .setContentIntent(pending)
+                        .setAutoCancel(true)
+                        .setDefaults(Notification.DEFAULT_SOUND);
+
+                NotificationManager manager = (NotificationManager)
+                        context.getSystemService(Context.NOTIFICATION_SERVICE);
+                manager.notify(NOTIFICATION_ID, builder.getNotification());
+            }
+
+        } else if (action.equals(BluetoothDevice.ACTION_PAIRING_CANCEL)) {
+            Intent pairingIntent = new Intent();
+
+            pairingIntent.setClass(context, BluetoothPairingDialog.class);
+            pairingIntent.setAction(BluetoothDevice.ACTION_PAIRING_REQUEST);
+            pairingIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            PendingIntent pending = PendingIntent.getActivity(context, 0,
+                                      pairingIntent, PendingIntent.FLAG_NO_CREATE);
+            if (pending != null) {
+                pending.cancel();
+            }
+
+            // Remove the notification
+            NotificationManager manager = (NotificationManager) context
+                    .getSystemService(Context.NOTIFICATION_SERVICE);
+            manager.cancel(NOTIFICATION_ID);
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothPermissionActivity.java b/src/com/android/settings/bluetooth_msm/BluetoothPermissionActivity.java
new file mode 100644
index 0000000..b9f5e7d9
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothPermissionActivity.java
@@ -0,0 +1,463 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (c) 2012 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.os.Handler;
+import android.os.Message;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.preference.Preference;
+import android.util.Log;
+import android.view.View;
+import android.widget.CheckBox;
+import android.widget.CompoundButton;
+import android.widget.EditText;
+import android.widget.TextView;
+import android.widget.Button;
+import android.widget.CompoundButton.OnCheckedChangeListener;
+
+import com.android.internal.app.AlertActivity;
+import com.android.internal.app.AlertController;
+
+import com.android.settings.R;
+
+/**
+ * BluetoothPermissionActivity shows a dialog for accepting incoming
+ * profile connection request from untrusted devices.
+ * It is also used to show a dialogue for accepting incoming phonebook
+ * read request. The request could be initiated by PBAP PCE or by HF AT+CPBR.
+ */
+public class BluetoothPermissionActivity extends AlertActivity implements
+        DialogInterface.OnClickListener, Preference.OnPreferenceChangeListener {
+    private static final String TAG = "BluetoothPermissionActivity";
+    private static final boolean DEBUG = Utils.D;
+
+    private View mView;
+    private TextView messageView;
+    private Button mOkButton;
+    private BluetoothDevice mDevice;
+    private String mReturnPackage = null;
+    private String mReturnClass = null;
+    private int requestType;
+    private CheckBox mRememberChoice;
+    private boolean mRememberChoiceValue = false;
+
+    private static final int MSG_INTERNAL_USER_CONFIRM_TIMEOUT = 1;
+    private static final int TIME_TO_WAIT = 30000;
+    /* Need it just to distinguish between DUN and SAP, because use the same routines
+       to call here*/
+    private String mUuid = null;
+    private static final String SAP_UUID = "0000112D-0000-1000-8000-00805F9B34FB";
+    private static final String DUN_UUID = "00001103-0000-1000-8000-00805F9B34FB";
+
+    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL)) {
+                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                if (mDevice.equals(device)) dismissDialog();
+            }
+        }
+    };
+    private boolean mReceiverRegistered = false;
+
+    private void dismissDialog() {
+        this.dismiss();
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        Intent i = getIntent();
+        String action = i.getAction();
+        if (!action.equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST)) {
+            Log.e(TAG, "Error: this activity may be started only with intent "
+                  + "ACTION_CONNECTION_ACCESS_REQUEST");
+            finish();
+            return;
+        }
+        mDevice = i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+        mReturnPackage = i.getStringExtra(BluetoothDevice.EXTRA_PACKAGE_NAME);
+        mReturnClass = i.getStringExtra(BluetoothDevice.EXTRA_CLASS_NAME);
+        requestType = i.getIntExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE,
+                                    BluetoothDevice.ERROR);
+
+        if (requestType == BluetoothDevice.REQUEST_TYPE_PROFILE_CONNECTION) {
+            showConnectionDialog();
+        } else if (requestType == BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS) {
+            showPhonebookDialog();
+        } else if (requestType == BluetoothDevice.REQUEST_TYPE_FILE_ACCESS) {
+            showFtpDialog();
+        } else if (requestType == BluetoothDevice.REQUEST_TYPE_MESSAGE_ACCESS) {
+            showMasDialog();
+        }  else if (requestType == BluetoothDevice.REQUEST_TYPE_SIM_ACCESS) {
+            mUuid = SAP_UUID;
+            showSapDialog();
+        } else if (requestType == BluetoothDevice.REQUEST_TYPE_DUN_ACCESS) {
+            mUuid = DUN_UUID;
+            showDUNDialog();
+        }else {
+            Log.e(TAG, "Error: bad request type: " + requestType);
+            finish();
+            return;
+        }
+
+        /* Post a delayed message to the handler to clear authorization dialog on time out */
+        mHandler.sendMessageDelayed(mHandler
+            .obtainMessage(MSG_INTERNAL_USER_CONFIRM_TIMEOUT), TIME_TO_WAIT);
+        registerReceiver(mReceiver,
+                         new IntentFilter(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL));
+        mReceiverRegistered = true;
+    }
+
+    private final Handler mHandler = new Handler() {
+      @Override
+      public void handleMessage(Message msg) {
+         switch (msg.what) {
+            case MSG_INTERNAL_USER_CONFIRM_TIMEOUT:
+               onNegative();
+               break;
+            default:
+               break;
+         }
+      }
+    };
+
+    private void showConnectionDialog() {
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_info;
+        p.mTitle = getString(R.string.bluetooth_connection_permission_request);
+        p.mView = createConnectionDialogView();
+        p.mPositiveButtonText = getString(R.string.yes);
+        p.mPositiveButtonListener = this;
+        p.mNegativeButtonText = getString(R.string.no);
+        p.mNegativeButtonListener = this;
+        mOkButton = mAlert.getButton(DialogInterface.BUTTON_POSITIVE);
+        setupAlert();
+    }
+
+    private void showPhonebookDialog() {
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_info;
+        p.mTitle = getString(R.string.bluetooth_phonebook_request);
+        p.mView = createPhonebookDialogView();
+        p.mPositiveButtonText = getString(android.R.string.yes);
+        p.mPositiveButtonListener = this;
+        p.mNegativeButtonText = getString(android.R.string.no);
+        p.mNegativeButtonListener = this;
+        mOkButton = mAlert.getButton(DialogInterface.BUTTON_POSITIVE);
+        setupAlert();
+    }
+
+    private void showFtpDialog() {
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_info;
+        p.mTitle = getString(R.string.bluetooth_ftp_request);
+        p.mView = createFtpDialogView();
+        p.mPositiveButtonText = getString(android.R.string.yes);
+        p.mPositiveButtonListener = this;
+        p.mNegativeButtonText = getString(android.R.string.no);
+        p.mNegativeButtonListener = this;
+        mOkButton = mAlert.getButton(DialogInterface.BUTTON_POSITIVE);
+        setupAlert();
+    }
+
+    private void showMasDialog() {
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_info;
+        p.mTitle = getString(R.string.bluetooth_mas_request);
+        p.mView = createMasDialogView();
+        p.mPositiveButtonText = getString(android.R.string.yes);
+        p.mPositiveButtonListener = this;
+        p.mNegativeButtonText = getString(android.R.string.no);
+        p.mNegativeButtonListener = this;
+        mOkButton = mAlert.getButton(DialogInterface.BUTTON_POSITIVE);
+        setupAlert();
+    }
+
+    private void showSapDialog() {
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_info;
+        p.mTitle = getString(R.string.bluetooth_sap_request);
+        p.mView = createSapDialogView();
+        p.mPositiveButtonText = getString(android.R.string.yes);
+        p.mPositiveButtonListener = this;
+        p.mNegativeButtonText = getString(android.R.string.no);
+        p.mNegativeButtonListener = this;
+        mOkButton = mAlert.getButton(DialogInterface.BUTTON_POSITIVE);
+        setupAlert();
+    }
+
+    private void showDUNDialog() {
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_info;
+        p.mTitle = getString(R.string.bluetooth_dun_request);
+        p.mView = createDUNDialogView();
+        p.mPositiveButtonText = getString(android.R.string.yes);
+        p.mPositiveButtonListener = this;
+        p.mNegativeButtonText = getString(android.R.string.no);
+        p.mNegativeButtonListener = this;
+        mOkButton = mAlert.getButton(DialogInterface.BUTTON_POSITIVE);
+        setupAlert();
+    }
+
+    private String createConnectionDisplayText() {
+        String mRemoteName = mDevice != null ? mDevice.getAliasName() : null;
+
+        if (mRemoteName == null) mRemoteName = getString(R.string.unknown);
+        String mMessage1 = getString(R.string.bluetooth_connection_dialog_text,
+                mRemoteName);
+        return mMessage1;
+    }
+
+    private String createPhonebookDisplayText() {
+        String mRemoteName = mDevice != null ? mDevice.getAliasName() : null;
+
+        if (mRemoteName == null) mRemoteName = getString(R.string.unknown);
+        String mMessage1 = getString(R.string.bluetooth_pb_acceptance_dialog_text,
+                                     mRemoteName, mRemoteName);
+        return mMessage1;
+    }
+
+    private String createFtpDisplayText() {
+        String mRemoteName = mDevice != null ? mDevice.getAliasName() : null;
+
+        if (mRemoteName == null) mRemoteName = getString(R.string.unknown);
+        String mMessage1 = getString(R.string.bluetooth_ftp_acceptance_dialog_text,
+                                     mRemoteName, mRemoteName);
+        return mMessage1;
+    }
+
+    private String createMasDisplayText() {
+        String mRemoteName = mDevice != null ? mDevice.getAliasName() : null;
+
+        if (mRemoteName == null) mRemoteName = getString(R.string.unknown);
+        String mMessage1 = getString(R.string.bluetooth_mas_acceptance_dialog_text,
+                                     mRemoteName, mRemoteName);
+        return mMessage1;
+    }
+
+    private String createSapDisplayText() {
+        String mRemoteName = mDevice != null ? mDevice.getAliasName() : null;
+
+        if (mRemoteName == null) mRemoteName = getString(R.string.unknown);
+        String mMessage1 = getString(R.string.bluetooth_sap_acceptance_dialog_text,
+                                     mRemoteName, mRemoteName);
+        return mMessage1;
+    }
+
+    private String createDUNDisplayText() {
+        String mRemoteName = mDevice != null ? mDevice.getAliasName() : null;
+
+        if (mRemoteName == null) mRemoteName = getString(R.string.unknown);
+        String mMessage1 = getString(R.string.bluetooth_dun_acceptance_dialog_text,
+                                     mRemoteName, mRemoteName);
+        return mMessage1;
+    }
+
+    private View createConnectionDialogView() {
+        mView = getLayoutInflater().inflate(R.layout.bluetooth_connection_access, null);
+        messageView = (TextView)mView.findViewById(R.id.message);
+        messageView.setText(createConnectionDisplayText());
+        return mView;
+    }
+
+    private View createPhonebookDialogView() {
+        mView = getLayoutInflater().inflate(R.layout.bluetooth_pb_access, null);
+        messageView = (TextView)mView.findViewById(R.id.message);
+        messageView.setText(createPhonebookDisplayText());
+        mRememberChoice = (CheckBox)mView.findViewById(R.id.bluetooth_pb_remember_choice);
+        mRememberChoice.setChecked(false);
+        mRememberChoice.setOnCheckedChangeListener(new OnCheckedChangeListener() {
+            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+                if (isChecked) {
+                    mRememberChoiceValue = true;
+                } else {
+                    mRememberChoiceValue = false;
+                }
+            }
+            });
+        return mView;
+    }
+
+    private View createFtpDialogView() {
+        mView = getLayoutInflater().inflate(R.layout.bluetooth_ftp_access, null);
+        messageView = (TextView)mView.findViewById(R.id.message);
+        messageView.setText(createFtpDisplayText());
+        mRememberChoice = (CheckBox)mView.findViewById(R.id.bluetooth_ftp_remember_choice);
+        mRememberChoice.setChecked(false);
+        mRememberChoice.setOnCheckedChangeListener(new OnCheckedChangeListener() {
+            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+                if (isChecked) {
+                    mRememberChoiceValue = true;
+                } else {
+                    mRememberChoiceValue = false;
+                }
+            }
+            });
+        return mView;
+    }
+
+    private View createMasDialogView() {
+        mView = getLayoutInflater().inflate(R.layout.bluetooth_mas_access, null);
+        messageView = (TextView)mView.findViewById(R.id.message);
+        messageView.setText(createMasDisplayText());
+        mRememberChoice = (CheckBox)mView.findViewById(R.id.bluetooth_mas_remember_choice);
+        mRememberChoice.setChecked(false);
+        mRememberChoice.setOnCheckedChangeListener(new OnCheckedChangeListener() {
+            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+                if (isChecked) {
+                    mRememberChoiceValue = true;
+                } else {
+                    mRememberChoiceValue = false;
+                }
+            }
+            });
+        return mView;
+    }
+
+    private View createSapDialogView() {
+        mView = getLayoutInflater().inflate(R.layout.bluetooth_sap_access, null);
+        messageView = (TextView)mView.findViewById(R.id.message);
+        messageView.setText(createSapDisplayText());
+        mRememberChoice = (CheckBox)mView.findViewById(R.id.bluetooth_sap_remember_choice);
+        mRememberChoice.setChecked(false);
+        mRememberChoice.setOnCheckedChangeListener(new OnCheckedChangeListener() {
+            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+                if (isChecked) {
+                    mRememberChoiceValue = true;
+                } else {
+                    mRememberChoiceValue = false;
+                }
+            }
+            });
+        return mView;
+    }
+
+    private View createDUNDialogView() {
+        mView = getLayoutInflater().inflate(R.layout.bluetooth_dun_access, null);
+        messageView = (TextView)mView.findViewById(R.id.message);
+        messageView.setText(createDUNDisplayText());
+        mRememberChoice = (CheckBox)mView.findViewById(R.id.bluetooth_dun_remember_choice);
+        mRememberChoice.setChecked(false);
+        mRememberChoice.setOnCheckedChangeListener(new OnCheckedChangeListener() {
+            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+                if (isChecked) {
+                    mRememberChoiceValue = true;
+                } else {
+                    mRememberChoiceValue = false;
+                }
+            }
+            });
+        return mView;
+    }
+
+    private void onPositive() {
+        if (DEBUG) Log.d(TAG, "onPositive mRememberChoiceValue: " + mRememberChoiceValue);
+
+        if (mRememberChoiceValue && (requestType == BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS)) {
+            savePhonebookPermissionChoice(CachedBluetoothDevice.PHONEBOOK_ACCESS_ALLOWED);
+        }
+        sendIntentToReceiver(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY, true,
+                             BluetoothDevice.EXTRA_ALWAYS_ALLOWED, mRememberChoiceValue);
+        mHandler.removeMessages(MSG_INTERNAL_USER_CONFIRM_TIMEOUT);
+        finish();
+    }
+
+    private void onNegative() {
+        if (DEBUG) Log.d(TAG, "onNegative mRememberChoiceValue: " + mRememberChoiceValue);
+
+        if (mRememberChoiceValue && (requestType == BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS)) {
+            savePhonebookPermissionChoice(CachedBluetoothDevice.PHONEBOOK_ACCESS_REJECTED);
+        }
+        sendIntentToReceiver(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY, false,
+                             null, false // dummy value, no effect since last param is null
+                             );
+        mHandler.removeMessages(MSG_INTERNAL_USER_CONFIRM_TIMEOUT);
+        finish();
+    }
+
+    private void sendIntentToReceiver(final String intentName, final boolean allowed,
+                                      final String extraName, final boolean extraValue) {
+        Intent intent = new Intent(intentName);
+
+        if (mReturnPackage != null && mReturnClass != null) {
+            intent.setClassName(mReturnPackage, mReturnClass);
+        }
+
+        intent.putExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT,
+                        allowed ? BluetoothDevice.CONNECTION_ACCESS_YES :
+                                  BluetoothDevice.CONNECTION_ACCESS_NO);
+
+        if (extraName != null) {
+            intent.putExtra(extraName, extraValue);
+        }
+        if ((mUuid == DUN_UUID) || (mUuid == SAP_UUID)) {
+            intent.putExtra("uuid", mUuid);
+        }
+        requestType = 0;
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
+        sendBroadcast(intent, android.Manifest.permission.BLUETOOTH_ADMIN);
+    }
+
+    public void onClick(DialogInterface dialog, int which) {
+        switch (which) {
+            case DialogInterface.BUTTON_POSITIVE:
+                onPositive();
+                break;
+
+            case DialogInterface.BUTTON_NEGATIVE:
+                onNegative();
+                break;
+            default:
+                break;
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        if (mReceiverRegistered) {
+            unregisterReceiver(mReceiver);
+            mReceiverRegistered = false;
+        }
+    }
+
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        return true;
+    }
+
+    private void savePhonebookPermissionChoice(int permissionChoice) {
+        LocalBluetoothManager bluetoothManager = LocalBluetoothManager.getInstance(this);
+        CachedBluetoothDeviceManager cachedDeviceManager =
+            bluetoothManager.getCachedDeviceManager();
+        CachedBluetoothDevice cachedDevice = cachedDeviceManager.findDevice(mDevice);
+        try {
+            cachedDevice.setPhonebookPermissionChoice(permissionChoice);
+        } catch (NullPointerException ex) {
+            Log.e(TAG, "Exception occured in savePhonebookPermissionChoice");
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothPermissionRequest.java b/src/com/android/settings/bluetooth_msm/BluetoothPermissionRequest.java
new file mode 100644
index 0000000..802121e
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothPermissionRequest.java
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (c) 2012 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.os.PowerManager;
+import android.util.Log;
+
+import com.android.settings.R;
+
+/**
+ * BluetoothPermissionRequest is a receiver to receive Bluetooth connection
+ * access request.
+ */
+public final class BluetoothPermissionRequest extends BroadcastReceiver {
+
+    private static final String TAG = "BluetoothPermissionRequest";
+    private static final boolean DEBUG = Utils.V;
+    public static final int NOTIFICATION_ID = android.R.drawable.stat_sys_data_bluetooth;
+    private static final int NOTIFICATION_ID_ACCESS_PBAP = -1000001;
+    private static final int NOTIFICATION_ID_ACCESS_FTP = -1000005;
+    private static final int NOTIFICATION_ID_ACCESS_MAP = -1000007;
+    private static final int NOTIFICATION_ID_ACCESS_SAP = -1000009;
+    private static final int NOTIFICATION_ID_ACCESS_DUN = -1000011;
+
+    Context mContext;
+    int mRequestType;
+    BluetoothDevice mDevice;
+    String mReturnPackage = null;
+    String mReturnClass = null;
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        mContext = context;
+        String action = intent.getAction();
+
+        if (DEBUG) Log.d(TAG, "onReceive");
+
+        if (action.equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST)) {
+            // convert broadcast intent into activity intent (same action string)
+            mDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            mRequestType = intent.getIntExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE,
+                                              BluetoothDevice.ERROR);
+            mReturnPackage = intent.getStringExtra(BluetoothDevice.EXTRA_PACKAGE_NAME);
+            mReturnClass = intent.getStringExtra(BluetoothDevice.EXTRA_CLASS_NAME);
+
+            Intent connectionAccessIntent = new Intent(action);
+            connectionAccessIntent.setClass(context, BluetoothPermissionActivity.class);
+            connectionAccessIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            connectionAccessIntent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE,
+                                            mRequestType);
+            connectionAccessIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
+            connectionAccessIntent.putExtra(BluetoothDevice.EXTRA_PACKAGE_NAME, mReturnPackage);
+            connectionAccessIntent.putExtra(BluetoothDevice.EXTRA_CLASS_NAME, mReturnClass);
+
+            // Check if user had made decisions on accepting or rejecting the phonebook access
+            // request. If there is, reply the request and return, no need to start permission
+            // activity dialog or notification.
+            if (checkUserChoice()) {
+                return;
+            }
+
+            String deviceAddress = mDevice != null ? mDevice.getAddress() : null;
+            PowerManager powerManager =
+                (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+
+            if (powerManager.isScreenOn() &&
+                LocalBluetoothPreferences.shouldShowDialogInForeground(context, deviceAddress) ) {
+                context.startActivity(connectionAccessIntent);
+            } else {
+                // Put up a notification that leads to the dialog
+
+                // Create an intent triggered by clicking on the
+                // "Clear All Notifications" button
+                Intent deleteIntent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
+                deleteIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
+                deleteIntent.putExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT,
+                        BluetoothDevice.CONNECTION_ACCESS_NO);
+
+                int notificationId = 0;
+                int stringId = 0;
+                if (mRequestType == BluetoothDevice.REQUEST_TYPE_PROFILE_CONNECTION) {
+                   /*It looks that the extra type REQUEST_TYPE_PROFILE_CONNECTION is defined
+                    *to create pop up for remote initiated A2DP, HF and HID but not used for now
+                    */
+                   notificationId = NOTIFICATION_ID;
+                   stringId = R.string.bluetooth_connection_permission_request;
+                } else if (mRequestType == BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS) {
+                   notificationId = NOTIFICATION_ID_ACCESS_PBAP;
+                   stringId = R.string.bluetooth_pbap_connection_permission_request;
+                } else if (mRequestType == BluetoothDevice.REQUEST_TYPE_FILE_ACCESS) {
+                   notificationId = NOTIFICATION_ID_ACCESS_FTP;
+                   stringId = R.string.bluetooth_ftp_connection_permission_request;
+                } else if (mRequestType == BluetoothDevice.REQUEST_TYPE_MESSAGE_ACCESS) {
+                   notificationId = NOTIFICATION_ID_ACCESS_MAP;
+                   stringId = R.string.bluetooth_map_connection_permission_request;
+                } else if (mRequestType == BluetoothDevice.REQUEST_TYPE_SIM_ACCESS) {
+                   notificationId = NOTIFICATION_ID_ACCESS_SAP;
+                   stringId = R.string.bluetooth_sap_connection_permission_request;
+                } else if (mRequestType == BluetoothDevice.REQUEST_TYPE_DUN_ACCESS) {
+                   notificationId = NOTIFICATION_ID_ACCESS_DUN;
+                   stringId = R.string.bluetooth_dun_connection_permission_request;
+                } else {
+                  /* Unhandled request */
+                  return;
+                }
+
+                Notification notification = new Notification(
+                    android.R.drawable.stat_sys_data_bluetooth,
+                    context.getString(stringId),
+                    System.currentTimeMillis());
+                String deviceName = mDevice != null ? mDevice.getAliasName() : null;
+                notification.setLatestEventInfo(context,
+                    context.getString(stringId),
+                    context.getString(R.string.bluetooth_connection_notif_message, deviceName),
+                    PendingIntent.getActivity(context, notificationId, connectionAccessIntent,
+                       PendingIntent.FLAG_ONE_SHOT));
+                notification.flags = Notification.FLAG_AUTO_CANCEL |
+                                     Notification.FLAG_ONLY_ALERT_ONCE;
+                notification.defaults = Notification.DEFAULT_SOUND;
+                notification.deleteIntent = PendingIntent.getBroadcast(context, 0, deleteIntent,
+                       PendingIntent.FLAG_ONE_SHOT);
+
+                NotificationManager notificationManager =
+                    (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+                notificationManager.notify(notificationId, notification);
+            }
+        } else if (action.equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL)) {
+            // Remove the notification
+            int notificationId = 0;
+            int clearNotification =  intent.getIntExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE,
+                                                        BluetoothDevice.ERROR);
+            if (clearNotification == BluetoothDevice.REQUEST_TYPE_PROFILE_CONNECTION) {
+              /* Not used for now */
+              notificationId = NOTIFICATION_ID;
+            } else if (clearNotification == BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS) {
+                notificationId = NOTIFICATION_ID_ACCESS_PBAP;
+            } else if(clearNotification == BluetoothDevice.REQUEST_TYPE_FILE_ACCESS) {
+                notificationId = NOTIFICATION_ID_ACCESS_FTP;
+            } else if(clearNotification == BluetoothDevice.REQUEST_TYPE_MESSAGE_ACCESS) {
+                notificationId = NOTIFICATION_ID_ACCESS_MAP;
+            } else if(clearNotification == BluetoothDevice.REQUEST_TYPE_SIM_ACCESS) {
+                notificationId = NOTIFICATION_ID_ACCESS_SAP;
+            } else if(clearNotification == BluetoothDevice.REQUEST_TYPE_DUN_ACCESS) {
+                notificationId = NOTIFICATION_ID_ACCESS_DUN;
+            } else {
+              /* Do not clear */
+              return;
+            }
+
+            NotificationManager manager = (NotificationManager) context
+                .getSystemService(Context.NOTIFICATION_SERVICE);
+            manager.cancel(notificationId);
+        }
+    }
+
+    /**
+     * @return true user had made a choice, this method replies to the request according
+     *              to user's previous decision
+     *         false user hadnot made any choice on this device
+     */
+    private boolean checkUserChoice() {
+        boolean processed = false;
+
+        // we only remember PHONEBOOK permission
+        if (mRequestType != BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS) {
+            return processed;
+        }
+
+        LocalBluetoothManager bluetoothManager = LocalBluetoothManager.getInstance(mContext);
+        CachedBluetoothDeviceManager cachedDeviceManager =
+            bluetoothManager.getCachedDeviceManager();
+        CachedBluetoothDevice cachedDevice = cachedDeviceManager.findDevice(mDevice);
+
+        if (cachedDevice == null) {
+            cachedDevice = cachedDeviceManager.addDevice(bluetoothManager.getBluetoothAdapter(),
+                bluetoothManager.getProfileManager(), mDevice);
+        }
+
+        int phonebookPermission = cachedDevice.getPhonebookPermissionChoice();
+
+        if (phonebookPermission == CachedBluetoothDevice.PHONEBOOK_ACCESS_UNKNOWN) {
+            return processed;
+        }
+
+        String intentName = BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY;
+        if (phonebookPermission == CachedBluetoothDevice.PHONEBOOK_ACCESS_ALLOWED) {
+            sendIntentToReceiver(intentName, true, BluetoothDevice.EXTRA_ALWAYS_ALLOWED, true);
+            processed = true;
+        } else if (phonebookPermission == CachedBluetoothDevice.PHONEBOOK_ACCESS_REJECTED) {
+            sendIntentToReceiver(intentName, false,
+                                 null, false // dummy value, no effect since previous param is null
+                                 );
+            processed = true;
+        } else {
+            Log.e(TAG, "Bad phonebookPermission: " + phonebookPermission);
+        }
+        return processed;
+    }
+
+    private void sendIntentToReceiver(final String intentName, final boolean allowed,
+                                      final String extraName, final boolean extraValue) {
+        Intent intent = new Intent(intentName);
+
+        if (mReturnPackage != null && mReturnClass != null) {
+            intent.setClassName(mReturnPackage, mReturnClass);
+        }
+
+        intent.putExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT,
+                        allowed ? BluetoothDevice.CONNECTION_ACCESS_YES :
+                        BluetoothDevice.CONNECTION_ACCESS_NO);
+
+        if (extraName != null) {
+            intent.putExtra(extraName, extraValue);
+        }
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
+        mContext.sendBroadcast(intent, android.Manifest.permission.BLUETOOTH_ADMIN);
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothProgressCategory.java b/src/com/android/settings/bluetooth_msm/BluetoothProgressCategory.java
new file mode 100644
index 0000000..1c81360
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothProgressCategory.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import com.android.settings.ProgressCategory;
+import com.android.settings.R;
+
+import android.content.Context;
+import android.util.AttributeSet;
+
+public class BluetoothProgressCategory extends ProgressCategory {
+    public BluetoothProgressCategory(Context context, AttributeSet attrs) {
+        super(context, attrs, R.string.bluetooth_no_devices_found);
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothSettings.java b/src/com/android/settings/bluetooth_msm/BluetoothSettings.java
new file mode 100644
index 0000000..c5089ea
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothSettings.java
@@ -0,0 +1,388 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (C) 2013 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.app.ActionBar;
+import android.app.Activity;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.preference.Preference;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceCategory;
+import android.preference.PreferenceGroup;
+import android.preference.PreferenceScreen;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Switch;
+import android.widget.TextView;
+
+import com.android.settings.ProgressCategory;
+import com.android.settings.R;
+
+/**
+ * BluetoothSettings is the Settings screen for Bluetooth configuration and
+ * connection management.
+ */
+public final class BluetoothSettings extends DeviceListPreferenceFragment {
+    private static final String TAG = "BluetoothSettings";
+
+    private static final int MENU_ID_SCAN = Menu.FIRST;
+    private static final int MENU_ID_RENAME_DEVICE = Menu.FIRST + 1;
+    private static final int MENU_ID_VISIBILITY_TIMEOUT = Menu.FIRST + 2;
+    private static final int MENU_ID_SHOW_RECEIVED = Menu.FIRST + 3;
+
+    /* Private intent to show the list of received files */
+    private static final String BTOPP_ACTION_OPEN_RECEIVED_FILES =
+            "android.btopp.intent.action.OPEN_RECEIVED_FILES";
+
+    private BluetoothEnabler mBluetoothEnabler;
+
+    private BluetoothDiscoverableEnabler mDiscoverableEnabler;
+
+    private PreferenceGroup mPairedDevicesCategory;
+
+    private PreferenceGroup mAvailableDevicesCategory;
+    private boolean mAvailableDevicesCategoryIsPresent;
+    private boolean mActivityStarted;
+
+    private TextView mEmptyView;
+
+    private final IntentFilter mIntentFilter;
+
+    // accessed from inner class (not private to avoid thunks)
+    Preference mMyDevicePreference;
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED)) {
+                updateDeviceName();
+            }
+        }
+
+        private void updateDeviceName() {
+            if (mLocalAdapter.isEnabled() && mMyDevicePreference != null) {
+                mMyDevicePreference.setTitle(mLocalAdapter.getName());
+            }
+        }
+    };
+
+    public BluetoothSettings() {
+        mIntentFilter = new IntentFilter(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
+    }
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        mActivityStarted = (savedInstanceState == null);    // don't auto start scan after rotation
+
+        mEmptyView = (TextView) getView().findViewById(android.R.id.empty);
+        getListView().setEmptyView(mEmptyView);
+    }
+
+    @Override
+    void addPreferencesForActivity() {
+        addPreferencesFromResource(R.xml.bluetooth_settings);
+
+        Activity activity = getActivity();
+
+        Switch actionBarSwitch = new Switch(activity);
+
+        if (activity instanceof PreferenceActivity) {
+            PreferenceActivity preferenceActivity = (PreferenceActivity) activity;
+            if (preferenceActivity.onIsHidingHeaders() || !preferenceActivity.onIsMultiPane()) {
+                final int padding = activity.getResources().getDimensionPixelSize(
+                        R.dimen.action_bar_switch_padding);
+                actionBarSwitch.setPadding(0, 0, padding, 0);
+                activity.getActionBar().setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM,
+                        ActionBar.DISPLAY_SHOW_CUSTOM);
+                activity.getActionBar().setCustomView(actionBarSwitch, new ActionBar.LayoutParams(
+                        ActionBar.LayoutParams.WRAP_CONTENT,
+                        ActionBar.LayoutParams.WRAP_CONTENT,
+                        Gravity.CENTER_VERTICAL | Gravity.RIGHT));
+            }
+        }
+
+        mBluetoothEnabler = new BluetoothEnabler(activity, actionBarSwitch);
+
+        setHasOptionsMenu(true);
+    }
+
+    @Override
+    public void onResume() {
+        // resume BluetoothEnabler before calling super.onResume() so we don't get
+        // any onDeviceAdded() callbacks before setting up view in updateContent()
+        if (mBluetoothEnabler != null) {
+            mBluetoothEnabler.resume();
+        }
+        super.onResume();
+
+        if (mDiscoverableEnabler != null) {
+            mDiscoverableEnabler.resume();
+        }
+        getActivity().registerReceiver(mReceiver, mIntentFilter);
+        if (mLocalAdapter != null) {
+            updateContent(mLocalAdapter.getBluetoothState(), mActivityStarted);
+        }
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        if (mBluetoothEnabler != null) {
+            mBluetoothEnabler.pause();
+        }
+        getActivity().unregisterReceiver(mReceiver);
+        if (mDiscoverableEnabler != null) {
+            mDiscoverableEnabler.pause();
+        }
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        if (mLocalAdapter == null) return;
+        boolean bluetoothIsEnabled = mLocalAdapter.getBluetoothState() == BluetoothAdapter.STATE_ON;
+        boolean isDiscovering = mLocalAdapter.isDiscovering();
+        int textId = isDiscovering ? R.string.bluetooth_searching_for_devices :
+            R.string.bluetooth_search_for_devices;
+        menu.add(Menu.NONE, MENU_ID_SCAN, 0, textId)
+                .setEnabled(bluetoothIsEnabled && !isDiscovering)
+                .setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
+        menu.add(Menu.NONE, MENU_ID_RENAME_DEVICE, 0, R.string.bluetooth_rename_device)
+                .setEnabled(bluetoothIsEnabled)
+                .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
+        menu.add(Menu.NONE, MENU_ID_VISIBILITY_TIMEOUT, 0, R.string.bluetooth_visibility_timeout)
+                .setEnabled(bluetoothIsEnabled)
+                .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
+        menu.add(Menu.NONE, MENU_ID_SHOW_RECEIVED, 0, R.string.bluetooth_show_received_files)
+                .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
+        super.onCreateOptionsMenu(menu, inflater);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case MENU_ID_SCAN:
+                if (mLocalAdapter.getBluetoothState() == BluetoothAdapter.STATE_ON) {
+                    startScanning();
+                }
+                return true;
+
+            case MENU_ID_RENAME_DEVICE:
+                new BluetoothNameDialogFragment().show(
+                        getFragmentManager(), "rename device");
+                return true;
+
+            case MENU_ID_VISIBILITY_TIMEOUT:
+                new BluetoothVisibilityTimeoutFragment().show(
+                        getFragmentManager(), "visibility timeout");
+                return true;
+
+            case MENU_ID_SHOW_RECEIVED:
+                Intent intent = new Intent(BTOPP_ACTION_OPEN_RECEIVED_FILES);
+                getActivity().sendBroadcast(intent);
+                return true;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    private void startScanning() {
+        if (!mAvailableDevicesCategoryIsPresent) {
+            getPreferenceScreen().addPreference(mAvailableDevicesCategory);
+        }
+        mLocalAdapter.startScanning(true);
+    }
+
+    @Override
+    void onDevicePreferenceClick(BluetoothDevicePreference btPreference) {
+        mLocalAdapter.stopScanning();
+        super.onDevicePreferenceClick(btPreference);
+    }
+
+    private void addDeviceCategory(PreferenceGroup preferenceGroup, int titleId,
+            BluetoothDeviceFilter.Filter filter) {
+        preferenceGroup.setTitle(titleId);
+        getPreferenceScreen().addPreference(preferenceGroup);
+        setFilter(filter);
+        setDeviceListGroup(preferenceGroup);
+        addCachedDevices();
+        preferenceGroup.setEnabled(true);
+    }
+
+    private void updateContent(int bluetoothState, boolean scanState) {
+        final PreferenceScreen preferenceScreen = getPreferenceScreen();
+        int messageId = 0;
+
+        switch (bluetoothState) {
+            case BluetoothAdapter.STATE_ON:
+                preferenceScreen.removeAll();
+                preferenceScreen.setOrderingAsAdded(true);
+                mDevicePreferenceMap.clear();
+
+                // This device
+                if (mMyDevicePreference == null) {
+                    mMyDevicePreference = new Preference(getActivity());
+                }
+                mMyDevicePreference.setTitle(mLocalAdapter.getName());
+                if (getResources().getBoolean(com.android.internal.R.bool.config_voice_capable)) {
+                    mMyDevicePreference.setIcon(R.drawable.ic_bt_cellphone);    // for phones
+                } else {
+                    mMyDevicePreference.setIcon(R.drawable.ic_bt_laptop);   // for tablets, etc.
+                }
+                mMyDevicePreference.setPersistent(false);
+                mMyDevicePreference.setEnabled(true);
+                preferenceScreen.addPreference(mMyDevicePreference);
+
+                if (mDiscoverableEnabler == null) {
+                    mDiscoverableEnabler = new BluetoothDiscoverableEnabler(getActivity(),
+                            mLocalAdapter, mMyDevicePreference);
+                    mDiscoverableEnabler.resume();
+                    LocalBluetoothManager.getInstance(getActivity()).setDiscoverableEnabler(
+                            mDiscoverableEnabler);
+                }
+
+                // Paired devices category
+                if (mPairedDevicesCategory == null) {
+                    mPairedDevicesCategory = new PreferenceCategory(getActivity());
+                } else {
+                    mPairedDevicesCategory.removeAll();
+                }
+                addDeviceCategory(mPairedDevicesCategory,
+                        R.string.bluetooth_preference_paired_devices,
+                        BluetoothDeviceFilter.BONDED_DEVICE_FILTER);
+                int numberOfPairedDevices = mPairedDevicesCategory.getPreferenceCount();
+
+                mDiscoverableEnabler.setNumberOfPairedDevices(numberOfPairedDevices);
+
+                // Available devices category
+                if (mAvailableDevicesCategory == null) {
+                    mAvailableDevicesCategory = new BluetoothProgressCategory(getActivity(), null);
+                } else {
+                    mAvailableDevicesCategory.removeAll();
+                }
+                addDeviceCategory(mAvailableDevicesCategory,
+                        R.string.bluetooth_preference_found_devices,
+                        BluetoothDeviceFilter.UNBONDED_DEVICE_FILTER);
+                int numberOfAvailableDevices = mAvailableDevicesCategory.getPreferenceCount();
+                mAvailableDevicesCategoryIsPresent = true;
+
+                if (numberOfAvailableDevices == 0) {
+                    preferenceScreen.removePreference(mAvailableDevicesCategory);
+                    mAvailableDevicesCategoryIsPresent = false;
+                }
+
+                if (numberOfPairedDevices == 0) {
+                    preferenceScreen.removePreference(mPairedDevicesCategory);
+                    if (scanState == true) {
+                        mActivityStarted = false;
+                        startScanning();
+                    } else {
+                        if (!mAvailableDevicesCategoryIsPresent) {
+                            getPreferenceScreen().addPreference(mAvailableDevicesCategory);
+                        }
+                    }
+                }
+                getActivity().invalidateOptionsMenu();
+                return; // not break
+
+            case BluetoothAdapter.STATE_TURNING_OFF:
+                messageId = R.string.bluetooth_turning_off;
+                break;
+
+            case BluetoothAdapter.STATE_OFF:
+                messageId = R.string.bluetooth_empty_list_bluetooth_off;
+                break;
+
+            case BluetoothAdapter.STATE_TURNING_ON:
+                messageId = R.string.bluetooth_turning_on;
+                break;
+        }
+
+        setDeviceListGroup(preferenceScreen);
+        removeAllDevices();
+        mEmptyView.setText(messageId);
+        getActivity().invalidateOptionsMenu();
+    }
+
+    @Override
+    public void onBluetoothStateChanged(int bluetoothState) {
+        super.onBluetoothStateChanged(bluetoothState);
+        updateContent(bluetoothState, true);
+    }
+
+    @Override
+    public void onScanningStateChanged(boolean started) {
+        super.onScanningStateChanged(started);
+        // Update options' enabled state
+        getActivity().invalidateOptionsMenu();
+    }
+
+    public void onDeviceBondStateChanged(CachedBluetoothDevice cachedDevice, int bondState) {
+        setDeviceListGroup(getPreferenceScreen());
+        removeAllDevices();
+        updateContent(mLocalAdapter.getBluetoothState(), false);
+    }
+
+    private final View.OnClickListener mDeviceProfilesListener = new View.OnClickListener() {
+        public void onClick(View v) {
+            // User clicked on advanced options icon for a device in the list
+            if (v.getTag() instanceof CachedBluetoothDevice) {
+                CachedBluetoothDevice device = (CachedBluetoothDevice) v.getTag();
+
+                Bundle args = new Bundle(1);
+                args.putParcelable(DeviceProfilesSettings.EXTRA_DEVICE, device.getDevice());
+
+                ((PreferenceActivity) getActivity()).startPreferencePanel(
+                        DeviceProfilesSettings.class.getName(), args,
+                        R.string.bluetooth_device_advanced_title, null, null, 0);
+            } else {
+                Log.w(TAG, "onClick() called for other View: " + v); // TODO remove
+            }
+        }
+    };
+
+    /**
+     * Add a listener, which enables the advanced settings icon.
+     * @param preference the newly added preference
+     */
+    @Override
+    void initDevicePreference(BluetoothDevicePreference preference) {
+        CachedBluetoothDevice cachedDevice = preference.getCachedDevice();
+        if (cachedDevice.getBondState() == BluetoothDevice.BOND_BONDED) {
+            // Only paired device have an associated advanced settings screen
+            preference.setOnSettingsClickListener(mDeviceProfilesListener);
+        }
+    }
+
+    @Override
+    protected int getHelpResource() {
+        return R.string.help_url_bluetooth;
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/BluetoothVisibilityTimeoutFragment.java b/src/com/android/settings/bluetooth_msm/BluetoothVisibilityTimeoutFragment.java
new file mode 100644
index 0000000..a65c6c1
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/BluetoothVisibilityTimeoutFragment.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.app.DialogFragment;
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.text.Editable;
+import android.text.InputFilter;
+import android.text.TextWatcher;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.widget.Button;
+import android.widget.EditText;
+
+import com.android.internal.app.AlertController;
+import com.android.settings.R;
+
+/**
+ * Dialog fragment for setting the discoverability timeout.
+ */
+public final class BluetoothVisibilityTimeoutFragment extends DialogFragment
+        implements DialogInterface.OnClickListener {
+
+    private final BluetoothDiscoverableEnabler mDiscoverableEnabler;
+
+    public BluetoothVisibilityTimeoutFragment() {
+        mDiscoverableEnabler = LocalBluetoothManager.getInstance(getActivity())
+                .getDiscoverableEnabler();
+    }
+
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        return new AlertDialog.Builder(getActivity())
+                .setTitle(R.string.bluetooth_visibility_timeout)
+                .setSingleChoiceItems(R.array.bluetooth_visibility_timeout_entries,
+                        mDiscoverableEnabler.getDiscoverableTimeoutIndex(), this)
+                .setNegativeButton(android.R.string.cancel, null)
+                .create();
+    }
+
+    public void onClick(DialogInterface dialog, int which) {
+        mDiscoverableEnabler.setDiscoverableTimeout(which);
+        dismiss();
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/CachedBluetoothDevice.java b/src/com/android/settings/bluetooth_msm/CachedBluetoothDevice.java
new file mode 100644
index 0000000..e5b77a2
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/CachedBluetoothDevice.java
@@ -0,0 +1,691 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012-2013 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothAdapter;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.ParcelUuid;
+import android.os.SystemClock;
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * CachedBluetoothDevice represents a remote Bluetooth device. It contains
+ * attributes of the device (such as the address, name, RSSI, etc.) and
+ * functionality that can be performed on the device (connect, pair, disconnect,
+ * etc.).
+ */
+final class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice> {
+    private static final String TAG = "CachedBluetoothDevice";
+    private static final boolean DEBUG = Utils.V;
+
+    private final Context mContext;
+    private final LocalBluetoothAdapter mLocalAdapter;
+    private final LocalBluetoothProfileManager mProfileManager;
+    private final BluetoothDevice mDevice;
+    private String mName;
+    private short mRssi;
+    private BluetoothClass mBtClass;
+    private HashMap<LocalBluetoothProfile, Integer> mProfileConnectionState;
+
+    private final List<LocalBluetoothProfile> mProfiles =
+            new ArrayList<LocalBluetoothProfile>();
+
+    // List of profiles that were previously in mProfiles, but have been removed
+    private final List<LocalBluetoothProfile> mRemovedProfiles =
+            new ArrayList<LocalBluetoothProfile>();
+
+    // Device supports PANU but not NAP: remove PanProfile after device disconnects from NAP
+    private boolean mLocalNapRoleConnected;
+
+    private boolean mVisible;
+
+    private boolean mDeviceRemove;
+
+    private int mPhonebookPermissionChoice;
+
+    private final Collection<Callback> mCallbacks = new ArrayList<Callback>();
+
+    // Following constants indicate the user's choices of Phone book access settings
+    // User hasn't made any choice or settings app has wiped out the memory
+    final static int PHONEBOOK_ACCESS_UNKNOWN = 0;
+    // User has accepted the connection and let Settings app remember the decision
+    final static int PHONEBOOK_ACCESS_ALLOWED = 1;
+    // User has rejected the connection and let Settings app remember the decision
+    final static int PHONEBOOK_ACCESS_REJECTED = 2;
+
+    private final static String PHONEBOOK_PREFS_NAME = "bluetooth_phonebook_permission";
+
+    /**
+     * When we connect to multiple profiles, we only want to display a single
+     * error even if they all fail. This tracks that state.
+     */
+    private boolean mIsConnectingErrorPossible;
+
+    /**
+     * Last time a bt profile auto-connect was attempted.
+     * If an ACTION_UUID intent comes in within
+     * MAX_UUID_DELAY_FOR_AUTO_CONNECT milliseconds, we will try auto-connect
+     * again with the new UUIDs
+     */
+    private long mConnectAttempted;
+
+    // See mConnectAttempted
+    private static final long MAX_UUID_DELAY_FOR_AUTO_CONNECT = 5000;
+
+    /** Auto-connect after pairing only if locally initiated. */
+    private boolean mConnectAfterPairing;
+
+    /**
+     * Describes the current device and profile for logging.
+     *
+     * @param profile Profile to describe
+     * @return Description of the device and profile
+     */
+    private String describe(LocalBluetoothProfile profile) {
+        StringBuilder sb = new StringBuilder();
+        sb.append("Address:").append(mDevice);
+        if (profile != null) {
+            sb.append(" Profile:").append(profile);
+        }
+
+        return sb.toString();
+    }
+
+    void onProfileStateChanged(LocalBluetoothProfile profile, int newProfileState) {
+        if (Utils.D) {
+            Log.d(TAG, "onProfileStateChanged: profile " + profile +
+                    " newProfileState " + newProfileState);
+        }
+
+        mProfileConnectionState.put(profile, newProfileState);
+        if (newProfileState == BluetoothProfile.STATE_CONNECTED) {
+            if (!mProfiles.contains(profile)) {
+                mRemovedProfiles.remove(profile);
+                mProfiles.add(profile);
+                if (profile instanceof PanProfile &&
+                        ((PanProfile) profile).isLocalRoleNap(mDevice)) {
+                    // Device doesn't support NAP, so remove PanProfile on disconnect
+                    mLocalNapRoleConnected = true;
+                }
+            }
+        } else if (mLocalNapRoleConnected && profile instanceof PanProfile &&
+                ((PanProfile) profile).isLocalRoleNap(mDevice) &&
+                newProfileState == BluetoothProfile.STATE_DISCONNECTED) {
+            Log.d(TAG, "Removing PanProfile from device after NAP disconnect");
+            mProfiles.remove(profile);
+            mRemovedProfiles.add(profile);
+            mLocalNapRoleConnected = false;
+        } else if ((profile instanceof SapProfile || profile instanceof DUNProfile) &&
+            newProfileState == BluetoothProfile.STATE_DISCONNECTED) {
+            mProfiles.remove(profile);
+            mRemovedProfiles.add(profile);
+            Log.d(TAG, "Removed Profile from the list");
+        }
+    }
+
+    CachedBluetoothDevice(Context context,
+                          LocalBluetoothAdapter adapter,
+                          LocalBluetoothProfileManager profileManager,
+                          BluetoothDevice device) {
+        mContext = context;
+        mLocalAdapter = adapter;
+        mProfileManager = profileManager;
+        mDevice = device;
+        mProfileConnectionState = new HashMap<LocalBluetoothProfile, Integer>();
+        fillData();
+    }
+
+    void disconnect() {
+        for (LocalBluetoothProfile profile : mProfiles) {
+            disconnect(profile);
+        }
+    }
+
+    void disconnect(LocalBluetoothProfile profile) {
+        if (profile.disconnect(mDevice)) {
+            if (Utils.D) {
+                Log.d(TAG, "Command sent successfully:DISCONNECT " + describe(profile));
+            }
+        }
+    }
+
+    public void resetAllServerProfiles() {
+        for (LocalBluetoothProfile profile : mProfiles) {
+            if (profile instanceof SapProfile) {
+                ((SapProfile)profile).setConnectionStatus(BluetoothProfile.STATE_DISCONNECTED);
+            }
+            if (profile instanceof DUNProfile) {
+                ((DUNProfile)profile).setConnectionStatus(BluetoothProfile.STATE_DISCONNECTED);
+            }
+        }
+    }
+
+    void connect(boolean connectAllProfiles) {
+        if (!ensurePaired()) {
+            return;
+        }
+
+        mConnectAttempted = SystemClock.elapsedRealtime();
+        connectWithoutResettingTimer(connectAllProfiles);
+    }
+
+    void onBondingDockConnect() {
+        // Attempt to connect if UUIDs are available. Otherwise,
+        // we will connect when the ACTION_UUID intent arrives.
+        connect(false);
+    }
+
+    private void connectWithoutResettingTimer(boolean connectAllProfiles) {
+        // Try to initialize the profiles if they were not.
+        if (mProfiles.isEmpty()) {
+            if (!updateProfiles()) {
+                // If UUIDs are not available yet, connect will be happen
+                // upon arrival of the ACTION_UUID intent.
+                if (DEBUG) Log.d(TAG, "No profiles. Maybe we will connect later");
+                return;
+            }
+        }
+
+        // Reset the only-show-one-error-dialog tracking variable
+        mIsConnectingErrorPossible = true;
+
+        int preferredProfiles = 0;
+        if ((connectAllProfiles == false) &&
+            (mLocalAdapter.isHostPatchRequired(mDevice,
+             BluetoothAdapter.HOST_PATCH_AVOID_CONNECT_ON_PAIR))) {
+             //Depending on class of device restricting the connection only to Carkit.
+             BluetoothClass btClass = mDevice.getBluetoothClass();
+             if (btClass.getDeviceClass() == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE) {
+                 Log.d(TAG, "No connection expected with current device");
+                 return;
+             }
+        }
+        for (LocalBluetoothProfile profile : mProfiles) {
+            if (connectAllProfiles ? profile.isConnectable() : profile.isAutoConnectable()) {
+                if (profile.isPreferred(mDevice)) {
+                    ++preferredProfiles;
+                    connectInt(profile);
+                }
+            }
+        }
+        if (DEBUG) Log.d(TAG, "Preferred profiles = " + preferredProfiles);
+
+        if (preferredProfiles == 0) {
+            connectAutoConnectableProfiles();
+        }
+    }
+
+    private void connectAutoConnectableProfiles() {
+        if (!ensurePaired()) {
+            return;
+        }
+        // Reset the only-show-one-error-dialog tracking variable
+        mIsConnectingErrorPossible = true;
+
+        for (LocalBluetoothProfile profile : mProfiles) {
+            if (profile.isAutoConnectable()) {
+                profile.setPreferred(mDevice, true);
+                connectInt(profile);
+            }
+        }
+    }
+
+    /**
+     * Connect this device to the specified profile.
+     *
+     * @param profile the profile to use with the remote device
+     */
+    void connectProfile(LocalBluetoothProfile profile) {
+        mConnectAttempted = SystemClock.elapsedRealtime();
+        // Reset the only-show-one-error-dialog tracking variable
+        mIsConnectingErrorPossible = true;
+        connectInt(profile);
+    }
+
+    private void connectInt(LocalBluetoothProfile profile) {
+        if (!ensurePaired()) {
+            return;
+        } else {
+            // connecting is unreliable while scanning, so cancel discovery
+            if (mLocalAdapter == null) {
+                Log.e(TAG, "Adapter is null");
+                return;
+            }
+            if (mLocalAdapter.isDiscovering()) {
+                mLocalAdapter.cancelDiscovery();
+            }
+        }
+        if (profile.connect(mDevice)) {
+            if (Utils.D) {
+                Log.d(TAG, "Command sent successfully:CONNECT " + describe(profile));
+            }
+            return;
+        }
+        Log.i(TAG, "Failed to connect " + profile.toString() + " to " + mName);
+    }
+
+    private boolean ensurePaired() {
+        if (getBondState() == BluetoothDevice.BOND_NONE) {
+            startPairing();
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    boolean startPairing() {
+        // Pairing is unreliable while scanning, so cancel discovery
+        if (mLocalAdapter.isDiscovering()) {
+            mLocalAdapter.cancelDiscovery();
+        }
+
+        if (!mDevice.createBond()) {
+            return false;
+        }
+
+        mConnectAfterPairing = true;  // auto-connect after pairing
+        return true;
+    }
+
+    /**
+     * Return true if user initiated pairing on this device. The message text is
+     * slightly different for local vs. remote initiated pairing dialogs.
+     */
+    boolean isUserInitiatedPairing() {
+        return mConnectAfterPairing;
+    }
+
+    void unpair() {
+        disconnect();
+
+        int state = getBondState();
+
+        if (state == BluetoothDevice.BOND_BONDING) {
+            mDevice.cancelBondProcess();
+        }
+
+        if (state != BluetoothDevice.BOND_NONE) {
+            final BluetoothDevice dev = mDevice;
+            if (dev != null) {
+                final boolean successful = dev.removeBond();
+                if (successful) {
+                    if (Utils.D) {
+                        Log.d(TAG, "Command sent successfully:REMOVE_BOND " + describe(null));
+                    }
+                    setRemovable(true);
+                } else if (Utils.V) {
+                    Log.v(TAG, "Framework rejected command immediately:REMOVE_BOND " +
+                            describe(null));
+                }
+            }
+        }
+    }
+
+    int getProfileConnectionState(LocalBluetoothProfile profile) {
+        if (mProfileConnectionState == null ||
+                mProfileConnectionState.get(profile) == null) {
+            // If cache is empty make the binder call to get the state
+            int state = profile.getConnectionStatus(mDevice);
+            mProfileConnectionState.put(profile, state);
+        }
+        return mProfileConnectionState.get(profile);
+    }
+
+    // TODO: do any of these need to run async on a background thread?
+    private void fillData() {
+        fetchName();
+        fetchBtClass();
+        updateProfiles();
+        fetchPhonebookPermissionChoice();
+
+        mVisible = false;
+        dispatchAttributesChanged();
+    }
+
+    BluetoothDevice getDevice() {
+        return mDevice;
+    }
+
+    String getName() {
+        return mName;
+    }
+
+    void setName(String name) {
+        if (!mName.equals(name)) {
+            if (TextUtils.isEmpty(name)) {
+                // TODO: use friendly name for unknown device (bug 1181856)
+                mName = mDevice.getAddress();
+            } else {
+                mName = name;
+                mDevice.setAlias(name);
+            }
+            dispatchAttributesChanged();
+        }
+    }
+
+    void refreshName() {
+        fetchName();
+        dispatchAttributesChanged();
+    }
+
+    private void fetchName() {
+        mName = mDevice.getAliasName();
+
+        if (TextUtils.isEmpty(mName)) {
+            mName = mDevice.getAddress();
+            if (DEBUG) Log.d(TAG, "Device has no name (yet), use address: " + mName);
+        }
+    }
+
+    void refresh() {
+        dispatchAttributesChanged();
+    }
+
+    boolean isVisible() {
+        return mVisible;
+    }
+
+    boolean isRemovable () {
+        return mDeviceRemove;
+   }
+
+
+    void setVisible(boolean visible) {
+        if (mVisible != visible) {
+            mVisible = visible;
+            dispatchAttributesChanged();
+        }
+    }
+
+    void setRemovable(boolean removable) {
+        mDeviceRemove = removable;
+    }
+
+
+    int getBondState() {
+        return mDevice.getBondState();
+    }
+
+    void setRssi(short rssi) {
+        if (mRssi != rssi) {
+            mRssi = rssi;
+            dispatchAttributesChanged();
+        }
+    }
+
+    /**
+     * Checks whether we are connected to this device (any profile counts).
+     *
+     * @return Whether it is connected.
+     */
+    boolean isConnected() {
+        for (LocalBluetoothProfile profile : mProfiles) {
+            int status = getProfileConnectionState(profile);
+            if (status == BluetoothProfile.STATE_CONNECTED) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    boolean isConnectedProfile(LocalBluetoothProfile profile) {
+        int status = getProfileConnectionState(profile);
+        return status == BluetoothProfile.STATE_CONNECTED;
+
+    }
+
+    boolean isBusy() {
+        for (LocalBluetoothProfile profile : mProfiles) {
+            int status = getProfileConnectionState(profile);
+            if (status == BluetoothProfile.STATE_CONNECTING
+                    || status == BluetoothProfile.STATE_DISCONNECTING) {
+                return true;
+            }
+        }
+        return getBondState() == BluetoothDevice.BOND_BONDING;
+    }
+
+    /**
+     * Fetches a new value for the cached BT class.
+     */
+    private void fetchBtClass() {
+        mBtClass = mDevice.getBluetoothClass();
+    }
+
+    private boolean updateProfiles() {
+        ParcelUuid[] uuids = mDevice.getUuids();
+        if (uuids == null) return false;
+
+        ParcelUuid[] localUuids = mLocalAdapter.getUuids();
+        if (localUuids == null) return false;
+
+        if (mProfileManager == null) {
+            Log.e(TAG, "ProfileManager is null");
+            return false;
+        }
+        /*Fixes the IOT issue of few UUIDs missing in the SDP updates
+        of few carkits. ProfileManager::addNewProfiles will make sure
+        it only adds the new uuids without clearing the existing profile
+        in the profile cache*/
+        mProfileManager.addNewProfiles(uuids, localUuids, mProfiles, mRemovedProfiles);
+
+        if (DEBUG) {
+            Log.e(TAG, "updating profiles for " + mDevice.getAliasName());
+            BluetoothClass bluetoothClass = mDevice.getBluetoothClass();
+
+            if (bluetoothClass != null) Log.v(TAG, "Class: " + bluetoothClass.toString());
+            Log.v(TAG, "UUID:");
+            for (ParcelUuid uuid : uuids) {
+                Log.v(TAG, "  " + uuid);
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Refreshes the UI for the BT class, including fetching the latest value
+     * for the class.
+     */
+    void refreshBtClass() {
+        fetchBtClass();
+        dispatchAttributesChanged();
+    }
+
+    /**
+     * Refreshes the UI when framework alerts us of a UUID change.
+     */
+    void onUuidChanged() {
+        updateProfiles();
+
+        if (DEBUG) {
+            Log.e(TAG, "onUuidChanged: Time since last connect"
+                    + (SystemClock.elapsedRealtime() - mConnectAttempted));
+        }
+
+        /*
+         * If a connect was attempted earlier without any UUID, we will do the
+         * connect now.
+         */
+        if (!mProfiles.isEmpty()
+                && (mConnectAttempted + MAX_UUID_DELAY_FOR_AUTO_CONNECT) > SystemClock
+                        .elapsedRealtime()) {
+            connectWithoutResettingTimer(false);
+        }
+        dispatchAttributesChanged();
+    }
+
+    void onBondingStateChanged(int bondState) {
+        if (bondState == BluetoothDevice.BOND_NONE) {
+            mProfiles.clear();
+            mConnectAfterPairing = false;  // cancel auto-connect
+            setPhonebookPermissionChoice(PHONEBOOK_ACCESS_UNKNOWN);
+        }
+
+        if (bondState == BluetoothDevice.BOND_BONDED) {
+            fetchName();
+        }
+        refresh();
+
+        if (bondState == BluetoothDevice.BOND_BONDED) {
+            if (mDevice.isBluetoothDock()) {
+                onBondingDockConnect();
+            } else if (mConnectAfterPairing) {
+                connect(false);
+            }
+            mConnectAfterPairing = false;
+        }
+
+        if (bondState == BluetoothDevice.BOND_RETRY) {
+            Log.i(TAG, "Bond state is Retry, set autoconnect");
+            mConnectAfterPairing = true;
+        }
+    }
+
+    void setBtClass(BluetoothClass btClass) {
+        if (btClass != null && mBtClass != btClass) {
+            mBtClass = btClass;
+            dispatchAttributesChanged();
+        }
+    }
+
+    BluetoothClass getBtClass() {
+        return mBtClass;
+    }
+
+    List<LocalBluetoothProfile> getProfiles() {
+        return Collections.unmodifiableList(mProfiles);
+    }
+
+    List<LocalBluetoothProfile> getConnectableProfiles() {
+        List<LocalBluetoothProfile> connectableProfiles =
+                new ArrayList<LocalBluetoothProfile>();
+        for (LocalBluetoothProfile profile : mProfiles) {
+            if (profile.isConnectable()) {
+                connectableProfiles.add(profile);
+            }
+        }
+        return connectableProfiles;
+    }
+
+    List<LocalBluetoothProfile> getRemovedProfiles() {
+        return mRemovedProfiles;
+    }
+
+    void registerCallback(Callback callback) {
+        synchronized (mCallbacks) {
+            mCallbacks.add(callback);
+        }
+    }
+
+    void unregisterCallback(Callback callback) {
+        synchronized (mCallbacks) {
+            mCallbacks.remove(callback);
+        }
+    }
+
+    private void dispatchAttributesChanged() {
+        synchronized (mCallbacks) {
+            for (Callback callback : mCallbacks) {
+                callback.onDeviceAttributesChanged();
+            }
+        }
+    }
+
+    @Override
+    public String toString() {
+        return mDevice.toString();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if ((o == null) || !(o instanceof CachedBluetoothDevice)) {
+            return false;
+        }
+        return mDevice.equals(((CachedBluetoothDevice) o).mDevice);
+    }
+
+    @Override
+    public int hashCode() {
+        return mDevice.getAddress().hashCode();
+    }
+
+    // This comparison uses non-final fields so the sort order may change
+    // when device attributes change (such as bonding state). Settings
+    // will completely refresh the device list when this happens.
+    public int compareTo(CachedBluetoothDevice another) {
+        // Connected above not connected
+        int comparison = (another.isConnected() ? 1 : 0) - (isConnected() ? 1 : 0);
+        if (comparison != 0) return comparison;
+
+        // Paired above not paired
+        comparison = (another.getBondState() == BluetoothDevice.BOND_BONDED ? 1 : 0) -
+            (getBondState() == BluetoothDevice.BOND_BONDED ? 1 : 0);
+        if (comparison != 0) return comparison;
+
+        // Visible above not visible
+        comparison = (another.mVisible ? 1 : 0) - (mVisible ? 1 : 0);
+        if (comparison != 0) return comparison;
+
+        // Stronger signal above weaker signal
+        comparison = another.mRssi - mRssi;
+        if (comparison != 0) return comparison;
+
+        // Fallback on name
+        return mName.compareTo(another.mName);
+    }
+
+    public interface Callback {
+        void onDeviceAttributesChanged();
+    }
+
+    int getPhonebookPermissionChoice() {
+        return mPhonebookPermissionChoice;
+    }
+
+    void setPhonebookPermissionChoice(int permissionChoice) {
+        SharedPreferences.Editor editor =
+            mContext.getSharedPreferences(PHONEBOOK_PREFS_NAME, Context.MODE_PRIVATE).edit();
+        if (permissionChoice == PHONEBOOK_ACCESS_UNKNOWN) {
+            editor.remove(mDevice.getAddress());
+        } else {
+            editor.putInt(mDevice.getAddress(), permissionChoice);
+        }
+        editor.commit();
+        mPhonebookPermissionChoice = permissionChoice;
+    }
+
+    private void fetchPhonebookPermissionChoice() {
+        SharedPreferences preference = mContext.getSharedPreferences(PHONEBOOK_PREFS_NAME,
+                                                                     Context.MODE_PRIVATE);
+        mPhonebookPermissionChoice = preference.getInt(mDevice.getAddress(),
+                                                       PHONEBOOK_ACCESS_UNKNOWN);
+    }
+
+}
diff --git a/src/com/android/settings/bluetooth_msm/CachedBluetoothDeviceManager.java b/src/com/android/settings/bluetooth_msm/CachedBluetoothDeviceManager.java
new file mode 100644
index 0000000..1a4b229
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/CachedBluetoothDeviceManager.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothDevice;
+import android.content.Context;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * CachedBluetoothDeviceManager manages the set of remote Bluetooth devices.
+ */
+final class CachedBluetoothDeviceManager {
+    private static final String TAG = "CachedBluetoothDeviceManager";
+    private static final boolean DEBUG = Utils.D;
+
+    private Context mContext;
+    private final List<CachedBluetoothDevice> mCachedDevices =
+            new ArrayList<CachedBluetoothDevice>();
+
+    CachedBluetoothDeviceManager(Context context) {
+        mContext = context;
+    }
+
+    public synchronized Collection<CachedBluetoothDevice> getCachedDevicesCopy() {
+        return new ArrayList<CachedBluetoothDevice>(mCachedDevices);
+    }
+
+    public static boolean onDeviceDisappeared(CachedBluetoothDevice cachedDevice) {
+        cachedDevice.setVisible(false);
+        return cachedDevice.getBondState() == BluetoothDevice.BOND_NONE;
+    }
+
+    public void onDeviceNameUpdated(BluetoothDevice device) {
+        CachedBluetoothDevice cachedDevice = findDevice(device);
+        if (cachedDevice != null) {
+            cachedDevice.refreshName();
+        }
+    }
+
+    /**
+     * Search for existing {@link CachedBluetoothDevice} or return null
+     * if this device isn't in the cache. Use {@link #addDevice}
+     * to create and return a new {@link CachedBluetoothDevice} for
+     * a newly discovered {@link BluetoothDevice}.
+     *
+     * @param device the address of the Bluetooth device
+     * @return the cached device object for this device, or null if it has
+     *   not been previously seen
+     */
+    CachedBluetoothDevice findDevice(BluetoothDevice device) {
+        for (CachedBluetoothDevice cachedDevice : mCachedDevices) {
+            if (cachedDevice.getDevice().equals(device)) {
+                return cachedDevice;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Create and return a new {@link CachedBluetoothDevice}. This assumes
+     * that {@link #findDevice} has already been called and returned null.
+     * @param device the address of the new Bluetooth device
+     * @return the newly created CachedBluetoothDevice object
+     */
+    CachedBluetoothDevice addDevice(LocalBluetoothAdapter adapter,
+            LocalBluetoothProfileManager profileManager,
+            BluetoothDevice device) {
+        CachedBluetoothDevice newDevice = new CachedBluetoothDevice(mContext, adapter,
+            profileManager, device);
+        mCachedDevices.add(newDevice);
+        return newDevice;
+    }
+
+    /**
+     * Attempts to get the name of a remote device, otherwise returns the address.
+     *
+     * @param device The remote device.
+     * @return The name, or if unavailable, the address.
+     */
+    public String getName(BluetoothDevice device) {
+        CachedBluetoothDevice cachedDevice = findDevice(device);
+        if (cachedDevice != null) {
+            return cachedDevice.getName();
+        }
+
+        String name = device.getAliasName();
+        if (name != null) {
+            return name;
+        }
+
+        return device.getAddress();
+    }
+
+    public synchronized void onScanningStateChanged(boolean started) {
+        // If starting a new scan, clear old visibility
+        // Iterate in reverse order since devices may be removed.
+        for (int i = mCachedDevices.size() - 1; i >= 0; i--) {
+            CachedBluetoothDevice cachedDevice = mCachedDevices.get(i);
+            if (started) {
+                cachedDevice.setVisible(false);
+            } else if (!started &&
+                cachedDevice.getBondState() == BluetoothDevice.BOND_NONE &&
+                cachedDevice.isRemovable()) {
+                mCachedDevices.remove(cachedDevice);
+            }
+        }
+    }
+
+    public synchronized void onBtClassChanged(BluetoothDevice device) {
+        CachedBluetoothDevice cachedDevice = findDevice(device);
+        if (cachedDevice != null) {
+            cachedDevice.refreshBtClass();
+        }
+    }
+
+    public synchronized void onUuidChanged(BluetoothDevice device) {
+        CachedBluetoothDevice cachedDevice = findDevice(device);
+        if (cachedDevice != null) {
+            cachedDevice.onUuidChanged();
+        }
+    }
+
+    public synchronized void onDeviceDeleted(CachedBluetoothDevice cachedDevice) {
+        Log.d(TAG,"onDeviceDeleted");
+        if (cachedDevice != null &&
+            cachedDevice.getBondState() == BluetoothDevice.BOND_NONE &&
+            cachedDevice.isRemovable()) {
+            mCachedDevices.remove(cachedDevice);
+        }
+    }
+
+    private void log(String msg) {
+        if (DEBUG) {
+            Log.d(TAG, msg);
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/DUNProfile.java b/src/com/android/settings/bluetooth_msm/DUNProfile.java
new file mode 100644
index 0000000..4c6d8f3
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/DUNProfile.java
@@ -0,0 +1,125 @@
+/*
+ ** Copyright 2008, The Android Open Source Project
+ ** Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothDUN;
+import android.bluetooth.BluetoothProfile;
+import android.content.Context;
+import android.util.Log;
+
+import com.android.settings.R;
+
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * DUNProfile handles Bluetooth DUN profile.
+ */
+final class DUNProfile implements LocalBluetoothProfile {
+    private BluetoothDUN mService;
+    private int mConnectionStatus = 0;
+
+    // Tethering direction for each device
+    private final HashMap<BluetoothDevice, Integer> mDeviceRoleMap =
+            new HashMap<BluetoothDevice, Integer>();
+
+    static final String NAME = "DUN";
+
+    // Order of this profile in device profiles list
+    private static final int ORDINAL = 5;
+
+    DUNProfile() {
+        mService = new BluetoothDUN();
+    }
+
+    public boolean isConnectable() {
+        return true;
+    }
+
+    public boolean isAutoConnectable() {
+        return false;
+    }
+
+    public boolean connect(BluetoothDevice device) {
+        return false;
+    }
+
+    public boolean disconnect(BluetoothDevice device) {
+        boolean ret = mService.disconnect();
+        return ret;
+    }
+
+    public int getConnectionStatus(BluetoothDevice device) {
+        return mConnectionStatus;
+    }
+
+    public void setConnectionStatus(int status) {
+        mConnectionStatus = status;
+    }
+
+    public boolean isPreferred(BluetoothDevice device) {
+        return true;
+    }
+
+    public int getPreferred(BluetoothDevice device) {
+        return -1;
+    }
+
+    public void setPreferred(BluetoothDevice device, boolean preferred) {
+        // ignore: isPreferred is always true for DUN
+    }
+
+    public boolean isProfileReady() {
+        return true;
+    }
+
+    public String toString() {
+        return NAME;
+    }
+
+    public int getOrdinal() {
+        return ORDINAL;
+    }
+
+    public int getNameResource(BluetoothDevice device) {
+        return R.string.bluetooth_profile_dun;
+    }
+
+    public int getSummaryResourceForDevice(BluetoothDevice device) {
+        int state = getConnectionStatus(device);
+        switch (state) {
+            case BluetoothProfile.STATE_DISCONNECTED:
+                return R.string.bluetooth_dun_profile_summary_use_for;
+
+            case BluetoothProfile.STATE_CONNECTED:
+                    return R.string.bluetooth_dun_profile_summary_connected;
+
+            default:
+                return Utils.getConnectionStateSummary(state);
+        }
+    }
+
+    public int getDrawableResource(BluetoothClass btClass) {
+        //TODO change this for DUN
+        return R.drawable.ic_bt_network_pan;
+    }
+
+}
diff --git a/src/com/android/settings/bluetooth_msm/DeviceListPreferenceFragment.java b/src/com/android/settings/bluetooth_msm/DeviceListPreferenceFragment.java
new file mode 100644
index 0000000..70377fc
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/DeviceListPreferenceFragment.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (C) 2013 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.os.Bundle;
+import android.preference.Preference;
+import android.preference.PreferenceCategory;
+import android.preference.PreferenceGroup;
+import android.preference.PreferenceScreen;
+import android.util.Log;
+
+import com.android.settings.ProgressCategory;
+import com.android.settings.SettingsPreferenceFragment;
+
+import java.util.Collection;
+import java.util.WeakHashMap;
+
+/**
+ * Parent class for settings fragments that contain a list of Bluetooth
+ * devices.
+ *
+ * @see BluetoothSettings
+ * @see DevicePickerFragment
+ */
+public abstract class DeviceListPreferenceFragment extends
+        SettingsPreferenceFragment implements BluetoothCallback {
+
+    private static final String TAG = "DeviceListPreferenceFragment";
+
+    private static final String KEY_BT_DEVICE_LIST = "bt_device_list";
+    private static final String KEY_BT_SCAN = "bt_scan";
+
+    private BluetoothDeviceFilter.Filter mFilter;
+
+    BluetoothDevice mSelectedDevice;
+
+    LocalBluetoothAdapter mLocalAdapter;
+    LocalBluetoothManager mLocalManager;
+
+    private PreferenceGroup mDeviceListGroup;
+
+    final WeakHashMap<CachedBluetoothDevice, BluetoothDevicePreference> mDevicePreferenceMap =
+            new WeakHashMap<CachedBluetoothDevice, BluetoothDevicePreference>();
+
+    DeviceListPreferenceFragment() {
+        mFilter = BluetoothDeviceFilter.ALL_FILTER;
+    }
+
+    final void setFilter(BluetoothDeviceFilter.Filter filter) {
+        mFilter = filter;
+    }
+
+    final void setFilter(int filterType) {
+        mFilter = BluetoothDeviceFilter.getFilter(filterType);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        mLocalManager = LocalBluetoothManager.getInstance(getActivity());
+        if (mLocalManager == null) {
+            Log.e(TAG, "Bluetooth is not supported on this device");
+            return;
+        }
+        mLocalAdapter = mLocalManager.getBluetoothAdapter();
+
+        addPreferencesForActivity();
+
+        mDeviceListGroup = (PreferenceCategory) findPreference(KEY_BT_DEVICE_LIST);
+    }
+
+    void setDeviceListGroup(PreferenceGroup preferenceGroup) {
+        mDeviceListGroup = preferenceGroup;
+    }
+
+    /** Add preferences from the subclass. */
+    abstract void addPreferencesForActivity();
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (mLocalManager == null) return;
+
+        mLocalManager.setForegroundActivity(getActivity());
+        mLocalManager.getEventManager().registerCallback(this);
+
+        updateProgressUi(mLocalAdapter.isDiscovering());
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        if (mLocalManager == null) return;
+
+        removeAllDevices();
+        mLocalManager.setForegroundActivity(null);
+        mLocalManager.getEventManager().unregisterCallback(this);
+    }
+
+    void removeAllDevices() {
+        mLocalAdapter.stopScanning();
+        mDevicePreferenceMap.clear();
+        mDeviceListGroup.removeAll();
+    }
+
+    void addCachedDevices() {
+        Collection<CachedBluetoothDevice> cachedDevices =
+                mLocalManager.getCachedDeviceManager().getCachedDevicesCopy();
+        for (CachedBluetoothDevice cachedDevice : cachedDevices) {
+            onDeviceAdded(cachedDevice);
+        }
+    }
+
+    void removeOorDevices() {
+        Collection<CachedBluetoothDevice> cachedDevices =
+                mLocalManager.getCachedDeviceManager().getCachedDevicesCopy();
+        for (CachedBluetoothDevice cachedDevice : cachedDevices) {
+             if (cachedDevice.getBondState() == BluetoothDevice.BOND_NONE &&
+                 !cachedDevice.isVisible()) {
+                 Log.d(TAG, "Device Removed " + cachedDevice);
+                 BluetoothDevicePreference preference = mDevicePreferenceMap.get(cachedDevice);
+                 if (preference != null) {
+                     mDeviceListGroup.removePreference(preference);
+                 }
+                 mDevicePreferenceMap.remove(cachedDevice);
+                 cachedDevice.setRemovable(true);
+             }
+         }
+    }
+
+    @Override
+    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen,
+            Preference preference) {
+        if (KEY_BT_SCAN.equals(preference.getKey())) {
+            mLocalAdapter.startScanning(true);
+            return true;
+        }
+
+        if (preference instanceof BluetoothDevicePreference) {
+            BluetoothDevicePreference btPreference = (BluetoothDevicePreference) preference;
+            CachedBluetoothDevice device = btPreference.getCachedDevice();
+            mSelectedDevice = device.getDevice();
+            onDevicePreferenceClick(btPreference);
+            return true;
+        }
+
+        return super.onPreferenceTreeClick(preferenceScreen, preference);
+    }
+
+    void onDevicePreferenceClick(BluetoothDevicePreference btPreference) {
+        btPreference.onClicked();
+    }
+
+    public void onDeviceAdded(CachedBluetoothDevice cachedDevice) {
+        if (mDevicePreferenceMap.get(cachedDevice) != null) {
+            return;
+        }
+
+        // Prevent updates while the list shows one of the state messages
+        if (mLocalAdapter.getBluetoothState() != BluetoothAdapter.STATE_ON) return;
+
+        if (mFilter.matches(cachedDevice.getDevice())) {
+            createDevicePreference(cachedDevice);
+        }
+     }
+
+    void createDevicePreference(CachedBluetoothDevice cachedDevice) {
+        BluetoothDevicePreference preference = new BluetoothDevicePreference(
+                getActivity(), cachedDevice);
+
+        initDevicePreference(preference);
+        mDeviceListGroup.addPreference(preference);
+        mDevicePreferenceMap.put(cachedDevice, preference);
+    }
+
+    /**
+     * Overridden in {@link BluetoothSettings} to add a listener.
+     * @param preference the newly added preference
+     */
+    void initDevicePreference(BluetoothDevicePreference preference) {
+        // Does nothing by default
+    }
+
+    public void onDeviceDeleted(CachedBluetoothDevice cachedDevice) {
+        BluetoothDevicePreference preference = mDevicePreferenceMap.remove(cachedDevice);
+        if (preference != null) {
+            mDeviceListGroup.removePreference(preference);
+        }
+    }
+
+    public void onScanningStateChanged(boolean started) {
+        if (started == false) {
+          removeOorDevices();
+        }
+        updateProgressUi(started);
+    }
+
+    private void updateProgressUi(boolean start) {
+        if (mDeviceListGroup instanceof BluetoothProgressCategory) {
+            ((BluetoothProgressCategory) mDeviceListGroup).setProgress(start);
+        }
+    }
+
+    public void onBluetoothStateChanged(int bluetoothState) {
+        if (bluetoothState == BluetoothAdapter.STATE_OFF) {
+            updateProgressUi(false);
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/DevicePickerActivity.java b/src/com/android/settings/bluetooth_msm/DevicePickerActivity.java
new file mode 100644
index 0000000..8f6e0df
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/DevicePickerActivity.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import com.android.settings.R;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+/**
+ * Activity for Bluetooth device picker dialog. The device picker logic
+ * is implemented in the {@link BluetoothSettings} fragment.
+ */
+public final class DevicePickerActivity extends Activity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.bluetooth_device_picker);
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/DevicePickerFragment.java b/src/com/android/settings/bluetooth_msm/DevicePickerFragment.java
new file mode 100644
index 0000000..87d31e7
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/DevicePickerFragment.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothDevicePicker;
+import android.content.Intent;
+import android.os.Bundle;
+
+import com.android.settings.R;
+
+/**
+ * BluetoothSettings is the Settings screen for Bluetooth configuration and
+ * connection management.
+ */
+public final class DevicePickerFragment extends DeviceListPreferenceFragment {
+
+    private boolean mNeedAuth;
+    private String mLaunchPackage;
+    private String mLaunchClass;
+    private boolean mStartScanOnResume;
+
+    @Override
+    void addPreferencesForActivity() {
+        addPreferencesFromResource(R.xml.device_picker);
+
+        Intent intent = getActivity().getIntent();
+        mNeedAuth = intent.getBooleanExtra(BluetoothDevicePicker.EXTRA_NEED_AUTH, false);
+        setFilter(intent.getIntExtra(BluetoothDevicePicker.EXTRA_FILTER_TYPE,
+                BluetoothDevicePicker.FILTER_TYPE_ALL));
+        mLaunchPackage = intent.getStringExtra(BluetoothDevicePicker.EXTRA_LAUNCH_PACKAGE);
+        mLaunchClass = intent.getStringExtra(BluetoothDevicePicker.EXTRA_LAUNCH_CLASS);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        getActivity().setTitle(getString(R.string.device_picker));
+        mStartScanOnResume = (savedInstanceState == null);  // don't start scan after rotation
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        addCachedDevices();
+        if (mStartScanOnResume) {
+            mLocalAdapter.startScanning(true);
+            mStartScanOnResume = false;
+        }
+    }
+
+    @Override
+    void onDevicePreferenceClick(BluetoothDevicePreference btPreference) {
+        mLocalAdapter.stopScanning();
+        LocalBluetoothPreferences.persistSelectedDeviceInPicker(
+                getActivity(), mSelectedDevice.getAddress());
+        if ((btPreference.getCachedDevice().getBondState() ==
+                BluetoothDevice.BOND_BONDED) || !mNeedAuth) {
+            sendDevicePickedIntent(mSelectedDevice);
+            finish();
+        } else {
+            super.onDevicePreferenceClick(btPreference);
+        }
+    }
+
+    public void onDeviceBondStateChanged(CachedBluetoothDevice cachedDevice,
+            int bondState) {
+        if (bondState == BluetoothDevice.BOND_BONDED) {
+            BluetoothDevice device = cachedDevice.getDevice();
+            if (device.equals(mSelectedDevice)) {
+                sendDevicePickedIntent(device);
+                finish();
+            }
+        }
+    }
+
+    @Override
+    public void onBluetoothStateChanged(int bluetoothState) {
+        super.onBluetoothStateChanged(bluetoothState);
+
+        if (bluetoothState == BluetoothAdapter.STATE_ON) {
+            mLocalAdapter.startScanning(false);
+        }
+    }
+
+    private void sendDevicePickedIntent(BluetoothDevice device) {
+        Intent intent = new Intent(BluetoothDevicePicker.ACTION_DEVICE_SELECTED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+        if (mLaunchPackage != null && mLaunchClass != null) {
+            intent.setClassName(mLaunchPackage, mLaunchClass);
+        }
+        getActivity().sendBroadcast(intent);
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/DeviceProfilesSettings.java b/src/com/android/settings/bluetooth_msm/DeviceProfilesSettings.java
new file mode 100644
index 0000000..39dd8d4
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/DeviceProfilesSettings.java
@@ -0,0 +1,428 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.app.AlertDialog;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothProfile;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.os.Bundle;
+import android.preference.CheckBoxPreference;
+import android.preference.EditTextPreference;
+import android.preference.Preference;
+import android.preference.PreferenceGroup;
+import android.preference.PreferenceScreen;
+import android.text.Html;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.View;
+import android.widget.EditText;
+import android.text.TextWatcher;
+import android.app.Dialog;
+import android.widget.Button;
+import android.text.Editable;
+import com.android.settings.R;
+import com.android.settings.SettingsPreferenceFragment;
+
+import java.util.HashMap;
+
+/**
+ * This preference fragment presents the user with all of the profiles
+ * for a particular device, and allows them to be individually connected
+ * (or disconnected).
+ */
+public final class DeviceProfilesSettings extends SettingsPreferenceFragment
+        implements CachedBluetoothDevice.Callback, Preference.OnPreferenceChangeListener {
+    private static final String TAG = "DeviceProfilesSettings";
+
+    private static final String KEY_RENAME_DEVICE = "rename_device";
+    private static final String KEY_PROFILE_CONTAINER = "profile_container";
+    private static final String KEY_UNPAIR = "unpair";
+
+    public static final String EXTRA_DEVICE = "device";
+    public static final String DISCONNECT_PROFILE = "profile";
+
+    private RenameEditTextPreference mRenameDeviceNamePref;
+    private LocalBluetoothManager mManager;
+    private CachedBluetoothDevice mCachedDevice;
+    private LocalBluetoothProfileManager mProfileManager;
+
+    private PreferenceGroup mProfileContainer;
+    private EditTextPreference mDeviceNamePref;
+
+    private final HashMap<LocalBluetoothProfile, CheckBoxPreference> mAutoConnectPrefs
+            = new HashMap<LocalBluetoothProfile, CheckBoxPreference>();
+
+    private AlertDialog mDisconnectDialog;
+    private boolean mProfileGroupIsRemoved;
+    private LocalBluetoothProfile mDisconnectingProfile;
+
+    private class RenameEditTextPreference implements TextWatcher{
+        public void afterTextChanged(Editable s) {
+            Dialog d = mDeviceNamePref.getDialog();
+            if (d instanceof AlertDialog) {
+                ((AlertDialog) d).getButton(AlertDialog.BUTTON_POSITIVE).setEnabled(s.length() > 0);
+            }
+        }
+
+        // TextWatcher interface
+        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+            // not used
+        }
+
+        // TextWatcher interface
+        public void onTextChanged(CharSequence s, int start, int before, int count) {
+            // not used
+        }
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        BluetoothDevice device;
+        int profileRes = 0;
+        if (savedInstanceState != null) {
+            device = savedInstanceState.getParcelable(EXTRA_DEVICE);
+            profileRes = savedInstanceState.getInt(DISCONNECT_PROFILE, 0);
+        } else {
+            Bundle args = getArguments();
+            device = args.getParcelable(EXTRA_DEVICE);
+        }
+
+        addPreferencesFromResource(R.xml.bluetooth_device_advanced);
+        getPreferenceScreen().setOrderingAsAdded(false);
+        mProfileContainer = (PreferenceGroup) findPreference(KEY_PROFILE_CONTAINER);
+        mDeviceNamePref = (EditTextPreference) findPreference(KEY_RENAME_DEVICE);
+
+        if (device == null) {
+            Log.w(TAG, "Activity started without a remote Bluetooth device");
+            finish();
+            return;  // TODO: test this failure path
+        }
+        mRenameDeviceNamePref = new RenameEditTextPreference();
+        mManager = LocalBluetoothManager.getInstance(getActivity());
+        CachedBluetoothDeviceManager deviceManager =
+                mManager.getCachedDeviceManager();
+        mProfileManager = mManager.getProfileManager();
+        mCachedDevice = deviceManager.findDevice(device);
+        if (mCachedDevice == null) {
+            Log.w(TAG, "Device not found, cannot connect to it");
+            finish();
+            return;  // TODO: test this failure path
+        }
+
+        String deviceName = mCachedDevice.getName();
+        mDeviceNamePref.setSummary(deviceName);
+        mDeviceNamePref.setText(deviceName);
+        mDeviceNamePref.setOnPreferenceChangeListener(this);
+
+        // Add a preference for each profile
+        addPreferencesForProfiles();
+
+        if (profileRes != 0) {
+            mDisconnectingProfile = getProfile(profileRes);
+            if (mDisconnectingProfile != null) {
+                onProfileClicked(mDisconnectingProfile);
+            }
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        if (mDisconnectDialog != null) {
+            mDisconnectDialog.dismiss();
+            mDisconnectingProfile = null;
+            mDisconnectDialog = null;
+        }
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        outState.putParcelable(EXTRA_DEVICE, mCachedDevice.getDevice());
+        if (mDisconnectingProfile != null) {
+            Log.e(TAG, "adding profile to disconnect");
+            outState.putInt(DISCONNECT_PROFILE,
+                    mDisconnectingProfile.getNameResource(mCachedDevice.getDevice()));
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+        mManager.setForegroundActivity(getActivity());
+        mCachedDevice.registerCallback(this);
+        if(mCachedDevice.getBondState() == BluetoothDevice.BOND_NONE)
+            finish();
+        refresh();
+        EditText et = mDeviceNamePref.getEditText();
+        if (et != null) {
+            et.addTextChangedListener(mRenameDeviceNamePref);
+            Dialog d = mDeviceNamePref.getDialog();
+            if (d instanceof AlertDialog) {
+                Button b = ((AlertDialog) d).getButton(AlertDialog.BUTTON_POSITIVE);
+                b.setEnabled(et.getText().length() > 0);
+            }
+        }
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+        mCachedDevice.unregisterCallback(this);
+        mManager.setForegroundActivity(null);
+    }
+
+    private void addPreferencesForProfiles() {
+        for (LocalBluetoothProfile profile : mCachedDevice.getConnectableProfiles()) {
+            Preference pref = createProfilePreference(profile);
+            mProfileContainer.addPreference(pref);
+        }
+        showOrHideProfileGroup();
+    }
+
+    private void showOrHideProfileGroup() {
+        int numProfiles = mProfileContainer.getPreferenceCount();
+        if (!mProfileGroupIsRemoved && numProfiles == 0) {
+            getPreferenceScreen().removePreference(mProfileContainer);
+            mProfileGroupIsRemoved = true;
+        } else if (mProfileGroupIsRemoved && numProfiles != 0) {
+            getPreferenceScreen().addPreference(mProfileContainer);
+            mProfileGroupIsRemoved = false;
+        }
+    }
+
+    private LocalBluetoothProfile getProfile(int profileRes) {
+        for (LocalBluetoothProfile profile : mCachedDevice.getConnectableProfiles()) {
+            if (profile.getNameResource(mCachedDevice.getDevice()) == profileRes) {
+               return profile;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Creates a checkbox preference for the particular profile. The key will be
+     * the profile's name.
+     *
+     * @param profile The profile for which the preference controls.
+     * @return A preference that allows the user to choose whether this profile
+     *         will be connected to.
+     */
+    private CheckBoxPreference createProfilePreference(LocalBluetoothProfile profile) {
+        CheckBoxPreference pref = new CheckBoxPreference(getActivity());
+        pref.setKey(profile.toString());
+        pref.setTitle(profile.getNameResource(mCachedDevice.getDevice()));
+        pref.setPersistent(false);
+        pref.setOrder(getProfilePreferenceIndex(profile.getOrdinal()));
+        pref.setOnPreferenceChangeListener(this);
+
+        int iconResource = profile.getDrawableResource(mCachedDevice.getBtClass());
+        if (iconResource != 0) {
+            pref.setIcon(getResources().getDrawable(iconResource));
+        }
+
+        /**
+         * Gray out profile while connecting and disconnecting
+         */
+        pref.setEnabled(!mCachedDevice.isBusy());
+
+        refreshProfilePreference(pref, profile);
+
+        return pref;
+    }
+
+    @Override
+    public boolean onPreferenceTreeClick(PreferenceScreen screen, Preference preference) {
+        String key = preference.getKey();
+        if (key.equals(KEY_UNPAIR)) {
+            unpairDevice();
+            finish();
+            return true;
+        }
+
+        return super.onPreferenceTreeClick(screen, preference);
+    }
+
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        if (preference == mDeviceNamePref) {
+            mCachedDevice.setName((String) newValue);
+        } else if (preference instanceof CheckBoxPreference) {
+            LocalBluetoothProfile prof = getProfileOf(preference);
+            onProfileClicked(prof);
+            return false;   // checkbox will update from onDeviceAttributesChanged() callback
+        } else {
+            return false;
+        }
+
+        return true;
+    }
+
+    private void onProfileClicked(LocalBluetoothProfile profile) {
+        BluetoothDevice device = mCachedDevice.getDevice();
+
+        int status = profile.getConnectionStatus(device);
+        boolean isConnected =
+                status == BluetoothProfile.STATE_CONNECTED;
+
+        if (isConnected) {
+            mDisconnectingProfile = null;
+            askDisconnect(getActivity(), profile);
+        } else {
+            profile.setPreferred(device, true);
+            mCachedDevice.connectProfile(profile);
+        }
+    }
+
+    private void askDisconnect(Context context,
+            final LocalBluetoothProfile profile) {
+        // local reference for callback
+        final CachedBluetoothDevice device = mCachedDevice;
+        String name = device.getName();
+        if (TextUtils.isEmpty(name)) {
+            name = context.getString(R.string.bluetooth_device);
+        }
+
+        String profileName = context.getString(profile.getNameResource(device.getDevice()));
+
+        String title = context.getString(R.string.bluetooth_disable_profile_title);
+        String message = context.getString(R.string.bluetooth_disable_profile_message,
+                profileName, name);
+
+        DialogInterface.OnClickListener disconnectListener =
+                new DialogInterface.OnClickListener() {
+            public void onClick(DialogInterface dialog, int which) {
+                Log.e(TAG, "removing profile to disconnect");
+                mDisconnectingProfile = null;
+                device.disconnect(profile);
+                profile.setPreferred(device.getDevice(), false);
+            }
+        };
+
+        DialogInterface.OnClickListener cancelOptListener =
+                new DialogInterface.OnClickListener() {
+            public void onClick(DialogInterface dialog, int which) {
+                Log.e(TAG, "removing profile to disconnect");
+                mDisconnectingProfile = null;
+            }
+        };
+
+        DialogInterface.OnCancelListener cancelListener =
+                new DialogInterface.OnCancelListener() {
+            public void onCancel(DialogInterface dialog) {
+                Log.e(TAG, "removing profile to disconnect");
+                mDisconnectingProfile = null;
+            }
+        };
+
+        mDisconnectDialog = Utils.showDisconnectDialog(context,
+                mDisconnectDialog, disconnectListener, cancelOptListener,
+                title, Html.fromHtml(message));
+        mDisconnectDialog.setOnCancelListener(cancelListener);
+        mDisconnectingProfile = profile;
+    }
+
+    public void onDeviceAttributesChanged() {
+        refresh();
+    }
+
+    private void refresh() {
+        String deviceName = mCachedDevice.getName();
+        mDeviceNamePref.setSummary(deviceName);
+        mDeviceNamePref.setText(deviceName);
+
+        refreshProfiles();
+    }
+
+    private void refreshProfiles() {
+        for (LocalBluetoothProfile profile : mCachedDevice.getConnectableProfiles()) {
+            CheckBoxPreference profilePref = (CheckBoxPreference)findPreference(profile.toString());
+            if (profilePref == null) {
+                profilePref = createProfilePreference(profile);
+                mProfileContainer.addPreference(profilePref);
+            } else {
+                refreshProfilePreference(profilePref, profile);
+            }
+        }
+        for (LocalBluetoothProfile profile : mCachedDevice.getRemovedProfiles()) {
+            Preference profilePref = findPreference(profile.toString());
+            if (profilePref != null) {
+                Log.d(TAG, "Removing " + profile.toString() + " from profile list");
+                mProfileContainer.removePreference(profilePref);
+            }
+        }
+        showOrHideProfileGroup();
+    }
+
+    private void refreshProfilePreference(CheckBoxPreference profilePref,
+            LocalBluetoothProfile profile) {
+        BluetoothDevice device = mCachedDevice.getDevice();
+        int connectionStatus = profile.getConnectionStatus(device);
+
+        /*
+         * Gray out checkbox while connecting and disconnecting
+         */
+        if (isServerRole(profile) && connectionStatus == BluetoothProfile.STATE_DISCONNECTED) {
+            /*no connection initiation from SAP server side*/
+            profilePref.setEnabled(false);
+            profilePref.setSummary(profile.getSummaryResourceForDevice(device));
+            Log.i(TAG, "SAP in disconnected mode -" + profile);
+            return;
+            }
+
+        profilePref.setEnabled(!mCachedDevice.isBusy());
+        profilePref.setChecked(profile.isPreferred(device));
+        profilePref.setSummary(profile.getSummaryResourceForDevice(device));
+    }
+
+    private LocalBluetoothProfile getProfileOf(Preference pref) {
+        if (!(pref instanceof CheckBoxPreference)) {
+            return null;
+        }
+        String key = pref.getKey();
+        if (TextUtils.isEmpty(key)) return null;
+
+        try {
+            return mProfileManager.getProfileByName(pref.getKey());
+        } catch (IllegalArgumentException ignored) {
+            return null;
+        }
+    }
+
+    private int getProfilePreferenceIndex(int profIndex) {
+        return mProfileContainer.getOrder() + profIndex * 10;
+    }
+
+    private void unpairDevice() {
+        mCachedDevice.unpair();
+    }
+
+    private boolean getAutoConnect(LocalBluetoothProfile prof) {
+        return prof.isPreferred(mCachedDevice.getDevice());
+    }
+
+    private boolean isServerRole(LocalBluetoothProfile profile) {
+        return (profile.equals("SAP") || (profile.equals("DUN")));
+    }
+
+}
diff --git a/src/com/android/settings/bluetooth_msm/DockEventReceiver.java b/src/com/android/settings/bluetooth_msm/DockEventReceiver.java
new file mode 100644
index 0000000..a3b6b3c
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/DockEventReceiver.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.app.Service;
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHeadset;
+import android.bluetooth.BluetoothProfile;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.os.PowerManager;
+import android.util.Log;
+
+public final class DockEventReceiver extends BroadcastReceiver {
+
+    private static final boolean DEBUG = DockService.DEBUG;
+
+    private static final String TAG = "DockEventReceiver";
+
+    public static final String ACTION_DOCK_SHOW_UI =
+        "com.android.settings.bluetooth.action.DOCK_SHOW_UI";
+
+    private static final int EXTRA_INVALID = -1234;
+
+    private static final Object sStartingServiceSync = new Object();
+
+    private static PowerManager.WakeLock sStartingService;
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        if (intent == null)
+            return;
+
+        int state = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, intent.getIntExtra(
+                BluetoothAdapter.EXTRA_STATE, EXTRA_INVALID));
+        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+
+        if (DEBUG) {
+            Log.d(TAG, "Action: " + intent.getAction() + " State:" + state + " Device: "
+                    + (device == null ? "null" : device.getAliasName()));
+        }
+
+        if (Intent.ACTION_DOCK_EVENT.equals(intent.getAction())
+                || ACTION_DOCK_SHOW_UI.endsWith(intent.getAction())) {
+            if (device == null) {
+                if (DEBUG) Log.d(TAG, "Device is missing");
+                return;
+            }
+
+            switch (state) {
+                case Intent.EXTRA_DOCK_STATE_UNDOCKED:
+                case Intent.EXTRA_DOCK_STATE_CAR:
+                case Intent.EXTRA_DOCK_STATE_DESK:
+                case Intent.EXTRA_DOCK_STATE_LE_DESK:
+                case Intent.EXTRA_DOCK_STATE_HE_DESK:
+                    Intent i = new Intent(intent);
+                    i.setClass(context, DockService.class);
+                    beginStartingService(context, i);
+                    break;
+                default:
+                    Log.e(TAG, "Unknown state: " + state);
+                    break;
+            }
+        } else if (BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED.equals(intent.getAction()) ||
+                   BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED.equals(intent.getAction())) {
+            int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE,
+                    BluetoothProfile.STATE_CONNECTED);
+            int oldState = intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, 0);
+
+            /*
+             *  Reconnect to the dock if:
+             *  1) it is a dock
+             *  2) it is disconnected
+             *  3) the disconnect is initiated remotely
+             *  4) the dock is still docked (check can only be done in the Service)
+             */
+            if (device == null) {
+                if (DEBUG) Log.d(TAG, "Device is missing");
+                return;
+            }
+
+            if (newState == BluetoothProfile.STATE_DISCONNECTED &&
+                    oldState != BluetoothProfile.STATE_DISCONNECTING) {
+                // Too bad, the dock state can't be checked from a BroadcastReceiver.
+                Intent i = new Intent(intent);
+                i.setClass(context, DockService.class);
+                beginStartingService(context, i);
+            }
+
+        } else if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {
+            int btState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
+            if (btState != BluetoothAdapter.STATE_TURNING_ON) {
+                Intent i = new Intent(intent);
+                i.setClass(context, DockService.class);
+                beginStartingService(context, i);
+            }
+        }
+    }
+
+    /**
+     * Start the service to process the current event notifications, acquiring
+     * the wake lock before returning to ensure that the service will run.
+     */
+    private static void beginStartingService(Context context, Intent intent) {
+        synchronized (sStartingServiceSync) {
+            if (sStartingService == null) {
+                PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+                sStartingService = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
+                        "StartingDockService");
+            }
+
+            sStartingService.acquire();
+
+            if (context.startService(intent) == null) {
+                Log.e(TAG, "Can't start DockService");
+            }
+        }
+    }
+
+    /**
+     * Called back by the service when it has finished processing notifications,
+     * releasing the wake lock if the service is now stopping.
+     */
+    public static void finishStartingService(Service service, int startId) {
+        synchronized (sStartingServiceSync) {
+            if (sStartingService != null) {
+                if (DEBUG) Log.d(TAG, "stopSelf id = " + startId);
+                if (service.stopSelfResult(startId)) {
+                    Log.d(TAG, "finishStartingService: stopping service");
+                    sStartingService.release();
+                }
+            }
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/DockService.java b/src/com/android/settings/bluetooth_msm/DockService.java
new file mode 100644
index 0000000..7c336a8
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/DockService.java
@@ -0,0 +1,871 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import com.android.settings.R;
+import com.android.settings.bluetooth.LocalBluetoothProfileManager.ServiceListener;
+
+import android.app.AlertDialog;
+import android.app.Notification;
+import android.app.Service;
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHeadset;
+import android.bluetooth.BluetoothProfile;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.CheckBox;
+import android.widget.CompoundButton;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+
+public final class DockService extends Service implements ServiceListener {
+
+    private static final String TAG = "DockService";
+
+    static final boolean DEBUG = false;
+
+    // Time allowed for the device to be undocked and redocked without severing
+    // the bluetooth connection
+    private static final long UNDOCKED_GRACE_PERIOD = 1000;
+
+    // Time allowed for the device to be undocked and redocked without turning
+    // off Bluetooth
+    private static final long DISABLE_BT_GRACE_PERIOD = 2000;
+
+    // Msg for user wanting the UI to setup the dock
+    private static final int MSG_TYPE_SHOW_UI = 111;
+
+    // Msg for device docked event
+    private static final int MSG_TYPE_DOCKED = 222;
+
+    // Msg for device undocked event
+    private static final int MSG_TYPE_UNDOCKED_TEMPORARY = 333;
+
+    // Msg for undocked command to be process after UNDOCKED_GRACE_PERIOD millis
+    // since MSG_TYPE_UNDOCKED_TEMPORARY
+    private static final int MSG_TYPE_UNDOCKED_PERMANENT = 444;
+
+    // Msg for disabling bt after DISABLE_BT_GRACE_PERIOD millis since
+    // MSG_TYPE_UNDOCKED_PERMANENT
+    private static final int MSG_TYPE_DISABLE_BT = 555;
+
+    private static final String SHARED_PREFERENCES_NAME = "dock_settings";
+
+    private static final String KEY_DISABLE_BT_WHEN_UNDOCKED = "disable_bt_when_undock";
+
+    private static final String KEY_DISABLE_BT = "disable_bt";
+
+    private static final String KEY_CONNECT_RETRY_COUNT = "connect_retry_count";
+
+    /*
+     * If disconnected unexpectedly, reconnect up to 6 times. Each profile counts
+     * as one time so it's only 3 times for both profiles on the car dock.
+     */
+    private static final int MAX_CONNECT_RETRY = 6;
+
+    private static final int INVALID_STARTID = -100;
+
+    // Created in OnCreate()
+    private volatile Looper mServiceLooper;
+    private volatile ServiceHandler mServiceHandler;
+    private Runnable mRunnable;
+    private LocalBluetoothAdapter mLocalAdapter;
+    private CachedBluetoothDeviceManager mDeviceManager;
+    private LocalBluetoothProfileManager mProfileManager;
+
+    // Normally set after getting a docked event and unset when the connection
+    // is severed. One exception is that mDevice could be null if the service
+    // was started after the docked event.
+    private BluetoothDevice mDevice;
+
+    // Created and used for the duration of the dialog
+    private AlertDialog mDialog;
+    private LocalBluetoothProfile[] mProfiles;
+    private boolean[] mCheckedItems;
+    private int mStartIdAssociatedWithDialog;
+
+    // Set while BT is being enabled.
+    private BluetoothDevice mPendingDevice;
+    private int mPendingStartId;
+    private int mPendingTurnOnStartId = INVALID_STARTID;
+    private int mPendingTurnOffStartId = INVALID_STARTID;
+
+    @Override
+    public void onCreate() {
+        if (DEBUG) Log.d(TAG, "onCreate");
+
+        LocalBluetoothManager manager = LocalBluetoothManager.getInstance(this);
+        if (manager == null) {
+            Log.e(TAG, "Can't get LocalBluetoothManager: exiting");
+            return;
+        }
+
+        mLocalAdapter = manager.getBluetoothAdapter();
+        mDeviceManager = manager.getCachedDeviceManager();
+        mProfileManager = manager.getProfileManager();
+        if (mProfileManager == null) {
+            Log.e(TAG, "Can't get LocalBluetoothProfileManager: exiting");
+            return;
+        }
+
+        HandlerThread thread = new HandlerThread("DockService");
+        thread.start();
+
+        mServiceLooper = thread.getLooper();
+        mServiceHandler = new ServiceHandler(mServiceLooper);
+    }
+
+    @Override
+    public void onDestroy() {
+        if (DEBUG) Log.d(TAG, "onDestroy");
+        mRunnable = null;
+        if (mDialog != null) {
+            mDialog.dismiss();
+            mDialog = null;
+        }
+        if (mProfileManager != null) {
+            mProfileManager.removeServiceListener(this);
+        }
+        if (mServiceLooper != null) {
+            mServiceLooper.quit();
+        }
+
+        mLocalAdapter = null;
+        mDeviceManager = null;
+        mProfileManager = null;
+        mServiceLooper = null;
+        mServiceHandler = null;
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        // not supported
+        return null;
+    }
+
+    private SharedPreferences getPrefs() {
+        return getSharedPreferences(SHARED_PREFERENCES_NAME, MODE_PRIVATE);
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        if (DEBUG) Log.d(TAG, "onStartCommand startId: " + startId + " flags: " + flags);
+
+        if (intent == null) {
+            // Nothing to process, stop.
+            if (DEBUG) Log.d(TAG, "START_NOT_STICKY - intent is null.");
+
+            // NOTE: We MUST not call stopSelf() directly, since we need to
+            // make sure the wake lock acquired by the Receiver is released.
+            DockEventReceiver.finishStartingService(this, startId);
+            return START_NOT_STICKY;
+        }
+
+        if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {
+            handleBtStateChange(intent, startId);
+            return START_NOT_STICKY;
+        }
+
+        /*
+         * This assumes that the intent sender has checked that this is a dock
+         * and that the intent is for a disconnect
+         */
+        final SharedPreferences prefs = getPrefs();
+        if (BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED.equals(intent.getAction())) {
+            BluetoothDevice disconnectedDevice = intent
+                    .getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            int retryCount = prefs.getInt(KEY_CONNECT_RETRY_COUNT, 0);
+            if (retryCount < MAX_CONNECT_RETRY) {
+                prefs.edit().putInt(KEY_CONNECT_RETRY_COUNT, retryCount + 1).apply();
+                handleUnexpectedDisconnect(disconnectedDevice, mProfileManager.getHeadsetProfile(), startId);
+            }
+            return START_NOT_STICKY;
+        } else if (BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED.equals(intent.getAction())) {
+            BluetoothDevice disconnectedDevice = intent
+                    .getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+
+            int retryCount = prefs.getInt(KEY_CONNECT_RETRY_COUNT, 0);
+            if (retryCount < MAX_CONNECT_RETRY) {
+                prefs.edit().putInt(KEY_CONNECT_RETRY_COUNT, retryCount + 1).apply();
+                handleUnexpectedDisconnect(disconnectedDevice, mProfileManager.getA2dpProfile(), startId);
+            }
+            return START_NOT_STICKY;
+        }
+
+        Message msg = parseIntent(intent);
+        if (msg == null) {
+            // Bad intent
+            if (DEBUG) Log.d(TAG, "START_NOT_STICKY - Bad intent.");
+            DockEventReceiver.finishStartingService(this, startId);
+            return START_NOT_STICKY;
+        }
+
+        if (msg.what == MSG_TYPE_DOCKED) {
+            prefs.edit().remove(KEY_CONNECT_RETRY_COUNT).apply();
+        }
+
+        msg.arg2 = startId;
+        processMessage(msg);
+
+        return START_NOT_STICKY;
+    }
+
+    private final class ServiceHandler extends Handler {
+        private ServiceHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            processMessage(msg);
+        }
+    }
+
+    // This method gets messages from both onStartCommand and mServiceHandler/mServiceLooper
+    private synchronized void processMessage(Message msg) {
+        int msgType = msg.what;
+        final int state = msg.arg1;
+        final int startId = msg.arg2;
+        BluetoothDevice device = null;
+        if (msg.obj != null) {
+            device = (BluetoothDevice) msg.obj;
+        }
+
+        if(DEBUG) Log.d(TAG, "processMessage: " + msgType + " state: " + state + " device = "
+                + (device == null ? "null" : device.toString()));
+
+        boolean deferFinishCall = false;
+
+        switch (msgType) {
+            case MSG_TYPE_SHOW_UI:
+                if (device != null) {
+                    createDialog(device, state, startId);
+                } else {
+                    Log.e(TAG, "Error! mDevice is null, can't create dialog");
+                }
+                break;
+
+            case MSG_TYPE_DOCKED:
+                deferFinishCall = msgTypeDocked(device, state, startId);
+                break;
+
+            case MSG_TYPE_UNDOCKED_PERMANENT:
+                deferFinishCall = msgTypeUndockedPermanent(device, startId);
+                break;
+
+            case MSG_TYPE_UNDOCKED_TEMPORARY:
+                msgTypeUndockedTemporary(device, state, startId);
+                break;
+
+            case MSG_TYPE_DISABLE_BT:
+                deferFinishCall = msgTypeDisableBluetooth(startId);
+                break;
+        }
+
+        if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY
+                && !deferFinishCall) {
+            // NOTE: We MUST not call stopSelf() directly, since we need to
+            // make sure the wake lock acquired by the Receiver is released.
+            DockEventReceiver.finishStartingService(this, startId);
+        }
+    }
+
+    private boolean msgTypeDisableBluetooth(int startId) {
+        if (DEBUG) {
+            Log.d(TAG, "BT DISABLE");
+        }
+        final SharedPreferences prefs = getPrefs();
+        if (mLocalAdapter.disable()) {
+            prefs.edit().remove(KEY_DISABLE_BT_WHEN_UNDOCKED).apply();
+            return false;
+        } else {
+            // disable() returned an error. Persist a flag to disable BT later
+            prefs.edit().putBoolean(KEY_DISABLE_BT, true).apply();
+            mPendingTurnOffStartId = startId;
+            if(DEBUG) {
+                Log.d(TAG, "disable failed. try again later " + startId);
+            }
+            return true;
+        }
+    }
+
+    private void msgTypeUndockedTemporary(BluetoothDevice device, int state,
+            int startId) {
+        // Undocked event received. Queue a delayed msg to sever connection
+        Message newMsg = mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT, state,
+                startId, device);
+        mServiceHandler.sendMessageDelayed(newMsg, UNDOCKED_GRACE_PERIOD);
+    }
+
+    private boolean msgTypeUndockedPermanent(BluetoothDevice device, int startId) {
+        // Grace period passed. Disconnect.
+        handleUndocked(device);
+        final SharedPreferences prefs = getPrefs();
+
+        if (DEBUG) {
+            Log.d(TAG, "DISABLE_BT_WHEN_UNDOCKED = "
+                    + prefs.getBoolean(KEY_DISABLE_BT_WHEN_UNDOCKED, false));
+        }
+
+        if (prefs.getBoolean(KEY_DISABLE_BT_WHEN_UNDOCKED, false)) {
+            if (hasOtherConnectedDevices(device)) {
+                // Don't disable BT if something is connected
+                prefs.edit().remove(KEY_DISABLE_BT_WHEN_UNDOCKED).apply();
+            } else {
+                // BT was disabled when we first docked
+                if (DEBUG) {
+                    Log.d(TAG, "QUEUED BT DISABLE");
+                }
+                // Queue a delayed msg to disable BT
+                Message newMsg = mServiceHandler.obtainMessage(
+                        MSG_TYPE_DISABLE_BT, 0, startId, null);
+                mServiceHandler.sendMessageDelayed(newMsg,
+                        DISABLE_BT_GRACE_PERIOD);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean msgTypeDocked(BluetoothDevice device, final int state,
+            final int startId) {
+        if (DEBUG) {
+            // TODO figure out why hasMsg always returns false if device
+            // is supplied
+            Log.d(TAG, "1 Has undock perm msg = "
+                    + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT, mDevice));
+            Log.d(TAG, "2 Has undock perm msg = "
+                    + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT, device));
+        }
+
+        mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
+        mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
+        getPrefs().edit().remove(KEY_DISABLE_BT).apply();
+
+        if (device != null && !device.equals(mDevice)) {
+            if (mDevice != null) {
+                // Not expected. Cleanup/undock existing
+                handleUndocked(mDevice);
+            }
+
+            mDevice = device;
+
+            // Register first in case LocalBluetoothProfileManager
+            // becomes ready after isManagerReady is called and it
+            // would be too late to register a service listener.
+            mProfileManager.addServiceListener(this);
+            if (mProfileManager.isManagerReady()) {
+                handleDocked(device, state, startId);
+                // Not needed after all
+                mProfileManager.removeServiceListener(this);
+            } else {
+                final BluetoothDevice d = device;
+                mRunnable = new Runnable() {
+                    public void run() {
+                        handleDocked(d, state, startId);  // FIXME: WTF runnable here?
+                    }
+                };
+                return true;
+            }
+        }
+        return false;
+    }
+
+    synchronized boolean hasOtherConnectedDevices(BluetoothDevice dock) {
+        Collection<CachedBluetoothDevice> cachedDevices = mDeviceManager.getCachedDevicesCopy();
+        Set<BluetoothDevice> btDevices = mLocalAdapter.getBondedDevices();
+        if (btDevices == null || cachedDevices == null || btDevices.isEmpty()) {
+            return false;
+        }
+        if(DEBUG) {
+            Log.d(TAG, "btDevices = " + btDevices.size());
+            Log.d(TAG, "cachedDeviceUIs = " + cachedDevices.size());
+        }
+
+        for (CachedBluetoothDevice deviceUI : cachedDevices) {
+            BluetoothDevice btDevice = deviceUI.getDevice();
+            if (!btDevice.equals(dock) && btDevices.contains(btDevice) && deviceUI
+                    .isConnected()) {
+                if(DEBUG) Log.d(TAG, "connected deviceUI = " + deviceUI.getName());
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private Message parseIntent(Intent intent) {
+        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+        int state = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, -1234);
+
+        if (DEBUG) {
+            Log.d(TAG, "Action: " + intent.getAction() + " State:" + state
+                    + " Device: " + (device == null ? "null" : device.getAliasName()));
+        }
+
+        if (device == null) {
+            Log.w(TAG, "device is null");
+            return null;
+        }
+
+        int msgType;
+        switch (state) {
+            case Intent.EXTRA_DOCK_STATE_UNDOCKED:
+                msgType = MSG_TYPE_UNDOCKED_TEMPORARY;
+                break;
+            case Intent.EXTRA_DOCK_STATE_DESK:
+            case Intent.EXTRA_DOCK_STATE_LE_DESK:
+            case Intent.EXTRA_DOCK_STATE_HE_DESK:
+            case Intent.EXTRA_DOCK_STATE_CAR:
+                if (DockEventReceiver.ACTION_DOCK_SHOW_UI.equals(intent.getAction())) {
+                    msgType = MSG_TYPE_SHOW_UI;
+                } else {
+                    msgType = MSG_TYPE_DOCKED;
+                }
+                break;
+            default:
+                return null;
+        }
+
+        return mServiceHandler.obtainMessage(msgType, state, 0, device);
+    }
+
+    private void createDialog(BluetoothDevice device,
+            int state, int startId) {
+        if (mDialog != null) {
+            // Shouldn't normally happen
+            mDialog.dismiss();
+            mDialog = null;
+        }
+        mDevice = device;
+        switch (state) {
+            case Intent.EXTRA_DOCK_STATE_CAR:
+            case Intent.EXTRA_DOCK_STATE_DESK:
+            case Intent.EXTRA_DOCK_STATE_LE_DESK:
+            case Intent.EXTRA_DOCK_STATE_HE_DESK:
+                break;
+            default:
+                return;
+        }
+
+        startForeground(0, new Notification());
+
+        // Device in a new dock.
+        boolean firstTime = !LocalBluetoothPreferences.hasDockAutoConnectSetting(this, device.getAddress());
+
+        CharSequence[] items = initBtSettings(device, state, firstTime);
+
+        final AlertDialog.Builder ab = new AlertDialog.Builder(this);
+        ab.setTitle(getString(R.string.bluetooth_dock_settings_title));
+
+        // Profiles
+        ab.setMultiChoiceItems(items, mCheckedItems, mMultiClickListener);
+
+        // Remember this settings
+        LayoutInflater inflater = (LayoutInflater)
+                getSystemService(LAYOUT_INFLATER_SERVICE);
+        float pixelScaleFactor = getResources().getDisplayMetrics().density;
+        View view = inflater.inflate(R.layout.remember_dock_setting, null);
+        CheckBox rememberCheckbox = (CheckBox) view.findViewById(R.id.remember);
+
+        // check "Remember setting" by default if no value was saved
+        boolean checked = firstTime || LocalBluetoothPreferences.getDockAutoConnectSetting(this, device.getAddress());
+        rememberCheckbox.setChecked(checked);
+        rememberCheckbox.setOnCheckedChangeListener(mCheckedChangeListener);
+        int viewSpacingLeft = (int) (14 * pixelScaleFactor);
+        int viewSpacingRight = (int) (14 * pixelScaleFactor);
+        ab.setView(view, viewSpacingLeft, 0 /* top */, viewSpacingRight, 0 /* bottom */);
+        if (DEBUG) {
+            Log.d(TAG, "Auto connect = "
+                    + LocalBluetoothPreferences.getDockAutoConnectSetting(this, device.getAddress()));
+        }
+
+        // Ok Button
+        ab.setPositiveButton(getString(android.R.string.ok), mClickListener);
+
+        mStartIdAssociatedWithDialog = startId;
+        mDialog = ab.create();
+        mDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
+        mDialog.setOnDismissListener(mDismissListener);
+        mDialog.show();
+    }
+
+    // Called when the individual bt profiles are clicked.
+    private final DialogInterface.OnMultiChoiceClickListener mMultiClickListener =
+            new DialogInterface.OnMultiChoiceClickListener() {
+                public void onClick(DialogInterface dialog, int which, boolean isChecked) {
+                    if (DEBUG) {
+                        Log.d(TAG, "Item " + which + " changed to " + isChecked);
+                    }
+                    mCheckedItems[which] = isChecked;
+                }
+            };
+
+
+    // Called when the "Remember" Checkbox is clicked
+    private final CompoundButton.OnCheckedChangeListener mCheckedChangeListener =
+            new CompoundButton.OnCheckedChangeListener() {
+                public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+                    if (DEBUG) {
+                        Log.d(TAG, "onCheckedChanged: Remember Settings = " + isChecked);
+                    }
+                    if (mDevice != null) {
+                        LocalBluetoothPreferences.saveDockAutoConnectSetting(
+                                DockService.this, mDevice.getAddress(), isChecked);
+                    }
+                }
+            };
+
+
+    // Called when the dialog is dismissed
+    private final DialogInterface.OnDismissListener mDismissListener =
+            new DialogInterface.OnDismissListener() {
+                public void onDismiss(DialogInterface dialog) {
+                    // NOTE: We MUST not call stopSelf() directly, since we need to
+                    // make sure the wake lock acquired by the Receiver is released.
+                    if (mPendingDevice == null) {
+                        DockEventReceiver.finishStartingService(
+                                DockService.this, mStartIdAssociatedWithDialog);
+                    }
+                    stopForeground(true);
+                }
+            };
+
+    // Called when clicked on the OK button
+    private final DialogInterface.OnClickListener mClickListener =
+            new DialogInterface.OnClickListener() {
+                public void onClick(DialogInterface dialog, int which) {
+                    if (which == DialogInterface.BUTTON_POSITIVE
+                            && mDevice != null) {
+                        if (!LocalBluetoothPreferences
+                                .hasDockAutoConnectSetting(
+                                        DockService.this,
+                                        mDevice.getAddress())) {
+                            LocalBluetoothPreferences
+                                    .saveDockAutoConnectSetting(
+                                            DockService.this,
+                                            mDevice.getAddress(), true);
+                        }
+
+                        applyBtSettings(mDevice, mStartIdAssociatedWithDialog);
+                    }
+                }
+            };
+
+    private CharSequence[] initBtSettings(BluetoothDevice device,
+            int state, boolean firstTime) {
+        // TODO Avoid hardcoding dock and profiles. Read from system properties
+        int numOfProfiles;
+        switch (state) {
+            case Intent.EXTRA_DOCK_STATE_DESK:
+            case Intent.EXTRA_DOCK_STATE_LE_DESK:
+            case Intent.EXTRA_DOCK_STATE_HE_DESK:
+                numOfProfiles = 1;
+                break;
+            case Intent.EXTRA_DOCK_STATE_CAR:
+                numOfProfiles = 2;
+                break;
+            default:
+                return null;
+        }
+
+        mProfiles = new LocalBluetoothProfile[numOfProfiles];
+        mCheckedItems = new boolean[numOfProfiles];
+        CharSequence[] items = new CharSequence[numOfProfiles];
+
+        // FIXME: convert switch to something else
+        switch (state) {
+            case Intent.EXTRA_DOCK_STATE_CAR:
+                items[0] = getString(R.string.bluetooth_dock_settings_headset);
+                items[1] = getString(R.string.bluetooth_dock_settings_a2dp);
+                mProfiles[0] = mProfileManager.getHeadsetProfile();
+                mProfiles[1] = mProfileManager.getA2dpProfile();
+                if (firstTime) {
+                    // Enable by default for car dock
+                    mCheckedItems[0] = true;
+                    mCheckedItems[1] = true;
+                } else {
+                    mCheckedItems[0] = mProfiles[0].isPreferred(device);
+                    mCheckedItems[1] = mProfiles[1].isPreferred(device);
+                }
+                break;
+
+            case Intent.EXTRA_DOCK_STATE_DESK:
+            case Intent.EXTRA_DOCK_STATE_LE_DESK:
+            case Intent.EXTRA_DOCK_STATE_HE_DESK:
+                items[0] = getString(R.string.bluetooth_dock_settings_a2dp);
+                mProfiles[0] = mProfileManager.getA2dpProfile();
+                if (firstTime) {
+                    // Disable by default for desk dock
+                    mCheckedItems[0] = false;
+                } else {
+                    mCheckedItems[0] = mProfiles[0].isPreferred(device);
+                }
+                break;
+        }
+        return items;
+    }
+
+    // TODO: move to background thread to fix strict mode warnings
+    private void handleBtStateChange(Intent intent, int startId) {
+        int btState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
+        synchronized (this) {
+            if(DEBUG) Log.d(TAG, "BtState = " + btState + " mPendingDevice = " + mPendingDevice);
+            if (btState == BluetoothAdapter.STATE_ON) {
+                handleBluetoothStateOn(startId);
+            } else if (btState == BluetoothAdapter.STATE_TURNING_OFF) {
+                // Remove the flag to disable BT if someone is turning off bt.
+                // The rational is that:
+                // a) if BT is off at undock time, no work needs to be done
+                // b) if BT is on at undock time, the user wants it on.
+                getPrefs().edit().remove(KEY_DISABLE_BT_WHEN_UNDOCKED).apply();
+                DockEventReceiver.finishStartingService(this, startId);
+            } else if (btState == BluetoothAdapter.STATE_OFF) {
+                // Bluetooth was turning off as we were trying to turn it on.
+                // Let's try again
+                if(DEBUG) Log.d(TAG, "Bluetooth = OFF mPendingDevice = " + mPendingDevice);
+
+                if (mPendingTurnOffStartId != INVALID_STARTID) {
+                    DockEventReceiver.finishStartingService(this, mPendingTurnOffStartId);
+                    getPrefs().edit().remove(KEY_DISABLE_BT).apply();
+                    mPendingTurnOffStartId = INVALID_STARTID;
+                }
+
+                if (mPendingDevice != null) {
+                    mLocalAdapter.enable();
+                    mPendingTurnOnStartId = startId;
+                } else {
+                    DockEventReceiver.finishStartingService(this, startId);
+                }
+            }
+        }
+    }
+
+    private void handleBluetoothStateOn(int startId) {
+        if (mPendingDevice != null) {
+            if (mPendingDevice.equals(mDevice)) {
+                if(DEBUG) {
+                    Log.d(TAG, "applying settings");
+                }
+                applyBtSettings(mPendingDevice, mPendingStartId);
+            } else if(DEBUG) {
+                Log.d(TAG, "mPendingDevice  (" + mPendingDevice + ") != mDevice ("
+                        + mDevice + ')');
+            }
+
+            mPendingDevice = null;
+            DockEventReceiver.finishStartingService(this, mPendingStartId);
+        } else {
+            final SharedPreferences prefs = getPrefs();
+            if (DEBUG) {
+                Log.d(TAG, "A DISABLE_BT_WHEN_UNDOCKED = "
+                        + prefs.getBoolean(KEY_DISABLE_BT_WHEN_UNDOCKED, false));
+            }
+            // Reconnect if docked and bluetooth was enabled by user.
+            Intent i = registerReceiver(null, new IntentFilter(Intent.ACTION_DOCK_EVENT));
+            if (i != null) {
+                int state = i.getIntExtra(Intent.EXTRA_DOCK_STATE,
+                        Intent.EXTRA_DOCK_STATE_UNDOCKED);
+                if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
+                    BluetoothDevice device = i
+                            .getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                    if (device != null) {
+                        connectIfEnabled(device);
+                    }
+                } else if (prefs.getBoolean(KEY_DISABLE_BT, false)
+                        && mLocalAdapter.disable()) {
+                    mPendingTurnOffStartId = startId;
+                    prefs.edit().remove(KEY_DISABLE_BT).apply();
+                    return;
+                }
+            }
+        }
+
+        if (mPendingTurnOnStartId != INVALID_STARTID) {
+            DockEventReceiver.finishStartingService(this, mPendingTurnOnStartId);
+            mPendingTurnOnStartId = INVALID_STARTID;
+        }
+
+        DockEventReceiver.finishStartingService(this, startId);
+    }
+
+    private synchronized void handleUnexpectedDisconnect(BluetoothDevice disconnectedDevice,
+            LocalBluetoothProfile profile, int startId) {
+        if (DEBUG) {
+            Log.d(TAG, "handling failed connect for " + disconnectedDevice);
+        }
+
+            // Reconnect if docked.
+            if (disconnectedDevice != null) {
+                // registerReceiver can't be called from a BroadcastReceiver
+                Intent intent = registerReceiver(null, new IntentFilter(Intent.ACTION_DOCK_EVENT));
+                if (intent != null) {
+                    int state = intent.getIntExtra(Intent.EXTRA_DOCK_STATE,
+                            Intent.EXTRA_DOCK_STATE_UNDOCKED);
+                    if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
+                        BluetoothDevice dockedDevice = intent
+                                .getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                        if (dockedDevice != null && dockedDevice.equals(disconnectedDevice)) {
+                            CachedBluetoothDevice cachedDevice = getCachedBluetoothDevice(
+                                    dockedDevice);
+                            cachedDevice.connectProfile(profile);
+                        }
+                    }
+                }
+            }
+
+            DockEventReceiver.finishStartingService(this, startId);
+    }
+
+    private synchronized void connectIfEnabled(BluetoothDevice device) {
+        CachedBluetoothDevice cachedDevice = getCachedBluetoothDevice(
+                device);
+        List<LocalBluetoothProfile> profiles = cachedDevice.getConnectableProfiles();
+        for (LocalBluetoothProfile profile : profiles) {
+            if (profile.getPreferred(device) == BluetoothProfile.PRIORITY_AUTO_CONNECT) {
+                cachedDevice.connect(false);
+                return;
+            }
+        }
+    }
+
+    private synchronized void applyBtSettings(BluetoothDevice device, int startId) {
+        if (device == null || mProfiles == null || mCheckedItems == null
+                || mLocalAdapter == null) {
+            return;
+        }
+
+        // Turn on BT if something is enabled
+        for (boolean enable : mCheckedItems) {
+            if (enable) {
+                int btState = mLocalAdapter.getBluetoothState();
+                if (DEBUG) {
+                    Log.d(TAG, "BtState = " + btState);
+                }
+                // May have race condition as the phone comes in and out and in the dock.
+                // Always turn on BT
+                mLocalAdapter.enable();
+
+                // if adapter was previously OFF, TURNING_OFF, or TURNING_ON
+                if (btState != BluetoothAdapter.STATE_ON) {
+                    if (mPendingDevice != null && mPendingDevice.equals(mDevice)) {
+                        return;
+                    }
+
+                    mPendingDevice = device;
+                    mPendingStartId = startId;
+                    if (btState != BluetoothAdapter.STATE_TURNING_ON) {
+                        getPrefs().edit().putBoolean(
+                                KEY_DISABLE_BT_WHEN_UNDOCKED, true).apply();
+                    }
+                    return;
+                }
+            }
+        }
+
+        mPendingDevice = null;
+
+        boolean callConnect = false;
+        CachedBluetoothDevice cachedDevice = getCachedBluetoothDevice(
+                device);
+        for (int i = 0; i < mProfiles.length; i++) {
+            LocalBluetoothProfile profile = mProfiles[i];
+            if (DEBUG) Log.d(TAG, profile.toString() + " = " + mCheckedItems[i]);
+
+            if (mCheckedItems[i]) {
+                // Checked but not connected
+                callConnect = true;
+            } else if (!mCheckedItems[i]) {
+                // Unchecked, may or may not be connected.
+                int status = profile.getConnectionStatus(cachedDevice.getDevice());
+                if (status == BluetoothProfile.STATE_CONNECTED) {
+                    if (DEBUG) Log.d(TAG, "applyBtSettings - Disconnecting");
+                    cachedDevice.disconnect(mProfiles[i]);
+                }
+            }
+            profile.setPreferred(device, mCheckedItems[i]);
+            if (DEBUG) {
+                if (mCheckedItems[i] != profile.isPreferred(device)) {
+                    Log.e(TAG, "Can't save preferred value");
+                }
+            }
+        }
+
+        if (callConnect) {
+            if (DEBUG) Log.d(TAG, "applyBtSettings - Connecting");
+            cachedDevice.connect(false);
+        }
+    }
+
+    private synchronized void handleDocked(BluetoothDevice device, int state,
+            int startId) {
+        if (LocalBluetoothPreferences.getDockAutoConnectSetting(this, device.getAddress())) {
+            // Setting == auto connect
+            initBtSettings(device, state, false);
+            applyBtSettings(mDevice, startId);
+        } else {
+            createDialog(device, state, startId);
+        }
+    }
+
+    private synchronized void handleUndocked(BluetoothDevice device) {
+        mRunnable = null;
+        mProfileManager.removeServiceListener(this);
+        if (mDialog != null) {
+            mDialog.dismiss();
+            mDialog = null;
+        }
+        mDevice = null;
+        mPendingDevice = null;
+        CachedBluetoothDevice cachedDevice = getCachedBluetoothDevice(device);
+        cachedDevice.disconnect();
+    }
+
+    private CachedBluetoothDevice getCachedBluetoothDevice(BluetoothDevice device) {
+        CachedBluetoothDevice cachedDevice = mDeviceManager.findDevice(device);
+        if (cachedDevice == null) {
+            cachedDevice = mDeviceManager.addDevice(mLocalAdapter, mProfileManager, device);
+        }
+        return cachedDevice;
+    }
+
+    public synchronized void onServiceConnected() {
+        if (mRunnable != null) {
+            mRunnable.run();
+            mRunnable = null;
+            mProfileManager.removeServiceListener(this);
+        }
+    }
+
+    public void onServiceDisconnected() {
+        // FIXME: shouldn't I do something on service disconnected too?
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/HeadsetProfile.java b/src/com/android/settings/bluetooth_msm/HeadsetProfile.java
new file mode 100644
index 0000000..1b8347c
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/HeadsetProfile.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHeadset;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothUuid;
+import android.content.Context;
+import android.os.ParcelUuid;
+import android.util.Log;
+
+import com.android.settings.R;
+
+import java.util.List;
+
+/**
+ * HeadsetProfile handles Bluetooth HFP and Headset profiles.
+ */
+final class HeadsetProfile implements LocalBluetoothProfile {
+    private static final String TAG = "HeadsetProfile";
+
+    private BluetoothHeadset mService;
+    private boolean mProfileReady;
+
+    private final LocalBluetoothAdapter mLocalAdapter;
+    private final CachedBluetoothDeviceManager mDeviceManager;
+    private final LocalBluetoothProfileManager mProfileManager;
+
+    static final ParcelUuid[] UUIDS = {
+        BluetoothUuid.HSP,
+        BluetoothUuid.Handsfree,
+    };
+
+    static final String NAME = "HEADSET";
+
+    // Order of this profile in device profiles list
+    private static final int ORDINAL = 0;
+
+    // These callbacks run on the main thread.
+    private final class HeadsetServiceListener
+            implements BluetoothProfile.ServiceListener {
+
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            mService = (BluetoothHeadset) proxy;
+            mProfileReady = true;
+            // We just bound to the service, so refresh the UI of the
+            // headset device.
+            List<BluetoothDevice> deviceList = mService.getConnectedDevices();
+            if (deviceList.isEmpty()) {
+                return;
+            }
+            BluetoothDevice firstDevice = deviceList.get(0);
+            CachedBluetoothDevice device = mDeviceManager.findDevice(firstDevice);
+            // we may add a new device here, but generally this should not happen
+            if (device == null) {
+                Log.w(TAG, "HeadsetProfile found new device: " + firstDevice);
+                device = mDeviceManager.addDevice(mLocalAdapter, mProfileManager, firstDevice);
+            }
+            device.onProfileStateChanged(HeadsetProfile.this,
+                    BluetoothProfile.STATE_CONNECTED);
+
+            mProfileManager.callServiceConnectedListeners();
+        }
+
+        public void onServiceDisconnected(int profile) {
+            mProfileReady = false;
+            mService = null;
+            mProfileManager.callServiceDisconnectedListeners();
+        }
+    }
+
+    // TODO(): The calls must get queued if mService becomes null.
+    // It can happen when the phone app crashes for some reason.
+    // All callers should have service listeners. Dock Service is the only
+    // one right now.
+    HeadsetProfile(Context context, LocalBluetoothAdapter adapter,
+            CachedBluetoothDeviceManager deviceManager,
+            LocalBluetoothProfileManager profileManager) {
+        mLocalAdapter = adapter;
+        mDeviceManager = deviceManager;
+        mProfileManager = profileManager;
+        mLocalAdapter.getProfileProxy(context, new HeadsetServiceListener(),
+                BluetoothProfile.HEADSET);
+    }
+
+    public boolean isConnectable() {
+        return true;
+    }
+
+    public boolean isAutoConnectable() {
+        return true;
+    }
+
+    public boolean connect(BluetoothDevice device) {
+        List<BluetoothDevice> sinks = mService.getConnectedDevices();
+        if (sinks != null) {
+            for (BluetoothDevice sink : sinks) {
+                 if (!sink.equals(device))
+                     mService.disconnect(sink);
+            }
+        }
+        return mService.connect(device);
+    }
+
+    public boolean disconnect(BluetoothDevice device) {
+        List<BluetoothDevice> deviceList = mService.getConnectedDevices();
+        if (!deviceList.isEmpty() && deviceList.get(0).equals(device)) {
+            // Downgrade priority as user is disconnecting the headset.
+            if (mService.getPriority(device) > BluetoothProfile.PRIORITY_ON) {
+                mService.setPriority(device, BluetoothProfile.PRIORITY_ON);
+            }
+            return mService.disconnect(device);
+        } else {
+            return false;
+        }
+    }
+
+    public int getConnectionStatus(BluetoothDevice device) {
+        if (mService == null) return BluetoothProfile.STATE_DISCONNECTED;
+
+        List<BluetoothDevice> deviceList = mService.getConnectedDevices();
+
+        return !deviceList.isEmpty() && deviceList.get(0).equals(device)
+                ? mService.getConnectionState(device)
+                : BluetoothProfile.STATE_DISCONNECTED;
+    }
+
+    public boolean isPreferred(BluetoothDevice device) {
+        return mService.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
+    }
+
+    public int getPreferred(BluetoothDevice device) {
+        return mService.getPriority(device);
+    }
+
+    public void setPreferred(BluetoothDevice device, boolean preferred) {
+        if (preferred) {
+            if (mService.getPriority(device) < BluetoothProfile.PRIORITY_ON) {
+                mService.setPriority(device, BluetoothProfile.PRIORITY_ON);
+            }
+        } else {
+            mService.setPriority(device, BluetoothProfile.PRIORITY_OFF);
+        }
+    }
+
+    public synchronized boolean isProfileReady() {
+        return mProfileReady;
+    }
+
+    public String toString() {
+        return NAME;
+    }
+
+    public int getOrdinal() {
+        return ORDINAL;
+    }
+
+    public int getNameResource(BluetoothDevice device) {
+        return R.string.bluetooth_profile_headset;
+    }
+
+    public int getSummaryResourceForDevice(BluetoothDevice device) {
+        int state = mService.getConnectionState(device);
+        switch (state) {
+            case BluetoothProfile.STATE_DISCONNECTED:
+                return R.string.bluetooth_headset_profile_summary_use_for;
+
+            case BluetoothProfile.STATE_CONNECTED:
+                return R.string.bluetooth_headset_profile_summary_connected;
+
+            default:
+                return Utils.getConnectionStateSummary(state);
+        }
+    }
+
+    public int getDrawableResource(BluetoothClass btClass) {
+        return R.drawable.ic_bt_headset_hfp;
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/HidProfile.java b/src/com/android/settings/bluetooth_msm/HidProfile.java
new file mode 100644
index 0000000..920f4bb
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/HidProfile.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothInputDevice;
+import android.bluetooth.BluetoothProfile;
+import android.content.Context;
+
+import com.android.settings.R;
+
+import java.util.List;
+
+/**
+ * HidProfile handles Bluetooth HID profile.
+ */
+final class HidProfile implements LocalBluetoothProfile {
+    private BluetoothInputDevice mService;
+    private boolean mProfileReady;
+
+    static final String NAME = "HID";
+
+    // Order of this profile in device profiles list
+    private static final int ORDINAL = 3;
+
+    // These callbacks run on the main thread.
+    private final class InputDeviceServiceListener
+            implements BluetoothProfile.ServiceListener {
+
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            mService = (BluetoothInputDevice) proxy;
+            mProfileReady = true;
+        }
+
+        public void onServiceDisconnected(int profile) {
+            mProfileReady = false;
+            mService = null;
+        }
+    }
+
+    HidProfile(Context context, LocalBluetoothAdapter adapter) {
+        adapter.getProfileProxy(context, new InputDeviceServiceListener(),
+                BluetoothProfile.INPUT_DEVICE);
+    }
+
+    public boolean isConnectable() {
+        return true;
+    }
+
+    public boolean isAutoConnectable() {
+        return true;
+    }
+
+    public boolean connect(BluetoothDevice device) {
+        return mService.connect(device);
+    }
+
+    public boolean disconnect(BluetoothDevice device) {
+        return mService.disconnect(device);
+    }
+
+    public int getConnectionStatus(BluetoothDevice device) {
+        List<BluetoothDevice> deviceList = mService.getConnectedDevices();
+
+        return !deviceList.isEmpty() && deviceList.get(0).equals(device)
+                ? mService.getConnectionState(device)
+                : BluetoothProfile.STATE_DISCONNECTED;
+    }
+
+    public boolean isPreferred(BluetoothDevice device) {
+        return mService.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
+    }
+
+    public int getPreferred(BluetoothDevice device) {
+        return mService.getPriority(device);
+    }
+
+    public void setPreferred(BluetoothDevice device, boolean preferred) {
+        if (preferred) {
+            if (mService.getPriority(device) < BluetoothProfile.PRIORITY_ON) {
+                mService.setPriority(device, BluetoothProfile.PRIORITY_ON);
+            }
+        } else {
+            mService.setPriority(device, BluetoothProfile.PRIORITY_OFF);
+        }
+    }
+
+    public boolean isProfileReady() {
+        return mProfileReady;
+    }
+
+    public String toString() {
+        return NAME;
+    }
+
+    public int getOrdinal() {
+        return ORDINAL;
+    }
+
+    public int getNameResource(BluetoothDevice device) {
+        // TODO: distinguish between keyboard and mouse?
+        return R.string.bluetooth_profile_hid;
+    }
+
+    public int getSummaryResourceForDevice(BluetoothDevice device) {
+        int state = mService.getConnectionState(device);
+        switch (state) {
+            case BluetoothProfile.STATE_DISCONNECTED:
+                return R.string.bluetooth_hid_profile_summary_use_for;
+
+            case BluetoothProfile.STATE_CONNECTED:
+                return R.string.bluetooth_hid_profile_summary_connected;
+
+            default:
+                return Utils.getConnectionStateSummary(state);
+        }
+    }
+
+    public int getDrawableResource(BluetoothClass btClass) {
+        if (btClass == null) {
+            return R.drawable.ic_bt_keyboard_hid;
+        }
+        return getHidClassDrawable(btClass);
+    }
+
+    static int getHidClassDrawable(BluetoothClass btClass) {
+        switch (btClass.getDeviceClass()) {
+            case BluetoothClass.Device.PERIPHERAL_KEYBOARD:
+            case BluetoothClass.Device.PERIPHERAL_KEYBOARD_POINTING:
+                return R.drawable.ic_bt_keyboard_hid;
+            case BluetoothClass.Device.PERIPHERAL_POINTING:
+                return R.drawable.ic_bt_pointing_hid;
+            default:
+                return R.drawable.ic_bt_misc_hid;
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/LocalBluetoothAdapter.java b/src/com/android/settings/bluetooth_msm/LocalBluetoothAdapter.java
new file mode 100644
index 0000000..eb9b370
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/LocalBluetoothAdapter.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (C) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothProfile;
+import android.content.Context;
+import android.os.ParcelUuid;
+import android.util.Log;
+
+import java.util.Set;
+
+/**
+ * LocalBluetoothAdapter provides an interface between the Settings app
+ * and the functionality of the local {@link BluetoothAdapter}, specifically
+ * those related to state transitions of the adapter itself.
+ *
+ * <p>Connection and bonding state changes affecting specific devices
+ * are handled by {@link CachedBluetoothDeviceManager},
+ * {@link BluetoothEventManager}, and {@link LocalBluetoothProfileManager}.
+ */
+public final class LocalBluetoothAdapter {
+    private static final String TAG = "LocalBluetoothAdapter";
+
+    /** This class does not allow direct access to the BluetoothAdapter. */
+    private final BluetoothAdapter mAdapter;
+
+    private LocalBluetoothProfileManager mProfileManager;
+
+    private static LocalBluetoothAdapter sInstance;
+
+    private int mState = BluetoothAdapter.ERROR;
+
+    private static final int SCAN_EXPIRATION_MS = 5 * 60 * 1000; // 5 mins
+
+    private long mLastScan;
+
+    private LocalBluetoothAdapter(BluetoothAdapter adapter) {
+        mAdapter = adapter;
+    }
+
+    void setProfileManager(LocalBluetoothProfileManager manager) {
+        mProfileManager = manager;
+    }
+
+    /**
+     * Get the singleton instance of the LocalBluetoothAdapter. If this device
+     * doesn't support Bluetooth, then null will be returned. Callers must be
+     * prepared to handle a null return value.
+     * @return the LocalBluetoothAdapter object, or null if not supported
+     */
+    static synchronized LocalBluetoothAdapter getInstance() {
+        if (sInstance == null) {
+            BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+            if (adapter != null) {
+                sInstance = new LocalBluetoothAdapter(adapter);
+            }
+        }
+
+        return sInstance;
+    }
+
+    // Pass-through BluetoothAdapter methods that we can intercept if necessary
+
+    void cancelDiscovery() {
+        mAdapter.cancelDiscovery();
+    }
+
+    boolean enable() {
+        return mAdapter.enable();
+    }
+
+    boolean disable() {
+        return mAdapter.disable();
+    }
+
+    void getProfileProxy(Context context,
+            BluetoothProfile.ServiceListener listener, int profile) {
+        mAdapter.getProfileProxy(context, listener, profile);
+    }
+
+    Set<BluetoothDevice> getBondedDevices() {
+        return mAdapter.getBondedDevices();
+    }
+
+    String getName() {
+        return mAdapter.getName();
+    }
+
+    int getScanMode() {
+        return mAdapter.getScanMode();
+    }
+
+    int getState() {
+        return mAdapter.getState();
+    }
+
+    ParcelUuid[] getUuids() {
+        return mAdapter.getUuids();
+    }
+
+    boolean isDiscovering() {
+        return mAdapter.isDiscovering();
+    }
+
+    boolean isEnabled() {
+        return mAdapter.isEnabled();
+    }
+
+    void setDiscoverableTimeout(int timeout) {
+        mAdapter.setDiscoverableTimeout(timeout);
+    }
+
+    void setName(String name) {
+        mAdapter.setName(name);
+    }
+
+    void setScanMode(int mode) {
+        mAdapter.setScanMode(mode);
+    }
+
+    boolean setScanMode(int mode, int duration) {
+        return mAdapter.setScanMode(mode, duration);
+    }
+
+    void startScanning(boolean force) {
+        // Only start if we're not already scanning
+        if (!mAdapter.isDiscovering()) {
+            if (!force) {
+                // Don't scan more than frequently than SCAN_EXPIRATION_MS,
+                // unless forced
+                if (mLastScan + SCAN_EXPIRATION_MS > System.currentTimeMillis()) {
+                    return;
+                }
+
+                // If we are playing music, don't scan unless forced.
+                A2dpProfile a2dp = mProfileManager.getA2dpProfile();
+                if (a2dp != null && a2dp.isA2dpPlaying()) {
+                    return;
+                }
+            }
+
+            if (mAdapter.startDiscovery()) {
+                mLastScan = System.currentTimeMillis();
+            }
+        }
+    }
+
+    void stopScanning() {
+        if (mAdapter.isDiscovering()) {
+            mAdapter.cancelDiscovery();
+        }
+    }
+
+    public synchronized int getBluetoothState() {
+        // Always sync state, in case it changed while paused
+        syncBluetoothState();
+        return mState;
+    }
+
+    synchronized void setBluetoothStateInt(int state) {
+        mState = state;
+
+        if (state == BluetoothAdapter.STATE_ON) {
+            // if mProfileManager hasn't been constructed yet, it will
+            // get the adapter UUIDs in its constructor when it is.
+            if (mProfileManager != null) {
+                mProfileManager.setBluetoothStateOn();
+            }
+        }
+    }
+
+    // Returns true if the state changed; false otherwise.
+    boolean syncBluetoothState() {
+        int currentState = mAdapter.getState();
+        if (currentState != mState) {
+            setBluetoothStateInt(mAdapter.getState());
+            return true;
+        }
+        return false;
+    }
+
+    public void setBluetoothEnabled(boolean enabled) {
+        if (enabled == false) {
+            if (mAdapter.isDiscovering()) {
+                Log.i(TAG, "Disabling scan process");
+                mAdapter.cancelDiscovery();
+            }
+        }
+
+        boolean success = enabled
+                ? mAdapter.enable()
+                : mAdapter.disable();
+
+        if (success) {
+            setBluetoothStateInt(enabled
+                ? BluetoothAdapter.STATE_TURNING_ON
+                : BluetoothAdapter.STATE_TURNING_OFF);
+        } else {
+            if (Utils.V) {
+                Log.v(TAG, "setBluetoothEnabled call, manager didn't return " +
+                        "success for enabled: " + enabled);
+            }
+
+            syncBluetoothState();
+        }
+    }
+
+    public boolean isHostPatchRequired(BluetoothDevice btDevice, int patch_id) {
+       return mAdapter.isHostPatchRequired(btDevice, patch_id);
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/LocalBluetoothManager.java b/src/com/android/settings/bluetooth_msm/LocalBluetoothManager.java
new file mode 100644
index 0000000..ae8dec2
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/LocalBluetoothManager.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.content.Context;
+import android.util.Log;
+
+/**
+ * LocalBluetoothManager provides a simplified interface on top of a subset of
+ * the Bluetooth API. Note that {@link #getInstance} will return null
+ * if there is no Bluetooth adapter on this device, and callers must be
+ * prepared to handle this case.
+ */
+public final class LocalBluetoothManager {
+    private static final String TAG = "LocalBluetoothManager";
+
+    /** Singleton instance. */
+    private static LocalBluetoothManager sInstance;
+
+    private final Context mContext;
+
+    /** If a BT-related activity is in the foreground, this will be it. */
+    private Context mForegroundActivity;
+
+    private BluetoothDiscoverableEnabler mDiscoverableEnabler;
+
+    private final LocalBluetoothAdapter mLocalAdapter;
+
+    private final CachedBluetoothDeviceManager mCachedDeviceManager;
+
+    /** The Bluetooth profile manager. */
+    private final LocalBluetoothProfileManager mProfileManager;
+
+    /** The broadcast receiver event manager. */
+    private final BluetoothEventManager mEventManager;
+
+    public static synchronized LocalBluetoothManager getInstance(Context context) {
+        if (sInstance == null) {
+            LocalBluetoothAdapter adapter = LocalBluetoothAdapter.getInstance();
+            if (adapter == null) {
+                return null;
+            }
+            // This will be around as long as this process is
+            Context appContext = context.getApplicationContext();
+            sInstance = new LocalBluetoothManager(adapter, appContext);
+        }
+
+        return sInstance;
+    }
+
+    public void setDiscoverableEnabler(BluetoothDiscoverableEnabler discoverableEnabler) {
+        mDiscoverableEnabler = discoverableEnabler;
+    }
+
+    public BluetoothDiscoverableEnabler getDiscoverableEnabler() {
+        return mDiscoverableEnabler;
+    }
+
+    private LocalBluetoothManager(LocalBluetoothAdapter adapter, Context context) {
+        mContext = context;
+        mLocalAdapter = adapter;
+
+        mCachedDeviceManager = new CachedBluetoothDeviceManager(context);
+        mEventManager = new BluetoothEventManager(mLocalAdapter,
+                mCachedDeviceManager, context);
+        mProfileManager = new LocalBluetoothProfileManager(context,
+                mLocalAdapter, mCachedDeviceManager, mEventManager);
+    }
+
+    public LocalBluetoothAdapter getBluetoothAdapter() {
+        return mLocalAdapter;
+    }
+
+    public Context getContext() {
+        return mContext;
+    }
+
+    public Context getForegroundActivity() {
+        return mForegroundActivity;
+    }
+
+    boolean isForegroundActivity() {
+        return mForegroundActivity != null;
+    }
+
+    synchronized void setForegroundActivity(Context context) {
+        if (context != null) {
+            Log.d(TAG, "setting foreground activity to non-null context");
+            mForegroundActivity = context;
+        } else {
+            if (mForegroundActivity != null) {
+                Log.d(TAG, "setting foreground activity to null");
+                mForegroundActivity = null;
+            }
+        }
+    }
+
+    CachedBluetoothDeviceManager getCachedDeviceManager() {
+        return mCachedDeviceManager;
+    }
+
+    BluetoothEventManager getEventManager() {
+        return mEventManager;
+    }
+
+    LocalBluetoothProfileManager getProfileManager() {
+        return mProfileManager;
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/LocalBluetoothPreferences.java b/src/com/android/settings/bluetooth_msm/LocalBluetoothPreferences.java
new file mode 100644
index 0000000..7e62b0e
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/LocalBluetoothPreferences.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.app.QueuedWork;
+import android.content.Context;
+import android.content.SharedPreferences;
+
+/**
+ * LocalBluetoothPreferences provides an interface to the preferences
+ * related to Bluetooth.
+ */
+final class LocalBluetoothPreferences {
+//    private static final String TAG = "LocalBluetoothPreferences";
+
+    private static final String SHARED_PREFERENCES_NAME = "bluetooth_settings";
+
+    // If a device was picked from the device picker or was in discoverable mode
+    // in the last 60 seconds, show the pairing dialogs in foreground instead
+    // of raising notifications
+    private static final int GRACE_PERIOD_TO_SHOW_DIALOGS_IN_FOREGROUND = 60 * 1000;
+
+    private static final String KEY_DISCOVERING_TIMESTAMP = "last_discovering_time";
+
+    private static final String KEY_LAST_SELECTED_DEVICE = "last_selected_device";
+
+    private static final String KEY_LAST_SELECTED_DEVICE_TIME = "last_selected_device_time";
+
+    private static final String KEY_DOCK_AUTO_CONNECT = "auto_connect_to_dock";
+
+    private static final String KEY_DISCOVERABLE_END_TIMESTAMP = "discoverable_end_timestamp";
+
+    private LocalBluetoothPreferences() {
+    }
+
+    private static SharedPreferences getSharedPreferences(Context context) {
+        return context.getSharedPreferences(SHARED_PREFERENCES_NAME, Context.MODE_PRIVATE);
+    }
+
+    static long getDiscoverableEndTimestamp(Context context) {
+        return getSharedPreferences(context).getLong(
+                KEY_DISCOVERABLE_END_TIMESTAMP, 0);
+    }
+
+    static boolean shouldShowDialogInForeground(Context context,
+            String deviceAddress) {
+        LocalBluetoothManager manager = LocalBluetoothManager.getInstance(context);
+        if (manager == null) {
+            return false;
+        }
+
+        // If Bluetooth Settings is visible
+        if (manager.isForegroundActivity()) {
+            return true;
+        }
+
+        long currentTimeMillis = System.currentTimeMillis();
+        SharedPreferences sharedPreferences = getSharedPreferences(context);
+
+        // If the device was in discoverABLE mode recently
+        long lastDiscoverableEndTime = sharedPreferences.getLong(
+                KEY_DISCOVERABLE_END_TIMESTAMP, 0);
+        if ((lastDiscoverableEndTime + GRACE_PERIOD_TO_SHOW_DIALOGS_IN_FOREGROUND)
+                > currentTimeMillis) {
+            return true;
+        }
+
+        // If the device was discoverING recently
+        LocalBluetoothAdapter adapter = manager.getBluetoothAdapter();
+        if (adapter != null && adapter.isDiscovering()) {
+            return true;
+        } else if ((sharedPreferences.getLong(KEY_DISCOVERING_TIMESTAMP, 0) +
+                GRACE_PERIOD_TO_SHOW_DIALOGS_IN_FOREGROUND) > currentTimeMillis) {
+            return true;
+        }
+
+        // If the device was picked in the device picker recently
+        if (deviceAddress != null) {
+            String lastSelectedDevice = sharedPreferences.getString(
+                    KEY_LAST_SELECTED_DEVICE, null);
+
+            if (deviceAddress.equals(lastSelectedDevice)) {
+                long lastDeviceSelectedTime = sharedPreferences.getLong(
+                        KEY_LAST_SELECTED_DEVICE_TIME, 0);
+                if ((lastDeviceSelectedTime + GRACE_PERIOD_TO_SHOW_DIALOGS_IN_FOREGROUND)
+                        > currentTimeMillis) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    static void persistSelectedDeviceInPicker(Context context, String deviceAddress) {
+        SharedPreferences.Editor editor = getSharedPreferences(context).edit();
+        editor.putString(KEY_LAST_SELECTED_DEVICE,
+                deviceAddress);
+        editor.putLong(KEY_LAST_SELECTED_DEVICE_TIME,
+                System.currentTimeMillis());
+        editor.apply();
+    }
+
+    static void persistDiscoverableEndTimestamp(Context context, long endTimestamp) {
+        SharedPreferences.Editor editor = getSharedPreferences(context).edit();
+        editor.putLong(KEY_DISCOVERABLE_END_TIMESTAMP, endTimestamp);
+        editor.apply();
+    }
+
+    static void persistDiscoveringTimestamp(final Context context) {
+        // Load the shared preferences and edit it on a background
+        // thread (but serialized!).
+        QueuedWork.singleThreadExecutor().submit(new Runnable() {
+                public void run() {
+                    SharedPreferences.Editor editor = getSharedPreferences(context).edit();
+                    editor.putLong(
+                            KEY_DISCOVERING_TIMESTAMP,
+                        System.currentTimeMillis());
+                    editor.apply();
+                }
+            });
+    }
+
+    static boolean hasDockAutoConnectSetting(Context context, String addr) {
+        return getSharedPreferences(context).contains(KEY_DOCK_AUTO_CONNECT + addr);
+    }
+
+    static boolean getDockAutoConnectSetting(Context context, String addr) {
+        return getSharedPreferences(context).getBoolean(KEY_DOCK_AUTO_CONNECT + addr,
+                false);
+    }
+
+    static void saveDockAutoConnectSetting(Context context, String addr, boolean autoConnect) {
+        SharedPreferences.Editor editor = getSharedPreferences(context).edit();
+        editor.putBoolean(KEY_DOCK_AUTO_CONNECT + addr, autoConnect);
+        editor.apply();
+    }
+
+    static void removeDockAutoConnectSetting(Context context, String addr) {
+        SharedPreferences.Editor editor = getSharedPreferences(context).edit();
+        editor.remove(KEY_DOCK_AUTO_CONNECT + addr);
+        editor.apply();
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/LocalBluetoothProfile.java b/src/com/android/settings/bluetooth_msm/LocalBluetoothProfile.java
new file mode 100644
index 0000000..8c0de95
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/LocalBluetoothProfile.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+
+/**
+ * LocalBluetoothProfile is an interface defining the basic
+ * functionality related to a Bluetooth profile.
+ */
+interface LocalBluetoothProfile {
+
+    /**
+     * Returns true if the user can initiate a connection, false otherwise.
+     */
+    boolean isConnectable();
+
+    /**
+     * Returns true if the user can enable auto connection for this profile.
+     */
+    boolean isAutoConnectable();
+
+    boolean connect(BluetoothDevice device);
+
+    boolean disconnect(BluetoothDevice device);
+
+    int getConnectionStatus(BluetoothDevice device);
+
+    boolean isPreferred(BluetoothDevice device);
+
+    int getPreferred(BluetoothDevice device);
+
+    void setPreferred(BluetoothDevice device, boolean preferred);
+
+    boolean isProfileReady();
+
+    /** Display order for device profile settings. */
+    int getOrdinal();
+
+    /**
+     * Returns the string resource ID for the localized name for this profile.
+     * @param device the Bluetooth device (to distinguish between PAN roles)
+     */
+    int getNameResource(BluetoothDevice device);
+
+    /**
+     * Returns the string resource ID for the summary text for this profile
+     * for the specified device, e.g. "Use for media audio" or
+     * "Connected to media audio".
+     * @param device the device to query for profile connection status
+     * @return a string resource ID for the profile summary text
+     */
+    int getSummaryResourceForDevice(BluetoothDevice device);
+
+    int getDrawableResource(BluetoothClass btClass);
+}
diff --git a/src/com/android/settings/bluetooth_msm/LocalBluetoothProfileManager.java b/src/com/android/settings/bluetooth_msm/LocalBluetoothProfileManager.java
new file mode 100644
index 0000000..cd05b8d
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/LocalBluetoothProfileManager.java
@@ -0,0 +1,476 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (C) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHeadset;
+import android.bluetooth.BluetoothInputDevice;
+import android.bluetooth.BluetoothPan;
+import android.bluetooth.BluetoothSap;
+import android.bluetooth.BluetoothDUN;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothUuid;
+import android.content.Context;
+import android.content.Intent;
+import android.os.ParcelUuid;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * LocalBluetoothProfileManager provides access to the LocalBluetoothProfile
+ * objects for the available Bluetooth profiles.
+ */
+final class LocalBluetoothProfileManager {
+    private static final String TAG = "LocalBluetoothProfileManager";
+
+    /** Singleton instance. */
+    private static LocalBluetoothProfileManager sInstance;
+
+    /**
+     * An interface for notifying BluetoothHeadset IPC clients when they have
+     * been connected to the BluetoothHeadset service.
+     * Only used by {@link DockService}.
+     */
+    public interface ServiceListener {
+        /**
+         * Called to notify the client when this proxy object has been
+         * connected to the BluetoothHeadset service. Clients must wait for
+         * this callback before making IPC calls on the BluetoothHeadset
+         * service.
+         */
+        void onServiceConnected();
+
+        /**
+         * Called to notify the client that this proxy object has been
+         * disconnected from the BluetoothHeadset service. Clients must not
+         * make IPC calls on the BluetoothHeadset service after this callback.
+         * This callback will currently only occur if the application hosting
+         * the BluetoothHeadset service, but may be called more often in future.
+         */
+        void onServiceDisconnected();
+    }
+
+    private final Context mContext;
+    private final LocalBluetoothAdapter mLocalAdapter;
+    private final CachedBluetoothDeviceManager mDeviceManager;
+    private final BluetoothEventManager mEventManager;
+
+    private A2dpProfile mA2dpProfile;
+    private HeadsetProfile mHeadsetProfile;
+    private final HidProfile mHidProfile;
+    private OppProfile mOppProfile;
+    private final PanProfile mPanProfile;
+    private SapProfile mSapProfile;
+    private DUNProfile mDUNProfile;
+
+    /**
+     * Mapping from profile name, e.g. "HEADSET" to profile object.
+     */
+    private final Map<String, LocalBluetoothProfile>
+            mProfileNameMap = new HashMap<String, LocalBluetoothProfile>();
+
+    LocalBluetoothProfileManager(Context context,
+            LocalBluetoothAdapter adapter,
+            CachedBluetoothDeviceManager deviceManager,
+            BluetoothEventManager eventManager) {
+        mContext = context;
+
+        mLocalAdapter = adapter;
+        mDeviceManager = deviceManager;
+        mEventManager = eventManager;
+        // pass this reference to adapter and event manager (circular dependency)
+        mLocalAdapter.setProfileManager(this);
+        mEventManager.setProfileManager(this);
+
+        ParcelUuid[] uuids = adapter.getUuids();
+
+        // uuids may be null if Bluetooth is turned off
+        if (uuids != null) {
+            updateLocalProfiles(uuids);
+        }
+
+        // Always add HID and PAN profiles
+        mHidProfile = new HidProfile(context, mLocalAdapter);
+        addProfile(mHidProfile, HidProfile.NAME,
+                BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED);
+
+        mPanProfile = new PanProfile(context);
+        addPanProfile(mPanProfile, PanProfile.NAME,
+                BluetoothPan.ACTION_CONNECTION_STATE_CHANGED);
+
+
+        mSapProfile = new SapProfile();
+        addSapProfile(mSapProfile, SapProfile.NAME,
+                BluetoothDevice.SAP_STATE_CHANGED);
+        mDUNProfile = new DUNProfile();
+        addDUNProfile(mDUNProfile, DUNProfile.NAME,
+                BluetoothDevice.DUN_STATE_CHANGED);
+
+
+        Log.d(TAG, "LocalBluetoothProfileManager construction complete");
+    }
+
+    /**
+     * Initialize or update the local profile objects. If a UUID was previously
+     * present but has been removed, we print a warning but don't remove the
+     * profile object as it might be referenced elsewhere, or the UUID might
+     * come back and we don't want multiple copies of the profile objects.
+     * @param uuids
+     */
+    void updateLocalProfiles(ParcelUuid[] uuids) {
+        // A2DP
+        if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSource)) {
+            if (mA2dpProfile == null) {
+                Log.d(TAG, "Adding local A2DP profile");
+                mA2dpProfile = new A2dpProfile(mContext);
+                addProfile(mA2dpProfile, A2dpProfile.NAME,
+                        BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+            }
+        } else if (mA2dpProfile != null) {
+            Log.w(TAG, "Warning: A2DP profile was previously added but the UUID is now missing.");
+        }
+
+        // Headset / Handsfree
+        if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree_AG) ||
+            BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP_AG)) {
+            if (mHeadsetProfile == null) {
+                Log.d(TAG, "Adding local HEADSET profile");
+                mHeadsetProfile = new HeadsetProfile(mContext, mLocalAdapter,
+                        mDeviceManager, this);
+                addProfile(mHeadsetProfile, HeadsetProfile.NAME,
+                        BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
+            }
+        } else if (mHeadsetProfile != null) {
+            Log.w(TAG, "Warning: HEADSET profile was previously added but the UUID is now missing.");
+        }
+
+        // OPP
+        if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.ObexObjectPush)) {
+            if (mOppProfile == null) {
+                Log.d(TAG, "Adding local OPP profile");
+                mOppProfile = new OppProfile();
+                // Note: no event handler for OPP, only name map.
+                mProfileNameMap.put(OppProfile.NAME, mOppProfile);
+            }
+        } else if (mOppProfile != null) {
+            Log.w(TAG, "Warning: OPP profile was previously added but the UUID is now missing.");
+        }
+        mEventManager.registerProfileIntentReceiver();
+
+        // There is no local SDP record for HID and Settings app doesn't control PBAP
+    }
+
+    private final Collection<ServiceListener> mServiceListeners =
+            new ArrayList<ServiceListener>();
+
+    private void addProfile(LocalBluetoothProfile profile,
+            String profileName, String stateChangedAction) {
+        mEventManager.addProfileHandler(stateChangedAction, new StateChangedHandler(profile));
+        mProfileNameMap.put(profileName, profile);
+    }
+
+    private void addPanProfile(LocalBluetoothProfile profile,
+            String profileName, String stateChangedAction) {
+        mEventManager.addProfileHandler(stateChangedAction,
+                new PanStateChangedHandler(profile));
+        mProfileNameMap.put(profileName, profile);
+    }
+
+    private void addSapProfile(LocalBluetoothProfile profile,
+            String profileName, String stateChangedAction) {
+        mEventManager.addProfileHandler(stateChangedAction,
+                new SapStateChangedHandler(profile));
+        mProfileNameMap.put(profileName, profile);
+        Log.d(TAG,"Added handler for SAP state changed Notifications");
+    }
+
+    private void addDUNProfile(LocalBluetoothProfile profile,
+            String profileName, String stateChangedAction) {
+        mEventManager.addProfileHandler(stateChangedAction,
+                new DUNStateChangedHandler(profile));
+        mProfileNameMap.put(profileName, profile);
+        Log.d(TAG,"Added handler for DUN state changed Notifications");
+    }
+
+    LocalBluetoothProfile getProfileByName(String name) {
+        return mProfileNameMap.get(name);
+    }
+
+    // Called from LocalBluetoothAdapter when state changes to ON
+    void setBluetoothStateOn() {
+        ParcelUuid[] uuids = mLocalAdapter.getUuids();
+        if (uuids != null) {
+            updateLocalProfiles(uuids);
+        }
+        mEventManager.readPairedDevices();
+    }
+
+    /**
+     * Generic handler for connection state change events for the specified profile.
+     */
+    private class StateChangedHandler implements BluetoothEventManager.Handler {
+        final LocalBluetoothProfile mProfile;
+
+        StateChangedHandler(LocalBluetoothProfile profile) {
+            mProfile = profile;
+        }
+
+        public void onReceive(Context context, Intent intent, BluetoothDevice device) {
+            CachedBluetoothDevice cachedDevice = mDeviceManager.findDevice(device);
+            if (cachedDevice == null) {
+                Log.w(TAG, "StateChangedHandler found new device: " + device);
+                cachedDevice = mDeviceManager.addDevice(mLocalAdapter,
+                        LocalBluetoothProfileManager.this, device);
+            }
+            int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+            int oldState = intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, 0);
+            if (newState == BluetoothProfile.STATE_DISCONNECTED &&
+                    oldState == BluetoothProfile.STATE_CONNECTING) {
+                Log.i(TAG, "Failed to connect " + mProfile + " device");
+            }
+
+            cachedDevice.onProfileStateChanged(mProfile, newState);
+            cachedDevice.refresh();
+        }
+    }
+    private class SapStateChangedHandler extends StateChangedHandler {
+
+       SapStateChangedHandler(LocalBluetoothProfile profile) {
+              super(profile);
+       }
+
+        @Override
+        public void onReceive(Context context, Intent intent, BluetoothDevice device) {
+            SapProfile sapProfile = (SapProfile) mProfile;
+            int state =  intent.getIntExtra("state", 0);
+            Log.d(TAG, "SapStateChanged" + state);
+            CachedBluetoothDevice cachedDevice = mDeviceManager.findDevice(device);
+            if (cachedDevice != null) {
+                cachedDevice.onProfileStateChanged(mProfile, state);
+                cachedDevice.refresh();
+                /*Update the Sap State here*/
+                sapProfile.setConnectionStatus(state);
+            } else {
+                Log.w(TAG, "No Cached device!,  shouldn't reach here");
+            }
+        }
+    }
+    /* State Change Handler for DUN Profile*/
+    private class DUNStateChangedHandler extends StateChangedHandler {
+
+       DUNStateChangedHandler(LocalBluetoothProfile profile) {
+              super(profile);
+       }
+
+        @Override
+        public void onReceive(Context context, Intent intent, BluetoothDevice device) {
+            DUNProfile dunProfile = (DUNProfile) mProfile;
+            int state =  intent.getIntExtra("state", 0);
+            Log.d(TAG, "DUNStateChanged" + state);
+            CachedBluetoothDevice cachedDevice = mDeviceManager.findDevice(device);
+            if (cachedDevice != null) {
+                cachedDevice.onProfileStateChanged(mProfile, state);
+                cachedDevice.refresh();
+                /*Update the DUN State here*/
+                dunProfile.setConnectionStatus(state);
+            } else {
+                Log.w(TAG, "No Cached device!,  shouldn't reach here");
+            }
+        }
+    }
+
+    /** State change handler for NAP and PANU profiles. */
+    private class PanStateChangedHandler extends StateChangedHandler {
+
+        PanStateChangedHandler(LocalBluetoothProfile profile) {
+            super(profile);
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent, BluetoothDevice device) {
+            PanProfile panProfile = (PanProfile) mProfile;
+            int role = intent.getIntExtra(BluetoothPan.EXTRA_LOCAL_ROLE, 0);
+            panProfile.setLocalRole(device, role);
+            super.onReceive(context, intent, device);
+        }
+    }
+
+    // called from DockService
+    void addServiceListener(ServiceListener l) {
+        mServiceListeners.add(l);
+    }
+
+    // called from DockService
+    void removeServiceListener(ServiceListener l) {
+        mServiceListeners.remove(l);
+    }
+
+    // not synchronized: use only from UI thread! (TODO: verify)
+    void callServiceConnectedListeners() {
+        for (ServiceListener l : mServiceListeners) {
+            l.onServiceConnected();
+        }
+    }
+
+    // not synchronized: use only from UI thread! (TODO: verify)
+    void callServiceDisconnectedListeners() {
+        for (ServiceListener listener : mServiceListeners) {
+            listener.onServiceDisconnected();
+        }
+    }
+
+    // This is called by DockService, so check Headset and A2DP.
+    public synchronized boolean isManagerReady() {
+        // Getting just the headset profile is fine for now. Will need to deal with A2DP
+        // and others if they aren't always in a ready state.
+        LocalBluetoothProfile profile = mHeadsetProfile;
+        if (profile != null) {
+            return profile.isProfileReady();
+        }
+        profile = mA2dpProfile;
+        if (profile != null) {
+            return profile.isProfileReady();
+        }
+        return false;
+    }
+
+    A2dpProfile getA2dpProfile() {
+        return mA2dpProfile;
+    }
+
+    HeadsetProfile getHeadsetProfile() {
+        return mHeadsetProfile;
+    }
+
+    /**
+     * Fill in a list of LocalBluetoothProfile objects that are supported by
+     * the local device and the remote device.
+     *
+     * @param uuids of the remote device
+     * @param localUuids UUIDs of the local device
+     * @param profiles The list of profiles to fill
+     * @param removedProfiles list of profiles that were removed
+     */
+    synchronized void updateProfiles(ParcelUuid[] uuids, ParcelUuid[] localUuids,
+            Collection<LocalBluetoothProfile> profiles,
+            Collection<LocalBluetoothProfile> removedProfiles) {
+        // Copy previous profile list into removedProfiles
+        removedProfiles.clear();
+        removedProfiles.addAll(profiles);
+        profiles.clear();
+
+        if (uuids == null) {
+            return;
+        }
+
+        if (mHeadsetProfile != null) {
+            if ((BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.HSP_AG) &&
+                    BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP)) ||
+                    (BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree_AG) &&
+                            BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree))) {
+                profiles.add(mHeadsetProfile);
+                removedProfiles.remove(mHeadsetProfile);
+            }
+        }
+
+        if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SINK_UUIDS) &&
+            mA2dpProfile != null) {
+            profiles.add(mA2dpProfile);
+            removedProfiles.remove(mA2dpProfile);
+        }
+
+        if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.ObexObjectPush) &&
+            mOppProfile != null) {
+            profiles.add(mOppProfile);
+            removedProfiles.remove(mOppProfile);
+        }
+
+        if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Hid) &&
+            mHidProfile != null) {
+            profiles.add(mHidProfile);
+            removedProfiles.remove(mHidProfile);
+        }
+
+        if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.NAP) &&
+            mPanProfile != null) {
+            profiles.add(mPanProfile);
+            removedProfiles.remove(mPanProfile);
+        }
+    }
+    /**
+     * Fill in a list of LocalBluetoothProfile objects that are supported by
+     * the local device and the remote device without deleting existing.
+     *
+     * @param uuids of the remote device
+     * @param localUuids UUIDs of the local device
+     * @param profiles The list of profiles to fill
+     * @param removedProfiles list of profiles that were removed
+     */
+    synchronized void addNewProfiles(ParcelUuid[] uuids, ParcelUuid[] localUuids,
+            Collection<LocalBluetoothProfile> profiles,
+            Collection<LocalBluetoothProfile> removedProfiles) {
+
+        if (uuids == null) {
+            return;
+        }
+
+        if (mHeadsetProfile != null) {
+            if (((BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.HSP_AG) &&
+                    BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP)) ||
+                    (BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree_AG) &&
+                            BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree))) &&
+                        !profiles.contains(mHeadsetProfile)) {
+                profiles.add(mHeadsetProfile);
+                removedProfiles.remove(mHeadsetProfile);
+            }
+        }
+
+        if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SINK_UUIDS) &&
+            (mA2dpProfile != null) &&
+            !profiles.contains(mA2dpProfile)) {
+            profiles.add(mA2dpProfile);
+            removedProfiles.remove(mA2dpProfile);
+        }
+
+        if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.ObexObjectPush) &&
+            (mOppProfile != null) &&
+            !profiles.contains(mOppProfile)) {
+            profiles.add(mOppProfile);
+            removedProfiles.remove(mOppProfile);
+        }
+
+        if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Hid) &&
+            (mHidProfile != null) &&
+            !profiles.contains(mHidProfile)) {
+            profiles.add(mHidProfile);
+            removedProfiles.remove(mHidProfile);
+        }
+
+        if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.NAP) &&
+            (mPanProfile != null) &&
+            !profiles.contains(mPanProfile)) {
+            profiles.add(mPanProfile);
+            removedProfiles.remove(mPanProfile);
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/OppProfile.java b/src/com/android/settings/bluetooth_msm/OppProfile.java
new file mode 100644
index 0000000..7ee2ad1
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/OppProfile.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import com.android.settings.R;
+
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothProfile;
+
+/**
+ * OppProfile handles Bluetooth OPP.
+ */
+final class OppProfile implements LocalBluetoothProfile {
+
+    static final String NAME = "OPP";
+
+    // Order of this profile in device profiles list
+    private static final int ORDINAL = 2;
+
+    public boolean isConnectable() {
+        return false;
+    }
+
+    public boolean isAutoConnectable() {
+        return false;
+    }
+
+    public boolean connect(BluetoothDevice device) {
+        return false;
+    }
+
+    public boolean disconnect(BluetoothDevice device) {
+        return false;
+    }
+
+    public int getConnectionStatus(BluetoothDevice device) {
+        return BluetoothProfile.STATE_DISCONNECTED; // Settings app doesn't handle OPP
+    }
+
+    public boolean isPreferred(BluetoothDevice device) {
+        return false;
+    }
+
+    public int getPreferred(BluetoothDevice device) {
+        return BluetoothProfile.PRIORITY_OFF; // Settings app doesn't handle OPP
+    }
+
+    public void setPreferred(BluetoothDevice device, boolean preferred) {
+    }
+
+    public boolean isProfileReady() {
+        return true;
+    }
+
+    public String toString() {
+        return NAME;
+    }
+
+    public int getOrdinal() {
+        return ORDINAL;
+    }
+
+    public int getNameResource(BluetoothDevice device) {
+        return R.string.bluetooth_profile_opp;
+    }
+
+    public int getSummaryResourceForDevice(BluetoothDevice device) {
+        return 0;   // OPP profile not displayed in UI
+    }
+
+    public int getDrawableResource(BluetoothClass btClass) {
+        return 0;   // no icon for OPP
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/PanProfile.java b/src/com/android/settings/bluetooth_msm/PanProfile.java
new file mode 100644
index 0000000..3db4a2b
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/PanProfile.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothPan;
+import android.bluetooth.BluetoothProfile;
+import android.content.Context;
+
+import com.android.settings.R;
+
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * PanProfile handles Bluetooth PAN profile (NAP and PANU).
+ */
+final class PanProfile implements LocalBluetoothProfile {
+    private BluetoothPan mService;
+
+    // Tethering direction for each device
+    private final HashMap<BluetoothDevice, Integer> mDeviceRoleMap =
+            new HashMap<BluetoothDevice, Integer>();
+
+    static final String NAME = "PAN";
+
+    // Order of this profile in device profiles list
+    private static final int ORDINAL = 4;
+
+    // These callbacks run on the main thread.
+    private final class PanServiceListener
+            implements BluetoothProfile.ServiceListener {
+
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            mService = (BluetoothPan) proxy;
+        }
+
+        public void onServiceDisconnected(int profile) {
+            mService = null;
+        }
+    }
+
+    PanProfile(Context context) {
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        adapter.getProfileProxy(context, new PanServiceListener(),
+                BluetoothProfile.PAN);
+    }
+
+    public boolean isConnectable() {
+        return true;
+    }
+
+    public boolean isAutoConnectable() {
+        return false;
+    }
+
+    public boolean connect(BluetoothDevice device) {
+        List<BluetoothDevice> sinks = mService.getConnectedDevices();
+        if (sinks != null) {
+            for (BluetoothDevice sink : sinks) {
+                mService.disconnect(sink);
+            }
+        }
+        return mService.connect(device);
+    }
+
+    public boolean disconnect(BluetoothDevice device) {
+        return mService.disconnect(device);
+    }
+
+    public int getConnectionStatus(BluetoothDevice device) {
+        return mService.getConnectionState(device);
+    }
+
+    public boolean isPreferred(BluetoothDevice device) {
+        return true;
+    }
+
+    public int getPreferred(BluetoothDevice device) {
+        return -1;
+    }
+
+    public void setPreferred(BluetoothDevice device, boolean preferred) {
+        // ignore: isPreferred is always true for PAN
+    }
+
+    public boolean isProfileReady() {
+        return true;
+    }
+
+    public String toString() {
+        return NAME;
+    }
+
+    public int getOrdinal() {
+        return ORDINAL;
+    }
+
+    public int getNameResource(BluetoothDevice device) {
+        if (isLocalRoleNap(device)) {
+            return R.string.bluetooth_profile_pan_nap;
+        } else {
+            return R.string.bluetooth_profile_pan;
+        }
+    }
+
+    public int getSummaryResourceForDevice(BluetoothDevice device) {
+        int state = mService.getConnectionState(device);
+        switch (state) {
+            case BluetoothProfile.STATE_DISCONNECTED:
+                return R.string.bluetooth_pan_profile_summary_use_for;
+
+            case BluetoothProfile.STATE_CONNECTED:
+                if (isLocalRoleNap(device)) {
+                    return R.string.bluetooth_pan_nap_profile_summary_connected;
+                } else {
+                    return R.string.bluetooth_pan_user_profile_summary_connected;
+                }
+
+            default:
+                return Utils.getConnectionStateSummary(state);
+        }
+    }
+
+    public int getDrawableResource(BluetoothClass btClass) {
+        return R.drawable.ic_bt_network_pan;
+    }
+
+    // Tethering direction determines UI strings.
+    void setLocalRole(BluetoothDevice device, int role) {
+        mDeviceRoleMap.put(device, role);
+    }
+
+    boolean isLocalRoleNap(BluetoothDevice device) {
+        if (mDeviceRoleMap.containsKey(device)) {
+            return mDeviceRoleMap.get(device) == BluetoothPan.LOCAL_NAP_ROLE;
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/RequestPermissionActivity.java b/src/com/android/settings/bluetooth_msm/RequestPermissionActivity.java
new file mode 100644
index 0000000..529312d
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/RequestPermissionActivity.java
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import com.android.settings.R;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.util.Log;
+
+/**
+ * RequestPermissionActivity asks the user whether to enable discovery. This is
+ * usually started by an application wanted to start bluetooth and or discovery
+ */
+public class RequestPermissionActivity extends Activity implements
+        DialogInterface.OnClickListener {
+    // Command line to test this
+    // adb shell am start -a android.bluetooth.adapter.action.REQUEST_ENABLE
+    // adb shell am start -a android.bluetooth.adapter.action.REQUEST_DISCOVERABLE
+
+    private static final String TAG = "RequestPermissionActivity";
+
+    private static final int MAX_DISCOVERABLE_TIMEOUT = 3600; // 1 hr
+
+    // Non-error return code: BT is starting or has started successfully. Used
+    // by this Activity and RequestPermissionHelperActivity
+    /* package */ static final int RESULT_BT_STARTING_OR_STARTED = -1000;
+
+    private static final int REQUEST_CODE_START_BT = 1;
+
+    private LocalBluetoothAdapter mLocalAdapter;
+
+    private int mTimeout = BluetoothDiscoverableEnabler.DEFAULT_DISCOVERABLE_TIMEOUT;
+
+    /*
+     * True if bluetooth wasn't enabled and RequestPermissionHelperActivity was
+     * started to ask the user and start bt.
+     *
+     * If/when that activity returns successfully, display please wait msg then
+     * go away when bt has started and discovery mode has been enabled.
+     */
+    private boolean mNeededToEnableBluetooth;
+
+    // True if requesting BT to be turned on
+    // False if requesting BT to be turned on + discoverable mode
+    private boolean mEnableOnly;
+
+    private boolean mUserConfirmed;
+
+    private AlertDialog mDialog;
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent == null) {
+                return;
+            }
+            if (mNeededToEnableBluetooth
+                    && BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {
+                int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothDevice.ERROR);
+                if (state == BluetoothAdapter.STATE_ON) {
+                    if (mUserConfirmed) {
+                        proceedAndFinish();
+                    }
+                }
+            }
+        }
+    };
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // Note: initializes mLocalAdapter and returns true on error
+        if (parseIntent()) {
+            finish();
+            return;
+        }
+
+        int btState = mLocalAdapter.getState();
+
+        switch (btState) {
+            case BluetoothAdapter.STATE_OFF:
+            case BluetoothAdapter.STATE_TURNING_OFF:
+            case BluetoothAdapter.STATE_TURNING_ON:
+                /*
+                 * Strictly speaking STATE_TURNING_ON belong with STATE_ON;
+                 * however, BT may not be ready when the user clicks yes and we
+                 * would fail to turn on discovery mode. By kicking this to the
+                 * RequestPermissionHelperActivity, this class will handle that
+                 * case via the broadcast receiver.
+                 */
+
+                /*
+                 * Start the helper activity to:
+                 * 1) ask the user about enabling bt AND discovery
+                 * 2) enable BT upon confirmation
+                 */
+                registerReceiver(mReceiver,
+                        new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED));
+                Intent intent = new Intent();
+                intent.setClass(this, RequestPermissionHelperActivity.class);
+                if (mEnableOnly) {
+                    intent.setAction(RequestPermissionHelperActivity.ACTION_INTERNAL_REQUEST_BT_ON);
+                } else {
+                    intent.setAction(RequestPermissionHelperActivity.
+                            ACTION_INTERNAL_REQUEST_BT_ON_AND_DISCOVERABLE);
+                    intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, mTimeout);
+                }
+                startActivityForResult(intent, REQUEST_CODE_START_BT);
+                mNeededToEnableBluetooth = true;
+                break;
+            case BluetoothAdapter.STATE_ON:
+                if (mEnableOnly) {
+                    // Nothing to do. Already enabled.
+                    proceedAndFinish();
+                } else {
+                    // Ask the user about enabling discovery mode
+                    createDialog();
+                }
+                break;
+            default:
+                Log.e(TAG, "Unknown adapter state: " + btState);
+        }
+    }
+
+    private void createDialog() {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setIcon(android.R.drawable.ic_dialog_info);
+        builder.setTitle(getString(R.string.bluetooth_permission_request));
+
+        if (mNeededToEnableBluetooth) {
+            // RequestPermissionHelperActivity has gotten confirmation from user
+            // to turn on BT
+            builder.setMessage(getString(R.string.bluetooth_turning_on));
+            builder.setCancelable(false);
+        } else {
+            // Ask the user whether to turn on discovery mode or not
+            // For lasting discoverable mode there is a different message
+            if (mTimeout == BluetoothDiscoverableEnabler.DISCOVERABLE_TIMEOUT_NEVER) {
+                builder.setMessage(
+                        getString(R.string.bluetooth_ask_lasting_discovery));
+            } else {
+                builder.setMessage(
+                        getString(R.string.bluetooth_ask_discovery, mTimeout));
+            }
+            builder.setPositiveButton(getString(R.string.yes), this);
+            builder.setNegativeButton(getString(R.string.no), this);
+        }
+
+        mDialog = builder.create();
+        mDialog.show();
+
+        if (getResources().getBoolean(R.bool.auto_confirm_bluetooth_activation_dialog) == true) {
+            // dismiss dialog immediately if settings say so
+            onClick(null, DialogInterface.BUTTON_POSITIVE);
+        }
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (requestCode != REQUEST_CODE_START_BT) {
+            Log.e(TAG, "Unexpected onActivityResult " + requestCode + ' ' + resultCode);
+            setResult(RESULT_CANCELED);
+            finish();
+            return;
+        }
+        if (resultCode != RESULT_BT_STARTING_OR_STARTED) {
+            setResult(resultCode);
+            finish();
+            return;
+        }
+
+        // Back from RequestPermissionHelperActivity. User confirmed to enable
+        // BT and discoverable mode.
+        mUserConfirmed = true;
+
+        if (mLocalAdapter.getBluetoothState() == BluetoothAdapter.STATE_ON) {
+            proceedAndFinish();
+        } else {
+            // If BT is not up yet, show "Turning on Bluetooth..."
+            createDialog();
+        }
+    }
+
+    public void onClick(DialogInterface dialog, int which) {
+        switch (which) {
+            case DialogInterface.BUTTON_POSITIVE:
+                proceedAndFinish();
+                break;
+
+            case DialogInterface.BUTTON_NEGATIVE:
+                setResult(RESULT_CANCELED);
+                finish();
+                break;
+        }
+    }
+
+    private void proceedAndFinish() {
+        int returnCode;
+
+        if (mEnableOnly) {
+            // BT enabled. Done
+            returnCode = RESULT_OK;
+        } else if (mLocalAdapter.setScanMode(
+                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE, mTimeout)) {
+            // If already in discoverable mode, this will extend the timeout.
+            LocalBluetoothPreferences.persistDiscoverableEndTimestamp(
+                    this, System.currentTimeMillis() + (long) mTimeout * 1000);
+            returnCode = mTimeout;
+            // Activity.RESULT_FIRST_USER should be 1
+            if (returnCode < RESULT_FIRST_USER) {
+                returnCode = RESULT_FIRST_USER;
+            }
+        } else {
+            returnCode = RESULT_CANCELED;
+        }
+
+        if (mDialog != null) {
+            mDialog.dismiss();
+        }
+
+        setResult(returnCode);
+        finish();
+    }
+
+    /**
+     * Parse the received Intent and initialize mLocalBluetoothAdapter.
+     * @return true if an error occurred; false otherwise
+     */
+    private boolean parseIntent() {
+        Intent intent = getIntent();
+        if (intent != null && intent.getAction().equals(BluetoothAdapter.ACTION_REQUEST_ENABLE)) {
+            mEnableOnly = true;
+        } else if (intent != null
+                && intent.getAction().equals(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE)) {
+            mTimeout = intent.getIntExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION,
+                    BluetoothDiscoverableEnabler.DEFAULT_DISCOVERABLE_TIMEOUT);
+
+            Log.d(TAG, "Setting Bluetooth Discoverable Timeout = " + mTimeout);
+
+            if (mTimeout < 0 || mTimeout > MAX_DISCOVERABLE_TIMEOUT) {
+                mTimeout = BluetoothDiscoverableEnabler.DEFAULT_DISCOVERABLE_TIMEOUT;
+            }
+        } else {
+            Log.e(TAG, "Error: this activity may be started only with intent "
+                    + BluetoothAdapter.ACTION_REQUEST_ENABLE + " or "
+                    + BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
+            setResult(RESULT_CANCELED);
+            return true;
+        }
+
+        LocalBluetoothManager manager = LocalBluetoothManager.getInstance(this);
+        if (manager == null) {
+            Log.e(TAG, "Error: there's a problem starting Bluetooth");
+            setResult(RESULT_CANCELED);
+            return true;
+        }
+        mLocalAdapter = manager.getBluetoothAdapter();
+
+        return false;
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        if (mNeededToEnableBluetooth) {
+            unregisterReceiver(mReceiver);
+        }
+    }
+
+    @Override
+    public void onBackPressed() {
+        setResult(RESULT_CANCELED);
+        super.onBackPressed();
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/RequestPermissionHelperActivity.java b/src/com/android/settings/bluetooth_msm/RequestPermissionHelperActivity.java
new file mode 100644
index 0000000..f108513
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/RequestPermissionHelperActivity.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import com.android.internal.app.AlertActivity;
+import com.android.internal.app.AlertController;
+import com.android.settings.R;
+
+import android.app.Activity;
+import android.bluetooth.BluetoothAdapter;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.View;
+import android.widget.TextView;
+
+/**
+ * RequestPermissionHelperActivity asks the user whether to enable discovery.
+ * This is usually started by RequestPermissionActivity.
+ */
+public class RequestPermissionHelperActivity extends AlertActivity implements
+        DialogInterface.OnClickListener {
+    private static final String TAG = "RequestPermissionHelperActivity";
+
+    public static final String ACTION_INTERNAL_REQUEST_BT_ON =
+        "com.android.settings.bluetooth.ACTION_INTERNAL_REQUEST_BT_ON";
+
+    public static final String ACTION_INTERNAL_REQUEST_BT_ON_AND_DISCOVERABLE =
+        "com.android.settings.bluetooth.ACTION_INTERNAL_REQUEST_BT_ON_AND_DISCOVERABLE";
+
+    private LocalBluetoothAdapter mLocalAdapter;
+
+    private int mTimeout;
+
+    // True if requesting BT to be turned on
+    // False if requesting BT to be turned on + discoverable mode
+    private boolean mEnableOnly;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // Note: initializes mLocalAdapter and returns true on error
+        if (parseIntent()) {
+            finish();
+            return;
+        }
+
+        createDialog();
+
+        if (getResources().getBoolean(R.bool.auto_confirm_bluetooth_activation_dialog) == true) {
+            // dismiss dialog immediately if settings say so
+            onClick(null, BUTTON_POSITIVE);
+            dismiss();
+        }
+    }
+
+    void createDialog() {
+        final AlertController.AlertParams p = mAlertParams;
+
+        if (mEnableOnly) {
+            p.mMessage = getString(R.string.bluetooth_ask_enablement);
+        } else {
+            if (mTimeout == BluetoothDiscoverableEnabler.DISCOVERABLE_TIMEOUT_NEVER) {
+                p.mMessage = getString(R.string.bluetooth_ask_enablement_and_lasting_discovery);
+            } else {
+                p.mMessage = getString(R.string.bluetooth_ask_enablement_and_discovery, mTimeout);
+            }
+        }
+
+        p.mPositiveButtonText = getString(R.string.allow);
+        p.mPositiveButtonListener = this;
+        p.mNegativeButtonText = getString(R.string.deny);
+        p.mNegativeButtonListener = this;
+
+        setupAlert();
+    }
+
+    public void onClick(DialogInterface dialog, int which) {
+        int returnCode;
+        // FIXME: fix this ugly switch logic!
+        switch (which) {
+            case BUTTON_POSITIVE:
+                int btState = 0;
+
+                try {
+                    // TODO There's a better way.
+                    int retryCount = 30;
+                    do {
+                        btState = mLocalAdapter.getBluetoothState();
+                        Thread.sleep(100);
+                    } while (btState == BluetoothAdapter.STATE_TURNING_OFF && --retryCount > 0);
+                } catch (InterruptedException ignored) {
+                    // don't care
+                }
+
+                if (btState == BluetoothAdapter.STATE_TURNING_ON
+                        || btState == BluetoothAdapter.STATE_ON
+                        || mLocalAdapter.enable()) {
+                    returnCode = RequestPermissionActivity.RESULT_BT_STARTING_OR_STARTED;
+                } else {
+                    returnCode = RESULT_CANCELED;
+                }
+                break;
+
+            case BUTTON_NEGATIVE:
+                returnCode = RESULT_CANCELED;
+                break;
+            default:
+                return;
+        }
+        setResult(returnCode);
+    }
+
+    /**
+     * Parse the received Intent and initialize mLocalBluetoothAdapter.
+     * @return true if an error occurred; false otherwise
+     */
+    private boolean parseIntent() {
+        Intent intent = getIntent();
+        if (intent != null && intent.getAction().equals(ACTION_INTERNAL_REQUEST_BT_ON)) {
+            mEnableOnly = true;
+        } else if (intent != null
+                && intent.getAction().equals(ACTION_INTERNAL_REQUEST_BT_ON_AND_DISCOVERABLE)) {
+            mEnableOnly = false;
+            // Value used for display purposes. Not range checking.
+            mTimeout = intent.getIntExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION,
+                    BluetoothDiscoverableEnabler.DEFAULT_DISCOVERABLE_TIMEOUT);
+        } else {
+            setResult(RESULT_CANCELED);
+            return true;
+        }
+
+        LocalBluetoothManager manager = LocalBluetoothManager.getInstance(this);
+        if (manager == null) {
+            Log.e(TAG, "Error: there's a problem starting Bluetooth");
+            setResult(RESULT_CANCELED);
+            return true;
+        }
+        mLocalAdapter = manager.getBluetoothAdapter();
+
+        return false;
+    }
+
+    @Override
+    public void onBackPressed() {
+        setResult(RESULT_CANCELED);
+        super.onBackPressed();
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/SapProfile.java b/src/com/android/settings/bluetooth_msm/SapProfile.java
new file mode 100644
index 0000000..730f121
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/SapProfile.java
@@ -0,0 +1,125 @@
+/*
+ ** Copyright 2008, The Android Open Source Project
+ ** Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothSap;
+import android.bluetooth.BluetoothProfile;
+import android.content.Context;
+import android.util.Log;
+
+import com.android.settings.R;
+
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * SapProfile handles Bluetooth SAP profile.
+ */
+final class SapProfile implements LocalBluetoothProfile {
+    private BluetoothSap mService;
+    private int mConnectionStatus = 0;
+
+    // Tethering direction for each device
+    private final HashMap<BluetoothDevice, Integer> mDeviceRoleMap =
+            new HashMap<BluetoothDevice, Integer>();
+
+    static final String NAME = "SAP";
+
+    // Order of this profile in device profiles list
+    private static final int ORDINAL = 5;
+
+    SapProfile() {
+        mService = new BluetoothSap();
+    }
+
+    public boolean isConnectable() {
+        return true;
+    }
+
+    public boolean isAutoConnectable() {
+        return false;
+    }
+
+    public boolean connect(BluetoothDevice device) {
+        return false;
+    }
+
+    public boolean disconnect(BluetoothDevice device) {
+        boolean ret = mService.disconnect();
+        return ret;
+    }
+
+    public int getConnectionStatus(BluetoothDevice device) {
+        return mConnectionStatus;
+    }
+
+    public void setConnectionStatus(int status) {
+        mConnectionStatus = status;
+    }
+
+    public boolean isPreferred(BluetoothDevice device) {
+        return true;
+    }
+
+    public int getPreferred(BluetoothDevice device) {
+        return -1;
+    }
+
+    public void setPreferred(BluetoothDevice device, boolean preferred) {
+        // ignore: isPreferred is always true for SAP
+    }
+
+    public boolean isProfileReady() {
+        return true;
+    }
+
+    public String toString() {
+        return NAME;
+    }
+
+    public int getOrdinal() {
+        return ORDINAL;
+    }
+
+    public int getNameResource(BluetoothDevice device) {
+        return R.string.bluetooth_profile_sap;
+    }
+
+    public int getSummaryResourceForDevice(BluetoothDevice device) {
+        int state = getConnectionStatus(device);
+        switch (state) {
+            case BluetoothProfile.STATE_DISCONNECTED:
+                return R.string.bluetooth_sap_profile_summary_use_for;
+
+            case BluetoothProfile.STATE_CONNECTED:
+                    return R.string.bluetooth_sap_profile_summary_connected;
+
+            default:
+                return Utils.getConnectionStateSummary(state);
+        }
+    }
+
+    public int getDrawableResource(BluetoothClass btClass) {
+        //TODO change this for SAP
+        return R.drawable.ic_bt_network_pan;
+    }
+
+}
diff --git a/src/com/android/settings/bluetooth_msm/Utf8ByteLengthFilter.java b/src/com/android/settings/bluetooth_msm/Utf8ByteLengthFilter.java
new file mode 100644
index 0000000..bae6e56
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/Utf8ByteLengthFilter.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.text.InputFilter;
+import android.text.Spanned;
+
+/**
+ * This filter will constrain edits so that the text length is not
+ * greater than the specified number of bytes using UTF-8 encoding.
+ * <p>The JNI method used by {@link android.server.BluetoothService}
+ * to convert UTF-16 to UTF-8 doesn't support surrogate pairs,
+ * therefore code points outside of the basic multilingual plane
+ * (0000-FFFF) will be encoded as a pair of 3-byte UTF-8 characters,
+ * rather than a single 4-byte UTF-8 encoding. Dalvik implements this
+ * conversion in {@code convertUtf16ToUtf8()} in
+ * {@code dalvik/vm/UtfString.c}.
+ * <p>This JNI method is unlikely to change in the future due to
+ * backwards compatibility requirements. It's also unclear whether
+ * the installed base of Bluetooth devices would correctly handle the
+ * encoding of surrogate pairs in UTF-8 as 4 bytes rather than 6.
+ * However, this filter will still work in scenarios where surrogate
+ * pairs are encoded as 4 bytes, with the caveat that the maximum
+ * length will be constrained more conservatively than necessary.
+ */
+class Utf8ByteLengthFilter implements InputFilter {
+    private final int mMaxBytes;
+
+    Utf8ByteLengthFilter(int maxBytes) {
+        mMaxBytes = maxBytes;
+    }
+
+    public CharSequence filter(CharSequence source, int start, int end,
+                               Spanned dest, int dstart, int dend) {
+        int srcByteCount = 0;
+        // count UTF-8 bytes in source substring
+        for (int i = start; i < end; i++) {
+            char c = source.charAt(i);
+            srcByteCount += (c < (char) 0x0080) ? 1 : (c < (char) 0x0800 ? 2 : 3);
+        }
+        int destLen = dest.length();
+        int destByteCount = 0;
+        // count UTF-8 bytes in destination excluding replaced section
+        for (int i = 0; i < destLen; i++) {
+            if (i < dstart || i >= dend) {
+                char c = dest.charAt(i);
+                destByteCount += (c < (char) 0x0080) ? 1 : (c < (char) 0x0800 ? 2 : 3);
+            }
+        }
+        int keepBytes = mMaxBytes - destByteCount;
+        if (keepBytes <= 0) {
+            return "";
+        } else if (keepBytes >= srcByteCount) {
+            return null; // use original dest string
+        } else {
+            // find end position of largest sequence that fits in keepBytes
+            for (int i = start; i < end; i++) {
+                char c = source.charAt(i);
+                keepBytes -= (c < (char) 0x0080) ? 1 : (c < (char) 0x0800 ? 2 : 3);
+                if (keepBytes < 0) {
+                    return source.subSequence(start, i);
+                }
+            }
+            // If the entire substring fits, we should have returned null
+            // above, so this line should not be reached. If for some
+            // reason it is, return null to use the original dest string.
+            return null;
+        }
+    }
+}
diff --git a/src/com/android/settings/bluetooth_msm/Utils.java b/src/com/android/settings/bluetooth_msm/Utils.java
new file mode 100644
index 0000000..9fd9a45
--- /dev/null
+++ b/src/com/android/settings/bluetooth_msm/Utils.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.bluetooth;
+
+import android.app.AlertDialog;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothProfile;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.widget.Toast;
+
+import com.android.settings.R;
+
+/**
+ * Utils is a helper class that contains constants for various
+ * Android resource IDs, debug logging flags, and static methods
+ * for creating dialogs.
+ */
+final class Utils {
+    static final boolean V = false; // verbose logging
+    static final boolean D = true;  // regular logging
+
+    private Utils() {
+    }
+
+    public static int getConnectionStateSummary(int connectionState) {
+        switch (connectionState) {
+        case BluetoothProfile.STATE_CONNECTED:
+            return R.string.bluetooth_connected;
+        case BluetoothProfile.STATE_CONNECTING:
+            return R.string.bluetooth_connecting;
+        case BluetoothProfile.STATE_DISCONNECTED:
+            return R.string.bluetooth_disconnected;
+        case BluetoothProfile.STATE_DISCONNECTING:
+            return R.string.bluetooth_disconnecting;
+        default:
+            return 0;
+        }
+    }
+
+    // Create (or recycle existing) and show disconnect dialog.
+    static AlertDialog showDisconnectDialog(Context context,
+            AlertDialog dialog,
+            DialogInterface.OnClickListener disconnectListener,
+            CharSequence title, CharSequence message) {
+        if (dialog == null) {
+            dialog = new AlertDialog.Builder(context)
+                    .setPositiveButton(android.R.string.ok, disconnectListener)
+                    .setNegativeButton(android.R.string.cancel, null)
+                    .create();
+        } else {
+            if (dialog.isShowing()) {
+                dialog.dismiss();
+            }
+            // use disconnectListener for the correct profile(s)
+            CharSequence okText = context.getText(android.R.string.ok);
+            dialog.setButton(DialogInterface.BUTTON_POSITIVE,
+                    okText, disconnectListener);
+        }
+        dialog.setTitle(title);
+        dialog.setMessage(message);
+        dialog.show();
+        return dialog;
+    }
+
+    // Create (or recycle existing) and show disconnect dialog.
+    static AlertDialog showDisconnectDialog(Context context,
+            AlertDialog dialog,
+            DialogInterface.OnClickListener disconnectListener,
+            DialogInterface.OnClickListener cancelListener,
+            CharSequence title, CharSequence message) {
+        if (dialog == null) {
+            dialog = new AlertDialog.Builder(context)
+                    .setPositiveButton(android.R.string.ok, disconnectListener)
+                    .setNegativeButton(android.R.string.cancel, cancelListener)
+                    .create();
+        } else {
+            if (dialog.isShowing()) {
+                dialog.dismiss();
+            }
+            // use disconnectListener for the correct profile(s)
+            CharSequence okText = context.getText(android.R.string.ok);
+            dialog.setButton(DialogInterface.BUTTON_POSITIVE,
+                    okText, disconnectListener);
+        }
+        dialog.setTitle(title);
+        dialog.setMessage(message);
+        dialog.show();
+        return dialog;
+    }
+
+    // TODO: wire this up to show connection errors...
+    static void showConnectingError(Context context, String name) {
+        // if (!mIsConnectingErrorPossible) {
+        //     return;
+        // }
+        // mIsConnectingErrorPossible = false;
+
+        showError(context, name, R.string.bluetooth_connecting_error_message);
+    }
+
+    static void showError(Context context, String name, int messageResId) {
+        String message = context.getString(messageResId, name);
+        LocalBluetoothManager manager = LocalBluetoothManager.getInstance(context);
+        Context activity = manager.getForegroundActivity();
+        if(manager.isForegroundActivity()) {
+            new AlertDialog.Builder(activity)
+                .setIcon(android.R.drawable.ic_dialog_alert)
+                .setTitle(R.string.bluetooth_error_title)
+                .setMessage(message)
+                .setPositiveButton(android.R.string.ok, null)
+                .show();
+        } else {
+            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();
+        }
+    }
+}
-- 
1.7.9.5

