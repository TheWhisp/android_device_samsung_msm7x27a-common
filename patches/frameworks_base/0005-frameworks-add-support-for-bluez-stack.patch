From c8468281a09b36a7130f6c55a93d802da53693aa Mon Sep 17 00:00:00 2001
From: Ram Mohan Korukonda <rkorukon@codeaurora.org>
Date: Fri, 4 Jan 2013 01:53:22 +0530
Subject: [PATCH 18/18] frameworks: add support for bluez stack

This is a combination of 18 commits.

bluetooth: Add frameworks support for bluetooth bluez stack

Based on the compilation flag compile either bluetooth frameworks code
from the core directory or the bluetoothmsm directory.

When BOARD_HAVE_BLUETOOTH_BLUEZ is set to true, bluetoothmsm code gets
compiled and if it is not set default bluetooth code under core gets
compiled.

Change-Id: I5fe3ed83c5d12d5fa43c16060756228dec6b5e7b

Conflicts:

	Android.mk
	core/jni/AndroidRuntime.cpp
	data/etc/platform.xml

Bluetooth: Parse Bluetooth IOP file for Photo Vcard

By default no Photo Vcard send to Carkit even Carkit
requests for it. As remote device unable to parse
Photo Vcard. If Customer wants feature can be enabled
by Bluetooth IOP files.

Change-Id: I4a311a5c9e7ce12ebd574851bfac79ac5471808a
CRs-Fixed: 363669

Bluetooth: PAN: Tethering code for Bluez solution

CRs-fixed: 444230
Change-Id: Ib18028fdab1e13ab191543e1afdcfa98e0846183

Bluetooth: Implementing finalize() method.

Added finalize() in BluetoothA2dp.java for
clean up in this method.

Change-Id: I4f23333db782f8d9fc6fadb41d0b33fbe694329a
CRs-Fixed: 443585

Bluetooth: PAN: Remove interface address from list incase of error

Remove Bluetooth address from list of Bluetooth interface addresses
if exception is thrown while configuring the interface.

Change-Id: I6eaca820abfff09564a26c9521bfab7d03051825
CRs-Fixed: 434952

Bluetooth: Added AVRCP1.3 intents in mediaplayer.

Added posting of Metadata Changed intents to BluetoothA2dpService
for updating MediaPlayer status like STOP, PAUSE, PLAY, FWD_SEEK,
REV_SEEK along with metadata of the current song.

Change-Id: I47bbea35c982d07fecdbb9245cc48af58fb1d78a
CRs-fixed: 443134

Conflicts:

	media/java/android/media/MediaPlayer.java

Bluetooth: Update the PLAYSTATUS and METADATA to remote device based on
           Actual state of Music App.

Registered for PLAYSTATUS_CHANGED intent which is provided by Music App
and based this information BluetoothA2dpService is  updating the Play
status and metadata to Remote device.

Change-Id: I5fe865fcdde3e0fd2442d0629e465711696d977a
CRs-fixed: 443134

Bluetooth: Clear the device from list only when device is disconnected.

CRs-Fixed: 434789
Change-Id: I6be3ec672d93a3cf550324b917db579576ed8e41

Bluetooth: Modified cancelBondProcess for HID mouse

The patch properly handles the cancelBondProcess for HID
mouse devices. The device creation cancel happens when
paired state of HID mouse device is false.

Change-Id: I962e126f8435724233a78f9c700f3353d4bda588

Bluetooth: GAP: Check for pairingState null before usage

Change-Id: I4bc0cb643d58b8f77d74c4579e470deef4fe04c5
CRs-fixed: 448558

Bluetooth: New implementation of AT command parsing.

Added new implementation for parsing the arguments of
an AT command.

Change-Id: Ieb2d2c25ef2e9d676db00177b5f3931b0b6ac791
CRs-Fixed: 444286

Bluetooth: Multiple gatt service for same service on the device support

Added the following support to allow the creation of multiple
gatt services for the same service on the same device:
1. BluetoothGattService maintains a serviceId which is used
to differentiate the gatt service object on the remote
for the same service
2. The service tracker in BluetoothService that maintains the
gatt service <-> callback mapping takes in object path concatenated
with the serviceId as the key so that we can differentiate
the gatt service to route the callback
3. All the asynchronous gatt client methods stores the serviceId
along with the object path as user data
4. Indications and notifications are routed to all the applications
that registered for the watcher on the characteritics
5. The characteristics watcher is deregistered only when all the
applications who registered for it called deregister
6. Disconnection is initiated on the device only when all the
gatt services on the device are closed.

Change-Id: I149f135a6e4f99cd7fd44a9cf7a059562df93ed8
CRs-fixed: 426328

Bluetooth: Cleanup userids array to avoid null pointer exception

This fix null pointer exception during multiple gatt services.

CRs-fixed: 485789
Change-Id: I3d6061ed0a817cdfb4ab8d526c71c569edf2f929

frameworks-bt : Advertise only supported profiles in SDP database

Enable or disable PBAP and NAP profiles based on the system property
variables defined in the BT init shell script.

Change-Id: I88ac0db70d0ee2c5aad56a61ac3ebeaa03479d1c
CRs-Fixed: 405182 481305

Bluetooth: Add break to avoid wrong fall through

Add break which is needed to avoid wrong fall through while
processing Obex Permission command.

Change-Id: Ifa790ef14751168ad78246514645f864af0c2e6b
CRs-Fixed: 436931

Conflicts:

	btobex/javax/btobex/HeaderSet.java

Bluetooth: Reverted changes to avoid LM_SECURE option for BT Socket.

The LM_SECURE options sets the SECURITY_HIGH for l2cap socket.
Previously this option  is avoided for meeting SAP connection
requirements. As this is required for CTS validation, reverting
back the existing google implementation.

(cherry picked from commit 0b0c7c4cb1c3c557d2d45aaa7b9c21347a338c75)

Change-Id: Ibbeb57bf5984ec0af50441562de70b4ed744a0f0
CRs-Fixed: 387173

bluetooth: Fix crash in bluez handler

Fix crash in event handler loop when the underlying dbus
mechanism is not available.

Change-Id: I26670f9d5d0fa738a3c89f1f7d603a307c9d3e04
CRs-Fixed: 471242

Bluetooth: JNI verbose log fix

Fix to avoid compilation errors after enabling JNI verbose logs.

CRs-Fixed: 475950
Change-Id: I3e2d54b0f5f8e0c005742adfc2ffc6f0ac33a33f
---
 Android.mk                                         |  138 +-
 .../java/android/bluetooth/AtCommandHandler.java   |   94 +
 .../java/android/bluetooth/AtCommandResult.java    |  115 +
 bluetoothmsm/java/android/bluetooth/AtParser.java  |  378 ++
 .../java/android/bluetooth/BluetoothA2dp.java      |  492 ++
 .../java/android/bluetooth/BluetoothAdapter.java   | 1663 ++++++
 .../bluetooth/BluetoothAssignedNumbers.java        |  521 ++
 .../android/bluetooth/BluetoothAudioGateway.java   |  202 +
 .../java/android/bluetooth/BluetoothClass.java     |  380 ++
 .../java/android/bluetooth/BluetoothDUN.java       |  121 +
 .../java/android/bluetooth/BluetoothDevice.aidl    |   19 +
 .../java/android/bluetooth/BluetoothDevice.java    | 1461 +++++
 .../android/bluetooth/BluetoothDevicePicker.java   |   72 +
 .../bluetooth/BluetoothDeviceProfileState.java     | 1485 +++++
 .../java/android/bluetooth/BluetoothGatt.java      |  635 +++
 .../bluetooth/BluetoothGattAppConfiguration.aidl   |   31 +
 .../bluetooth/BluetoothGattAppConfiguration.java   |  138 +
 .../android/bluetooth/BluetoothGattCallback.java   |  134 +
 .../android/bluetooth/BluetoothGattService.java    |  696 +++
 .../java/android/bluetooth/BluetoothHeadset.java   |  957 ++++
 .../java/android/bluetooth/BluetoothHealth.java    |  489 ++
 .../bluetooth/BluetoothHealthAppConfiguration.aidl |   19 +
 .../bluetooth/BluetoothHealthAppConfiguration.java |  165 +
 .../android/bluetooth/BluetoothHealthCallback.java |   68 +
 .../android/bluetooth/BluetoothInputDevice.java    |  330 ++
 .../android/bluetooth/BluetoothInputStream.java    |   98 +
 .../android/bluetooth/BluetoothOutputStream.java   |   92 +
 .../java/android/bluetooth/BluetoothPan.java       |  306 ++
 .../java/android/bluetooth/BluetoothPbap.java      |  263 +
 .../java/android/bluetooth/BluetoothProfile.java   |  192 +
 .../android/bluetooth/BluetoothProfileState.java   |  160 +
 .../java/android/bluetooth/BluetoothSap.java       |  102 +
 .../android/bluetooth/BluetoothServerSocket.java   |  144 +
 .../java/android/bluetooth/BluetoothSocket.java    |  530 ++
 .../bluetooth/BluetoothTetheringDataTracker.java   |  327 ++
 .../java/android/bluetooth/BluetoothUuid.java      |  242 +
 .../java/android/bluetooth/HeadsetBase.java        |  298 +
 .../java/android/bluetooth/IBluetooth.aidl         |  208 +
 .../java/android/bluetooth/IBluetoothA2dp.aidl     |   44 +
 .../java/android/bluetooth/IBluetoothCallback.aidl |   29 +
 .../android/bluetooth/IBluetoothGattCallback.aidl  |   62 +
 .../android/bluetooth/IBluetoothGattProfile.aidl   |   30 +
 .../android/bluetooth/IBluetoothGattService.aidl   |   29 +
 .../java/android/bluetooth/IBluetoothHeadset.aidl  |   61 +
 .../android/bluetooth/IBluetoothHeadsetPhone.aidl  |   39 +
 .../bluetooth/IBluetoothHealthCallback.aidl        |   32 +
 .../bluetooth/IBluetoothLEFindMeServices.aidl      |   48 +
 .../bluetooth/IBluetoothLEProximityServices.aidl   |   53 +
 .../java/android/bluetooth/IBluetoothManager.aidl  |   34 +
 .../java/android/bluetooth/IBluetoothPbap.aidl     |   32 +
 .../IBluetoothPreferredDeviceListCallback.aidl     |   44 +
 .../bluetooth/IBluetoothStateChangeCallback.aidl   |   27 +
 .../bluetooth/IBluetoothThermometerCallBack.aidl   |   50 +
 .../bluetooth/IBluetoothThermometerServices.aidl   |   49 +
 bluetoothmsm/java/android/bluetooth/package.html   |   31 +
 .../java/android/server/BluetoothA2dpService.java  | 1444 +++++
 .../android/server/BluetoothAdapterProperties.java |  105 +
 .../server/BluetoothAdapterStateMachine.java       |  921 ++++
 .../java/android/server/BluetoothBondState.java    |  533 ++
 .../android/server/BluetoothDeviceProperties.java  |  143 +
 .../java/android/server/BluetoothEventLoop.java    | 1610 ++++++
 .../server/BluetoothGattProfileHandler.java        | 1082 ++++
 .../server/BluetoothHealthProfileHandler.java      |  671 +++
 .../server/BluetoothInputProfileHandler.java       |  226 +
 .../android/server/BluetoothManagerService.java    |   93 +
 .../android/server/BluetoothPanProfileHandler.java |  417 ++
 .../java/android/server/BluetoothService.java      | 5715 ++++++++++++++++++++
 bluetoothmsm/java/android/server/package.html      |    5 +
 btobex/Android.mk                                  |   11 +
 btobex/javax/btobex/ApplicationParameter.java      |  134 +
 btobex/javax/btobex/Authenticator.java             |  115 +
 btobex/javax/btobex/BaseStream.java                |   76 +
 btobex/javax/btobex/ClientOperation.java           |  831 +++
 btobex/javax/btobex/ClientSession.java             |  748 +++
 btobex/javax/btobex/HeaderSet.java                 |  741 +++
 btobex/javax/btobex/ObexHelper.java                | 1223 +++++
 btobex/javax/btobex/ObexSession.java               |  218 +
 btobex/javax/btobex/ObexTransport.java             |   76 +
 btobex/javax/btobex/Operation.java                 |  183 +
 btobex/javax/btobex/PasswordAuthentication.java    |   79 +
 btobex/javax/btobex/PrivateInputStream.java        |  181 +
 btobex/javax/btobex/PrivateOutputStream.java       |  172 +
 btobex/javax/btobex/ResponseCodes.java             |  326 ++
 btobex/javax/btobex/ServerOperation.java           |  847 +++
 btobex/javax/btobex/ServerRequestHandler.java      |  348 ++
 btobex/javax/btobex/ServerSession.java             |  830 +++
 btobex/javax/btobex/SessionNotifier.java           |  128 +
 core/jni/Android.mk                                |   20 +
 core/jni/AndroidRuntime.cpp                        |   18 +
 .../android_bluetooth_BluetoothAudioGateway.cpp    |  562 ++
 .../android_bluetooth_BluetoothSocket.cpp          |  725 +++
 .../bluetoothmsm/android_bluetooth_HeadsetBase.cpp |  567 ++
 core/jni/bluetoothmsm/android_bluetooth_c.c        |   31 +
 core/jni/bluetoothmsm/android_bluetooth_c.h        |   39 +
 core/jni/bluetoothmsm/android_bluetooth_common.cpp | 1092 ++++
 core/jni/bluetoothmsm/android_bluetooth_common.h   |  263 +
 .../android_server_BluetoothA2dpService.cpp        |  671 +++
 .../android_server_BluetoothEventLoop.cpp          | 2532 +++++++++
 .../android_server_BluetoothService.cpp            | 3812 +++++++++++++
 core/res/res/values/config.xml                     |    4 +
 core/res/res/values/symbols.xml                    |    1 +
 data/etc/platform.xml                              |    3 +-
 media/java/android/media/MediaPlayer.java          |  173 +-
 media/jni/android_media_MediaPlayer.cpp            |    2 +-
 services/java/Android.mk                           |    6 +
 105 files changed, 45190 insertions(+), 22 deletions(-)
 create mode 100644 bluetoothmsm/java/android/bluetooth/AtCommandHandler.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/AtCommandResult.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/AtParser.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothA2dp.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothAdapter.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothAssignedNumbers.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothAudioGateway.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothClass.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothDUN.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothDevice.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothDevice.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothDevicePicker.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothDeviceProfileState.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothGatt.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothGattAppConfiguration.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothGattAppConfiguration.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothGattCallback.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothGattService.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothHeadset.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothHealth.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothHealthAppConfiguration.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothHealthAppConfiguration.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothHealthCallback.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothInputDevice.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothInputStream.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothOutputStream.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothPan.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothPbap.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothProfile.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothProfileState.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothSap.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothServerSocket.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothSocket.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothTetheringDataTracker.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/BluetoothUuid.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/HeadsetBase.java
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetooth.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothA2dp.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothCallback.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothGattCallback.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothGattProfile.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothGattService.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothHeadset.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothHeadsetPhone.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothHealthCallback.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothLEFindMeServices.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothLEProximityServices.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothManager.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothPbap.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothPreferredDeviceListCallback.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothStateChangeCallback.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothThermometerCallBack.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/IBluetoothThermometerServices.aidl
 create mode 100644 bluetoothmsm/java/android/bluetooth/package.html
 create mode 100755 bluetoothmsm/java/android/server/BluetoothA2dpService.java
 create mode 100644 bluetoothmsm/java/android/server/BluetoothAdapterProperties.java
 create mode 100644 bluetoothmsm/java/android/server/BluetoothAdapterStateMachine.java
 create mode 100644 bluetoothmsm/java/android/server/BluetoothBondState.java
 create mode 100644 bluetoothmsm/java/android/server/BluetoothDeviceProperties.java
 create mode 100644 bluetoothmsm/java/android/server/BluetoothEventLoop.java
 create mode 100644 bluetoothmsm/java/android/server/BluetoothGattProfileHandler.java
 create mode 100644 bluetoothmsm/java/android/server/BluetoothHealthProfileHandler.java
 create mode 100644 bluetoothmsm/java/android/server/BluetoothInputProfileHandler.java
 create mode 100644 bluetoothmsm/java/android/server/BluetoothManagerService.java
 create mode 100644 bluetoothmsm/java/android/server/BluetoothPanProfileHandler.java
 create mode 100644 bluetoothmsm/java/android/server/BluetoothService.java
 create mode 100644 bluetoothmsm/java/android/server/package.html
 create mode 100644 btobex/Android.mk
 create mode 100644 btobex/javax/btobex/ApplicationParameter.java
 create mode 100644 btobex/javax/btobex/Authenticator.java
 create mode 100644 btobex/javax/btobex/BaseStream.java
 create mode 100644 btobex/javax/btobex/ClientOperation.java
 create mode 100644 btobex/javax/btobex/ClientSession.java
 create mode 100644 btobex/javax/btobex/HeaderSet.java
 create mode 100644 btobex/javax/btobex/ObexHelper.java
 create mode 100644 btobex/javax/btobex/ObexSession.java
 create mode 100644 btobex/javax/btobex/ObexTransport.java
 create mode 100644 btobex/javax/btobex/Operation.java
 create mode 100644 btobex/javax/btobex/PasswordAuthentication.java
 create mode 100644 btobex/javax/btobex/PrivateInputStream.java
 create mode 100644 btobex/javax/btobex/PrivateOutputStream.java
 create mode 100644 btobex/javax/btobex/ResponseCodes.java
 create mode 100644 btobex/javax/btobex/ServerOperation.java
 create mode 100644 btobex/javax/btobex/ServerRequestHandler.java
 create mode 100644 btobex/javax/btobex/ServerSession.java
 create mode 100644 btobex/javax/btobex/SessionNotifier.java
 create mode 100644 core/jni/bluetoothmsm/android_bluetooth_BluetoothAudioGateway.cpp
 create mode 100644 core/jni/bluetoothmsm/android_bluetooth_BluetoothSocket.cpp
 create mode 100644 core/jni/bluetoothmsm/android_bluetooth_HeadsetBase.cpp
 create mode 100644 core/jni/bluetoothmsm/android_bluetooth_c.c
 create mode 100644 core/jni/bluetoothmsm/android_bluetooth_c.h
 create mode 100644 core/jni/bluetoothmsm/android_bluetooth_common.cpp
 create mode 100644 core/jni/bluetoothmsm/android_bluetooth_common.h
 create mode 100644 core/jni/bluetoothmsm/android_server_BluetoothA2dpService.cpp
 create mode 100644 core/jni/bluetoothmsm/android_server_BluetoothEventLoop.cpp
 create mode 100644 core/jni/bluetoothmsm/android_server_BluetoothService.cpp
 mode change 100644 => 100755 media/java/android/media/MediaPlayer.java

diff --git a/Android.mk b/Android.mk
index d1e7d90..37eeca8 100644
--- a/Android.mk
+++ b/Android.mk
@@ -26,6 +26,17 @@ LOCAL_PATH := $(call my-dir)
 # TODO: find a more appropriate way to do this.
 framework_res_source_path := APPS/framework-res_intermediates/src
 
+# Include the bluetoothmsm for bluez frameworks
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ), true)
+FRAMEWORKS_BASE_SUBDIRS += \
+	$(addsuffix /java, \
+	    bluetoothmsm \
+	)
+
+FRAMEWORKS_BASE_JAVA_SRC_DIRS += \
+	$(addprefix frameworks/base/, bluetoothmsm/java)
+endif
+
 include $(CLEAR_VARS)
 
 # FRAMEWORKS_BASE_SUBDIRS comes from build/core/pathmap.mk
@@ -44,6 +55,22 @@ LOCAL_SRC_FILES += \
 LOCAL_SRC_FILES := $(filter-out \
 			org/mobilecontrol/% \
 			,$(LOCAL_SRC_FILES))
+BLUETOOTH_SRC := \
+	core/java/android/bluetooth \
+
+BLUETOOTH_MSM_SRC := \
+	bluetoothmsm/java/android/bluetooth \
+	bluetoothmsm/java/android/server\
+
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ), true)
+    LOCAL_SRC_FILES := $(filter-out \
+			$(call find-other-java-files, $(BLUETOOTH_SRC)) \
+			,$(LOCAL_SRC_FILES))
+else
+    LOCAL_SRC_FILES := $(filter-out \
+			$(call find-other-java-files, $(BLUETOOTH_MSM_SRC)) \
+			,$(LOCAL_SRC_FILES))
+endif
 
 ## READ ME: ########################################################
 ##
@@ -86,19 +113,6 @@ LOCAL_SRC_FILES += \
 	core/java/android/app/backup/IFullBackupRestoreObserver.aidl \
 	core/java/android/app/backup/IRestoreObserver.aidl \
 	core/java/android/app/backup/IRestoreSession.aidl \
-	core/java/android/bluetooth/IBluetooth.aidl \
-	core/java/android/bluetooth/IBluetoothA2dp.aidl \
-	core/java/android/bluetooth/IBluetoothCallback.aidl \
-	core/java/android/bluetooth/IBluetoothHeadset.aidl \
-	core/java/android/bluetooth/IBluetoothHeadsetPhone.aidl \
-	core/java/android/bluetooth/IBluetoothHealth.aidl \
-	core/java/android/bluetooth/IBluetoothHealthCallback.aidl \
-	core/java/android/bluetooth/IBluetoothInputDevice.aidl \
-	core/java/android/bluetooth/IBluetoothPan.aidl \
-	core/java/android/bluetooth/IBluetoothManager.aidl \
-	core/java/android/bluetooth/IBluetoothManagerCallback.aidl \
-	core/java/android/bluetooth/IBluetoothPbap.aidl \
-	core/java/android/bluetooth/IBluetoothStateChangeCallback.aidl \
 	core/java/android/content/IClipboard.aidl \
 	core/java/android/content/IContentService.aidl \
 	core/java/android/content/IIntentReceiver.aidl \
@@ -242,6 +256,41 @@ LOCAL_SRC_FILES += \
 	fmradio/java/com/stericsson/hardware/fm/IOnAutomaticSwitchListener.aidl
 #
 
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ), true)
+LOCAL_SRC_FILES += \
+	bluetoothmsm/java/android/bluetooth/IBluetooth.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothA2dp.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothCallback.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothGattCallback.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothGattProfile.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothGattService.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothHeadset.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothHeadsetPhone.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothHealthCallback.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothLEFindMeServices.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothLEProximityServices.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothManager.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothPbap.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothPreferredDeviceListCallback.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothStateChangeCallback.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothThermometerCallBack.aidl \
+	bluetoothmsm/java/android/bluetooth/IBluetoothThermometerServices.aidl
+else
+LOCAL_SRC_FILES += \
+	core/java/android/bluetooth/IBluetooth.aidl \
+	core/java/android/bluetooth/IBluetoothA2dp.aidl \
+	core/java/android/bluetooth/IBluetoothCallback.aidl \
+	core/java/android/bluetooth/IBluetoothHeadset.aidl \
+	core/java/android/bluetooth/IBluetoothHeadsetPhone.aidl \
+	core/java/android/bluetooth/IBluetoothHealth.aidl \
+	core/java/android/bluetooth/IBluetoothHealthCallback.aidl \
+	core/java/android/bluetooth/IBluetoothInputDevice.aidl \
+	core/java/android/bluetooth/IBluetoothManager.aidl \
+	core/java/android/bluetooth/IBluetoothManagerCallback.aidl \
+	core/java/android/bluetooth/IBluetoothPan.aidl \
+	core/java/android/bluetooth/IBluetoothPbap.aidl \
+	core/java/android/bluetooth/IBluetoothStateChangeCallback.aidl
+endif
 
 # FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
 LOCAL_AIDL_INCLUDES += $(FRAMEWORKS_BASE_JAVA_SRC_DIRS)
@@ -289,8 +338,6 @@ aidl_files := \
 	frameworks/base/core/java/android/app/NotificationGroup.aidl \
 	frameworks/base/core/java/android/app/Profile.aidl \
 	frameworks/base/core/java/android/app/PendingIntent.aidl \
-	frameworks/base/core/java/android/bluetooth/BluetoothDevice.aidl \
-	frameworks/base/core/java/android/bluetooth/BluetoothHealthAppConfiguration.aidl \
 	frameworks/base/core/java/android/content/ComponentName.aidl \
 	frameworks/base/core/java/android/content/Intent.aidl \
 	frameworks/base/core/java/android/content/IntentSender.aidl \
@@ -335,6 +382,17 @@ aidl_files := \
 	frameworks/base/telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl \
 
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ), true)
+aidl_files += \
+	frameworks/base/bluetoothmsm/java/android/bluetooth/BluetoothDevice.aidl \
+	frameworks/base/bluetoothmsm/java/android/bluetooth/BluetoothGattAppConfiguration.aidl \
+	frameworks/base/bluetoothmsm/java/android/bluetooth/BluetoothHealthAppConfiguration.aidl
+else
+aidl_files += \
+	frameworks/base/core/java/android/bluetooth/BluetoothDevice.aidl \
+	frameworks/base/core/java/android/bluetooth/BluetoothHealthAppConfiguration.aidl
+endif
+
 gen := $(TARGET_OUT_COMMON_INTERMEDIATES)/framework.aidl
 $(gen): PRIVATE_SRC_FILES := $(aidl_files)
 ALL_SDK_FILES += $(gen)
@@ -572,6 +630,16 @@ framework_docs_LOCAL_DROIDDOC_OPTIONS += \
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=$(framework_docs_LOCAL_API_CHECK_SRC_FILES)
+
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ), true)
+    LOCAL_SRC_FILES := $(filter-out \
+			$(call find-other-java-files, $(BLUETOOTH_SRC)) \
+			,$(LOCAL_SRC_FILES))
+else
+    LOCAL_SRC_FILES := $(filter-out \
+			$(call find-other-java-files, $(BLUETOOTH_MSM_SRC)) \
+			,$(LOCAL_SRC_FILES))
+endif
 LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
 LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES) framework
 LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
@@ -603,6 +671,16 @@ $(call dist-for-goals,sdk,$(INTERNAL_PLATFORM_API_FILE))
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
+
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ), true)
+    LOCAL_SRC_FILES := $(filter-out \
+			$(call find-other-java-files, $(BLUETOOTH_SRC)) \
+			,$(LOCAL_SRC_FILES))
+else
+    LOCAL_SRC_FILES := $(filter-out \
+			$(call find-other-java-files, $(BLUETOOTH_MSM_SRC)) \
+			,$(LOCAL_SRC_FILES))
+endif
 LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
 LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
 LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
@@ -632,6 +710,16 @@ droidcore: doc-comment-check-docs
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
+
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ), true)
+    LOCAL_SRC_FILES := $(filter-out \
+			$(call find-other-java-files, $(BLUETOOTH_SRC)) \
+			,$(LOCAL_SRC_FILES))
+else
+    LOCAL_SRC_FILES := $(filter-out \
+			$(call find-other-java-files, $(BLUETOOTH_MSM_SRC)) \
+			,$(LOCAL_SRC_FILES))
+endif
 LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
 LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
 LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
@@ -670,6 +758,16 @@ $(full_target): $(framework_built)
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
+
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ), true)
+    LOCAL_SRC_FILES := $(filter-out \
+			$(call find-other-java-files, $(BLUETOOTH_SRC)) \
+			,$(LOCAL_SRC_FILES))
+else
+    LOCAL_SRC_FILES := $(filter-out \
+			$(call find-other-java-files, $(BLUETOOTH_MSM_SRC)) \
+			,$(LOCAL_SRC_FILES))
+endif
 LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
 LOCAL_STATIC_JAVA_LIBRARIES:=$(framework_docs_LOCAL_STATIC_JAVA_LIBRARIES)
 LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
@@ -730,6 +828,16 @@ $(full_target): framework-res-package-target
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
+
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ), true)
+    LOCAL_SRC_FILES := $(filter-out \
+			$(call find-other-java-files, $(BLUETOOTH_SRC)) \
+			,$(LOCAL_SRC_FILES))
+else
+    LOCAL_SRC_FILES := $(filter-out \
+			$(call find-other-java-files, $(BLUETOOTH_MSM_SRC)) \
+			,$(LOCAL_SRC_FILES))
+endif
 LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
 LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES) framework
 LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
diff --git a/bluetoothmsm/java/android/bluetooth/AtCommandHandler.java b/bluetoothmsm/java/android/bluetooth/AtCommandHandler.java
new file mode 100644
index 0000000..6deab34
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/AtCommandHandler.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.bluetooth.AtCommandResult;
+
+/**
+ * Handler Interface for {@link AtParser}.<p>
+ * @hide
+ */
+public abstract class AtCommandHandler {
+
+    /**
+     * Handle Basic commands "ATA".<p>
+     * These are single letter commands such as ATA and ATD. Anything following
+     * the single letter command ('A' and 'D' respectively) will be passed as
+     * 'arg'.<p>
+     * For example, "ATDT1234" would result in the call
+     * handleBasicCommand("T1234").<p>
+     * @param arg Everything following the basic command character.
+     * @return    The result of this command.
+     */
+    public AtCommandResult handleBasicCommand(String arg) {
+        return new AtCommandResult(AtCommandResult.ERROR);
+    }
+
+    /**
+     * Handle Actions command "AT+FOO".<p>
+     * Action commands are part of the Extended command syntax, and are
+     * typically used to signal an action on "FOO".<p>
+     * @return The result of this command.
+     */
+    public AtCommandResult handleActionCommand() {
+        return new AtCommandResult(AtCommandResult.ERROR);
+    }
+
+    /**
+     * Handle Read command "AT+FOO?".<p>
+     * Read commands are part of the Extended command syntax, and are
+     * typically used to read the value of "FOO".<p>
+     * @return The result of this command.
+     */
+    public AtCommandResult handleReadCommand() {
+        return new AtCommandResult(AtCommandResult.ERROR);
+    }
+
+    /**
+     * Handle Set command "AT+FOO=...".<p>
+     * Set commands are part of the Extended command syntax, and are
+     * typically used to set the value of "FOO". Multiple arguments can be
+     * sent.<p>
+     * AT+FOO=[<arg1>[,<arg2>[,...]]]<p>
+     * Each argument will be either numeric (Integer) or String.
+     * handleSetCommand is passed a generic Object[] array in which each
+     * element will be an Integer (if it can be parsed with parseInt()) or
+     * String.<p>
+     * Missing arguments ",," are set to empty Strings.<p>
+     * @param args Array of String and/or Integer's. There will always be at
+     *             least one element in this array.
+     * @return     The result of this command.
+     */
+    // Typically used to set this parameter
+    public AtCommandResult handleSetCommand(Object[] args) {
+        return new AtCommandResult(AtCommandResult.ERROR);
+    }
+
+    /**
+     * Handle Test command "AT+FOO=?".<p>
+     * Test commands are part of the Extended command syntax, and are typically
+     * used to request an indication of the range of legal values that "FOO"
+     * can take.<p>
+     * By default we return an OK result, to indicate that this command is at
+     * least recognized.<p>
+     * @return The result of this command.
+     */
+    public AtCommandResult handleTestCommand() {
+        return new AtCommandResult(AtCommandResult.OK);
+    }
+
+}
diff --git a/bluetoothmsm/java/android/bluetooth/AtCommandResult.java b/bluetoothmsm/java/android/bluetooth/AtCommandResult.java
new file mode 100644
index 0000000..9675234
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/AtCommandResult.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+/**
+ * The result of execution of a single AT command.<p>
+ *
+ *
+ * This class can represent the final response to an AT command line, and also
+ * intermediate responses to a single command within a chained AT command
+ * line.<p>
+ *
+ * The actual responses that are intended to be send in reply to the AT command
+ * line are stored in a string array. The final response is stored as an
+ * int enum, converted to a string when toString() is called. Only a single
+ * final response is sent from multiple commands chained into a single command
+ * line.<p>
+ * @hide
+ */
+public class AtCommandResult {
+    // Result code enumerations
+    public static final int OK = 0;
+    public static final int ERROR = 1;
+    public static final int UNSOLICITED = 2;
+
+    private static final String OK_STRING = "OK";
+    private static final String ERROR_STRING = "ERROR";
+
+    private int mResultCode;  // Result code
+    private StringBuilder mResponse; // Response with CRLF line breaks
+
+    /**
+     * Construct a new AtCommandResult with given result code, and an empty
+     * response array.
+     * @param resultCode One of OK, ERROR or UNSOLICITED.
+     */
+    public AtCommandResult(int resultCode) {
+        mResultCode = resultCode;
+        mResponse = new StringBuilder();
+    }
+
+    /**
+     * Construct a new AtCommandResult with result code OK, and the specified
+     * single line response.
+     * @param response The single line response.
+     */
+    public AtCommandResult(String response) {
+        this(OK);
+        addResponse(response);
+    }
+
+    public int getResultCode() {
+        return mResultCode;
+    }
+
+    /**
+     * Add another line to the response.
+     */
+    public void addResponse(String response) {
+        appendWithCrlf(mResponse, response);
+    }
+
+    /**
+     * Add the given result into this AtCommandResult object.<p>
+     * Used to combine results from multiple commands in a single command line
+     * (command chaining).
+     * @param result The AtCommandResult to add to this result.
+     */
+    public void addResult(AtCommandResult result) {
+        if (result != null) {
+            appendWithCrlf(mResponse, result.mResponse.toString());
+            mResultCode = result.mResultCode;
+        }
+    }
+
+    /**
+     * Generate the string response ready to send
+     */
+    public String toString() {
+        StringBuilder result = new StringBuilder(mResponse.toString());
+        switch (mResultCode) {
+        case OK:
+            appendWithCrlf(result, OK_STRING);
+            break;
+        case ERROR:
+            appendWithCrlf(result, ERROR_STRING);
+            break;
+        }
+        return result.toString();
+    }
+
+    /** Append a string to a string builder, joining with a double
+     * CRLF. Used to create multi-line AT command replies
+     */
+    public static void appendWithCrlf(StringBuilder str1, String str2) {
+        if (str1.length() > 0 && str2.length() > 0) {
+            str1.append("\r\n\r\n");
+        }
+        str1.append(str2);
+    }
+};
diff --git a/bluetoothmsm/java/android/bluetooth/AtParser.java b/bluetoothmsm/java/android/bluetooth/AtParser.java
new file mode 100644
index 0000000..c7d4259
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/AtParser.java
@@ -0,0 +1,378 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (C) 2013 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import java.util.*;
+
+/**
+ * An AT (Hayes command) Parser based on (a subset of) the ITU-T V.250 standard.
+ * <p>
+ *
+ * Conformant with the subset of V.250 required for implementation of the
+ * Bluetooth Headset and Handsfree Profiles, as per Bluetooth SIP
+ * specifications. Also implements some V.250 features not required by
+ * Bluetooth - such as chained commands.<p>
+ *
+ * Command handlers are registered with an AtParser object. These handlers are
+ * invoked when command lines are processed by AtParser's process() method.<p>
+ *
+ * The AtParser object accepts a new command line to parse via its process()
+ * method. It breaks each command line into one or more commands. Each command
+ * is parsed for name, type, and (optional) arguments, and an appropriate
+ * external handler method is called through the AtCommandHandler interface.
+ *
+ * The command types are<ul>
+ * <li>Basic Command. For example "ATDT1234567890". Basic command names are a
+ * single character (e.g. "D"), and everything following this character is
+ * passed to the handler as a string argument (e.g. "T1234567890").
+ * <li>Action Command. For example "AT+CIMI". The command name is "CIMI", and
+ * there are no arguments for action commands.
+ * <li>Read Command. For example "AT+VGM?". The command name is "VGM", and there
+ * are no arguments for get commands.
+ * <li>Set Command. For example "AT+VGM=14". The command name is "VGM", and
+ * there is a single integer argument in this case. In the general case then
+ * can be zero or more arguments (comma delimited) each of integer or string
+ * form.
+ * <li>Test Command. For example "AT+VGM=?. No arguments.
+ * </ul>
+ *
+ * In V.250 the last four command types are known as Extended Commands, and
+ * they are used heavily in Bluetooth.<p>
+ *
+ * Basic commands cannot be chained in this implementation. For Bluetooth
+ * headset/handsfree use this is acceptable, because they only use the basic
+ * commands ATA and ATD, which are not allowed to be chained. For general V.250
+ * use we would need to improve this class to allow Basic command chaining -
+ * however it's tricky to get right because there is no delimiter for Basic
+ * command chaining.<p>
+ *
+ * Extended commands can be chained. For example:<p>
+ * AT+VGM?;+VGM=14;+CIMI<p>
+ * This is equivalent to:<p>
+ * AT+VGM?
+ * AT+VGM=14
+ * AT+CIMI
+ * Except that only one final result code is return (although several
+ * intermediate responses may be returned), and as soon as one command in the
+ * chain fails the rest are abandoned.<p>
+ *
+ * Handlers are registered by there command name via register(Char c, ...) or
+ * register(String s, ...). Handlers for Basic command should be registered by
+ * the basic command character, and handlers for Extended commands should be
+ * registered by String.<p>
+ *
+ * Refer to:<ul>
+ * <li>ITU-T Recommendation V.250
+ * <li>ETSI TS 127.007  (AT Command set for User Equipment, 3GPP TS 27.007)
+ * <li>Bluetooth Headset Profile Spec (K6)
+ * <li>Bluetooth Handsfree Profile Spec (HFP 1.5)
+ * </ul>
+ * @hide
+ */
+public class AtParser {
+
+    // Extended command type enumeration, only used internally
+    private static final int TYPE_ACTION = 0;   // AT+FOO
+    private static final int TYPE_READ = 1;     // AT+FOO?
+    private static final int TYPE_SET = 2;      // AT+FOO=
+    private static final int TYPE_TEST = 3;     // AT+FOO=?
+    private HashMap<String, AtCommandHandler> mExtHandlers;
+    private HashMap<Character, AtCommandHandler> mBasicHandlers;
+
+    private String mLastInput;  // for "A/" (repeat last command) support
+
+    /**
+     * Create a new AtParser.<p>
+     * No handlers are registered.
+     */
+    public AtParser() {
+        mBasicHandlers = new HashMap<Character, AtCommandHandler>();
+        mExtHandlers = new HashMap<String, AtCommandHandler>();
+        mLastInput = "";
+    }
+
+    /**
+     * Register a Basic command handler.<p>
+     * Basic command handlers are later called via their
+     * <code>handleBasicCommand(String args)</code> method.
+     * @param  command Command name - a single character
+     * @param  handler Handler to register
+     */
+    public void register(Character command, AtCommandHandler handler) {
+        mBasicHandlers.put(command, handler);
+    }
+
+    /**
+     * Register an Extended command handler.<p>
+     * Extended command handlers are later called via:<ul>
+     * <li><code>handleActionCommand()</code>
+     * <li><code>handleGetCommand()</code>
+     * <li><code>handleSetCommand()</code>
+     * <li><code>handleTestCommand()</code>
+     * </ul>
+     * Only one method will be called for each command processed.
+     * @param  command Command name - can be multiple characters
+     * @param  handler Handler to register
+     */
+    public void register(String command, AtCommandHandler handler) {
+        mExtHandlers.put(command, handler);
+    }
+
+
+    /**
+     * Strip input of whitespace and force Uppercase - except sections inside
+     * quotes. Also fixes unmatched quotes (by appending a quote). Double
+     * quotes " are the only quotes allowed by V.250
+     */
+    static private String clean(String input) {
+        StringBuilder out = new StringBuilder(input.length());
+
+        for (int i = 0; i < input.length(); i++) {
+            char c = input.charAt(i);
+            if (c == '"') {
+                int j = input.indexOf('"', i + 1 );  // search for closing "
+                if (j == -1) {  // unmatched ", insert one.
+                    out.append(input.substring(i, input.length()));
+                    out.append('"');
+                    break;
+                }
+                out.append(input.substring(i, j + 1));
+                i = j;
+            } else if (c != ' ') {
+                out.append(Character.toUpperCase(c));
+            }
+        }
+
+        return out.toString();
+    }
+
+    static private boolean isAtoZ(char c) {
+        return (c >= 'A' && c <= 'Z');
+    }
+
+    /**
+     * Find a character ch, ignoring quoted sections.
+     * Return input.length() if not found.
+     */
+    static private int findChar(char ch, String input, int fromIndex) {
+        for (int i = fromIndex; i < input.length(); i++) {
+            char c = input.charAt(i);
+            if (c == '"') {
+                i = input.indexOf('"', i + 1);
+                if (i == -1) {
+                    return input.length();
+                }
+            } else if (c == ch) {
+                return i;
+            }
+        }
+        return input.length();
+    }
+
+    /**
+     * Break an argument string into individual arguments (comma delimited).
+     * Integer arguments are turned into Integer objects. Otherwise a String
+     * object is used.
+     */
+    static private Object[] generateArgs(String input) {
+        ArrayList<Object> out = new ArrayList<Object>();
+        String[] arguments = input.split(",");
+        for(int i = 0; i < arguments.length; i++){
+            if(arguments[i] == null){
+                out.add(new Integer(-1));
+            } else{
+                try {
+                    out.add(new Integer(arguments[i]));
+                } catch (NumberFormatException e) {
+                    if(arguments[i].length() == 0){
+                        out.add(new Integer(-1));
+                    } else {
+                        out.add(arguments[i]);
+                    }
+                }
+            }
+        }
+        return out.toArray();
+    }
+
+    /**
+     * Return the index of the end of character after the last character in
+     * the extended command name. Uses the V.250 spec for allowed command
+     * names.
+     */
+    static private int findEndExtendedName(String input, int index) {
+        for (int i = index; i < input.length(); i++) {
+            char c = input.charAt(i);
+
+            // V.250 defines the following chars as legal extended command
+            // names
+            if (isAtoZ(c)) continue;
+            if (c >= '0' && c <= '9') continue;
+            switch (c) {
+            case '!':
+            case '%':
+            case '-':
+            case '.':
+            case '/':
+            case ':':
+            case '_':
+                continue;
+            default:
+                return i;
+            }
+        }
+        return input.length();
+    }
+
+    /**
+     * Processes an incoming AT command line.<p>
+     * This method will invoke zero or one command handler methods for each
+     * command in the command line.<p>
+     * @param raw_input The AT input, without EOL delimiter (e.g. <CR>).
+     * @return          Result object for this command line. This can be
+     *                  converted to a String[] response with toStrings().
+     */
+    public AtCommandResult process(String raw_input) {
+        String input = clean(raw_input);
+
+        // Handle "A/" (repeat previous line)
+        if (input.regionMatches(0, "A/", 0, 2)) {
+            input = new String(mLastInput);
+        } else {
+            mLastInput = new String(input);
+        }
+
+        // Handle empty line - no response necessary
+        if (input.equals("")) {
+            // Return []
+            return new AtCommandResult(AtCommandResult.UNSOLICITED);
+        }
+
+        // Anything else deserves an error
+        if (!input.regionMatches(0, "AT", 0, 2)) {
+            // Return ["ERROR"]
+            return new AtCommandResult(AtCommandResult.ERROR);
+        }
+
+        // Ok we have a command that starts with AT. Process it
+        int index = 2;
+        AtCommandResult result =
+                new AtCommandResult(AtCommandResult.OK);
+        while (index < input.length()) {
+            char c = input.charAt(index);
+
+            if (isAtoZ(c)) {
+                // Option 1: Basic Command
+                // Pass the rest of the line as is to the handler. Do not
+                // look for any more commands on this line.
+                String args = input.substring(index + 1);
+                if (mBasicHandlers.containsKey((Character)c)) {
+                    result.addResult(mBasicHandlers.get(
+                            (Character)c).handleBasicCommand(args));
+                    return result;
+                } else {
+                    // no handler
+                    result.addResult(
+                            new AtCommandResult(AtCommandResult.ERROR));
+                    return result;
+                }
+                // control never reaches here
+            }
+
+            if (c == '+') {
+                // Option 2: Extended Command
+                // Search for first non-name character. Short-circuit if
+                // we don't handle this command name.
+                int i = findEndExtendedName(input, index + 1);
+                String commandName = input.substring(index, i);
+                if (!mExtHandlers.containsKey(commandName)) {
+                    // no handler
+                    result.addResult(
+                            new AtCommandResult(AtCommandResult.ERROR));
+                    return result;
+                }
+                AtCommandHandler handler = mExtHandlers.get(commandName);
+
+                // Search for end of this command - this is usually the end of
+                // line
+                int endIndex = findChar(';', input, index);
+
+                // Determine what type of command this is.
+                // Default to TYPE_ACTION if we can't find anything else
+                // obvious.
+                int type;
+
+                if (i >= endIndex) {
+                    type = TYPE_ACTION;
+                } else if (input.charAt(i) == '?') {
+                    type = TYPE_READ;
+                } else if (input.charAt(i) == '=') {
+                    if (i + 1 < endIndex) {
+                        if (input.charAt(i + 1) == '?') {
+                            type = TYPE_TEST;
+                        } else {
+                            type = TYPE_SET;
+                        }
+                    } else if ((i + 1) == endIndex) {
+                          //Invalid command as there is no string argument after "=". e.g. "AT+VTS="
+                          result.addResult(new AtCommandResult(AtCommandResult.ERROR));
+                          break;
+                    } else {
+                        type = TYPE_SET;
+                    }
+                } else {
+                    type = TYPE_ACTION;
+                }
+
+                // Call this command. Short-circuit as soon as a command fails
+                switch (type) {
+                case TYPE_ACTION:
+                    result.addResult(handler.handleActionCommand());
+                    break;
+                case TYPE_READ:
+                    result.addResult(handler.handleReadCommand());
+                    break;
+                case TYPE_TEST:
+                    result.addResult(handler.handleTestCommand());
+                    break;
+                case TYPE_SET:
+                    Object[] args =
+                            generateArgs(input.substring(i + 1, endIndex));
+                    if (args == null) {
+                        //Invalid command as there are no arguments after "=". e.g. "AT+VTS=,"
+                        result.addResult(new AtCommandResult(AtCommandResult.ERROR));
+                        break;
+                    }
+                    result.addResult(handler.handleSetCommand(args));
+                    break;
+                }
+                if (result.getResultCode() != AtCommandResult.OK) {
+                    return result;   // short-circuit
+                }
+
+                index = endIndex;
+            } else {
+                // Can't tell if this is a basic or extended command.
+                // Push forwards and hope we hit something.
+                index++;
+            }
+        }
+        // Finished processing (and all results were ok)
+        return result;
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothA2dp.java b/bluetoothmsm/java/android/bluetooth/BluetoothA2dp.java
new file mode 100644
index 0000000..c5f2553
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothA2dp.java
@@ -0,0 +1,492 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2013 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.content.Context;
+import android.os.IBinder;
+import android.os.ParcelUuid;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.server.BluetoothA2dpService;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * This class provides the public APIs to control the Bluetooth A2DP
+ * profile.
+ *
+ *<p>BluetoothA2dp is a proxy object for controlling the Bluetooth A2DP
+ * Service via IPC. Use {@link BluetoothAdapter#getProfileProxy} to get
+ * the BluetoothA2dp proxy object.
+ *
+ * <p> Android only supports one connected Bluetooth A2dp device at a time.
+ * Each method is protected with its appropriate permission.
+ */
+public final class BluetoothA2dp implements BluetoothProfile {
+    private static final String TAG = "BluetoothA2dp";
+    private static final boolean DBG = false;
+
+    /**
+     * Intent used to broadcast the change in connection state of the A2DP
+     * profile.
+     *
+     * <p>This intent will have 3 extras:
+     * <ul>
+     *   <li> {@link #EXTRA_STATE} - The current state of the profile. </li>
+     *   <li> {@link #EXTRA_PREVIOUS_STATE}- The previous state of the profile.</li>
+     *   <li> {@link BluetoothDevice#EXTRA_DEVICE} - The remote device. </li>
+     * </ul>
+     *
+     * <p>{@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} can be any of
+     * {@link #STATE_DISCONNECTED}, {@link #STATE_CONNECTING},
+     * {@link #STATE_CONNECTED}, {@link #STATE_DISCONNECTING}.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission to
+     * receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CONNECTION_STATE_CHANGED =
+        "android.bluetooth.a2dp.profile.action.CONNECTION_STATE_CHANGED";
+
+    /**
+     * Intent used to broadcast the change in the Playing state of the A2DP
+     * profile.
+     *
+     * <p>This intent will have 3 extras:
+     * <ul>
+     *   <li> {@link #EXTRA_STATE} - The current state of the profile. </li>
+     *   <li> {@link #EXTRA_PREVIOUS_STATE}- The previous state of the profile. </li>
+     *   <li> {@link BluetoothDevice#EXTRA_DEVICE} - The remote device. </li>
+     * </ul>
+     *
+     * <p>{@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} can be any of
+     * {@link #STATE_PLAYING}, {@link #STATE_NOT_PLAYING},
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission to
+     * receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PLAYING_STATE_CHANGED =
+        "android.bluetooth.a2dp.profile.action.PLAYING_STATE_CHANGED";
+
+    /**
+     * A2DP sink device is streaming music. This state can be one of
+     * {@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} of
+     * {@link #ACTION_PLAYING_STATE_CHANGED} intent.
+     */
+    public static final int STATE_PLAYING   =  10;
+
+    /**
+     * A2DP sink device is NOT streaming music. This state can be one of
+     * {@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} of
+     * {@link #ACTION_PLAYING_STATE_CHANGED} intent.
+     */
+    public static final int STATE_NOT_PLAYING   =  11;
+
+    private ServiceListener mServiceListener;
+    private IBluetoothA2dp mService;
+    private BluetoothAdapter mAdapter;
+
+    /**
+     * Create a BluetoothA2dp proxy object for interacting with the local
+     * Bluetooth A2DP service.
+     *
+     */
+    /*package*/ BluetoothA2dp(Context mContext, ServiceListener l) {
+        IBinder b = ServiceManager.getService(BluetoothA2dpService.BLUETOOTH_A2DP_SERVICE);
+        mServiceListener = l;
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+        if (b != null) {
+            mService = IBluetoothA2dp.Stub.asInterface(b);
+            if (mServiceListener != null) {
+                mServiceListener.onServiceConnected(BluetoothProfile.A2DP, this);
+            }
+        } else {
+            Log.w(TAG, "Bluetooth A2DP service not available!");
+
+            // Instead of throwing an exception which prevents people from going
+            // into Wireless settings in the emulator. Let it crash later when it is actually used.
+            mService = null;
+        }
+    }
+
+    /*package*/ void close() {
+        mServiceListener = null;
+    }
+
+    public void finalize() {
+        close();
+    }
+
+    /**
+     * Initiate connection to a profile of the remote bluetooth device.
+     *
+     * <p> Currently, the system supports only 1 connection to the
+     * A2DP profile. The API will automatically disconnect connected
+     * devices before connecting.
+     *
+     * <p> This API returns false in scenarios like the profile on the
+     * device is already connected or Bluetooth is not turned on.
+     * When this API returns true, it is guaranteed that
+     * connection state intent for the profile will be broadcasted with
+     * the state. Users can get the connection state of the profile
+     * from this intent.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Remote Bluetooth Device
+     * @return false on immediate error,
+     *               true otherwise
+     * @hide
+     */
+    public boolean connect(BluetoothDevice device) {
+        if (DBG) log("connect(" + device + ")");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.connect(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Initiate disconnection from a profile
+     *
+     * <p> This API will return false in scenarios like the profile on the
+     * Bluetooth device is not in connected state etc. When this API returns,
+     * true, it is guaranteed that the connection state change
+     * intent will be broadcasted with the state. Users can get the
+     * disconnection state of the profile from this intent.
+     *
+     * <p> If the disconnection is initiated by a remote device, the state
+     * will transition from {@link #STATE_CONNECTED} to
+     * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
+     * host (local) device the state will transition from
+     * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
+     * state {@link #STATE_DISCONNECTED}. The transition to
+     * {@link #STATE_DISCONNECTING} can be used to distinguish between the
+     * two scenarios.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Remote Bluetooth Device
+     * @return false on immediate error,
+     *               true otherwise
+     * @hide
+     */
+    public boolean disconnect(BluetoothDevice device) {
+        if (DBG) log("disconnect(" + device + ")");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.disconnect(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public List<BluetoothDevice> getConnectedDevices() {
+        if (DBG) log("getConnectedDevices()");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.getConnectedDevices();
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return new ArrayList<BluetoothDevice>();
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return new ArrayList<BluetoothDevice>();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+        if (DBG) log("getDevicesMatchingStates()");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.getDevicesMatchingConnectionStates(states);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return new ArrayList<BluetoothDevice>();
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return new ArrayList<BluetoothDevice>();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public int getConnectionState(BluetoothDevice device) {
+        if (DBG) log("getState(" + device + ")");
+        if (mService != null && isEnabled()
+            && isValidDevice(device)) {
+            try {
+                return mService.getConnectionState(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return BluetoothProfile.STATE_DISCONNECTED;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return BluetoothProfile.STATE_DISCONNECTED;
+    }
+
+    /**
+     * Set priority of the profile
+     *
+     * <p> The device should already be paired.
+     *  Priority can be one of {@link #PRIORITY_ON} or
+     * {@link #PRIORITY_OFF},
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Paired bluetooth device
+     * @param priority
+     * @return true if priority is set, false on error
+     * @hide
+     */
+    public boolean setPriority(BluetoothDevice device, int priority) {
+        if (DBG) log("setPriority(" + device + ", " + priority + ")");
+        if (mService != null && isEnabled()
+            && isValidDevice(device)) {
+            if (priority != BluetoothProfile.PRIORITY_OFF &&
+                priority != BluetoothProfile.PRIORITY_ON) {
+              return false;
+            }
+            try {
+                return mService.setPriority(device, priority);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Get the priority of the profile.
+     *
+     * <p> The priority can be any of:
+     * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
+     * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param device Bluetooth device
+     * @return priority of the device
+     * @hide
+     */
+    public int getPriority(BluetoothDevice device) {
+        if (DBG) log("getPriority(" + device + ")");
+        if (mService != null && isEnabled()
+            && isValidDevice(device)) {
+            try {
+                return mService.getPriority(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return BluetoothProfile.PRIORITY_OFF;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return BluetoothProfile.PRIORITY_OFF;
+    }
+
+    /**
+     * Check if A2DP profile is streaming music.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param device BluetoothDevice device
+     */
+    public boolean isA2dpPlaying(BluetoothDevice device) {
+        if (mService != null && isEnabled()
+            && isValidDevice(device)) {
+            try {
+                return mService.isA2dpPlaying(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Initiate suspend from an A2DP sink.
+     *
+     * <p> This API will return false in scenarios like the A2DP
+     * device is not in connected state etc. When this API returns,
+     * true, it is guaranteed that {@link #ACTION_CONNECTION_STATE_CHANGED}
+     * intent will be broadcasted with the state. Users can get the
+     * state of the A2DP device from this intent.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Remote A2DP sink
+     * @return false on immediate error,
+     *               true otherwise
+     * @hide
+     */
+    public boolean suspendSink(BluetoothDevice device) {
+        if (mService != null && isEnabled()
+            && isValidDevice(device)) {
+            try {
+                return mService.suspendSink(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Initiate resume from a suspended A2DP sink.
+     *
+     * <p> This API will return false in scenarios like the A2DP
+     * device is not in suspended state etc. When this API returns,
+     * true, it is guaranteed that {@link #ACTION_SINK_STATE_CHANGED}
+     * intent will be broadcasted with the state. Users can get the
+     * state of the A2DP device from this intent.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     *
+     * @param device Remote A2DP sink
+     * @return false on immediate error,
+     *               true otherwise
+     * @hide
+     */
+    public boolean resumeSink(BluetoothDevice device) {
+        if (mService != null && isEnabled()
+            && isValidDevice(device)) {
+            try {
+                return mService.resumeSink(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * This function checks if the remote device is an AVCRP
+     * target and thus whether we should send volume keys
+     * changes or not.
+     * @hide
+     */
+    public boolean shouldSendVolumeKeys(BluetoothDevice device) {
+        if (isEnabled() && isValidDevice(device)) {
+            ParcelUuid[] uuids = device.getUuids();
+            if (uuids == null) return false;
+
+            for (ParcelUuid uuid: uuids) {
+                if (BluetoothUuid.isAvrcpTarget(uuid)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Allow or disallow incoming connection
+     * @param device Sink
+     * @param value True / False
+     * @return Success or Failure of the binder call.
+     * @hide
+     */
+    public boolean allowIncomingConnect(BluetoothDevice device, boolean value) {
+        if (DBG) log("allowIncomingConnect(" + device + ":" + value + ")");
+        try {
+            return mService.allowIncomingConnect(device, value);
+        } catch (RemoteException e) {
+            Log.e(TAG, "", e);
+            return false;
+        }
+    }
+
+    /**
+     * Helper for converting a state to a string.
+     *
+     * For debug use only - strings are not internationalized.
+     * @hide
+     */
+    public static String stateToString(int state) {
+        switch (state) {
+        case STATE_DISCONNECTED:
+            return "disconnected";
+        case STATE_CONNECTING:
+            return "connecting";
+        case STATE_CONNECTED:
+            return "connected";
+        case STATE_DISCONNECTING:
+            return "disconnecting";
+        case STATE_PLAYING:
+            return "playing";
+        case STATE_NOT_PLAYING:
+          return "not playing";
+        default:
+            return "<unknown state " + state + ">";
+        }
+    }
+
+    private boolean isEnabled() {
+       if (mAdapter.getState() == BluetoothAdapter.STATE_ON) return true;
+       return false;
+    }
+
+    private boolean isValidDevice(BluetoothDevice device) {
+       if (device == null) return false;
+
+       if (BluetoothAdapter.checkBluetoothAddress(device.getAddress())) return true;
+       return false;
+    }
+
+    private static void log(String msg) {
+      Log.d(TAG, msg);
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothAdapter.java b/bluetoothmsm/java/android/bluetooth/BluetoothAdapter.java
new file mode 100644
index 0000000..eeef634
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothAdapter.java
@@ -0,0 +1,1663 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.content.Context;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.ParcelUuid;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+import android.util.Pair;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.Random;
+import java.util.Set;
+import java.util.UUID;
+
+/**
+ * Represents the local device Bluetooth adapter. The {@link BluetoothAdapter}
+ * lets you perform fundamental Bluetooth tasks, such as initiate
+ * device discovery, query a list of bonded (paired) devices,
+ * instantiate a {@link BluetoothDevice} using a known MAC address, and create
+ * a {@link BluetoothServerSocket} to listen for connection requests from other
+ * devices.
+ *
+ * <p>To get a {@link BluetoothAdapter} representing the local Bluetooth
+ * adapter, call the static {@link #getDefaultAdapter} method.
+ * Fundamentally, this is your starting point for all
+ * Bluetooth actions. Once you have the local adapter, you can get a set of
+ * {@link BluetoothDevice} objects representing all paired devices with
+ * {@link #getBondedDevices()}; start device discovery with
+ * {@link #startDiscovery()}; or create a {@link BluetoothServerSocket} to
+ * listen for incoming connection requests with
+ * {@link #listenUsingRfcommWithServiceRecord(String,UUID)}.
+ *
+ * <p class="note"><strong>Note:</strong>
+ * Most methods require the {@link android.Manifest.permission#BLUETOOTH}
+ * permission and some also require the
+ * {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For more information about using Bluetooth, read the
+ * <a href="{@docRoot}guide/topics/wireless/bluetooth.html">Bluetooth</a> developer guide.</p>
+ * </div>
+ *
+ * {@see BluetoothDevice}
+ * {@see BluetoothServerSocket}
+ */
+public final class BluetoothAdapter {
+    private static final String TAG = "BluetoothAdapter";
+    private static final boolean DBG = false;
+
+    /**
+     * Sentinel error value for this class. Guaranteed to not equal any other
+     * integer constant in this class. Provided as a convenience for functions
+     * that require a sentinel error value, for example:
+     * <p><code>Intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
+     * BluetoothAdapter.ERROR)</code>
+     */
+    public static final int ERROR = Integer.MIN_VALUE;
+
+    /**
+     * Broadcast Action: The state of the local Bluetooth adapter has been
+     * changed.
+     * <p>For example, Bluetooth has been turned on or off.
+     * <p>Always contains the extra fields {@link #EXTRA_STATE} and {@link
+     * #EXTRA_PREVIOUS_STATE} containing the new and old states
+     * respectively.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_STATE_CHANGED =
+            "android.bluetooth.adapter.action.STATE_CHANGED";
+
+    /**
+     * Used as an int extra field in {@link #ACTION_STATE_CHANGED}
+     * intents to request the current power state. Possible values are:
+     * {@link #STATE_OFF},
+     * {@link #STATE_TURNING_ON},
+     * {@link #STATE_ON},
+     * {@link #STATE_TURNING_OFF},
+     */
+    public static final String EXTRA_STATE =
+            "android.bluetooth.adapter.extra.STATE";
+    /**
+     * Used as an int extra field in {@link #ACTION_STATE_CHANGED}
+     * intents to request the previous power state. Possible values are:
+     * {@link #STATE_OFF},
+     * {@link #STATE_TURNING_ON},
+     * {@link #STATE_ON},
+     * {@link #STATE_TURNING_OFF},
+     */
+    public static final String EXTRA_PREVIOUS_STATE =
+            "android.bluetooth.adapter.extra.PREVIOUS_STATE";
+
+    /**
+     * Indicates the local Bluetooth adapter is off.
+     */
+    public static final int STATE_OFF = 10;
+    /**
+     * Indicates the local Bluetooth adapter is turning on. However local
+     * clients should wait for {@link #STATE_ON} before attempting to
+     * use the adapter.
+     */
+    public static final int STATE_TURNING_ON = 11;
+    /**
+     * Indicates the local Bluetooth adapter is on, and ready for use.
+     */
+    public static final int STATE_ON = 12;
+    /**
+     * Indicates the local Bluetooth adapter is turning off. Local clients
+     * should immediately attempt graceful disconnection of any remote links.
+     */
+    public static final int STATE_TURNING_OFF = 13;
+
+    /**
+     * Activity Action: Show a system activity that requests discoverable mode.
+     * This activity will also request the user to turn on Bluetooth if it
+     * is not currently enabled.
+     * <p>Discoverable mode is equivalent to {@link
+     * #SCAN_MODE_CONNECTABLE_DISCOVERABLE}. It allows remote devices to see
+     * this Bluetooth adapter when they perform a discovery.
+     * <p>For privacy, Android is not discoverable by default.
+     * <p>The sender of this Intent can optionally use extra field {@link
+     * #EXTRA_DISCOVERABLE_DURATION} to request the duration of
+     * discoverability. Currently the default duration is 120 seconds, and
+     * maximum duration is capped at 300 seconds for each request.
+     * <p>Notification of the result of this activity is posted using the
+     * {@link android.app.Activity#onActivityResult} callback. The
+     * <code>resultCode</code>
+     * will be the duration (in seconds) of discoverability or
+     * {@link android.app.Activity#RESULT_CANCELED} if the user rejected
+     * discoverability or an error has occurred.
+     * <p>Applications can also listen for {@link #ACTION_SCAN_MODE_CHANGED}
+     * for global notification whenever the scan mode changes. For example, an
+     * application can be notified when the device has ended discoverability.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_REQUEST_DISCOVERABLE =
+            "android.bluetooth.adapter.action.REQUEST_DISCOVERABLE";
+
+    /**
+     * Used as an optional int extra field in {@link
+     * #ACTION_REQUEST_DISCOVERABLE} intents to request a specific duration
+     * for discoverability in seconds. The current default is 120 seconds, and
+     * requests over 300 seconds will be capped. These values could change.
+     */
+    public static final String EXTRA_DISCOVERABLE_DURATION =
+            "android.bluetooth.adapter.extra.DISCOVERABLE_DURATION";
+
+    /**
+     * Activity Action: Show a system activity that allows the user to turn on
+     * Bluetooth.
+     * <p>This system activity will return once Bluetooth has completed turning
+     * on, or the user has decided not to turn Bluetooth on.
+     * <p>Notification of the result of this activity is posted using the
+     * {@link android.app.Activity#onActivityResult} callback. The
+     * <code>resultCode</code>
+     * will be {@link android.app.Activity#RESULT_OK} if Bluetooth has been
+     * turned on or {@link android.app.Activity#RESULT_CANCELED} if the user
+     * has rejected the request or an error has occurred.
+     * <p>Applications can also listen for {@link #ACTION_STATE_CHANGED}
+     * for global notification whenever Bluetooth is turned on or off.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_REQUEST_ENABLE =
+            "android.bluetooth.adapter.action.REQUEST_ENABLE";
+
+    /**
+     * Broadcast Action: Indicates the Bluetooth scan mode of the local Adapter
+     * has changed.
+     * <p>Always contains the extra fields {@link #EXTRA_SCAN_MODE} and {@link
+     * #EXTRA_PREVIOUS_SCAN_MODE} containing the new and old scan modes
+     * respectively.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_SCAN_MODE_CHANGED =
+            "android.bluetooth.adapter.action.SCAN_MODE_CHANGED";
+
+    /**
+     * Used as an int extra field in {@link #ACTION_SCAN_MODE_CHANGED}
+     * intents to request the current scan mode. Possible values are:
+     * {@link #SCAN_MODE_NONE},
+     * {@link #SCAN_MODE_CONNECTABLE},
+     * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE},
+     */
+    public static final String EXTRA_SCAN_MODE = "android.bluetooth.adapter.extra.SCAN_MODE";
+    /**
+     * Used as an int extra field in {@link #ACTION_SCAN_MODE_CHANGED}
+     * intents to request the previous scan mode. Possible values are:
+     * {@link #SCAN_MODE_NONE},
+     * {@link #SCAN_MODE_CONNECTABLE},
+     * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE},
+     */
+    public static final String EXTRA_PREVIOUS_SCAN_MODE =
+            "android.bluetooth.adapter.extra.PREVIOUS_SCAN_MODE";
+
+    /**
+     * Indicates that both inquiry scan and page scan are disabled on the local
+     * Bluetooth adapter. Therefore this device is neither discoverable
+     * nor connectable from remote Bluetooth devices.
+     */
+    public static final int SCAN_MODE_NONE = 20;
+    /**
+     * Indicates that inquiry scan is disabled, but page scan is enabled on the
+     * local Bluetooth adapter. Therefore this device is not discoverable from
+     * remote Bluetooth devices, but is connectable from remote devices that
+     * have previously discovered this device.
+     */
+    public static final int SCAN_MODE_CONNECTABLE = 21;
+    /**
+     * Indicates that both inquiry scan and page scan are enabled on the local
+     * Bluetooth adapter. Therefore this device is both discoverable and
+     * connectable from remote Bluetooth devices.
+     */
+    public static final int SCAN_MODE_CONNECTABLE_DISCOVERABLE = 23;
+
+
+    /**
+     * Broadcast Action: The local Bluetooth adapter has started the remote
+     * device discovery process.
+     * <p>This usually involves an inquiry scan of about 12 seconds, followed
+     * by a page scan of each new device to retrieve its Bluetooth name.
+     * <p>Register for {@link BluetoothDevice#ACTION_FOUND} to be notified as
+     * remote Bluetooth devices are found.
+     * <p>Device discovery is a heavyweight procedure. New connections to
+     * remote Bluetooth devices should not be attempted while discovery is in
+     * progress, and existing connections will experience limited bandwidth
+     * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
+     * discovery.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DISCOVERY_STARTED =
+            "android.bluetooth.adapter.action.DISCOVERY_STARTED";
+    /**
+     * Broadcast Action: The local Bluetooth adapter has finished the device
+     * discovery process.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DISCOVERY_FINISHED =
+            "android.bluetooth.adapter.action.DISCOVERY_FINISHED";
+
+    /**
+     * Broadcast Action: The local Bluetooth adapter has changed its friendly
+     * Bluetooth name.
+     * <p>This name is visible to remote Bluetooth devices.
+     * <p>Always contains the extra field {@link #EXTRA_LOCAL_NAME} containing
+     * the name.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_LOCAL_NAME_CHANGED =
+            "android.bluetooth.adapter.action.LOCAL_NAME_CHANGED";
+    /**
+     * Used as a String extra field in {@link #ACTION_LOCAL_NAME_CHANGED}
+     * intents to request the local Bluetooth name.
+     */
+    public static final String EXTRA_LOCAL_NAME = "android.bluetooth.adapter.extra.LOCAL_NAME";
+
+    /**
+     * Intent used to broadcast the change in connection state of the local
+     * Bluetooth adapter to a profile of the remote device. When the adapter is
+     * not connected to any profiles of any remote devices and it attempts a
+     * connection to a profile this intent will sent. Once connected, this intent
+     * will not be sent for any more connection attempts to any profiles of any
+     * remote device. When the adapter disconnects from the last profile its
+     * connected to of any remote device, this intent will be sent.
+     *
+     * <p> This intent is useful for applications that are only concerned about
+     * whether the local adapter is connected to any profile of any device and
+     * are not really concerned about which profile. For example, an application
+     * which displays an icon to display whether Bluetooth is connected or not
+     * can use this intent.
+     *
+     * <p>This intent will have 3 extras:
+     * {@link #EXTRA_CONNECTION_STATE} - The current connection state.
+     * {@link #EXTRA_PREVIOUS_CONNECTION_STATE}- The previous connection state.
+     * {@link BluetoothDevice#EXTRA_DEVICE} - The remote device.
+     *
+     * {@link #EXTRA_CONNECTION_STATE} or {@link #EXTRA_PREVIOUS_CONNECTION_STATE}
+     * can be any of {@link #STATE_DISCONNECTED}, {@link #STATE_CONNECTING},
+     * {@link #STATE_CONNECTED}, {@link #STATE_DISCONNECTING}.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CONNECTION_STATE_CHANGED =
+        "android.bluetooth.adapter.action.CONNECTION_STATE_CHANGED";
+
+    /**
+     * Extra used by {@link #ACTION_CONNECTION_STATE_CHANGED}
+     *
+     * This extra represents the current connection state.
+     */
+    public static final String EXTRA_CONNECTION_STATE =
+        "android.bluetooth.adapter.extra.CONNECTION_STATE";
+
+    /**
+     * Extra used by {@link #ACTION_CONNECTION_STATE_CHANGED}
+     *
+     * This extra represents the previous connection state.
+     */
+    public static final String EXTRA_PREVIOUS_CONNECTION_STATE =
+          "android.bluetooth.adapter.extra.PREVIOUS_CONNECTION_STATE";
+
+    /** The profile is in disconnected state */
+    public static final int STATE_DISCONNECTED  = 0;
+    /** The profile is in connecting state */
+    public static final int STATE_CONNECTING    = 1;
+    /** The profile is in connected state */
+    public static final int STATE_CONNECTED     = 2;
+    /** The profile is in disconnecting state */
+    public static final int STATE_DISCONNECTING = 3;
+
+    /** @hide */
+    public static final String BLUETOOTH_SERVICE = "bluetooth";
+
+    /**
+     * Dummy BLUETOOTH_MANAGER_SERVICE for JB MR1
+     * @hide
+     */
+    public static final String BLUETOOTH_MANAGER_SERVICE = "bluetooth_manager";
+
+    private static final int ADDRESS_LENGTH = 17;
+
+    /** @hide */ public static final int HOST_PATCH_DONT_REMOVE_SERVICE = 1;
+    /** @hide */ public static final int HOST_PATCH_AVOID_CONNECT_ON_PAIR = 2;
+    /** @hide */ public static final int HOST_PATCH_AVOID_AUTO_CONNECT = 3;
+    /** @hide */ public static final int HOST_PATCH_ENABLE_PHOTO_ON_PBAP = 4;
+
+    /**
+     * Lazily initialized singleton. Guaranteed final after first object
+     * constructed.
+     */
+    private static BluetoothAdapter sAdapter;
+
+    private final IBluetooth mService;
+
+    private Handler mServiceRecordHandler;
+
+    /** @hide */
+    public boolean isHostPatchRequired (BluetoothDevice btDevice, int patch_id) {
+        try {
+            return mService.isHostPatchRequired (btDevice, patch_id);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Get a handle to the default local Bluetooth adapter.
+     * <p>Currently Android only supports one Bluetooth adapter, but the API
+     * could be extended to support more. This will always return the default
+     * adapter.
+     * @return the default local adapter, or null if Bluetooth is not supported
+     *         on this hardware platform
+     */
+    public static synchronized BluetoothAdapter getDefaultAdapter() {
+        if (sAdapter == null) {
+            IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
+            if (b != null) {
+                IBluetooth service = IBluetooth.Stub.asInterface(b);
+                sAdapter = new BluetoothAdapter(service);
+            }
+        }
+        return sAdapter;
+    }
+
+    /**
+     * Use {@link #getDefaultAdapter} to get the BluetoothAdapter instance.
+     * @hide
+     */
+    public BluetoothAdapter(IBluetooth service) {
+        if (service == null) {
+            throw new IllegalArgumentException("service is null");
+        }
+        mService = service;
+        mServiceRecordHandler = null;
+    }
+
+    /**
+     * Get a {@link BluetoothDevice} object for the given Bluetooth hardware
+     * address.
+     * <p>Valid Bluetooth hardware addresses must be upper case, in a format
+     * such as "00:11:22:33:AA:BB". The helper {@link #checkBluetoothAddress} is
+     * available to validate a Bluetooth address.
+     * <p>A {@link BluetoothDevice} will always be returned for a valid
+     * hardware address, even if this adapter has never seen that device.
+     *
+     * @param address valid Bluetooth MAC address
+     * @throws IllegalArgumentException if address is invalid
+     */
+    public BluetoothDevice getRemoteDevice(String address) {
+        return new BluetoothDevice(address);
+    }
+
+    /**
+     * Get a {@link BluetoothDevice} object for the given Bluetooth hardware
+     * address.
+     * <p>Valid Bluetooth hardware addresses must be 6 bytes. This method
+     * expects the address in network byte order (MSB first).
+     * <p>A {@link BluetoothDevice} will always be returned for a valid
+     * hardware address, even if this adapter has never seen that device.
+     *
+     * @param address Bluetooth MAC address (6 bytes)
+     * @throws IllegalArgumentException if address is invalid
+     */
+    public BluetoothDevice getRemoteDevice(byte[] address) {
+        if (address == null || address.length != 6) {
+            throw new IllegalArgumentException("Bluetooth address must have 6 bytes");
+        }
+        return new BluetoothDevice(String.format("%02X:%02X:%02X:%02X:%02X:%02X",
+                address[0], address[1], address[2], address[3], address[4], address[5]));
+    }
+
+    /**
+     * Return true if Bluetooth is currently enabled and ready for use.
+     * <p>Equivalent to:
+     * <code>getBluetoothState() == STATE_ON</code>
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @return true if the local adapter is turned on
+     */
+    public boolean isEnabled() {
+        try {
+            return mService.isEnabled();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Query the registration state of a service
+     * @return true if the service is registered
+     * @hide
+     */
+    public boolean isServiceRegistered(ParcelUuid uuid) {
+       try {
+           return mService.isServiceRegistered(uuid);
+       } catch (RemoteException e) {Log.e(TAG, "", e);}
+       return false;
+    }
+
+    /**
+     * Register/deregister a service
+     * @param uuid uuid of the service to be registered
+     * @param enable true/false to register/deregister a service
+     * @return true if register/deregister is succeeded
+     * @hide
+     */
+    public boolean registerService(ParcelUuid uuid , boolean enable) {
+      try {
+          return mService.registerService(uuid, enable);
+      } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Get the current state of the local Bluetooth adapter.
+     * <p>Possible return values are
+     * {@link #STATE_OFF},
+     * {@link #STATE_TURNING_ON},
+     * {@link #STATE_ON},
+     * {@link #STATE_TURNING_OFF}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @return current state of Bluetooth adapter
+     */
+    public int getState() {
+        if (mService == null) return STATE_OFF;
+        try {
+            return mService.getBluetoothState();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return STATE_OFF;
+    }
+
+    /**
+     * Turn on the local Bluetooth adapter&mdash;do not use without explicit
+     * user action to turn on Bluetooth.
+     * <p>This powers on the underlying Bluetooth hardware, and starts all
+     * Bluetooth system services.
+     * <p class="caution"><strong>Bluetooth should never be enabled without
+     * direct user consent</strong>. If you want to turn on Bluetooth in order
+     * to create a wireless connection, you should use the {@link
+     * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
+     * user permission to turn on Bluetooth. The {@link #enable()} method is
+     * provided only for applications that include a user interface for changing
+     * system settings, such as a "power manager" app.</p>
+     * <p>This is an asynchronous call: it will return immediately, and
+     * clients should listen for {@link #ACTION_STATE_CHANGED}
+     * to be notified of subsequent adapter state changes. If this call returns
+     * true, then the adapter state will immediately transition from {@link
+     * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
+     * later transition to either {@link #STATE_OFF} or {@link
+     * #STATE_ON}. If this call returns false then there was an
+     * immediate problem that will prevent the adapter from being turned on -
+     * such as Airplane mode, or the adapter is already turned on.
+     * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission
+     *
+     * @return true to indicate adapter startup has begun, or false on
+     *         immediate error
+     */
+    public boolean enable() {
+        try {
+            return mService.enable();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Turn off the local Bluetooth adapter&mdash;do not use without explicit
+     * user action to turn off Bluetooth.
+     * <p>This gracefully shuts down all Bluetooth connections, stops Bluetooth
+     * system services, and powers down the underlying Bluetooth hardware.
+     * <p class="caution"><strong>Bluetooth should never be disabled without
+     * direct user consent</strong>. The {@link #disable()} method is
+     * provided only for applications that include a user interface for changing
+     * system settings, such as a "power manager" app.</p>
+     * <p>This is an asynchronous call: it will return immediately, and
+     * clients should listen for {@link #ACTION_STATE_CHANGED}
+     * to be notified of subsequent adapter state changes. If this call returns
+     * true, then the adapter state will immediately transition from {@link
+     * #STATE_ON} to {@link #STATE_TURNING_OFF}, and some time
+     * later transition to either {@link #STATE_OFF} or {@link
+     * #STATE_ON}. If this call returns false then there was an
+     * immediate problem that will prevent the adapter from being turned off -
+     * such as the adapter already being turned off.
+     * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission
+     *
+     * @return true to indicate adapter shutdown has begun, or false on
+     *         immediate error
+     */
+    public boolean disable() {
+        try {
+            return mService.disable(true);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Returns the hardware address of the local Bluetooth adapter.
+     * <p>For example, "00:11:22:AA:BB:CC".
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @return Bluetooth hardware address as string
+     */
+    public String getAddress() {
+        try {
+            return mService.getAddress();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return null;
+    }
+
+    /**
+     * Get the friendly Bluetooth name of the local Bluetooth adapter.
+     * <p>This name is visible to remote Bluetooth devices.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @return the Bluetooth name, or null on error
+     */
+    public String getName() {
+        try {
+            return mService.getName();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return null;
+    }
+
+    /**
+     * Get the UUIDs supported by the local Bluetooth adapter.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @return the UUIDs supported by the local Bluetooth Adapter.
+     * @hide
+     */
+    public ParcelUuid[] getUuids() {
+        if (getState() != STATE_ON) return null;
+        try {
+            return mService.getUuids();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return null;
+    }
+
+    /**
+     * Get the Class of Device (COD) of the local Bluetooth adapter.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @return the Bluetooth COD, or null on error
+     * @hide
+     */
+    public String getCOD() {
+        try {
+            return mService.getCOD();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return null;
+    }
+
+    /**
+     * Set the friendly Bluetooth name of the local Bluetooth adapter.
+     * <p>This name is visible to remote Bluetooth devices.
+     * <p>Valid Bluetooth names are a maximum of 248 bytes using UTF-8
+     * encoding, although many remote devices can only display the first
+     * 40 characters, and some may be limited to just 20.
+     * <p>If Bluetooth state is not {@link #STATE_ON}, this API
+     * will return false. After turning on Bluetooth,
+     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
+     * to get the updated value.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     *
+     * @param name a valid Bluetooth name
+     * @return     true if the name was set, false otherwise
+     */
+    public boolean setName(String name) {
+        if (getState() != STATE_ON) return false;
+        try {
+            return mService.setName(name);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+  /**
+     * Set whether WiFi can be used for Bluetooth transfers
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     * @param enable Set true allows WiFi (system default)
+     *
+     * @hide
+     */
+    public void setUseWifi(boolean enable) {
+        try {
+            mService.setUseWifiForBtTransfers(enable);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+    }
+
+    /**
+     * Get the current Bluetooth scan mode of the local Bluetooth adaper.
+     * <p>The Bluetooth scan mode determines if the local adapter is
+     * connectable and/or discoverable from remote Bluetooth devices.
+     * <p>Possible values are:
+     * {@link #SCAN_MODE_NONE},
+     * {@link #SCAN_MODE_CONNECTABLE},
+     * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
+     * <p>If Bluetooth state is not {@link #STATE_ON}, this API
+     * will return {@link #SCAN_MODE_NONE}. After turning on Bluetooth,
+     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
+     * to get the updated value.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @return scan mode
+     */
+    public int getScanMode() {
+        if (getState() != STATE_ON) return SCAN_MODE_NONE;
+        try {
+            return mService.getScanMode();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return SCAN_MODE_NONE;
+    }
+
+    /**
+     * Set the Bluetooth scan mode of the local Bluetooth adapter.
+     * <p>The Bluetooth scan mode determines if the local adapter is
+     * connectable and/or discoverable from remote Bluetooth devices.
+     * <p>For privacy reasons, discoverable mode is automatically turned off
+     * after <code>duration</code> seconds. For example, 120 seconds should be
+     * enough for a remote device to initiate and complete its discovery
+     * process.
+     * <p>Valid scan mode values are:
+     * {@link #SCAN_MODE_NONE},
+     * {@link #SCAN_MODE_CONNECTABLE},
+     * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
+     * <p>If Bluetooth state is not {@link #STATE_ON}, this API
+     * will return false. After turning on Bluetooth,
+     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
+     * to get the updated value.
+     * <p>Requires {@link android.Manifest.permission#WRITE_SECURE_SETTINGS}
+     * <p>Applications cannot set the scan mode. They should use
+     * <code>startActivityForResult(
+     * BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE})
+     * </code>instead.
+     *
+     * @param mode valid scan mode
+     * @param duration time in seconds to apply scan mode, only used for
+     *                 {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}
+     * @return     true if the scan mode was set, false otherwise
+     * @hide
+     */
+    public boolean setScanMode(int mode, int duration) {
+        if (getState() != STATE_ON) return false;
+        try {
+            return mService.setScanMode(mode, duration);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /** @hide */
+    public boolean setScanMode(int mode) {
+        if (getState() != STATE_ON) return false;
+        return setScanMode(mode, 120);
+    }
+
+    /** @hide */
+    public int getDiscoverableTimeout() {
+        if (getState() != STATE_ON) return -1;
+        try {
+            return mService.getDiscoverableTimeout();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return -1;
+    }
+
+    /** @hide */
+    public void setDiscoverableTimeout(int timeout) {
+        if (getState() != STATE_ON) return;
+        try {
+            mService.setDiscoverableTimeout(timeout);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+    }
+
+    /**
+     * Start the remote device discovery process.
+     * <p>The discovery process usually involves an inquiry scan of about 12
+     * seconds, followed by a page scan of each new device to retrieve its
+     * Bluetooth name.
+     * <p>This is an asynchronous call, it will return immediately. Register
+     * for {@link #ACTION_DISCOVERY_STARTED} and {@link
+     * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
+     * discovery starts and completes. Register for {@link
+     * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
+     * are found.
+     * <p>Device discovery is a heavyweight procedure. New connections to
+     * remote Bluetooth devices should not be attempted while discovery is in
+     * progress, and existing connections will experience limited bandwidth
+     * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
+     * discovery. Discovery is not managed by the Activity,
+     * but is run as a system service, so an application should always call
+     * {@link BluetoothAdapter#cancelDiscovery()} even if it
+     * did not directly request a discovery, just to be sure.
+     * <p>Device discovery will only find remote devices that are currently
+     * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
+     * not discoverable by default, and need to be entered into a special mode.
+     * <p>If Bluetooth state is not {@link #STATE_ON}, this API
+     * will return false. After turning on Bluetooth,
+     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
+     * to get the updated value.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
+     *
+     * @return true on success, false on error
+     */
+    public boolean startDiscovery() {
+        if (getState() != STATE_ON) return false;
+        try {
+            return mService.startDiscovery();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Cancel the current device discovery process.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
+     * <p>Because discovery is a heavyweight procedure for the Bluetooth
+     * adapter, this method should always be called before attempting to connect
+     * to a remote device with {@link
+     * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
+     * the  Activity, but is run as a system service, so an application should
+     * always call cancel discovery even if it did not directly request a
+     * discovery, just to be sure.
+     * <p>If Bluetooth state is not {@link #STATE_ON}, this API
+     * will return false. After turning on Bluetooth,
+     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
+     * to get the updated value.
+     *
+     * @return true on success, false on error
+     */
+    public boolean cancelDiscovery() {
+        if (getState() != STATE_ON) return false;
+        try {
+            return mService.cancelDiscovery();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Return true if the local Bluetooth adapter is currently in the device
+     * discovery process.
+     * <p>Device discovery is a heavyweight procedure. New connections to
+     * remote Bluetooth devices should not be attempted while discovery is in
+     * progress, and existing connections will experience limited bandwidth
+     * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
+     * discovery.
+     * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}
+     * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery
+     * starts or completes.
+     * <p>If Bluetooth state is not {@link #STATE_ON}, this API
+     * will return false. After turning on Bluetooth,
+     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
+     * to get the updated value.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+     *
+     * @return true if discovering
+     */
+    public boolean isDiscovering() {
+        if (getState() != STATE_ON) return false;
+        try {
+            return mService.isDiscovering();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Return the set of {@link BluetoothDevice} objects that are bonded
+     * (paired) to the local adapter.
+     * <p>If Bluetooth state is not {@link #STATE_ON}, this API
+     * will return an empty set. After turning on Bluetooth,
+     * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
+     * to get the updated value.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+     *
+     * @return unmodifiable set of {@link BluetoothDevice}, or null on error
+     */
+    public Set<BluetoothDevice> getBondedDevices() {
+        if (getState() != STATE_ON) {
+            return toDeviceSet(new String[0]);
+        }
+        try {
+            return toDeviceSet(mService.listBonds());
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return null;
+    }
+
+    /**
+     * Get the current connection state of the local Bluetooth adapter.
+     * This can be used to check whether the local Bluetooth adapter is connected
+     * to any profile of any other remote Bluetooth Device.
+     *
+     * <p> Use this function along with {@link #ACTION_CONNECTION_STATE_CHANGED}
+     * intent to get the connection state of the adapter.
+     *
+     * @return One of {@link #STATE_CONNECTED}, {@link #STATE_DISCONNECTED},
+     * {@link #STATE_CONNECTING} or {@link #STATE_DISCONNECTED}
+     *
+     * @hide
+     */
+    public int getConnectionState() {
+        if (getState() != STATE_ON) return BluetoothAdapter.STATE_DISCONNECTED;
+        try {
+            return mService.getAdapterConnectionState();
+        } catch (RemoteException e) {Log.e(TAG, "getConnectionState:", e);}
+        return BluetoothAdapter.STATE_DISCONNECTED;
+    }
+
+    /**
+     * Get the current connection state of a profile.
+     * This function can be used to check whether the local Bluetooth adapter
+     * is connected to any remote device for a specific profile.
+     * Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
+     * {@link BluetoothProfile#A2DP}.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+     *
+     * <p> Return value can be one of
+     * {@link BluetoothProfile#STATE_DISCONNECTED},
+     * {@link BluetoothProfile#STATE_CONNECTING},
+     * {@link BluetoothProfile#STATE_CONNECTED},
+     * {@link BluetoothProfile#STATE_DISCONNECTING}
+     */
+    public int getProfileConnectionState(int profile) {
+        if (getState() != STATE_ON) return BluetoothProfile.STATE_DISCONNECTED;
+        try {
+            return mService.getProfileConnectionState(profile);
+        } catch (RemoteException e) {
+            Log.e(TAG, "getProfileConnectionState:", e);
+        }
+        return BluetoothProfile.STATE_DISCONNECTED;
+    }
+
+    /**
+    /**
+     * Picks RFCOMM channels until none are left.
+     * Avoids reserved channels.
+     */
+    private static class RfcommChannelPicker {
+        private static final int[] RESERVED_RFCOMM_CHANNELS =  new int[] {
+            1,   // DUN
+            10,  // HFAG
+            11,  // HSAG
+            12,  // OPUSH
+            15,  // SAP
+            16,  // MAS0
+            17,  // MAS1
+            19,  // PBAP
+            20,  // FTP
+        };
+        private static LinkedList<Integer> sChannels;  // master list of non-reserved channels
+        private static Random sRandom;
+
+        private final LinkedList<Integer> mChannels;  // local list of channels left to try
+
+        private final UUID mUuid;
+
+        public RfcommChannelPicker(UUID uuid) {
+            synchronized (RfcommChannelPicker.class) {
+                if (sChannels == null) {
+                    // lazy initialization of non-reserved rfcomm channels
+                    sChannels = new LinkedList<Integer>();
+                    for (int i = 1; i <= BluetoothSocket.MAX_RFCOMM_CHANNEL; i++) {
+                        sChannels.addLast(new Integer(i));
+                    }
+                    for (int reserved : RESERVED_RFCOMM_CHANNELS) {
+                        sChannels.remove(new Integer(reserved));
+                    }
+                    sRandom = new Random();
+                }
+                mChannels = (LinkedList<Integer>)sChannels.clone();
+            }
+            mUuid = uuid;
+        }
+        /* Returns next random channel, or -1 if we're out */
+        public int nextChannel() {
+            if (mChannels.size() == 0) {
+                return -1;
+            }
+            return mChannels.remove(sRandom.nextInt(mChannels.size()));
+        }
+    }
+
+    /**
+     * Create a listening, secure RFCOMM Bluetooth socket.
+     * <p>A remote device connecting to this socket will be authenticated and
+     * communication on this socket will be encrypted.
+     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming
+     * connections from a listening {@link BluetoothServerSocket}.
+     * <p>Valid RFCOMM channels are in range 1 to 30.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * @param channel RFCOMM channel to listen on
+     * @return a listening RFCOMM BluetoothServerSocket
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions, or channel in use.
+     * @hide
+     */
+    public BluetoothServerSocket listenUsingRfcommOn(int channel) throws IOException {
+        BluetoothServerSocket socket = new BluetoothServerSocket(
+                BluetoothSocket.TYPE_RFCOMM, true, true, channel);
+        int errno = socket.mSocket.bindListen();
+        if (errno != 0) {
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            socket.mSocket.throwErrnoNative(errno);
+        }
+        return socket;
+    }
+
+
+    /**
+     * Create a listening, secure L2Cap Bluetooth socket.
+     * <p>A remote device connecting to this socket will be authenticated and
+     * communication on this socket will be encrypted.
+     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming
+     * connections from a listening {@link BluetoothServerSocket}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * @param psm L2Cap psm to listen on
+     * @return a listening L2Cap BluetoothServerSocket
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions, or channel in use.
+     * @hide
+     */
+    public BluetoothServerSocket listenUsingL2capOn(int psm) throws IOException {
+        BluetoothServerSocket socket = new BluetoothServerSocket(
+                BluetoothSocket.TYPE_L2CAP, true, true, psm);
+        int errno = socket.mSocket.bindListen();
+        if (errno != 0) {
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            socket.mSocket.throwErrnoNative(errno);
+        }
+        return socket;
+    }
+
+    /**
+     * Create a listening, secure EL2Cap Bluetooth socket.
+     * <p>A remote device connecting to this socket will be authenticated and
+     * communication on this socket will be encrypted.
+     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming
+     * connections from a listening {@link BluetoothServerSocket}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * @param psm L2Cap psm to listen on
+     * @return a listening L2Cap BluetoothServerSocket
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions, or channel in use.
+     * @hide
+     */
+    public BluetoothServerSocket listenUsingEl2capOn(int psm) throws IOException {
+        BluetoothServerSocket socket = new BluetoothServerSocket(
+                BluetoothSocket.TYPE_EL2CAP, true, true, psm);
+        int errno = socket.mSocket.bindListen();
+        if (errno != 0) {
+            try {
+                socket.close();
+            } catch (IOException e) {
+                // Intentionally ignoring (give close() a chance, but we're
+                // going to be throwing up an exception regardless (below)).
+            }
+            socket.mSocket.throwErrnoNative(errno);
+        }
+        return socket;
+    }
+
+    /**
+     * Create a listening, secure RFCOMM Bluetooth socket with Service Record.
+     * <p>A remote device connecting to this socket will be authenticated and
+     * communication on this socket will be encrypted.
+     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming
+     * connections from a listening {@link BluetoothServerSocket}.
+     * <p>The system will assign an unused RFCOMM channel to listen on.
+     * <p>The system will also register a Service Discovery
+     * Protocol (SDP) record with the local SDP server containing the specified
+     * UUID, service name, and auto-assigned channel. Remote Bluetooth devices
+     * can use the same UUID to query our SDP server and discover which channel
+     * to connect to. This SDP record will be removed when this socket is
+     * closed, or if this application closes unexpectedly.
+     * <p>Use {@link BluetoothDevice#createRfcommSocketToServiceRecord} to
+     * connect to this socket from another device using the same {@link UUID}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     * @param name service name for SDP record
+     * @param uuid uuid for SDP record
+     * @return a listening RFCOMM BluetoothServerSocket
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions, or channel in use.
+     */
+    public BluetoothServerSocket listenUsingRfcommWithServiceRecord(String name, UUID uuid)
+            throws IOException {
+        return createNewRfcommSocketAndRecord(name, uuid, true, true);
+    }
+
+    /**
+     * Create a listening, insecure RFCOMM Bluetooth socket with Service Record.
+     * <p>The link key is not required to be authenticated, i.e the communication may be
+     * vulnerable to Man In the Middle attacks. For Bluetooth 2.1 devices,
+     * the link will be encrypted, as encryption is mandartory.
+     * For legacy devices (pre Bluetooth 2.1 devices) the link will not
+     * be encrypted. Use {@link #listenUsingRfcommWithServiceRecord}, if an
+     * encrypted and authenticated communication channel is desired.
+     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming
+     * connections from a listening {@link BluetoothServerSocket}.
+     * <p>The system will assign an unused RFCOMM channel to listen on.
+     * <p>The system will also register a Service Discovery
+     * Protocol (SDP) record with the local SDP server containing the specified
+     * UUID, service name, and auto-assigned channel. Remote Bluetooth devices
+     * can use the same UUID to query our SDP server and discover which channel
+     * to connect to. This SDP record will be removed when this socket is
+     * closed, or if this application closes unexpectedly.
+     * <p>Use {@link BluetoothDevice#createRfcommSocketToServiceRecord} to
+     * connect to this socket from another device using the same {@link UUID}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     * @param name service name for SDP record
+     * @param uuid uuid for SDP record
+     * @return a listening RFCOMM BluetoothServerSocket
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions, or channel in use.
+     */
+    public BluetoothServerSocket listenUsingInsecureRfcommWithServiceRecord(String name, UUID uuid)
+            throws IOException {
+        return createNewRfcommSocketAndRecord(name, uuid, false, false);
+    }
+
+     /**
+     * Create a listening, encrypted,
+     * RFCOMM Bluetooth socket with Service Record.
+     * <p>The link will be encrypted, but the link key is not required to be authenticated
+     * i.e the communication is vulnerable to Man In the Middle attacks. Use
+     * {@link #listenUsingRfcommWithServiceRecord}, to ensure an authenticated link key.
+     * <p> Use this socket if authentication of link key is not possible.
+     * For example, for Bluetooth 2.1 devices, if any of the devices does not have
+     * an input and output capability or just has the ability to display a numeric key,
+     * a secure socket connection is not possible and this socket can be used.
+     * Use {@link #listenUsingInsecureRfcommWithServiceRecord}, if encryption is not required.
+     * For Bluetooth 2.1 devices, the link will be encrypted, as encryption is mandartory.
+     * For more details, refer to the Security Model section 5.2 (vol 3) of
+     * Bluetooth Core Specification version 2.1 + EDR.
+     * <p>Use {@link BluetoothServerSocket#accept} to retrieve incoming
+     * connections from a listening {@link BluetoothServerSocket}.
+     * <p>The system will assign an unused RFCOMM channel to listen on.
+     * <p>The system will also register a Service Discovery
+     * Protocol (SDP) record with the local SDP server containing the specified
+     * UUID, service name, and auto-assigned channel. Remote Bluetooth devices
+     * can use the same UUID to query our SDP server and discover which channel
+     * to connect to. This SDP record will be removed when this socket is
+     * closed, or if this application closes unexpectedly.
+     * <p>Use {@link BluetoothDevice#createRfcommSocketToServiceRecord} to
+     * connect to this socket from another device using the same {@link UUID}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     * @param name service name for SDP record
+     * @param uuid uuid for SDP record
+     * @return a listening RFCOMM BluetoothServerSocket
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions, or channel in use.
+     * @hide
+     */
+    public BluetoothServerSocket listenUsingEncryptedRfcommWithServiceRecord(
+            String name, UUID uuid) throws IOException {
+        return createNewRfcommSocketAndRecord(name, uuid, false, true);
+    }
+
+    private BluetoothServerSocket createNewRfcommSocketAndRecord(String name, UUID uuid,
+            boolean auth, boolean encrypt) throws IOException {
+        RfcommChannelPicker picker = new RfcommChannelPicker(uuid);
+
+        BluetoothServerSocket socket;
+        int channel;
+        int errno;
+        while (true) {
+            channel = picker.nextChannel();
+
+            if (channel == -1) {
+                throw new IOException("No available channels");
+            }
+
+            socket = new BluetoothServerSocket(
+                    BluetoothSocket.TYPE_RFCOMM, auth, encrypt, channel);
+            errno = socket.mSocket.bindListen();
+            if (errno == 0) {
+                if (DBG) Log.d(TAG, "listening on RFCOMM channel " + channel);
+                break;  // success
+            } else if (errno == BluetoothSocket.EADDRINUSE) {
+                if (DBG) Log.d(TAG, "RFCOMM channel " + channel + " in use");
+                try {
+                    socket.close();
+                } catch (IOException e) {}
+                continue;  // try another channel
+            } else {
+                try {
+                    socket.close();
+                } catch (IOException e) {}
+                socket.mSocket.throwErrnoNative(errno);  // Exception as a result of bindListen()
+            }
+        }
+
+        int handle = -1;
+        try {
+            handle = mService.addRfcommServiceRecord(name, new ParcelUuid(uuid), channel,
+                    new Binder());
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        if (handle == -1) {
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            throw new IOException("Not able to register SDP record for " + name);
+        }
+
+        if (mServiceRecordHandler == null) {
+            Looper looper = Looper.getMainLooper();
+            if (looper != null) {
+                if (DBG) Log.d(TAG, "Handler to Remove SDP record:MainLooper");
+                mServiceRecordHandler = new Handler(looper) {
+                    public void handleMessage(Message msg) {
+                        /* handle socket closing */
+                        int handle = msg.what;
+                        try {
+                            if (DBG) Log.d(TAG, "Removing service record " +
+                                           Integer.toHexString(handle));
+                            mService.removeServiceRecord(handle);
+                        } catch (RemoteException e) {Log.e(TAG, "", e);}
+                    }
+                };
+            }else {
+                if (DBG) Log.d(TAG, "Handler to Remove SDP record:myLooper");
+                mServiceRecordHandler = new Handler() {
+                    public void handleMessage(Message msg) {
+                        /* handle socket closing */
+                        int handle = msg.what;
+                        try {
+                            if (DBG) Log.d(TAG, "Removing service record " +
+                                           Integer.toHexString(handle));
+                            mService.removeServiceRecord(handle);
+                        } catch (RemoteException e) {Log.e(TAG, "", e);}
+                    }
+                };
+            }
+        }
+        socket.setCloseHandler(mServiceRecordHandler, handle);
+        return socket;
+    }
+
+
+    /**
+     * Construct an unencrypted, unauthenticated, RFCOMM server socket.
+     * Call #accept to retrieve connections to this socket.
+     * @return An RFCOMM BluetoothServerSocket
+     * @throws IOException On error, for example Bluetooth not available, or
+     *                     insufficient permissions.
+     * @hide
+     */
+    public BluetoothServerSocket listenUsingInsecureRfcommOn(int port) throws IOException {
+        BluetoothServerSocket socket = new BluetoothServerSocket(
+                BluetoothSocket.TYPE_RFCOMM, false, false, port);
+        int errno = socket.mSocket.bindListen();
+        if (errno != 0) {
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            socket.mSocket.throwErrnoNative(errno);
+        }
+        return socket;
+    }
+
+     /**
+     * Construct an encrypted, RFCOMM server socket.
+     * Call #accept to retrieve connections to this socket.
+     * @return An RFCOMM BluetoothServerSocket
+     * @throws IOException On error, for example Bluetooth not available, or
+     *                     insufficient permissions.
+     * @hide
+     */
+    public BluetoothServerSocket listenUsingEncryptedRfcommOn(int port)
+            throws IOException {
+        BluetoothServerSocket socket = new BluetoothServerSocket(
+                BluetoothSocket.TYPE_RFCOMM, false, true, port);
+        int errno = socket.mSocket.bindListen();
+        if (errno != 0) {
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            socket.mSocket.throwErrnoNative(errno);
+        }
+        return socket;
+    }
+
+    /**
+     * Construct an unencrypted, unauthenticated, L2Cap server socket.
+     * Call #accept to retrieve connections to this socket.
+     * @param psm L2Cap psm to listen on
+     * @return An L2Cap BluetoothServerSocket
+     * @throws IOException On error, for example Bluetooth not available, or
+     *                     insufficient permissions.
+     * @hide
+     */
+    public BluetoothServerSocket listenUsingInsecureL2capOn(int psm) throws IOException {
+        BluetoothServerSocket socket = new BluetoothServerSocket(
+                BluetoothSocket.TYPE_L2CAP, false, false, psm);
+        int errno = socket.mSocket.bindListen();
+        if (errno != 0) {
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            socket.mSocket.throwErrnoNative(errno);
+        }
+        return socket;
+    }
+
+    /**
+     * Construct an unencrypted, unauthenticated, EL2Cap server socket.
+     * Call #accept to retrieve connections to this socket.
+     * @param psm L2Cap psm to listen on
+     * @return An L2Cap BluetoothServerSocket
+     * @throws IOException On error, for example Bluetooth not available, or
+     *                     insufficient permissions.
+     * @hide
+     */
+    public BluetoothServerSocket listenUsingInsecureEl2capOn(int psm) throws IOException {
+        BluetoothServerSocket socket = new BluetoothServerSocket(
+                BluetoothSocket.TYPE_EL2CAP, false, false, psm);
+        int errno = socket.mSocket.bindListen();
+        if (errno != 0) {
+            try {
+                socket.close();
+            } catch (IOException e) {
+                // Intentionally ignoring (give close() a chance, but we're
+                // going to be throwing up an exception regardless (below)).
+            }
+            socket.mSocket.throwErrnoNative(errno);
+        }
+        return socket;
+    }
+
+
+    /**
+     * Construct a SCO server socket.
+     * Call #accept to retrieve connections to this socket.
+     * @return A SCO BluetoothServerSocket
+     * @throws IOException On error, for example Bluetooth not available, or
+     *                     insufficient permissions.
+     * @hide
+     */
+    public static BluetoothServerSocket listenUsingScoOn() throws IOException {
+        BluetoothServerSocket socket = new BluetoothServerSocket(
+                BluetoothSocket.TYPE_SCO, false, false, -1);
+        int errno = socket.mSocket.bindListen();
+        if (errno != 0) {
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            socket.mSocket.throwErrnoNative(errno);
+        }
+        return socket;
+    }
+
+    /**
+     * Read the local Out of Band Pairing Data
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @return Pair<byte[], byte[]> of Hash and Randomizer
+     *
+     * @hide
+     */
+    public Pair<byte[], byte[]> readOutOfBandData() {
+        if (getState() != STATE_ON) return null;
+        try {
+            byte[] hash;
+            byte[] randomizer;
+
+            byte[] ret = mService.readOutOfBandData();
+
+            if (ret  == null || ret.length != 32) return null;
+
+            hash = Arrays.copyOfRange(ret, 0, 16);
+            randomizer = Arrays.copyOfRange(ret, 16, 32);
+
+            if (DBG) {
+                Log.d(TAG, "readOutOfBandData:" + Arrays.toString(hash) +
+                  ":" + Arrays.toString(randomizer));
+            }
+            return new Pair<byte[], byte[]>(hash, randomizer);
+
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return null;
+    }
+
+    /**
+     * Get the profile proxy object associated with the profile.
+     *
+     * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
+     * {@link BluetoothProfile#A2DP}. Clients must implements
+     * {@link BluetoothProfile.ServiceListener} to get notified of
+     * the connection status and to get the proxy object.
+     *
+     * @param context Context of the application
+     * @param listener The service Listener for connection callbacks.
+     * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
+     *                {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
+     * @return true on success, false on error
+     */
+    public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener,
+                                   int profile) {
+        if (context == null || listener == null) return false;
+
+        if (profile == BluetoothProfile.HEADSET) {
+            BluetoothHeadset headset = new BluetoothHeadset(context, listener);
+            return true;
+        } else if (profile == BluetoothProfile.A2DP) {
+            BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
+            return true;
+        } else if (profile == BluetoothProfile.INPUT_DEVICE) {
+            BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
+            return true;
+        } else if (profile == BluetoothProfile.PAN) {
+            BluetoothPan pan = new BluetoothPan(context, listener);
+            return true;
+        } else if (profile == BluetoothProfile.HEALTH) {
+            BluetoothHealth health = new BluetoothHealth(context, listener);
+            return true;
+        } else if (profile == BluetoothProfile.GATT) {
+            BluetoothGatt gatt = new BluetoothGatt(context, listener);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Close the connection of the profile proxy to the Service.
+     *
+     * <p> Clients should call this when they are no longer using
+     * the proxy obtained from {@link #getProfileProxy}.
+     * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
+     * {@link BluetoothProfile#A2DP}
+     *
+     * @param profile
+     * @param proxy Profile proxy object
+     */
+    public void closeProfileProxy(int profile, BluetoothProfile proxy) {
+        if (proxy == null) return;
+
+        switch (profile) {
+            case BluetoothProfile.HEADSET:
+                BluetoothHeadset headset = (BluetoothHeadset)proxy;
+                headset.close();
+                break;
+            case BluetoothProfile.A2DP:
+                BluetoothA2dp a2dp = (BluetoothA2dp)proxy;
+                a2dp.close();
+                break;
+            case BluetoothProfile.INPUT_DEVICE:
+                BluetoothInputDevice iDev = (BluetoothInputDevice)proxy;
+                iDev.close();
+                break;
+            case BluetoothProfile.PAN:
+                BluetoothPan pan = (BluetoothPan)proxy;
+                pan.close();
+                break;
+            case BluetoothProfile.HEALTH:
+                BluetoothHealth health = (BluetoothHealth)proxy;
+                health.close();
+                break;
+           case BluetoothProfile.GATT:
+                BluetoothGatt gatt = (BluetoothGatt)proxy;
+                gatt.close();
+                break;
+        }
+    }
+
+    /**
+     * Enable the Bluetooth Adapter, but don't auto-connect devices
+     * and don't persist state. Only for use by system applications.
+     * @hide
+     */
+    public boolean enableNoAutoConnect() {
+        try {
+            return mService.enableNoAutoConnect();
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Enable control of the Bluetooth Adapter for a single application.
+     *
+     * <p>Some applications need to use Bluetooth for short periods of time to
+     * transfer data but don't want all the associated implications like
+     * automatic connection to headsets etc.
+     *
+     * <p> Multiple applications can call this. This is reference counted and
+     * Bluetooth disabled only when no one else is using it. There will be no UI
+     * shown to the user while bluetooth is being enabled. Any user action will
+     * override this call. For example, if user wants Bluetooth on and the last
+     * user of this API wanted to disable Bluetooth, Bluetooth will not be
+     * turned off.
+     *
+     * <p> This API is only meant to be used by internal applications. Third
+     * party applications but use {@link #enable} and {@link #disable} APIs.
+     *
+     * <p> If this API returns true, it means the callback will be called.
+     * The callback will be called with the current state of Bluetooth.
+     * If the state is not what was requested, an internal error would be the
+     * reason. If Bluetooth is already on and if this function is called to turn
+     * it on, the api will return true and a callback will be called.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @param on True for on, false for off.
+     * @param callback The callback to notify changes to the state.
+     * @hide
+     */
+    public boolean changeApplicationBluetoothState(boolean on,
+                                                   BluetoothStateChangeCallback callback) {
+        if (callback == null) return false;
+
+        try {
+            return mService.changeApplicationBluetoothState(on, new
+                    StateChangeCallbackWrapper(callback), new Binder());
+        } catch (RemoteException e) {
+            Log.e(TAG, "changeBluetoothState", e);
+        }
+        return false;
+    }
+
+    /**
+     * @hide
+     */
+    public interface BluetoothStateChangeCallback {
+        public void onBluetoothStateChange(boolean on);
+    }
+
+    /**
+     * @hide
+     */
+    public class StateChangeCallbackWrapper extends IBluetoothStateChangeCallback.Stub {
+        private BluetoothStateChangeCallback mCallback;
+
+        StateChangeCallbackWrapper(BluetoothStateChangeCallback
+                callback) {
+            mCallback = callback;
+        }
+
+        @Override
+        public void onBluetoothStateChange(boolean on) {
+            mCallback.onBluetoothStateChange(on);
+        }
+    }
+
+    private Set<BluetoothDevice> toDeviceSet(String[] addresses) {
+        Set<BluetoothDevice> devices = new HashSet<BluetoothDevice>(addresses.length);
+        for (int i = 0; i < addresses.length; i++) {
+            devices.add(getRemoteDevice(addresses[i]));
+        }
+        return Collections.unmodifiableSet(devices);
+    }
+
+    /**
+     * Validate a String Bluetooth address, such as "00:43:A8:23:10:F0"
+     * <p>Alphabetic characters must be uppercase to be valid.
+     *
+     * @param address Bluetooth address as string
+     * @return true if the address is valid, false otherwise
+     */
+    public static boolean checkBluetoothAddress(String address) {
+        if (address == null || address.length() != ADDRESS_LENGTH) {
+            return false;
+        }
+        for (int i = 0; i < ADDRESS_LENGTH; i++) {
+            char c = address.charAt(i);
+            switch (i % 3) {
+            case 0:
+            case 1:
+                if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F')) {
+                    // hex character, OK
+                    break;
+                }
+                return false;
+            case 2:
+                if (c == ':') {
+                    break;  // OK
+                }
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Clear the Preferred Devices List.
+     *
+     * <p>Clears all the devices in the Preferred devices list.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @param pListCallback The callback to notify the application regarding
+     * whether the Preferred devices list has been cleared or not.
+     * @return false, if internal checks fail; True if the process of
+     *         clearing preferred devices list was started.
+     * @hide
+     */
+    public boolean clearPreferredDeviceList(IBluetoothPreferredDeviceListCallback pListCallback) {
+        Log.d(TAG, "BT adapter clearPreferredDeviceList");
+        try {
+            return mService.clearPreferredDeviceList(pListCallback);
+        } catch (RemoteException e) {
+            Log.e(TAG, "clearPreferredDeviceList", e);
+        }
+        return false;
+    }
+    /**
+     * Create Connection request to the devices in the Preferred Devices list
+     *
+     * @param pListCallback The callback to notify the application regarding
+     * whether the create connection request for the devices in the Preferred devices
+     * list has been sent or not.
+     * @return false, if internal checks fail; True if the process of
+     *         creating connection request to preferred devices list was started.
+     * @hide
+     */
+    public boolean gattConnectToPreferredDeviceList(IBluetoothPreferredDeviceListCallback pListCallback) {
+        Log.d(TAG, "BT adapter gattConnectToPreferredDeviceList");
+        try {
+            return mService.gattConnectToPreferredDeviceList(pListCallback);
+        } catch (RemoteException e) {
+            Log.e(TAG, "gattConnectToPreferredDeviceList", e);
+        }
+        return false;
+    }
+     /**
+      * Cancel create connection request to the devices in the Preferred
+      * devices list
+      *
+      * @param pListCallback The callback to notify the application regarding
+      * whether the cancel create connection request for the devices in the Preferred devices
+      * list has been sent or not.
+      * @return false, if internal checks fail; True if the process of
+      *         cancel create connection request to preferred devices list was started.
+      * @hide
+      */
+    public boolean gattCancelConnectToPreferredDeviceList(IBluetoothPreferredDeviceListCallback pListCallback) {
+        Log.d(TAG, "BT adapter gattCancelConnectToPreferredDeviceList");
+        try {
+            return mService.gattCancelConnectToPreferredDeviceList(pListCallback);
+        } catch (RemoteException e) {
+            Log.e(TAG, "gattCancelConnectToPreferredDeviceList", e);
+        }
+        return false;
+    }
+    /**
+     * Automatic connection request to the devices in the Preferred
+     * devices list
+     *
+     * @param pListCallback The callback to notify the application regarding
+     * whether the Auto Connect request has been sent or not.
+     * @return false, if internal checks fail; True if the process of
+     *         auto connection request for devices in preferred devices list was started.
+     * @hide
+     */
+   public boolean gattAutoConnect(IBluetoothPreferredDeviceListCallback pListCallback,
+           BluetoothDevice btDevice) {
+       Log.d(TAG, "BT adapter gattAutoConnect");
+       boolean status = false;
+       try {
+           //call add device to preferred devices list
+           status = mService.addToPreferredDeviceListWrapper(btDevice, pListCallback, "AutoConnect");
+       } catch (RemoteException e) {
+           Log.e(TAG, "gattAutoConnect", e);
+       }
+       return status;
+   }
+   /**
+    * Automatic connection cancel request to the devices in the Preferred
+    * devices list
+    *
+    * @param pListCallback The callback to notify the application regarding
+    * whether the Auto Connect cancel request has been sent or not.
+    * @return false, if internal checks fail; True if the process of
+    *         auto connect cancel request for devices in preferred devices list was started.
+   * @hide
+   */
+   public boolean gattAutoConnectCancel(IBluetoothPreferredDeviceListCallback pListCallback,
+           BluetoothDevice btDevice) {
+       Log.d(TAG, "BT adapter gattAutoConnectCancel");
+       boolean status = false;
+       try {
+           //Stop the scan
+           status = mService.gattCancelConnectToPreferredDeviceListWrapper(pListCallback, btDevice, "AutoConnectCancel");
+       } catch (RemoteException e) {
+           Log.e(TAG, "gattAutoConnectCancel", e);
+       }
+       return status;
+   }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothAssignedNumbers.java b/bluetoothmsm/java/android/bluetooth/BluetoothAssignedNumbers.java
new file mode 100644
index 0000000..580e9ff
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothAssignedNumbers.java
@@ -0,0 +1,521 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+/**
+ * Bluetooth Assigned Numbers.
+ * <p>
+ * For now we only include Company ID values.
+ * @see <a href="https://www.bluetooth.org/technical/assignednumbers/identifiers.htm">
+ * The Official Bluetooth SIG Member Website | Company Identifiers</a>
+ *
+ */
+public class BluetoothAssignedNumbers {
+
+    // Bluetooth SIG Company ID values
+    /*
+     * Ericsson Technology Licensing.
+     */
+    public static final int ERICSSON_TECHNOLOGY = 0x0000;
+
+    /*
+     * Nokia Mobile Phones.
+     */
+    public static final int NOKIA_MOBILE_PHONES = 0x0001;
+
+    /*
+     * Intel Corp.
+     */
+    public static final int INTEL = 0x0002;
+
+    /*
+     * IBM Corp.
+     */
+    public static final int IBM = 0x0003;
+
+    /*
+     * Toshiba Corp.
+     */
+    public static final int TOSHIBA = 0x0004;
+
+    /*
+     * 3Com.
+     */
+    public static final int THREECOM = 0x0005;
+
+    /*
+     * Microsoft.
+     */
+    public static final int MICROSOFT = 0x0006;
+
+    /*
+     * Lucent.
+     */
+    public static final int LUCENT = 0x0007;
+
+    /*
+     * Motorola.
+     */
+    public static final int MOTOROLA = 0x0008;
+
+    /*
+     * Infineon Technologies AG.
+     */
+    public static final int INFINEON_TECHNOLOGIES = 0x0009;
+
+    /*
+     * Cambridge Silicon Radio.
+     */
+    public static final int CAMBRIDGE_SILICON_RADIO = 0x000A;
+
+    /*
+     * Silicon Wave.
+     */
+    public static final int SILICON_WAVE = 0x000B;
+
+    /*
+     * Digianswer A/S.
+     */
+    public static final int DIGIANSWER = 0x000C;
+
+    /*
+     * Texas Instruments Inc.
+     */
+    public static final int TEXAS_INSTRUMENTS = 0x000D;
+
+    /*
+     * Parthus Technologies Inc.
+     */
+    public static final int PARTHUS_TECHNOLOGIES = 0x000E;
+
+    /*
+     * Broadcom Corporation.
+     */
+    public static final int BROADCOM = 0x000F;
+
+    /*
+     * Mitel Semiconductor.
+     */
+    public static final int MITEL_SEMICONDUCTOR = 0x0010;
+
+    /*
+     * Widcomm, Inc.
+     */
+    public static final int WIDCOMM = 0x0011;
+
+    /*
+     * Zeevo, Inc.
+     */
+    public static final int ZEEVO = 0x0012;
+
+    /*
+     * Atmel Corporation.
+     */
+    public static final int ATMEL = 0x0013;
+
+    /*
+     * Mitsubishi Electric Corporation.
+     */
+    public static final int MITSUBISHI_ELECTRIC = 0x0014;
+
+    /*
+     * RTX Telecom A/S.
+     */
+    public static final int RTX_TELECOM = 0x0015;
+
+    /*
+     * KC Technology Inc.
+     */
+    public static final int KC_TECHNOLOGY = 0x0016;
+
+    /*
+     * Newlogic.
+     */
+    public static final int NEWLOGIC = 0x0017;
+
+    /*
+     * Transilica, Inc.
+     */
+    public static final int TRANSILICA = 0x0018;
+
+    /*
+     * Rohde & Schwarz GmbH & Co. KG.
+     */
+    public static final int ROHDE_AND_SCHWARZ = 0x0019;
+
+    /*
+     * TTPCom Limited.
+     */
+    public static final int TTPCOM = 0x001A;
+
+    /*
+     * Signia Technologies, Inc.
+     */
+    public static final int SIGNIA_TECHNOLOGIES = 0x001B;
+
+    /*
+     * Conexant Systems Inc.
+     */
+    public static final int CONEXANT_SYSTEMS = 0x001C;
+
+    /*
+     * Qualcomm.
+     */
+    public static final int QUALCOMM = 0x001D;
+
+    /*
+     * Inventel.
+     */
+    public static final int INVENTEL = 0x001E;
+
+    /*
+     * AVM Berlin.
+     */
+    public static final int AVM_BERLIN = 0x001F;
+
+    /*
+     * BandSpeed, Inc.
+     */
+    public static final int BANDSPEED = 0x0020;
+
+    /*
+     * Mansella Ltd.
+     */
+    public static final int MANSELLA = 0x0021;
+
+    /*
+     * NEC Corporation.
+     */
+    public static final int NEC = 0x0022;
+
+    /*
+     * WavePlus Technology Co., Ltd.
+     */
+    public static final int WAVEPLUS_TECHNOLOGY = 0x0023;
+
+    /*
+     * Alcatel.
+     */
+    public static final int ALCATEL = 0x0024;
+
+    /*
+     * Philips Semiconductors.
+     */
+    public static final int PHILIPS_SEMICONDUCTORS = 0x0025;
+
+    /*
+     * C Technologies.
+     */
+    public static final int C_TECHNOLOGIES = 0x0026;
+
+    /*
+     * Open Interface.
+     */
+    public static final int OPEN_INTERFACE = 0x0027;
+
+    /*
+     * R F Micro Devices.
+     */
+    public static final int RF_MICRO_DEVICES = 0x0028;
+
+    /*
+     * Hitachi Ltd.
+     */
+    public static final int HITACHI = 0x0029;
+
+    /*
+     * Symbol Technologies, Inc.
+     */
+    public static final int SYMBOL_TECHNOLOGIES = 0x002A;
+
+    /*
+     * Tenovis.
+     */
+    public static final int TENOVIS = 0x002B;
+
+    /*
+     * Macronix International Co. Ltd.
+     */
+    public static final int MACRONIX = 0x002C;
+
+    /*
+     * GCT Semiconductor.
+     */
+    public static final int GCT_SEMICONDUCTOR = 0x002D;
+
+    /*
+     * Norwood Systems.
+     */
+    public static final int NORWOOD_SYSTEMS = 0x002E;
+
+    /*
+     * MewTel Technology Inc.
+     */
+    public static final int MEWTEL_TECHNOLOGY = 0x002F;
+
+    /*
+     * ST Microelectronics.
+     */
+    public static final int ST_MICROELECTRONICS = 0x0030;
+
+    /*
+     * Synopsys.
+     */
+    public static final int SYNOPSYS = 0x0031;
+
+    /*
+     * Red-M (Communications) Ltd.
+     */
+    public static final int RED_M = 0x0032;
+
+    /*
+     * Commil Ltd.
+     */
+    public static final int COMMIL = 0x0033;
+
+    /*
+     * Computer Access Technology Corporation (CATC).
+     */
+    public static final int CATC = 0x0034;
+
+    /*
+     * Eclipse (HQ Espana) S.L.
+     */
+    public static final int ECLIPSE = 0x0035;
+
+    /*
+     * Renesas Technology Corp.
+     */
+    public static final int RENESAS_TECHNOLOGY = 0x0036;
+
+    /*
+     * Mobilian Corporation.
+     */
+    public static final int MOBILIAN_CORPORATION = 0x0037;
+
+    /*
+     * Terax.
+     */
+    public static final int TERAX = 0x0038;
+
+    /*
+     * Integrated System Solution Corp.
+     */
+    public static final int INTEGRATED_SYSTEM_SOLUTION = 0x0039;
+
+    /*
+     * Matsushita Electric Industrial Co., Ltd.
+     */
+    public static final int MATSUSHITA_ELECTRIC = 0x003A;
+
+    /*
+     * Gennum Corporation.
+     */
+    public static final int GENNUM = 0x003B;
+
+    /*
+     * Research In Motion.
+     */
+    public static final int RESEARCH_IN_MOTION = 0x003C;
+
+    /*
+     * IPextreme, Inc.
+     */
+    public static final int IPEXTREME = 0x003D;
+
+    /*
+     * Systems and Chips, Inc.
+     */
+    public static final int SYSTEMS_AND_CHIPS = 0x003E;
+
+    /*
+     * Bluetooth SIG, Inc.
+     */
+    public static final int BLUETOOTH_SIG = 0x003F;
+
+    /*
+     * Seiko Epson Corporation.
+     */
+    public static final int SEIKO_EPSON = 0x0040;
+
+    /*
+     * Integrated Silicon Solution Taiwan, Inc.
+     */
+    public static final int INTEGRATED_SILICON_SOLUTION = 0x0041;
+
+    /*
+     * CONWISE Technology Corporation Ltd.
+     */
+    public static final int CONWISE_TECHNOLOGY = 0x0042;
+
+    /*
+     * PARROT SA.
+     */
+    public static final int PARROT = 0x0043;
+
+    /*
+     * Socket Mobile.
+     */
+    public static final int SOCKET_MOBILE = 0x0044;
+
+    /*
+     * Atheros Communications, Inc.
+     */
+    public static final int ATHEROS_COMMUNICATIONS = 0x0045;
+
+    /*
+     * MediaTek, Inc.
+     */
+    public static final int MEDIATEK = 0x0046;
+
+    /*
+     * Bluegiga.
+     */
+    public static final int BLUEGIGA = 0x0047;
+
+    /*
+     * Marvell Technology Group Ltd.
+     */
+    public static final int MARVELL = 0x0048;
+
+    /*
+     * 3DSP Corporation.
+     */
+    public static final int THREE_DSP = 0x0049;
+
+    /*
+     * Accel Semiconductor Ltd.
+     */
+    public static final int ACCEL_SEMICONDUCTOR = 0x004A;
+
+    /*
+     * Continental Automotive Systems.
+     */
+    public static final int CONTINENTAL_AUTOMOTIVE = 0x004B;
+
+    /*
+     * Apple, Inc.
+     */
+    public static final int APPLE = 0x004C;
+
+    /*
+     * Staccato Communications, Inc.
+     */
+    public static final int STACCATO_COMMUNICATIONS = 0x004D;
+
+    /*
+     * Avago Technologies.
+     */
+    public static final int AVAGO = 0x004E;
+
+    /*
+     * APT Licensing Ltd.
+     */
+    public static final int APT_LICENSING = 0x004F;
+
+    /*
+     * SiRF Technology, Inc.
+     */
+    public static final int SIRF_TECHNOLOGY = 0x0050;
+
+    /*
+     * Tzero Technologies, Inc.
+     */
+    public static final int TZERO_TECHNOLOGIES = 0x0051;
+
+    /*
+     * J&M Corporation.
+     */
+    public static final int J_AND_M = 0x0052;
+
+    /*
+     * Free2move AB.
+     */
+    public static final int FREE2MOVE = 0x0053;
+
+    /*
+     * 3DiJoy Corporation.
+     */
+    public static final int THREE_DIJOY = 0x0054;
+
+    /*
+     * Plantronics, Inc.
+     */
+    public static final int PLANTRONICS = 0x0055;
+
+    /*
+     * Sony Ericsson Mobile Communications.
+     */
+    public static final int SONY_ERICSSON = 0x0056;
+
+    /*
+     * Harman International Industries, Inc.
+     */
+    public static final int HARMAN_INTERNATIONAL = 0x0057;
+
+    /*
+     * Vizio, Inc.
+     */
+    public static final int VIZIO = 0x0058;
+
+    /*
+     * Nordic Semiconductor ASA.
+     */
+    public static final int NORDIC_SEMICONDUCTOR = 0x0059;
+
+    /*
+     * EM Microelectronic-Marin SA.
+     */
+    public static final int EM_MICROELECTRONIC_MARIN = 0x005A;
+
+    /*
+     * Ralink Technology Corporation.
+     */
+    public static final int RALINK_TECHNOLOGY = 0x005B;
+
+    /*
+     * Belkin International, Inc.
+     */
+    public static final int BELKIN_INTERNATIONAL = 0x005C;
+
+    /*
+     * Realtek Semiconductor Corporation.
+     */
+    public static final int REALTEK_SEMICONDUCTOR = 0x005D;
+
+    /*
+     * Stonestreet One, LLC.
+     */
+    public static final int STONESTREET_ONE = 0x005E;
+
+    /*
+     * Wicentric, Inc.
+     */
+    public static final int WICENTRIC = 0x005F;
+
+    /*
+     * RivieraWaves S.A.S.
+     */
+    public static final int RIVIERAWAVES = 0x0060;
+
+    /*
+     * You can't instantiate one of these.
+     */
+    private BluetoothAssignedNumbers() {
+    }
+
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothAudioGateway.java b/bluetoothmsm/java/android/bluetooth/BluetoothAudioGateway.java
new file mode 100644
index 0000000..ae1f931
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothAudioGateway.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import java.lang.Thread;
+
+import android.os.Message;
+import android.os.Handler;
+import android.util.Log;
+
+/**
+ * Listens for incoming RFCOMM connection for the headset / handsfree service.
+ *
+ * TODO: Use the new generic BluetoothSocket class instead of this legacy code
+ *
+ * @hide
+ */
+public final class BluetoothAudioGateway {
+    private static final String TAG = "BT Audio Gateway";
+    private static final boolean DBG = false;
+
+    private int mNativeData;
+    static { classInitNative(); }
+
+    /* in */
+    private int mHandsfreeAgRfcommChannel = -1;
+    private int mHeadsetAgRfcommChannel   = -1;
+
+    /* out - written by native code */
+    private String mConnectingHeadsetAddress;
+    private int mConnectingHeadsetRfcommChannel; /* -1 when not connected */
+    private int mConnectingHeadsetSocketFd;
+    private String mConnectingHandsfreeAddress;
+    private int mConnectingHandsfreeRfcommChannel; /* -1 when not connected */
+    private int mConnectingHandsfreeSocketFd;
+    private int mTimeoutRemainingMs; /* in/out */
+
+    private final BluetoothAdapter mAdapter;
+
+    public static final int DEFAULT_HF_AG_CHANNEL = 10;
+    public static final int DEFAULT_HS_AG_CHANNEL = 11;
+
+    public BluetoothAudioGateway(BluetoothAdapter adapter) {
+        this(adapter, DEFAULT_HF_AG_CHANNEL, DEFAULT_HS_AG_CHANNEL);
+    }
+
+    public BluetoothAudioGateway(BluetoothAdapter adapter, int handsfreeAgRfcommChannel,
+                int headsetAgRfcommChannel) {
+        mAdapter = adapter;
+        mHandsfreeAgRfcommChannel = handsfreeAgRfcommChannel;
+        mHeadsetAgRfcommChannel = headsetAgRfcommChannel;
+        initializeNativeDataNative();
+    }
+
+    private Thread mConnectThead;
+    private volatile boolean mInterrupted;
+    private static final int SELECT_WAIT_TIMEOUT = 1000;
+
+    private Handler mCallback;
+
+    public class IncomingConnectionInfo {
+        public BluetoothAdapter mAdapter;
+        public BluetoothDevice mRemoteDevice;
+        public int mSocketFd;
+        public int mRfcommChan;
+        IncomingConnectionInfo(BluetoothAdapter adapter, BluetoothDevice remoteDevice,
+                int socketFd, int rfcommChan) {
+            mAdapter = adapter;
+            mRemoteDevice = remoteDevice;
+            mSocketFd = socketFd;
+            mRfcommChan = rfcommChan;
+        }
+    }
+
+    public static final int MSG_INCOMING_HEADSET_CONNECTION   = 100;
+    public static final int MSG_INCOMING_HANDSFREE_CONNECTION = 101;
+
+    public synchronized boolean start(Handler callback) {
+
+        if (mConnectThead == null) {
+            mCallback = callback;
+            mConnectThead = new Thread(TAG) {
+                    public void run() {
+                        if (DBG) log("Connect Thread starting");
+                        while (!mInterrupted) {
+                            //Log.i(TAG, "waiting for connect");
+                            mConnectingHeadsetRfcommChannel = -1;
+                            mConnectingHandsfreeRfcommChannel = -1;
+                            if (waitForHandsfreeConnectNative(SELECT_WAIT_TIMEOUT) == false) {
+                                if (mTimeoutRemainingMs > 0) {
+                                    try {
+                                        Log.i(TAG, "select thread timed out, but " +
+                                              mTimeoutRemainingMs + "ms of waiting remain.");
+                                        Thread.sleep(mTimeoutRemainingMs);
+                                    } catch (InterruptedException e) {
+                                        Log.i(TAG, "select thread was interrupted (2), exiting");
+                                        mInterrupted = true;
+                                    }
+                                }
+                            }
+                            else {
+                                Log.i(TAG, "connect notification!");
+                                /* A device connected (most likely just one, but
+                                   it is possible for two separate devices, one
+                                   a headset and one a handsfree, to connect
+                                   simultaneously.
+                                */
+                                if (mConnectingHeadsetRfcommChannel >= 0) {
+                                    Log.i(TAG, "Incoming connection from headset " +
+                                          mConnectingHeadsetAddress + " on channel " +
+                                          mConnectingHeadsetRfcommChannel);
+                                    Message msg = Message.obtain(mCallback);
+                                    msg.what = MSG_INCOMING_HEADSET_CONNECTION;
+                                    msg.obj = new IncomingConnectionInfo(
+                                        mAdapter,
+                                        mAdapter.getRemoteDevice(mConnectingHeadsetAddress),
+                                        mConnectingHeadsetSocketFd,
+                                        mConnectingHeadsetRfcommChannel);
+                                    msg.sendToTarget();
+                                }
+                                if (mConnectingHandsfreeRfcommChannel >= 0) {
+                                    Log.i(TAG, "Incoming connection from handsfree " +
+                                          mConnectingHandsfreeAddress + " on channel " +
+                                          mConnectingHandsfreeRfcommChannel);
+                                    Message msg = Message.obtain();
+                                    msg.setTarget(mCallback);
+                                    msg.what = MSG_INCOMING_HANDSFREE_CONNECTION;
+                                    msg.obj = new IncomingConnectionInfo(
+                                        mAdapter,
+                                        mAdapter.getRemoteDevice(mConnectingHandsfreeAddress),
+                                        mConnectingHandsfreeSocketFd,
+                                        mConnectingHandsfreeRfcommChannel);
+                                    msg.sendToTarget();
+                                }
+                            }
+                        }
+                        if (DBG) log("Connect Thread finished");
+                    }
+                };
+
+            if (setUpListeningSocketsNative() == false) {
+                Log.e(TAG, "Could not set up listening socket, exiting");
+                return false;
+            }
+
+            mInterrupted = false;
+            mConnectThead.start();
+        }
+
+        return true;
+    }
+
+    public synchronized void stop() {
+        if (mConnectThead != null) {
+            if (DBG) log("stopping Connect Thread");
+            mInterrupted = true;
+            try {
+                mConnectThead.interrupt();
+                if (DBG) log("waiting for thread to terminate");
+                mConnectThead.join();
+                mConnectThead = null;
+                mCallback = null;
+                tearDownListeningSocketsNative();
+            } catch (InterruptedException e) {
+                Log.w(TAG, "Interrupted waiting for Connect Thread to join");
+            }
+        }
+    }
+
+    protected void finalize() throws Throwable {
+        try {
+            cleanupNativeDataNative();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    private static native void classInitNative();
+    private native void initializeNativeDataNative();
+    private native void cleanupNativeDataNative();
+    private native boolean waitForHandsfreeConnectNative(int timeoutMs);
+    private native boolean setUpListeningSocketsNative();
+    private native void tearDownListeningSocketsNative();
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothClass.java b/bluetoothmsm/java/android/bluetooth/BluetoothClass.java
new file mode 100644
index 0000000..9453787
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothClass.java
@@ -0,0 +1,380 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Represents a Bluetooth class, which describes general characteristics
+ * and capabilities of a device. For example, a Bluetooth class will
+ * specify the general device type such as a phone, a computer, or
+ * headset, and whether it's capable of services such as audio or telephony.
+ *
+ * <p>Every Bluetooth class is composed of zero or more service classes, and
+ * exactly one device class. The device class is further broken down into major
+ * and minor device class components.
+ *
+ * <p>{@link BluetoothClass} is useful as a hint to roughly describe a device
+ * (for example to show an icon in the UI), but does not reliably describe which
+ * Bluetooth profiles or services are actually supported by a device. Accurate
+ * service discovery is done through SDP requests, which are automatically
+ * performed when creating an RFCOMM socket with {@link
+ * BluetoothDevice#createRfcommSocketToServiceRecord} and {@link
+ * BluetoothAdapter#listenUsingRfcommWithServiceRecord}</p>
+ *
+ * <p>Use {@link BluetoothDevice#getBluetoothClass} to retrieve the class for
+ * a remote device.
+ *
+ * <!--
+ * The Bluetooth class is a 32 bit field. The format of these bits is defined at
+ * http://www.bluetooth.org/Technical/AssignedNumbers/baseband.htm
+ * (login required). This class contains that 32 bit field, and provides
+ * constants and methods to determine which Service Class(es) and Device Class
+ * are encoded in that field.
+ * -->
+ */
+public final class BluetoothClass implements Parcelable {
+    /**
+     * Legacy error value. Applications should use null instead.
+     * @hide
+     */
+    public static final int ERROR = 0xFF000000;
+
+    private final int mClass;
+
+    /** @hide */
+    public BluetoothClass(int classInt) {
+        mClass = classInt;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof BluetoothClass) {
+            return mClass == ((BluetoothClass)o).mClass;
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        return mClass;
+    }
+
+    @Override
+    public String toString() {
+        return Integer.toHexString(mClass);
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public static final Parcelable.Creator<BluetoothClass> CREATOR =
+            new Parcelable.Creator<BluetoothClass>() {
+        public BluetoothClass createFromParcel(Parcel in) {
+            return new BluetoothClass(in.readInt());
+        }
+        public BluetoothClass[] newArray(int size) {
+            return new BluetoothClass[size];
+        }
+    };
+
+    public void writeToParcel(Parcel out, int flags) {
+        out.writeInt(mClass);
+    }
+
+    /**
+     * Defines all service class constants.
+     * <p>Each {@link BluetoothClass} encodes zero or more service classes.
+     */
+    public static final class Service {
+        private static final int BITMASK                 = 0xFFE000;
+
+        public static final int LIMITED_DISCOVERABILITY = 0x002000;
+        public static final int POSITIONING             = 0x010000;
+        public static final int NETWORKING              = 0x020000;
+        public static final int RENDER                  = 0x040000;
+        public static final int CAPTURE                 = 0x080000;
+        public static final int OBJECT_TRANSFER         = 0x100000;
+        public static final int AUDIO                   = 0x200000;
+        public static final int TELEPHONY               = 0x400000;
+        public static final int INFORMATION             = 0x800000;
+    }
+
+    /**
+     * Return true if the specified service class is supported by this
+     * {@link BluetoothClass}.
+     * <p>Valid service classes are the public constants in
+     * {@link BluetoothClass.Service}. For example, {@link
+     * BluetoothClass.Service#AUDIO}.
+     *
+     * @param service valid service class
+     * @return true if the service class is supported
+     */
+    public boolean hasService(int service) {
+        return ((mClass & Service.BITMASK & service) != 0);
+    }
+
+    /**
+     * Defines all device class constants.
+     * <p>Each {@link BluetoothClass} encodes exactly one device class, with
+     * major and minor components.
+     * <p>The constants in {@link
+     * BluetoothClass.Device} represent a combination of major and minor
+     * device components (the complete device class). The constants in {@link
+     * BluetoothClass.Device.Major} represent only major device classes.
+     * <p>See {@link BluetoothClass.Service} for service class constants.
+     */
+    public static class Device {
+        private static final int BITMASK               = 0x1FFC;
+
+        /**
+         * Defines all major device class constants.
+         * <p>See {@link BluetoothClass.Device} for minor classes.
+         */
+        public static class Major {
+            private static final int BITMASK           = 0x1F00;
+
+            public static final int MISC              = 0x0000;
+            public static final int COMPUTER          = 0x0100;
+            public static final int PHONE             = 0x0200;
+            public static final int NETWORKING        = 0x0300;
+            public static final int AUDIO_VIDEO       = 0x0400;
+            public static final int PERIPHERAL        = 0x0500;
+            public static final int IMAGING           = 0x0600;
+            public static final int WEARABLE          = 0x0700;
+            public static final int TOY               = 0x0800;
+            public static final int HEALTH            = 0x0900;
+            public static final int UNCATEGORIZED     = 0x1F00;
+        }
+
+        // Devices in the COMPUTER major class
+        public static final int COMPUTER_UNCATEGORIZED              = 0x0100;
+        public static final int COMPUTER_DESKTOP                    = 0x0104;
+        public static final int COMPUTER_SERVER                     = 0x0108;
+        public static final int COMPUTER_LAPTOP                     = 0x010C;
+        public static final int COMPUTER_HANDHELD_PC_PDA            = 0x0110;
+        public static final int COMPUTER_PALM_SIZE_PC_PDA           = 0x0114;
+        public static final int COMPUTER_WEARABLE                   = 0x0118;
+
+        // Devices in the PHONE major class
+        public static final int PHONE_UNCATEGORIZED                 = 0x0200;
+        public static final int PHONE_CELLULAR                      = 0x0204;
+        public static final int PHONE_CORDLESS                      = 0x0208;
+        public static final int PHONE_SMART                         = 0x020C;
+        public static final int PHONE_MODEM_OR_GATEWAY              = 0x0210;
+        public static final int PHONE_ISDN                          = 0x0214;
+
+        // Minor classes for the AUDIO_VIDEO major class
+        public static final int AUDIO_VIDEO_UNCATEGORIZED           = 0x0400;
+        public static final int AUDIO_VIDEO_WEARABLE_HEADSET        = 0x0404;
+        public static final int AUDIO_VIDEO_HANDSFREE               = 0x0408;
+        //public static final int AUDIO_VIDEO_RESERVED              = 0x040C;
+        public static final int AUDIO_VIDEO_MICROPHONE              = 0x0410;
+        public static final int AUDIO_VIDEO_LOUDSPEAKER             = 0x0414;
+        public static final int AUDIO_VIDEO_HEADPHONES              = 0x0418;
+        public static final int AUDIO_VIDEO_PORTABLE_AUDIO          = 0x041C;
+        public static final int AUDIO_VIDEO_CAR_AUDIO               = 0x0420;
+        public static final int AUDIO_VIDEO_SET_TOP_BOX             = 0x0424;
+        public static final int AUDIO_VIDEO_HIFI_AUDIO              = 0x0428;
+        public static final int AUDIO_VIDEO_VCR                     = 0x042C;
+        public static final int AUDIO_VIDEO_VIDEO_CAMERA            = 0x0430;
+        public static final int AUDIO_VIDEO_CAMCORDER               = 0x0434;
+        public static final int AUDIO_VIDEO_VIDEO_MONITOR           = 0x0438;
+        public static final int AUDIO_VIDEO_VIDEO_DISPLAY_AND_LOUDSPEAKER = 0x043C;
+        public static final int AUDIO_VIDEO_VIDEO_CONFERENCING      = 0x0440;
+        //public static final int AUDIO_VIDEO_RESERVED              = 0x0444;
+        public static final int AUDIO_VIDEO_VIDEO_GAMING_TOY        = 0x0448;
+
+        /** Devices in the IMAGING major class
+        * @hide
+        */
+        public static final int IMAGING_DISPLAY                     = 0x0610;
+        /**
+        * @hide
+        */
+        public static final int IMAGING_CAMERA                      = 0x0620;
+        /**
+        * @hide
+        */
+        public static final int IMAGING_SCANNER                     = 0x0640;
+        /**
+        * @hide
+        */
+        public static final int IMAGING_PRINTER                     = 0x0680;
+
+        // Devices in the WEARABLE major class
+        public static final int WEARABLE_UNCATEGORIZED              = 0x0700;
+        public static final int WEARABLE_WRIST_WATCH                = 0x0704;
+        public static final int WEARABLE_PAGER                      = 0x0708;
+        public static final int WEARABLE_JACKET                     = 0x070C;
+        public static final int WEARABLE_HELMET                     = 0x0710;
+        public static final int WEARABLE_GLASSES                    = 0x0714;
+
+        // Devices in the TOY major class
+        public static final int TOY_UNCATEGORIZED                   = 0x0800;
+        public static final int TOY_ROBOT                           = 0x0804;
+        public static final int TOY_VEHICLE                         = 0x0808;
+        public static final int TOY_DOLL_ACTION_FIGURE              = 0x080C;
+        public static final int TOY_CONTROLLER                      = 0x0810;
+        public static final int TOY_GAME                            = 0x0814;
+
+        // Devices in the HEALTH major class
+        public static final int HEALTH_UNCATEGORIZED                = 0x0900;
+        public static final int HEALTH_BLOOD_PRESSURE               = 0x0904;
+        public static final int HEALTH_THERMOMETER                  = 0x0908;
+        public static final int HEALTH_WEIGHING                     = 0x090C;
+        public static final int HEALTH_GLUCOSE                      = 0x0910;
+        public static final int HEALTH_PULSE_OXIMETER               = 0x0914;
+        public static final int HEALTH_PULSE_RATE                   = 0x0918;
+        public static final int HEALTH_DATA_DISPLAY                 = 0x091C;
+
+        // Devices in PERIPHERAL major class
+        /**
+         * @hide
+         */
+        public static final int PERIPHERAL_NON_KEYBOARD_NON_POINTING = 0x0500;
+        /**
+         * @hide
+         */
+        public static final int PERIPHERAL_KEYBOARD                  = 0x0540;
+        /**
+         * @hide
+         */
+        public static final int PERIPHERAL_POINTING                  = 0x0580;
+        /**
+         * @hide
+         */
+        public static final int PERIPHERAL_KEYBOARD_POINTING         = 0x05C0;
+    }
+
+    /**
+     * Return the major device class component of this {@link BluetoothClass}.
+     * <p>Values returned from this function can be compared with the
+     * public constants in {@link BluetoothClass.Device.Major} to determine
+     * which major class is encoded in this Bluetooth class.
+     *
+     * @return major device class component
+     */
+    public int getMajorDeviceClass() {
+        return (mClass & Device.Major.BITMASK);
+    }
+
+    /**
+     * Return the (major and minor) device class component of this
+     * {@link BluetoothClass}.
+     * <p>Values returned from this function can be compared with the
+     * public constants in {@link BluetoothClass.Device} to determine which
+     * device class is encoded in this Bluetooth class.
+     *
+     * @return device class component
+     */
+    public int getDeviceClass() {
+        return (mClass & Device.BITMASK);
+    }
+
+    /** @hide */
+    public static final int PROFILE_HEADSET = 0;
+    /** @hide */
+    public static final int PROFILE_A2DP = 1;
+    /** @hide */
+    public static final int PROFILE_OPP = 2;
+    /** @hide */
+    public static final int PROFILE_HID = 3;
+    /** @hide */
+    public static final int PROFILE_PANU = 4;
+    /** @hide */
+    public static final int PROFILE_NAP = 5;
+
+    /**
+     * Check class bits for possible bluetooth profile support.
+     * This is a simple heuristic that tries to guess if a device with the
+     * given class bits might support specified profile. It is not accurate for all
+     * devices. It tries to err on the side of false positives.
+     * @param profile The profile to be checked
+     * @return True if this device might support specified profile.
+     * @hide
+     */
+    public boolean doesClassMatch(int profile) {
+        if (profile == PROFILE_A2DP) {
+            if (hasService(Service.RENDER)) {
+                return true;
+            }
+            // By the A2DP spec, sinks must indicate the RENDER service.
+            // However we found some that do not (Chordette). So lets also
+            // match on some other class bits.
+            switch (getDeviceClass()) {
+                case Device.AUDIO_VIDEO_HIFI_AUDIO:
+                case Device.AUDIO_VIDEO_HEADPHONES:
+                case Device.AUDIO_VIDEO_LOUDSPEAKER:
+                case Device.AUDIO_VIDEO_CAR_AUDIO:
+                    return true;
+                default:
+                    return false;
+            }
+        } else if (profile == PROFILE_HEADSET) {
+            // The render service class is required by the spec for HFP, so is a
+            // pretty good signal
+            if (hasService(Service.RENDER)) {
+                return true;
+            }
+            // Just in case they forgot the render service class
+            switch (getDeviceClass()) {
+                case Device.AUDIO_VIDEO_HANDSFREE:
+                case Device.AUDIO_VIDEO_WEARABLE_HEADSET:
+                case Device.AUDIO_VIDEO_CAR_AUDIO:
+                    return true;
+                default:
+                    return false;
+            }
+        } else if (profile == PROFILE_OPP) {
+            if (hasService(Service.OBJECT_TRANSFER)) {
+                return true;
+            }
+
+            switch (getDeviceClass()) {
+                case Device.COMPUTER_UNCATEGORIZED:
+                case Device.COMPUTER_DESKTOP:
+                case Device.COMPUTER_SERVER:
+                case Device.COMPUTER_LAPTOP:
+                case Device.COMPUTER_HANDHELD_PC_PDA:
+                case Device.COMPUTER_PALM_SIZE_PC_PDA:
+                case Device.COMPUTER_WEARABLE:
+                case Device.PHONE_UNCATEGORIZED:
+                case Device.PHONE_CELLULAR:
+                case Device.PHONE_CORDLESS:
+                case Device.PHONE_SMART:
+                case Device.PHONE_MODEM_OR_GATEWAY:
+                case Device.PHONE_ISDN:
+                    return true;
+                default:
+                    return false;
+            }
+        } else if (profile == PROFILE_HID) {
+            return (getDeviceClass() & Device.Major.PERIPHERAL) == Device.Major.PERIPHERAL;
+        } else if (profile == PROFILE_PANU || profile == PROFILE_NAP){
+            // No good way to distinguish between the two, based on class bits.
+            if (hasService(Service.NETWORKING)) {
+                return true;
+            }
+            return (getDeviceClass() & Device.Major.NETWORKING) == Device.Major.NETWORKING;
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothDUN.java b/bluetoothmsm/java/android/bluetooth/BluetoothDUN.java
new file mode 100644
index 0000000..2dd9fc0
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothDUN.java
@@ -0,0 +1,121 @@
+
+/*
+* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*        * Redistributions of source code must retain the above copyright
+*            notice, this list of conditions and the following disclaimer.
+*        * Redistributions in binary form must reproduce the above copyright
+*            notice, this list of conditions and the following disclaimer in the
+*            documentation and/or other materials provided with the distribution.
+*        * Neither the name of Code Aurora nor
+*            the names of its contributors may be used to endorse or promote
+*            products derived from this software without specific prior written
+*            permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+package android.bluetooth;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.RemoteException;
+import android.os.IBinder;
+import android.os.ServiceManager;
+import android.util.Log;
+import android.os.SystemProperties;
+
+/**
+ *
+ * Public API for controlling the Bluetooth Dun Service.
+ *
+ * @hide
+ */
+public class BluetoothDUN {
+
+    private static final String TAG = "BluetoothDUN";
+    private static final boolean DBG = false;
+    private IBluetooth mService;
+
+    public BluetoothDUN() {
+        IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
+        if (b != null) {
+            mService = IBluetooth.Stub.asInterface(b);
+        } else {
+            Log.i(TAG, "Failed to get the Bluetooth Interface");
+        }
+    }
+     /**
+     * Initiate the disconnection from DUN server.
+     * Status of the DUN  server can be determined by the signal emitted
+     * from org.qcom.sap
+     */
+    public boolean disconnect() {
+        Log.i(TAG, "->disconnect");
+        try {
+            mService.disconnectDUN();
+            return true;
+        } catch(RemoteException e) {
+            Log.e(TAG, "", e);
+        }
+
+        return false;
+    }
+
+    /**
+    * Starts the DUN daemon and adds DUN to sdp record
+    */
+    public boolean Enable() {
+        Log.i(TAG, "->enableDUN");
+
+        if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.dun", false) == false) {
+            return false;
+        }
+
+        try {
+            mService.enableDUN();
+            return true;
+        } catch(RemoteException e) {
+            Log.e(TAG, "", e);
+        }
+
+        return false;
+    }
+
+   /**
+   * Stops the DUN daemon and removes DUN from sdp record
+   */
+    public boolean Disable() {
+        Log.i(TAG, "->disableDUN");
+
+        if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.dun", false) == false) {
+            return false;
+        }
+
+        try {
+            mService.disableDUN();
+            return true;
+        } catch(RemoteException e) {
+            Log.e(TAG, "", e);
+        }
+
+        return false;
+    }
+}
+
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothDevice.aidl b/bluetoothmsm/java/android/bluetooth/BluetoothDevice.aidl
new file mode 100644
index 0000000..daae74d
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothDevice.aidl
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+parcelable BluetoothDevice;
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothDevice.java b/bluetoothmsm/java/android/bluetooth/BluetoothDevice.java
new file mode 100644
index 0000000..5ee2429
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothDevice.java
@@ -0,0 +1,1461 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.os.IBinder;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.os.ParcelUuid;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.util.UUID;
+import java.util.Vector;
+
+/**
+ * Represents a remote Bluetooth device. A {@link BluetoothDevice} lets you
+ * create a connection with the respective device or query information about
+ * it, such as the name, address, class, and bonding state.
+ *
+ * <p>This class is really just a thin wrapper for a Bluetooth hardware
+ * address. Objects of this class are immutable. Operations on this class
+ * are performed on the remote Bluetooth hardware address, using the
+ * {@link BluetoothAdapter} that was used to create this {@link
+ * BluetoothDevice}.
+ *
+ * <p>To get a {@link BluetoothDevice}, use
+ * {@link BluetoothAdapter#getRemoteDevice(String)
+ * BluetoothAdapter.getRemoteDevice(String)} to create one representing a device
+ * of a known MAC address (which you can get through device discovery with
+ * {@link BluetoothAdapter}) or get one from the set of bonded devices
+ * returned by {@link BluetoothAdapter#getBondedDevices()
+ * BluetoothAdapter.getBondedDevices()}. You can then open a
+ * {@link BluetoothSocket} for communication with the remote device, using
+ * {@link #createRfcommSocketToServiceRecord(UUID)}.
+ *
+ * <p class="note"><strong>Note:</strong>
+ * Requires the {@link android.Manifest.permission#BLUETOOTH} permission.
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For more information about using Bluetooth, read the
+ * <a href="{@docRoot}guide/topics/wireless/bluetooth.html">Bluetooth</a> developer guide.</p>
+ * </div>
+ *
+ * {@see BluetoothAdapter}
+ * {@see BluetoothSocket}
+ */
+public final class BluetoothDevice implements Parcelable {
+    private static final String TAG = "BluetoothDevice";
+
+    /**
+     * Sentinel error value for this class. Guaranteed to not equal any other
+     * integer constant in this class. Provided as a convenience for functions
+     * that require a sentinel error value, for example:
+     * <p><code>Intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,
+     * BluetoothDevice.ERROR)</code>
+     */
+    public static final int ERROR = Integer.MIN_VALUE;
+
+    /**
+     * Broadcast Action: Remote device discovered.
+     * <p>Sent when a remote device is found during discovery.
+     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link
+     * #EXTRA_CLASS}. Can contain the extra fields {@link #EXTRA_NAME} and/or
+     * {@link #EXTRA_RSSI} if they are available.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     */
+     // TODO: Change API to not broadcast RSSI if not available (incoming connection)
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_FOUND =
+            "android.bluetooth.device.action.FOUND";
+
+    /**
+     * Broadcast Action: Remote device disappeared.
+     * <p>Sent when a remote device that was found in the last discovery is not
+     * found in the current discovery.
+     * <p>Always contains the extra field {@link #EXTRA_DEVICE}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DISAPPEARED =
+            "android.bluetooth.device.action.DISAPPEARED";
+
+    /**
+     * Broadcast Action: Bluetooth class of a remote device has changed.
+     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link
+     * #EXTRA_CLASS}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     * @see {@link BluetoothClass}
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CLASS_CHANGED =
+            "android.bluetooth.device.action.CLASS_CHANGED";
+
+     /**
+     * Broadcast Action: RSSI update from the remote device
+     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link
+     * #EXTRA_RSSI}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_RSSI_UPDATE =
+            "android.bluetooth.device.action.RSSI_UPDATE";
+    /**
+     * Broadcast Action: Negotiated connection parameters update
+     * for the connection between the Gatt server and the remote GATT
+     * client device
+     * <p>Always contains the extra fields {@link #EXTRA_CONN_INTERVAL}
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_LE_CONN_PARAMS =
+            "android.bluetooth.device.action.LE_CONN_PARAMS";
+
+    /**
+     * Broadcast Action: Indicates a low level (ACL) connection has been
+     * established with a remote device.
+     * <p>Always contains the extra field {@link #EXTRA_DEVICE}.
+     * <p>ACL connections are managed automatically by the Android Bluetooth
+     * stack.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_ACL_CONNECTED =
+            "android.bluetooth.device.action.ACL_CONNECTED";
+
+    /**
+     * Broadcast Action: Indicates that a low level (ACL) disconnection has
+     * been requested for a remote device, and it will soon be disconnected.
+     * <p>This is useful for graceful disconnection. Applications should use
+     * this intent as a hint to immediately terminate higher level connections
+     * (RFCOMM, L2CAP, or profile connections) to the remote device.
+     * <p>Always contains the extra field {@link #EXTRA_DEVICE}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_ACL_DISCONNECT_REQUESTED =
+            "android.bluetooth.device.action.ACL_DISCONNECT_REQUESTED";
+
+    /**
+     * Broadcast Action: Indicates a low level (ACL) disconnection from a
+     * remote device.
+     * <p>Always contains the extra field {@link #EXTRA_DEVICE}.
+     * <p>ACL connections are managed automatically by the Android Bluetooth
+     * stack.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_ACL_DISCONNECTED =
+            "android.bluetooth.device.action.ACL_DISCONNECTED";
+
+    /**
+     * Broadcast Action: Indicates the friendly name of a remote device has
+     * been retrieved for the first time, or changed since the last retrieval.
+     * <p>Always contains the extra fields {@link #EXTRA_DEVICE} and {@link
+     * #EXTRA_NAME}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_NAME_CHANGED =
+            "android.bluetooth.device.action.NAME_CHANGED";
+
+    /**
+     * Broadcast Action: Indicates the alias of a remote device has been
+     * changed.
+     * <p>Always contains the extra field {@link #EXTRA_DEVICE}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     *
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_ALIAS_CHANGED =
+            "android.bluetooth.device.action.ALIAS_CHANGED";
+
+    /**
+     * Broadcast Action: Indicates a change in the bond state of a remote
+     * device. For example, if a device is bonded (paired).
+     * <p>Always contains the extra fields {@link #EXTRA_DEVICE}, {@link
+     * #EXTRA_BOND_STATE} and {@link #EXTRA_PREVIOUS_BOND_STATE}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     */
+    // Note: When EXTRA_BOND_STATE is BOND_NONE then this will also
+    // contain a hidden extra field EXTRA_REASON with the result code.
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_BOND_STATE_CHANGED =
+            "android.bluetooth.device.action.BOND_STATE_CHANGED";
+
+    /**
+     * Used as a Parcelable {@link BluetoothDevice} extra field in every intent
+     * broadcast by this class. It contains the {@link BluetoothDevice} that
+     * the intent applies to.
+     */
+    public static final String EXTRA_DEVICE = "android.bluetooth.device.extra.DEVICE";
+
+    /**
+     * Used as a String extra field in {@link #ACTION_NAME_CHANGED} and {@link
+     * #ACTION_FOUND} intents. It contains the friendly Bluetooth name.
+     */
+    public static final String EXTRA_NAME = "android.bluetooth.device.extra.NAME";
+
+    /**
+     * Used as an optional short extra field in {@link #ACTION_FOUND} intents.
+     * Contains the RSSI value of the remote device as reported by the
+     * Bluetooth hardware.
+     */
+    public static final String EXTRA_RSSI = "android.bluetooth.device.extra.RSSI";
+    /**
+     * Used as a String extra field in {ACTION_FOUND} intent.
+     * It contains the comma separated uuid string values of services.
+     * @hide
+     */
+    public static final String EXTRA_UUIDS = "android.bluetooth.device.extra.UUIDS";
+    /**
+     * Used as an UINT 16 extra field in {ACTION_LE_CONN_PARAMS} intent.
+     * It contains the negotiated connection interval value after establishing LE connection.
+     * @hide */
+    public static final String EXTRA_CONN_INTERVAL = "android.bluetooth.device.extra.CONN_INTERVAL";
+
+    /**
+     * Used as a Parcelable {@link BluetoothClass} extra field in {@link
+     * #ACTION_FOUND} and {@link #ACTION_CLASS_CHANGED} intents.
+     */
+    public static final String EXTRA_CLASS = "android.bluetooth.device.extra.CLASS";
+
+    /**
+     * Used as an int extra field in {@link #ACTION_BOND_STATE_CHANGED} intents.
+     * Contains the bond state of the remote device.
+     * <p>Possible values are:
+     * {@link #BOND_NONE},
+     * {@link #BOND_BONDING},
+     * {@link #BOND_BONDED}.
+      */
+    public static final String EXTRA_BOND_STATE = "android.bluetooth.device.extra.BOND_STATE";
+    /**
+     * Used as an int extra field in {@link #ACTION_BOND_STATE_CHANGED} intents.
+     * Contains the previous bond state of the remote device.
+     * <p>Possible values are:
+     * {@link #BOND_NONE},
+     * {@link #BOND_BONDING},
+     * {@link #BOND_BONDED}.
+      */
+    public static final String EXTRA_PREVIOUS_BOND_STATE =
+            "android.bluetooth.device.extra.PREVIOUS_BOND_STATE";
+
+    /** @hide */
+    public static final String EXTRA_SECURE_PAIRING = "android.bluetooth.device.extra.SECURE";
+
+    /**
+     * Indicates the remote device is not bonded (paired).
+     * <p>There is no shared link key with the remote device, so communication
+     * (if it is allowed at all) will be unauthenticated and unencrypted.
+     */
+    public static final int BOND_NONE = 10;
+    /**
+     * Indicates bonding (pairing) is in progress with the remote device.
+     */
+    public static final int BOND_BONDING = 11;
+    /**
+     * Indicates the remote device is bonded (paired).
+     * <p>A shared link keys exists locally for the remote device, so
+     * communication can be authenticated and encrypted.
+     * <p><i>Being bonded (paired) with a remote device does not necessarily
+     * mean the device is currently connected. It just means that the pending
+     * procedure was completed at some earlier time, and the link key is still
+     * stored locally, ready to use on the next connection.
+     * </i>
+     */
+    public static final int BOND_BONDED = 12;
+
+    /**
+     * This bonding state will be used, When auto pairing fails and
+     * retry the manual bonding process.
+     * @hide */
+    public static final int BOND_RETRY = 13;
+
+    /** @hide */
+    public static final String EXTRA_REASON = "android.bluetooth.device.extra.REASON";
+    /** @hide */
+    public static final String EXTRA_PAIRING_VARIANT =
+            "android.bluetooth.device.extra.PAIRING_VARIANT";
+    /** @hide */
+    public static final String EXTRA_PAIRING_KEY = "android.bluetooth.device.extra.PAIRING_KEY";
+
+    /**
+     * Broadcast Action: This intent is used to broadcast the {@link UUID}
+     * wrapped as a {@link android.os.ParcelUuid} of the remote device after it
+     * has been fetched. This intent is sent only when the UUIDs of the remote
+     * device are requested to be fetched using Service Discovery Protocol
+     * <p> Always contains the extra field {@link #EXTRA_DEVICE}
+     * <p> Always contains the extra field {@link #EXTRA_UUID}
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_UUID =
+            "android.bluetooth.device.action.UUID";
+
+    /**
+     * Broadcast Action: Indicates a failure to retrieve the name of a remote
+     * device.
+     * <p>Always contains the extra field {@link #EXTRA_DEVICE}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     * @hide
+     */
+    //TODO: is this actually useful?
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_NAME_FAILED =
+            "android.bluetooth.device.action.NAME_FAILED";
+
+    /** @hide */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PAIRING_REQUEST =
+            "android.bluetooth.device.action.PAIRING_REQUEST";
+    /** @hide */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PAIRING_CANCEL =
+            "android.bluetooth.device.action.PAIRING_CANCEL";
+
+    /** @hide */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CONNECTION_ACCESS_REQUEST =
+            "android.bluetooth.device.action.CONNECTION_ACCESS_REQUEST";
+
+    /** @hide */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CONNECTION_ACCESS_REPLY =
+            "android.bluetooth.device.action.CONNECTION_ACCESS_REPLY";
+
+    /** @hide */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CONNECTION_ACCESS_CANCEL =
+            "android.bluetooth.device.action.CONNECTION_ACCESS_CANCEL";
+
+    /**
+     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REQUEST} intent.
+     * @hide
+     */
+    public static final String EXTRA_ACCESS_REQUEST_TYPE =
+        "android.bluetooth.device.extra.ACCESS_REQUEST_TYPE";
+
+    /**@hide*/
+    public static final int REQUEST_TYPE_PROFILE_CONNECTION = 1;
+
+    /**@hide*/
+    public static final int REQUEST_TYPE_PHONEBOOK_ACCESS = 2;
+
+    /**@hide*/
+    public static final int REQUEST_TYPE_FILE_ACCESS = 3;
+
+    /**@hide*/
+    public static final int REQUEST_TYPE_MESSAGE_ACCESS = 4;
+
+    /**@hide*/
+    public static final int REQUEST_TYPE_SIM_ACCESS = 5;
+
+    /**@hide*/
+    public static final int REQUEST_TYPE_DUN_ACCESS = 6;
+
+    /**
+     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REQUEST} intents,
+     * Contains package name to return reply intent to.
+     * @hide
+     */
+    public static final String EXTRA_PACKAGE_NAME = "android.bluetooth.device.extra.PACKAGE_NAME";
+
+    /**
+     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REQUEST} intents,
+     * Contains class name to return reply intent to.
+     * @hide
+     */
+    public static final String EXTRA_CLASS_NAME = "android.bluetooth.device.extra.CLASS_NAME";
+
+    /**
+     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REPLY} intent.
+     * @hide
+     */
+    public static final String EXTRA_CONNECTION_ACCESS_RESULT =
+        "android.bluetooth.device.extra.CONNECTION_ACCESS_RESULT";
+
+    /**@hide*/
+    public static final int CONNECTION_ACCESS_YES = 1;
+
+    /**@hide*/
+    public static final int CONNECTION_ACCESS_NO = 2;
+
+    /**
+     * Used as an extra field in {@link #ACTION_CONNECTION_ACCESS_REPLY} intents,
+     * Contains boolean to indicate if the allowed response is once-for-all so that
+     * next request will be granted without asking user again.
+     * @hide
+     */
+    public static final String EXTRA_ALWAYS_ALLOWED =
+        "android.bluetooth.device.extra.ALWAYS_ALLOWED";
+
+    /**
+     * A bond attempt succeeded
+     * @hide
+     */
+    public static final String ACTION_GATT =
+            "android.bluetooth.device.action.GATT";
+
+    /** A bond attempt succeeded
+     * @hide */
+    public static final int BOND_SUCCESS = 0;
+
+    /**
+     * A bond attempt failed because pins did not match, or remote device did
+     * not respond to pin request in time
+     * @hide
+     */
+    public static final int UNBOND_REASON_AUTH_FAILED = 1;
+
+    /**
+     * A bond attempt failed because the other side explicitly rejected
+     * bonding
+     * @hide
+     */
+    public static final int UNBOND_REASON_AUTH_REJECTED = 2;
+
+    /**
+     * A bond attempt failed because we canceled the bonding process
+     * @hide
+     */
+    public static final int UNBOND_REASON_AUTH_CANCELED = 3;
+
+    /**
+     * A bond attempt failed because we could not contact the remote device
+     * @hide
+     */
+    public static final int UNBOND_REASON_REMOTE_DEVICE_DOWN = 4;
+
+    /**
+     * A bond attempt failed because a discovery is in progress
+     * @hide
+     */
+    public static final int UNBOND_REASON_DISCOVERY_IN_PROGRESS = 5;
+
+    /**
+     * A bond attempt failed because of authentication timeout
+     * @hide
+     */
+    public static final int UNBOND_REASON_AUTH_TIMEOUT = 6;
+
+    /**
+     * A bond attempt failed because of repeated attempts
+     * @hide
+     */
+    public static final int UNBOND_REASON_REPEATED_ATTEMPTS = 7;
+
+    /**
+     * A bond attempt failed because we received an Authentication Cancel
+     * by remote end
+     * @hide
+     */
+    public static final int UNBOND_REASON_REMOTE_AUTH_CANCELED = 8;
+
+    /**
+     * An existing bond was explicitly revoked
+     * @hide
+     */
+    public static final int UNBOND_REASON_REMOVED = 9;
+
+    /**
+     * The user will be prompted to enter a pin
+     * @hide
+     */
+    public static final int PAIRING_VARIANT_PIN = 0;
+
+    /**
+     * The user will be prompted to enter a passkey
+     * @hide
+     */
+    public static final int PAIRING_VARIANT_PASSKEY = 1;
+
+    /**
+     * The user will be prompted to confirm the passkey displayed on the screen
+     * @hide
+     */
+    public static final int PAIRING_VARIANT_PASSKEY_CONFIRMATION = 2;
+
+    /**
+     * The user will be prompted to accept or deny the incoming pairing request
+     * @hide
+     */
+    public static final int PAIRING_VARIANT_CONSENT = 3;
+
+    /**
+     * The user will be prompted to enter the passkey displayed on remote device
+     * This is used for Bluetooth 2.1 pairing.
+     * @hide
+     */
+    public static final int PAIRING_VARIANT_DISPLAY_PASSKEY = 4;
+
+    /**
+     * The user will be prompted to enter the PIN displayed on remote device.
+     * This is used for Bluetooth 2.0 pairing.
+     * @hide
+     */
+    public static final int PAIRING_VARIANT_DISPLAY_PIN = 5;
+
+    /**
+     * The user will be prompted to accept or deny the OOB pairing request
+     * @hide
+     */
+    public static final int PAIRING_VARIANT_OOB_CONSENT = 6;
+
+    /**
+     * Used as an extra field in {@link #ACTION_UUID} intents,
+     * Contains the {@link android.os.ParcelUuid}s of the remote device which
+     * is a parcelable version of {@link UUID}.
+     */
+    public static final String EXTRA_UUID = "android.bluetooth.device.extra.UUID";
+    /**
+     * Used as an extra field in ACTION_GATT intent.
+     * Contains the object paths of the GATT based services on remote device.
+     * @hide
+     */
+    public static final String EXTRA_GATT = "android.bluetooth.device.extra.GATT";
+    /**
+     * Used as an extra field in ACTION_GATT intent.
+     * Contains the result code for GATT service discovery.
+     * @hide
+     */
+    public static final String EXTRA_GATT_RESULT = "android.bluetooth.device.extra.GATT_RESULT";
+
+    /** A GATT request was successful.
+     * @hide */
+    public static final int GATT_RESULT_SUCCESS = 0;
+    /** A GATT request failed due to timeout.
+     * @hide */
+    public static final int GATT_RESULT_TIMEOUT = 1;
+    /** A GATT request failed (generic cause).
+     * @hide */
+    public static final int GATT_RESULT_FAIL = 2;
+   /** A GATT request cannot be completed  because of busy state.
+     * @hide */
+    public static final int GATT_RESULT_BUSY = 3;
+    /** A GATT operation requested on disconnected device.
+     * @hide */
+    public static final int GATT_RESULT_NOT_CONNECTED = 4;
+    /** A GATT LE connect request on existing connection.
+     * @hide */
+    public static final int GATT_ALREADY_CONNECTED = 5;
+    /** A GATT operation not supported.
+     * @hide */
+    public static final int GATT_RESULT_NOT_SUPPORTED= 6;
+
+    /**
+     * Used as an extra field for SAP state change events.
+     * @hide
+     */
+    public static final String SAP_STATE_CHANGED = "com.android.bluetooth.sap.statechanged";
+
+    /**
+     * Used as an extra field for DUN state change events.
+     * @hide
+     */
+    public static final String DUN_STATE_CHANGED = "com.android.bluetooth.dun.statechanged";
+    /**
+     * Lazy initialization. Guaranteed final after first object constructed, or
+     * getService() called.
+     * TODO: Unify implementation of sService amongst BluetoothFoo API's
+     */
+    private static IBluetooth sService;
+
+    private final String mAddress;
+
+    /*package*/ static IBluetooth getService() {
+        synchronized (BluetoothDevice.class) {
+            if (sService == null) {
+                IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
+                if (b == null) {
+                    throw new RuntimeException("Bluetooth service not available");
+                }
+                sService = IBluetooth.Stub.asInterface(b);
+            }
+        }
+        return sService;
+    }
+
+    /**
+     * Create a new BluetoothDevice
+     * Bluetooth MAC address must be upper case, such as "00:11:22:33:AA:BB",
+     * and is validated in this constructor.
+     * @param address valid Bluetooth MAC address
+     * @throws RuntimeException Bluetooth is not available on this platform
+     * @throws IllegalArgumentException address is invalid
+     * @hide
+     */
+    /*package*/ BluetoothDevice(String address) {
+        getService();  // ensures sService is initialized
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            throw new IllegalArgumentException(address + " is not a valid Bluetooth address");
+        }
+
+        mAddress = address;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof BluetoothDevice) {
+            return mAddress.equals(((BluetoothDevice)o).getAddress());
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        return mAddress.hashCode();
+    }
+
+    /**
+     * Returns a string representation of this BluetoothDevice.
+     * <p>Currently this is the Bluetooth hardware address, for example
+     * "00:11:22:AA:BB:CC". However, you should always use {@link #getAddress}
+     * if you explicitly require the Bluetooth hardware address in case the
+     * {@link #toString} representation changes in the future.
+     * @return string representation of this BluetoothDevice
+     */
+    @Override
+    public String toString() {
+        return mAddress;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public static final Parcelable.Creator<BluetoothDevice> CREATOR =
+            new Parcelable.Creator<BluetoothDevice>() {
+        public BluetoothDevice createFromParcel(Parcel in) {
+            return new BluetoothDevice(in.readString());
+        }
+        public BluetoothDevice[] newArray(int size) {
+            return new BluetoothDevice[size];
+        }
+    };
+
+    public void writeToParcel(Parcel out, int flags) {
+        out.writeString(mAddress);
+    }
+
+    /**
+     * Returns the hardware address of this BluetoothDevice.
+     * <p> For example, "00:11:22:AA:BB:CC".
+     * @return Bluetooth hardware address as string
+     */
+    public String getAddress() {
+        return mAddress;
+    }
+
+    /**
+     * Get the friendly Bluetooth name of the remote device.
+     *
+     * <p>The local adapter will automatically retrieve remote names when
+     * performing a device scan, and will cache them. This method just returns
+     * the name for this device from the cache.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @return the Bluetooth name, or null if there was a problem.
+     */
+    public String getName() {
+        try {
+            return sService.getRemoteName(mAddress);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return null;
+    }
+
+    /**
+     * Get the Bluetooth alias of the remote device.
+     * <p>Alias is the locally modified name of a remote device.
+     *
+     * @return the Bluetooth alias, or null if no alias or there was a problem
+     * @hide
+     */
+    public String getAlias() {
+        try {
+            return sService.getRemoteAlias(mAddress);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return null;
+    }
+
+    /**
+     * Set the Bluetooth alias of the remote device.
+     * <p>Alias is the locally modified name of a remote device.
+     * <p>This methoid overwrites the alias. The changed
+     * alias is saved in the local storage so that the change
+     * is preserved over power cycle.
+     *
+     * @return true on success, false on error
+     * @hide
+     */
+    public boolean setAlias(String alias) {
+        try {
+            return sService.setRemoteAlias(mAddress, alias);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Get the Bluetooth alias of the remote device.
+     * If Alias is null, get the Bluetooth name instead.
+     * @see #getAlias()
+     * @see #getName()
+     *
+     * @return the Bluetooth alias, or null if no alias or there was a problem
+     * @hide
+     */
+    public String getAliasName() {
+        String name = getAlias();
+        if (name == null) {
+            name = getName();
+        }
+        return name;
+    }
+
+    /**
+     * Start the bonding (pairing) process with the remote device.
+     * <p>This is an asynchronous call, it will return immediately. Register
+     * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
+     * the bonding process completes, and its result.
+     * <p>Android system services will handle the necessary user interactions
+     * to confirm and complete the bonding process.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
+     *
+     * @return false on immediate error, true if bonding will begin
+     * @hide
+     */
+    public boolean createBond() {
+        try {
+            return sService.createBond(mAddress);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+     /**
+     * Register the watcher for monitoring RSSI of the remote device.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+     *
+     * @param rssiThreshold
+     * @param interval
+     * @param updateOnThreshExceed
+     * @hide
+     */
+   public boolean registerRssiUpdateWatcher(int rssiThreshold, int interval,
+                                             boolean updateOnThreshExceed) {
+        try {
+            return sService.registerRssiUpdateWatcher(mAddress,
+                                                      rssiThreshold,
+                                                      interval,
+                                                      updateOnThreshExceed);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+     /**
+     * Unregister the watcher for monitoring RSSI of the remote
+     * device.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+     *
+     * @hide
+     */
+    public boolean unregisterRssiUpdateWatcher() {
+        try {
+            return sService.unregisterRssiUpdateWatcher(mAddress);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Start the bonding (pairing) process with the remote device using the
+     * Out Of Band mechanism.
+     *
+     * <p>This is an asynchronous call, it will return immediately. Register
+     * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
+     * the bonding process completes, and its result.
+     *
+     * <p>Android system services will handle the necessary user interactions
+     * to confirm and complete the bonding process.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
+     *
+     * @param hash - Simple Secure pairing hash
+     * @param randomizer - The random key obtained using OOB
+     * @return false on immediate error, true if bonding will begin
+     *
+     * @hide
+     */
+    public boolean createBondOutOfBand(byte[] hash, byte[] randomizer) {
+        try {
+            return sService.createBondOutOfBand(mAddress, hash, randomizer);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Set the Out Of Band data for a remote device to be used later
+     * in the pairing mechanism. Users can obtain this data through other
+     * trusted channels
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
+     *
+     * @param hash Simple Secure pairing hash
+     * @param randomizer The random key obtained using OOB
+     * @return false on error; true otherwise
+     *
+     * @hide
+     */
+    public boolean setDeviceOutOfBandData(byte[] hash, byte[] randomizer) {
+      try {
+        return sService.setDeviceOutOfBandData(mAddress, hash, randomizer);
+      } catch (RemoteException e) {Log.e(TAG, "", e);}
+      return false;
+    }
+
+    /**
+     * Cancel an in-progress bonding request started with {@link #createBond}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
+     *
+     * @return true on success, false on error
+     * @hide
+     */
+    public boolean cancelBondProcess() {
+        try {
+            return sService.cancelBondProcess(mAddress);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Remove bond (pairing) with the remote device.
+     * <p>Delete the link key associated with the remote device, and
+     * immediately terminate connections to that device that require
+     * authentication and encryption.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
+     *
+     * @return true on success, false on error
+     * @hide
+     */
+    public boolean removeBond() {
+        try {
+            return sService.removeBond(mAddress);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Get the bond state of the remote device.
+     * <p>Possible values for the bond state are:
+     * {@link #BOND_NONE},
+     * {@link #BOND_BONDING},
+     * {@link #BOND_BONDED}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+     *
+     * @return the bond state
+     */
+    public int getBondState() {
+        try {
+            return sService.getBondState(mAddress);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return BOND_NONE;
+    }
+
+    /**
+     * Get the Bluetooth class of the remote device.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+     *
+     * @return Bluetooth class object, or null on error
+     */
+    public BluetoothClass getBluetoothClass() {
+        try {
+            int classInt = sService.getRemoteClass(mAddress);
+            if (classInt == BluetoothClass.ERROR) return null;
+            return new BluetoothClass(classInt);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return null;
+    }
+
+    /**
+     * Set the Bluetooth class of the remote device.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+     *
+     * @param classOfDevice the Bluetooth COD value to be set
+     * @hide
+     */
+    public boolean setBluetoothClass(int classOfDevice) {
+        try {
+            return sService.setBluetoothClass(mAddress, classOfDevice);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Set the preferred connection parameters of the remote device.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+     *
+     * @param connection parameters values.
+     * @hide
+     */
+    public boolean setLEConnectionParams(byte prohibitRemoteChg,
+                                         byte filterPolicy,
+                                         int scanInterval,
+                                         int scanWindow,
+                                         int intervalMin,
+                                         int intervalMax,
+                                         int latency,
+                                         int superVisionTimeout,
+                                         int minCeLen,
+                                         int maxCeLen,
+                                         int connTimeout) {
+        try {
+            return sService.setLEConnectionParams(mAddress,
+                                                  prohibitRemoteChg,
+                                                  filterPolicy,
+                                                  scanInterval,
+                                                  scanWindow,
+                                                  intervalMin,
+                                                  intervalMax,
+                                                  latency,
+                                                  superVisionTimeout,
+                                                  minCeLen,
+                                                  maxCeLen,
+                                                  connTimeout
+                                                  );
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Update the LE connection parameters of the remote device.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+     *
+     * @param connection parameters values.
+     * @hide
+     */
+    public boolean updateLEConnectionParams(byte prohibitRemoteChg,
+                                            int intervalMin,
+                                            int intervalMax,
+                                            int slaveLatency,
+                                            int supervisionTimeout) {
+        try {
+            return sService.updateLEConnectionParams(mAddress,
+                                                prohibitRemoteChg,
+                                                intervalMin,
+                                                intervalMax,
+                                                slaveLatency,
+                                                supervisionTimeout);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Get trust state of a remote device.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+     * @hide
+     */
+    public boolean getTrustState() {
+        try {
+            return sService.getTrustState(mAddress);
+        } catch (RemoteException e) {
+            Log.e(TAG, "", e);
+        }
+        return false;
+    }
+
+    /**
+     * Set trust state for a remote device.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
+     * @param value the trust state value (true or false)
+     * @hide
+     */
+    public boolean setTrust(boolean value) {
+        try {
+            return sService.setTrust(mAddress, value);
+        } catch (RemoteException e) {
+            Log.e(TAG, "", e);
+        }
+        return false;
+    }
+
+    /**
+     * Returns the supported features (UUIDs) of the remote device.
+     *
+     * <p>This method does not start a service discovery procedure to retrieve the UUIDs
+     * from the remote device. Instead, the local cached copy of the service
+     * UUIDs are returned.
+     * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+     *
+     * @return the supported features (UUIDs) of the remote device,
+     *         or null on error
+     */
+     public ParcelUuid[] getUuids() {
+        try {
+            return sService.getRemoteUuids(mAddress);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return null;
+    }
+
+     /**
+      * Perform a service discovery on the remote device to get the UUIDs supported.
+      *
+      * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
+      * with the UUIDs supported by the remote end. If there is an error
+      * in getting the SDP records or if the process takes a long time,
+      * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
+      * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
+      * if service discovery is not to be performed.
+      * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
+      *
+      * @return False if the sanity check fails, True if the process
+      *               of initiating an ACL connection to the remote device
+      *               was started.
+      */
+     public boolean fetchUuidsWithSdp() {
+        try {
+            return sService.fetchRemoteUuids(mAddress, null, null);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /** @hide */
+    public int getServiceChannel(ParcelUuid uuid) {
+         try {
+             return sService.getRemoteServiceChannel(mAddress, uuid);
+         } catch (RemoteException e) {Log.e(TAG, "", e);}
+         return BluetoothDevice.ERROR;
+    }
+
+    /** @hide */
+    public int getL2capPsm(ParcelUuid uuid) {
+         try {
+             return sService.getRemoteL2capPsm(mAddress, uuid);
+         } catch (RemoteException e) {Log.e(TAG, "", e);}
+         return BluetoothDevice.ERROR;
+    }
+
+    /** @hide */
+    public String getFeature(String feature) {
+         try {
+             return sService.getRemoteFeature(mAddress, feature);
+         } catch (RemoteException e) {Log.e(TAG, "", e);}
+         return null;
+    }
+
+    /** @hide */
+    public boolean setPin(byte[] pin) {
+        try {
+            return sService.setPin(mAddress, pin);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /** @hide */
+    public boolean setPasskey(int passkey) {
+        try {
+            return sService.setPasskey(mAddress, passkey);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /** @hide */
+    public boolean setPairingConfirmation(boolean confirm) {
+        try {
+            return sService.setPairingConfirmation(mAddress, confirm);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /** @hide */
+    public boolean setRemoteOutOfBandData() {
+        try {
+          return sService.setRemoteOutOfBandData(mAddress);
+      } catch (RemoteException e) {Log.e(TAG, "", e);}
+      return false;
+    }
+
+    /** @hide */
+    public boolean cancelPairingUserInput() {
+        try {
+            return sService.cancelPairingUserInput(mAddress);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /** @hide */
+    public boolean isBluetoothDock() {
+        try {
+            return sService.isBluetoothDock(mAddress);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        return false;
+    }
+
+    /**
+     * Create an RFCOMM {@link BluetoothSocket} ready to start a secure
+     * outgoing connection to this remote device on given channel.
+     * <p>The remote device will be authenticated and communication on this
+     * socket will be encrypted.
+     * <p> Use this socket only if an authenticated socket link is possible.
+     * Authentication refers to the authentication of the link key to
+     * prevent man-in-the-middle type of attacks.
+     * For example, for Bluetooth 2.1 devices, if any of the devices does not
+     * have an input and output capability or just has the ability to
+     * display a numeric key, a secure socket connection is not possible.
+     * In such a case, use {#link createInsecureRfcommSocket}.
+     * For more details, refer to the Security Model section 5.2 (vol 3) of
+     * Bluetooth Core Specification version 2.1 + EDR.
+     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
+     * connection.
+     * <p>Valid RFCOMM channels are in range 1 to 30.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @param channel RFCOMM channel to connect to
+     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions
+     * @hide
+     */
+    public BluetoothSocket createRfcommSocket(int channel) throws IOException {
+        return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, true, true, this, channel,
+                null);
+    }
+
+    /**
+     * Create an L2Cap {@link BluetoothSocket} ready to start a secure
+     * outgoing connection to this remote device on given channel.
+     * <p>The remote device will be authenticated and communication on this
+     * socket will be encrypted.
+     * <p>Use {@link BluetoothSocket#connect} to intiate the outgoing
+     * connection.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @param psm L2Cap psm to connect to
+     * @return a L2Cap BluetoothSocket ready for an outgoing connection
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions
+     * @hide
+     */
+    public BluetoothSocket createL2capSocket(int psm) throws IOException {
+        return new BluetoothSocket(BluetoothSocket.TYPE_L2CAP, -1, true, true, this, psm,
+                null);
+    }
+
+    /**
+     * Create an L2Cap {@link BluetoothSocket} ready to start an insecure
+     * outgoing connection to this remote device on given channel.
+     * <p>The remote device not will be authenticated and communication on this
+     * socket will not be encrypted.
+     * <p>Use {@link BluetoothSocket#connect} to intiate the outgoing
+     * connection.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @param psm L2Cap psm to connect to
+     * @return a L2Cap BluetoothSocket ready for an outgoing connection
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions
+     * @hide
+     */
+    public BluetoothSocket createInsecureL2capSocket(int psm) throws IOException {
+        return new BluetoothSocket(BluetoothSocket.TYPE_L2CAP, -1, false, false, this, psm,
+                null);
+    }
+
+    /**
+     * Create an EL2CAP {@link BluetoothSocket} ready to start a secure
+     * outgoing connection to this remote device on given channel.
+     * <p>The remote device will be authenticated and communication on this
+     * socket will be encrypted.
+     * <p>Use {@link BluetoothSocket#connect} to intiate the outgoing
+     * connection.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @param psm L2Cap psm to connect to
+     * @return a L2Cap BluetoothSocket ready for an outgoing connection
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions
+     * @hide
+     */
+    public BluetoothSocket createEl2capSocket(int psm) throws IOException {
+        return new BluetoothSocket(BluetoothSocket.TYPE_EL2CAP, -1, true, true, this, psm,
+                null);
+    }
+
+    /**
+     * Create an EL2CAP {@link BluetoothSocket} ready to start an insecure
+     * outgoing connection to this remote device on given channel.
+     * <p>The remote device not will be authenticated and communication on this
+     * socket will not be encrypted.
+     * <p>Use {@link BluetoothSocket#connect} to intiate the outgoing
+     * connection.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @param psm L2Cap psm to connect to
+     * @return a L2Cap BluetoothSocket ready for an outgoing connection
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions
+     * @hide
+     */
+    public BluetoothSocket createInsecureEl2capSocket(int psm) throws IOException {
+        return new BluetoothSocket(BluetoothSocket.TYPE_EL2CAP, -1, false, false, this, psm,
+                null);
+    }
+
+    /**
+     * Create an RFCOMM {@link BluetoothSocket} ready to start a secure
+     * outgoing connection to this remote device using SDP lookup of uuid.
+     * <p>This is designed to be used with {@link
+     * BluetoothAdapter#listenUsingRfcommWithServiceRecord} for peer-peer
+     * Bluetooth applications.
+     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
+     * connection. This will also perform an SDP lookup of the given uuid to
+     * determine which channel to connect to.
+     * <p>The remote device will be authenticated and communication on this
+     * socket will be encrypted.
+     * <p> Use this socket only if an authenticated socket link is possible.
+     * Authentication refers to the authentication of the link key to
+     * prevent man-in-the-middle type of attacks.
+     * For example, for Bluetooth 2.1 devices, if any of the devices does not
+     * have an input and output capability or just has the ability to
+     * display a numeric key, a secure socket connection is not possible.
+     * In such a case, use {#link createInsecureRfcommSocketToServiceRecord}.
+     * For more details, refer to the Security Model section 5.2 (vol 3) of
+     * Bluetooth Core Specification version 2.1 + EDR.
+     * <p>Hint: If you are connecting to a Bluetooth serial board then try
+     * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
+     * However if you are connecting to an Android peer then please generate
+     * your own unique UUID.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @param uuid service record uuid to lookup RFCOMM channel
+     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions
+     */
+    public BluetoothSocket createRfcommSocketToServiceRecord(UUID uuid) throws IOException {
+        return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, true, true, this, -1,
+                new ParcelUuid(uuid));
+    }
+
+    /**
+     * Create an RFCOMM {@link BluetoothSocket} socket ready to start an insecure
+     * outgoing connection to this remote device using SDP lookup of uuid.
+     * <p> The communication channel will not have an authenticated link key
+     * i.e it will be subject to man-in-the-middle attacks. For Bluetooth 2.1
+     * devices, the link key will be encrypted, as encryption is mandatory.
+     * For legacy devices (pre Bluetooth 2.1 devices) the link key will
+     * be not be encrypted. Use {@link #createRfcommSocketToServiceRecord} if an
+     * encrypted and authenticated communication channel is desired.
+     * <p>This is designed to be used with {@link
+     * BluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord} for peer-peer
+     * Bluetooth applications.
+     * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
+     * connection. This will also perform an SDP lookup of the given uuid to
+     * determine which channel to connect to.
+     * <p>The remote device will be authenticated and communication on this
+     * socket will be encrypted.
+     * <p>Hint: If you are connecting to a Bluetooth serial board then try
+     * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
+     * However if you are connecting to an Android peer then please generate
+     * your own unique UUID.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
+     *
+     * @param uuid service record uuid to lookup RFCOMM channel
+     * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions
+     */
+    public BluetoothSocket createInsecureRfcommSocketToServiceRecord(UUID uuid) throws IOException {
+        return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, false, false, this, -1,
+                new ParcelUuid(uuid));
+    }
+
+    /**
+     * Construct an insecure RFCOMM socket ready to start an outgoing
+     * connection.
+     * Call #connect on the returned #BluetoothSocket to begin the connection.
+     * The remote device will not be authenticated and communication on this
+     * socket will not be encrypted.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     *
+     * @param port    remote port
+     * @return An RFCOMM BluetoothSocket
+     * @throws IOException On error, for example Bluetooth not available, or
+     *                     insufficient permissions.
+     * @hide
+     */
+    public BluetoothSocket createInsecureRfcommSocket(int port) throws IOException {
+        return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, false, false, this, port,
+                null);
+    }
+
+    /**
+     * Construct a SCO socket ready to start an outgoing connection.
+     * Call #connect on the returned #BluetoothSocket to begin the connection.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     *
+     * @return a SCO BluetoothSocket
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions.
+     * @hide
+     */
+    public BluetoothSocket createScoSocket() throws IOException {
+        return new BluetoothSocket(BluetoothSocket.TYPE_SCO, -1, true, true, this, -1, null);
+    }
+
+    /**
+     * Construct a SCO socket for WBS ready to start an outgoing connection.
+     * Call #connect on the returned #BluetoothSocket to begin the connection.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     *
+     * @return a SCO BluetoothSocket
+     * @throws IOException on error, for example Bluetooth not available, or
+     *                     insufficient permissions.
+     * @hide
+     */
+    public BluetoothSocket createScoWbsSocket() throws IOException {
+        return new BluetoothSocket(BluetoothSocket.TYPE_SCO_WBS, -1, true, true, this, -1, null);
+    }
+
+    /**
+     * Check that a pin is valid and convert to byte array.
+     *
+     * Bluetooth pin's are 1 to 16 bytes of UTF-8 characters.
+     * @param pin pin as java String
+     * @return the pin code as a UTF-8 byte array, or null if it is an invalid
+     *         Bluetooth pin.
+     * @hide
+     */
+    public static byte[] convertPinToBytes(String pin) {
+        if (pin == null) {
+            return null;
+        }
+        byte[] pinBytes;
+        try {
+            pinBytes = pin.getBytes("UTF-8");
+        } catch (UnsupportedEncodingException uee) {
+            Log.e(TAG, "UTF-8 not supported?!?");  // this should not happen
+            return null;
+        }
+        if (pinBytes.length <= 0 || pinBytes.length > 16) {
+            return null;
+        }
+        return pinBytes;
+    }
+
+   /**
+     * Broadcast Action
+     * Always contains the extra field {EXTRA_DEVICE}
+     * Always contains the extra field {EXTRA_UUID}
+     * Always contains the extra filed {EXTRA_PATH}
+     * Requires BLUETOOTH to receive.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_GATT_SERVICE =
+            "android.bleutooth.device.action.GATT_SERVICE";
+
+  /**
+     * Broadcast Action
+     * Requires BLUETOOTH to receive.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_GATT_SERVICE_CHANGED =
+            "android.bleutooth.device.action.GATT_SERVICES_CHANGED";
+
+   /**
+     * Get GATT-based service for a given UUID.
+     *
+     *
+     * @param uuid GATT service UUID
+     * @return False, if internal checks fail; True if the process of
+     *             retrieving information about GATT services was started.
+     *
+     * @hide
+     */
+    public boolean getGattServices(UUID uuid) {
+
+        ParcelUuid convertUuid = new ParcelUuid(uuid);
+
+        try {
+            return sService.getGattServices(mAddress, convertUuid);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+        return false;
+    }
+
+    /**
+     * Get all GATT-based services on the remote device..
+     *
+     * @return False, if internal checks fail; True if the process of
+     *             retrieving information about GATT services was started.
+     *
+     * @hide
+     */
+    public boolean getGattServices() {
+
+        try {
+            return sService.getGattServices(mAddress, null);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+        return false;
+    }
+    /**
+     * Add device to Preferred devices list
+     * @param pListCallback The callback to notify the application regarding
+     * whether the add device to Preferred devices list request has been sent or not.
+     *
+     * @return false, if internal checks fail; True if the process of
+     *         adding device to preferred devices list was started.
+     *
+     * @hide
+     */
+    public boolean addToPreferredDeviceList(IBluetoothPreferredDeviceListCallback pListCallback) {
+        Log.d(TAG, "BT device addToPreferredDeviceList");
+        try {
+            return sService.addToPreferredDeviceList(mAddress, pListCallback);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+        return false;
+    }
+    /**
+     * Remove device from Preferred devices list
+     * @param pListCallback The callback to notify the application regarding
+     * whether the remove device from Preferred devices list request has been sent or not.
+     * @return False, if internal checks fail; True if the process of
+     * removing device from preferred devices list was started.
+     *
+     * @hide
+     */
+    public boolean removeFromPreferredDeviceList(IBluetoothPreferredDeviceListCallback pListCallback) {
+        Log.d(TAG, "BT device removeFromPreferredDeviceList");
+        try {
+            return sService.removeFromPreferredDeviceList(mAddress, pListCallback);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+        return false;
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothDevicePicker.java b/bluetoothmsm/java/android/bluetooth/BluetoothDevicePicker.java
new file mode 100644
index 0000000..c794be2
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothDevicePicker.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+
+/**
+ * A helper to show a system "Device Picker" activity to the user.
+ *
+ * @hide
+ */
+public interface BluetoothDevicePicker {
+    public static final String EXTRA_NEED_AUTH =
+            "android.bluetooth.devicepicker.extra.NEED_AUTH";
+    public static final String EXTRA_FILTER_TYPE =
+            "android.bluetooth.devicepicker.extra.FILTER_TYPE";
+    public static final String EXTRA_LAUNCH_PACKAGE =
+            "android.bluetooth.devicepicker.extra.LAUNCH_PACKAGE";
+    public static final String EXTRA_LAUNCH_CLASS =
+            "android.bluetooth.devicepicker.extra.DEVICE_PICKER_LAUNCH_CLASS";
+
+    /**
+     * Broadcast when one BT device is selected from BT device picker screen.
+     * Selected {@link BluetoothDevice} is returned in extra data named
+     * {@link BluetoothDevice#EXTRA_DEVICE}.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DEVICE_SELECTED =
+            "android.bluetooth.devicepicker.action.DEVICE_SELECTED";
+
+    /**
+     * Broadcast when someone want to select one BT device from devices list.
+     * This intent contains below extra data:
+     * - {@link #EXTRA_NEED_AUTH} (boolean): if need authentication
+     * - {@link #EXTRA_FILTER_TYPE} (int): what kinds of device should be
+     *                                     listed
+     * - {@link #EXTRA_LAUNCH_PACKAGE} (string): where(which package) this
+     *                                           intent come from
+     * - {@link #EXTRA_LAUNCH_CLASS} (string): where(which class) this intent
+     *                                         come from
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_LAUNCH =
+            "android.bluetooth.devicepicker.action.LAUNCH";
+
+    /** Ask device picker to show all kinds of BT devices */
+    public static final int FILTER_TYPE_ALL = 0;
+    /** Ask device picker to show BT devices that support AUDIO profiles */
+    public static final int FILTER_TYPE_AUDIO = 1;
+    /** Ask device picker to show BT devices that support Object Transfer */
+    public static final int FILTER_TYPE_TRANSFER = 2;
+    /** Ask device picker to show BT devices that support
+     * Personal Area Networking User (PANU) profile*/
+    public static final int FILTER_TYPE_PANU = 3;
+    /** Ask device picker to show BT devices that support Network Access Point (NAP) profile */
+    public static final int FILTER_TYPE_NAP = 4;
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothDeviceProfileState.java b/bluetoothmsm/java/android/bluetooth/BluetoothDeviceProfileState.java
new file mode 100644
index 0000000..5f20627
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothDeviceProfileState.java
@@ -0,0 +1,1485 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Message;
+import android.bluetooth.BluetoothAdapter;
+import android.os.PowerManager;
+import android.server.BluetoothA2dpService;
+import android.server.BluetoothService;
+import android.util.Log;
+import android.util.Pair;
+import android.os.ParcelUuid;
+
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+
+import java.util.Set;
+import java.util.List;
+
+/**
+ * This class is the Profile connection state machine associated with a remote
+ * device. When the device bonds an instance of this class is created.
+ * This tracks incoming and outgoing connections of all the profiles. Incoming
+ * connections are preferred over outgoing connections and HFP preferred over
+ * A2DP. When the device is unbonded, the instance is removed.
+ *
+ * States:
+ * {@link BondedDevice}: This state represents a bonded device. When in this
+ * state none of the profiles are in transition states.
+ *
+ * {@link OutgoingHandsfree}: Handsfree profile connection is in a transition
+ * state because of a outgoing Connect or Disconnect.
+ *
+ * {@link IncomingHandsfree}: Handsfree profile connection is in a transition
+ * state because of a incoming Connect or Disconnect.
+ *
+ * {@link IncomingA2dp}: A2dp profile connection is in a transition
+ * state because of a incoming Connect or Disconnect.
+ *
+ * {@link OutgoingA2dp}: A2dp profile connection is in a transition
+ * state because of a outgoing Connect or Disconnect.
+ *
+ * Todo(): Write tests for this class, when the Android Mock support is completed.
+ * @hide
+ */
+public final class BluetoothDeviceProfileState extends StateMachine {
+    private static final String TAG = "BluetoothDeviceProfileState";
+    private static final boolean DBG = false;
+
+    // TODO(): Restructure the state machine to make it scalable with regard to profiles.
+    public static final int CONNECT_HFP_OUTGOING = 1;
+    public static final int CONNECT_HFP_INCOMING = 2;
+    public static final int CONNECT_A2DP_OUTGOING = 3;
+    public static final int CONNECT_A2DP_INCOMING = 4;
+    public static final int CONNECT_HID_OUTGOING = 5;
+    public static final int CONNECT_HID_INCOMING = 6;
+
+    public static final int DISCONNECT_HFP_OUTGOING = 50;
+    private static final int DISCONNECT_HFP_INCOMING = 51;
+    public static final int DISCONNECT_A2DP_OUTGOING = 52;
+    public static final int DISCONNECT_A2DP_INCOMING = 53;
+    public static final int DISCONNECT_HID_OUTGOING = 54;
+    public static final int DISCONNECT_HID_INCOMING = 55;
+    public static final int DISCONNECT_PBAP_OUTGOING = 56;
+
+    public static final int UNPAIR = 100;
+    public static final int AUTO_CONNECT_PROFILES = 101;
+    public static final int TRANSITION_TO_STABLE = 102;
+    public static final int CONNECT_OTHER_PROFILES = 103;
+    private static final int CONNECTION_ACCESS_REQUEST_REPLY = 104;
+    private static final int CONNECTION_ACCESS_REQUEST_EXPIRY = 105;
+    private static final int UNPAIR_COMPLETE = 106;
+
+    public static final int CONNECT_OTHER_PROFILES_DELAY = 4000; // 4 secs
+    private static final int CONNECTION_ACCESS_REQUEST_EXPIRY_TIMEOUT = 7000; // 7 secs
+    private static final int CONNECTION_ACCESS_UNDEFINED = -1;
+    private static final long INIT_INCOMING_REJECT_TIMER = 1000; // 1 sec
+    private static final long MAX_INCOMING_REJECT_TIMER = 3600 * 1000 * 4; // 4 hours
+    private static final int UNPAIR_COMPLETE_DELAY = 2000; // 2 secs delay in bluez
+
+    private static final String ACCESS_AUTHORITY_PACKAGE = "com.android.settings";
+    private static final String ACCESS_AUTHORITY_CLASS =
+        "com.android.settings.bluetooth.BluetoothPermissionRequest";
+    private static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
+
+    private BondedDevice mBondedDevice = new BondedDevice();
+    private OutgoingHandsfree mOutgoingHandsfree = new OutgoingHandsfree();
+    private IncomingHandsfree mIncomingHandsfree = new IncomingHandsfree();
+    private IncomingA2dp mIncomingA2dp = new IncomingA2dp();
+    private OutgoingA2dp mOutgoingA2dp = new OutgoingA2dp();
+    private OutgoingHid mOutgoingHid = new OutgoingHid();
+    private IncomingHid mIncomingHid = new IncomingHid();
+
+    private Context mContext;
+    private BluetoothService mService;
+    private BluetoothA2dpService mA2dpService;
+    private BluetoothHeadset  mHeadsetService;
+    private BluetoothPbap     mPbapService;
+    private PbapServiceListener mPbap;
+    private BluetoothAdapter mAdapter;
+    private boolean mPbapServiceConnected;
+    private boolean mAutoConnectionPending;
+    private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
+
+    private BluetoothDevice mDevice;
+    private int mHeadsetState = BluetoothProfile.STATE_DISCONNECTED;
+    private int mA2dpState = BluetoothProfile.STATE_DISCONNECTED;
+    private long mIncomingRejectTimer;
+    private boolean mConnectionAccessReplyReceived = false;
+    private Pair<Integer, String> mIncomingConnections;
+    private PowerManager.WakeLock mWakeLock;
+    private PowerManager mPowerManager;
+    private boolean mPairingRequestRcvd = false;
+    private boolean mExpectingSdpComplete = false;
+
+    private boolean mUnpairStarted = false;
+
+    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            if (device == null || !device.equals(mDevice)) return;
+
+            if (action.equals(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED)) {
+                int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                int oldState = intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, 0);
+                // We trust this device now
+                if (newState == BluetoothHeadset.STATE_CONNECTED) {
+                    setTrust(BluetoothDevice.CONNECTION_ACCESS_YES);
+                }
+                mA2dpState = newState;
+                if (oldState == BluetoothA2dp.STATE_CONNECTED &&
+                    newState == BluetoothA2dp.STATE_DISCONNECTED) {
+                    sendMessage(DISCONNECT_A2DP_INCOMING);
+                }
+                if (newState == BluetoothProfile.STATE_CONNECTED ||
+                    newState == BluetoothProfile.STATE_DISCONNECTED) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
+                int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                int oldState = intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, 0);
+                // We trust this device now
+                if (newState == BluetoothHeadset.STATE_CONNECTED) {
+                    setTrust(BluetoothDevice.CONNECTION_ACCESS_YES);
+                }
+                mHeadsetState = newState;
+                if (oldState == BluetoothHeadset.STATE_CONNECTED &&
+                    newState == BluetoothHeadset.STATE_DISCONNECTED) {
+                    sendMessage(DISCONNECT_HFP_INCOMING);
+                }
+                if (newState == BluetoothProfile.STATE_CONNECTED ||
+                    newState == BluetoothProfile.STATE_DISCONNECTED) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            } else if (action.equals(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED)) {
+                int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                int oldState =
+                    intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, 0);
+                // We trust this device now
+                if (newState == BluetoothHeadset.STATE_CONNECTED) {
+                    setTrust(BluetoothDevice.CONNECTION_ACCESS_YES);
+                }
+                if (oldState == BluetoothProfile.STATE_CONNECTED &&
+                    newState == BluetoothProfile.STATE_DISCONNECTED) {
+                    sendMessage(DISCONNECT_HID_INCOMING);
+                }
+                if (newState == BluetoothProfile.STATE_CONNECTED ||
+                    newState == BluetoothProfile.STATE_DISCONNECTED) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            } else if (action.equals(BluetoothDevice.ACTION_ACL_DISCONNECTED)) {
+                // This is technically not needed, but we can get stuck sometimes.
+                // For example, if incoming A2DP fails, we are not informed by Bluez
+                sendMessage(TRANSITION_TO_STABLE);
+            } else if (action.equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY)) {
+                mWakeLock.release();
+                int val = intent.getIntExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT,
+                                             BluetoothDevice.CONNECTION_ACCESS_NO);
+                Message msg = obtainMessage(CONNECTION_ACCESS_REQUEST_REPLY);
+                msg.arg1 = val;
+                sendMessage(msg);
+            } else if (action.equals(BluetoothDevice.ACTION_PAIRING_REQUEST)) {
+                mPairingRequestRcvd = true;
+            } else if (action.equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) {
+                int state = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,
+                        BluetoothDevice.ERROR);
+                if (state == BluetoothDevice.BOND_BONDED && mPairingRequestRcvd) {
+                    setTrust(BluetoothDevice.CONNECTION_ACCESS_YES);
+                    mPairingRequestRcvd = false;
+                } else if (state == BluetoothDevice.BOND_NONE) {
+                    mPairingRequestRcvd = false;
+                } else if (state == BluetoothDevice.BOND_BONDED) {
+                    mExpectingSdpComplete = true;
+                }
+            } else if (action.equals(BluetoothDevice.ACTION_UUID)) {
+                 mExpectingSdpComplete = false;
+            }
+        }
+    };
+
+    private boolean isPhoneDocked(BluetoothDevice autoConnectDevice) {
+        // This works only because these broadcast intents are "sticky"
+        Intent i = mContext.registerReceiver(null, new IntentFilter(Intent.ACTION_DOCK_EVENT));
+        if (i != null) {
+            int state = i.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
+            if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
+                BluetoothDevice device = i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                if (device != null && autoConnectDevice.equals(device)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public BluetoothDeviceProfileState(Context context, String address,
+          BluetoothService service, BluetoothA2dpService a2dpService, boolean setTrust) {
+        super("BDP:" + address);
+        mContext = context;
+        mDevice = new BluetoothDevice(address);
+        mService = service;
+        mA2dpService = a2dpService;
+
+        addState(mBondedDevice);
+        addState(mOutgoingHandsfree);
+        addState(mIncomingHandsfree);
+        addState(mIncomingA2dp);
+        addState(mOutgoingA2dp);
+        addState(mOutgoingHid);
+        addState(mIncomingHid);
+        setInitialState(mBondedDevice);
+
+        IntentFilter filter = new IntentFilter();
+        // Fine-grained state broadcasts
+        filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
+        filter.addAction(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
+        filter.addAction(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
+        filter.addAction(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
+        filter.addAction(BluetoothDevice.ACTION_UUID);
+
+        mContext.registerReceiver(mBroadcastReceiver, filter);
+
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+        mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
+                                BluetoothProfile.HEADSET);
+        // TODO(): Convert PBAP to the new Profile APIs.
+        mPbap = new PbapServiceListener();
+
+        mIncomingConnections = mService.getIncomingState(address);
+        mIncomingRejectTimer = readTimerValue();
+        mPowerManager = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = mPowerManager.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK |
+                                              PowerManager.ACQUIRE_CAUSES_WAKEUP |
+                                              PowerManager.ON_AFTER_RELEASE, TAG);
+        mWakeLock.setReferenceCounted(false);
+
+        if (setTrust) {
+            setTrust(BluetoothDevice.CONNECTION_ACCESS_YES);
+        }
+    }
+
+    private BluetoothProfile.ServiceListener mBluetoothProfileServiceListener =
+        new BluetoothProfile.ServiceListener() {
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            synchronized(BluetoothDeviceProfileState.this) {
+                mHeadsetService = (BluetoothHeadset) proxy;
+                mHeadsetState = BluetoothProfile.STATE_DISCONNECTED;
+                if (mAutoConnectionPending) {
+                    sendMessage(AUTO_CONNECT_PROFILES);
+                    mAutoConnectionPending = false;
+                }
+            }
+        }
+        public void onServiceDisconnected(int profile) {
+            synchronized(BluetoothDeviceProfileState.this) {
+                mHeadsetService = null;
+                if (mHeadsetState != BluetoothHeadset.STATE_DISCONNECTED) {
+                    // It seems BluetoothHeadsetService crashed. I am the only
+                    // class to know valid BluetoothHeadset state. Let me send the
+                    // updated status to other listeners.
+                    int prevState = mHeadsetState;
+                    Intent intent = new Intent(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
+                    mHeadsetState = BluetoothHeadset.STATE_DISCONNECTED;
+                    mService.sendConnectionStateChange(mDevice, BluetoothProfile.HEADSET,
+                                                       mHeadsetState, prevState);
+                    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
+                    intent.putExtra(BluetoothProfile.EXTRA_STATE, mHeadsetState);
+                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
+                    mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+                }
+            }
+        }
+    };
+
+    private class PbapServiceListener implements BluetoothPbap.ServiceListener {
+        public PbapServiceListener() {
+            mPbapService = new BluetoothPbap(mContext, this);
+        }
+        public void onServiceConnected() {
+            synchronized(BluetoothDeviceProfileState.this) {
+                mPbapServiceConnected = true;
+            }
+        }
+        public void onServiceDisconnected() {
+            synchronized(BluetoothDeviceProfileState.this) {
+                mPbapServiceConnected = false;
+            }
+        }
+    }
+
+    private class BondedDevice extends State {
+        @Override
+        public void enter() {
+            Log.i(TAG, "Entering ACL Connected state with: " + getCurrentMessage().what);
+            Message m = new Message();
+            m.copyFrom(getCurrentMessage());
+            sendMessageAtFrontOfQueue(m);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            log("ACL Connected State -> Processing Message: " + message.what);
+            switch(message.what) {
+                case CONNECT_HFP_OUTGOING:
+                    if (mUnpairStarted == true) {
+                        log("Discarding message " + message.what);
+                    } else {
+                        transitionTo(mOutgoingHandsfree);
+                    }
+                    break;
+                case DISCONNECT_HFP_OUTGOING:
+                    transitionTo(mOutgoingHandsfree);
+                    break;
+                case CONNECT_HFP_INCOMING:
+                    if (mUnpairStarted == true) {
+                        log("Discarding message " + message.what);
+                    } else {
+                        transitionTo(mIncomingHandsfree);
+                    }
+                    break;
+                case DISCONNECT_HFP_INCOMING:
+                    transitionTo(mIncomingHandsfree);
+                    break;
+                case CONNECT_A2DP_OUTGOING:
+                    if (mUnpairStarted == true) {
+                        log("Discarding message " + message.what);
+                    } else {
+                        transitionTo(mOutgoingA2dp);
+                    }
+                    break;
+                case DISCONNECT_A2DP_OUTGOING:
+                    transitionTo(mOutgoingA2dp);
+                    break;
+                case CONNECT_A2DP_INCOMING:
+                    if (mUnpairStarted == true) {
+                        log("Discarding message " + message.what);
+                    } else {
+                        transitionTo(mIncomingA2dp);
+                    }
+                    break;
+                case DISCONNECT_A2DP_INCOMING:
+                    transitionTo(mIncomingA2dp);
+                    break;
+                case CONNECT_HID_OUTGOING:
+                case DISCONNECT_HID_OUTGOING:
+                    if (mUnpairStarted == true) {
+                        log("Discarding message " + message.what);
+                    } else {
+                        transitionTo(mOutgoingHid);
+                    }
+                    break;
+                case CONNECT_HID_INCOMING:
+                case DISCONNECT_HID_INCOMING:
+                    if (mUnpairStarted == true) {
+                        log("Discarding message " + message.what);
+                    } else {
+                        transitionTo(mIncomingHid);
+                    }
+                    break;
+                case DISCONNECT_PBAP_OUTGOING:
+                    processCommand(DISCONNECT_PBAP_OUTGOING);
+                    break;
+                case UNPAIR:
+                    if (mHeadsetState != BluetoothHeadset.STATE_DISCONNECTED) {
+                        sendMessage(DISCONNECT_HFP_OUTGOING);
+                        deferMessage(message);
+                        break;
+                    } else if (mA2dpState != BluetoothA2dp.STATE_DISCONNECTED) {
+                        sendMessage(DISCONNECT_A2DP_OUTGOING);
+                        deferMessage(message);
+                        break;
+                    } else if (mService.getInputDeviceConnectionState(mDevice) !=
+                            BluetoothInputDevice.STATE_DISCONNECTED) {
+                        sendMessage(DISCONNECT_HID_OUTGOING);
+                        deferMessage(message);
+                        break;
+                    }
+                    processCommand(UNPAIR);
+                    break;
+                case AUTO_CONNECT_PROFILES:
+                    if (isPhoneDocked(mDevice)) {
+                        // Don't auto connect to docks.
+                        break;
+                    } else {
+                        if (mHeadsetService == null) {
+                              mAutoConnectionPending = true;
+                              log("AUTO_CONNECT Waiting for HeadsetSerive bind " +
+                                    mDevice.getAddress());
+                              break;
+                        } else if (mHeadsetService.getPriority(mDevice) ==
+                              BluetoothHeadset.PRIORITY_AUTO_CONNECT &&
+                              mHeadsetService.getDevicesMatchingConnectionStates(
+                                  new int[] {BluetoothProfile.STATE_CONNECTED,
+                                             BluetoothProfile.STATE_CONNECTING,
+                                             BluetoothProfile.STATE_DISCONNECTING}).size() == 0) {
+                            mHeadsetService.connect(mDevice);
+                        }
+                        if (mA2dpService != null &&
+                              mA2dpService.getPriority(mDevice) ==
+                              BluetoothA2dp.PRIORITY_AUTO_CONNECT &&
+                              mA2dpService.getDevicesMatchingConnectionStates(
+                                  new int[] {BluetoothA2dp.STATE_CONNECTED,
+                                             BluetoothProfile.STATE_CONNECTING,
+                                             BluetoothProfile.STATE_DISCONNECTING}).size() == 0) {
+                            mA2dpService.connect(mDevice);
+                        }
+                        if (mService.getInputDevicePriority(mDevice) ==
+                              BluetoothInputDevice.PRIORITY_AUTO_CONNECT) {
+                            mService.connectInputDevice(mDevice);
+                        }
+                    }
+                    break;
+                case CONNECT_OTHER_PROFILES:
+                    if (isPhoneDocked(mDevice)) {
+                       break;
+                    }
+                    if (message.arg1 == CONNECT_A2DP_OUTGOING) {
+                        if (mA2dpService != null &&
+                            (mA2dpService.getPriority(mDevice) >
+                             BluetoothProfile.PRIORITY_OFF) &&
+                            mA2dpService.getDevicesMatchingConnectionStates(
+                                new int[] {BluetoothProfile.STATE_CONNECTED,
+                                           BluetoothProfile.STATE_CONNECTING}).size() ==0) {
+                            Log.i(TAG, "A2dp:Connect Other Profiles");
+                            mA2dpService.connect(mDevice);
+                        }
+                    } else if (message.arg1 == CONNECT_HFP_OUTGOING) {
+                        if (mHeadsetService == null) {
+                            deferMessage(message);
+                        } else {
+                            if ((mHeadsetService.getPriority(mDevice) >
+                                 BluetoothProfile.PRIORITY_OFF) &&
+                                 mHeadsetService.getDevicesMatchingConnectionStates(
+                                    new int[] {BluetoothProfile.STATE_CONNECTED,
+                                               BluetoothProfile.STATE_CONNECTING}).size() ==0) {
+                                Log.i(TAG, "Headset:Connect Other Profiles");
+                                mHeadsetService.connect(mDevice);
+                            }
+                        }
+                    }
+                    break;
+                case TRANSITION_TO_STABLE:
+                    // ignore.
+                    break;
+                case UNPAIR_COMPLETE:
+                    processCommand(UNPAIR_COMPLETE);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    @Override
+    //<MR1 change>
+    protected void onQuitting() {
+        mContext.unregisterReceiver(mBroadcastReceiver);
+        mBroadcastReceiver = null;
+        mAdapter.closeProfileProxy(BluetoothProfile.HEADSET, mHeadsetService);
+        mBluetoothProfileServiceListener = null;
+        mOutgoingHandsfree = null;
+        mPbap = null;
+        mPbapService.close();
+        mPbapService = null;
+        mIncomingHid = null;
+        mOutgoingHid = null;
+        mIncomingHandsfree = null;
+        mOutgoingHandsfree = null;
+        mIncomingA2dp = null;
+        mOutgoingA2dp = null;
+        mBondedDevice = null;
+	//<MR1 change>
+        super.onQuitting();
+    }
+
+    private class OutgoingHandsfree extends State {
+        private boolean mStatus = false;
+        private int mCommand;
+
+        @Override
+        public void enter() {
+            Log.i(TAG, "Entering OutgoingHandsfree state with: " + getCurrentMessage().what);
+            mCommand = getCurrentMessage().what;
+            if (mCommand != CONNECT_HFP_OUTGOING &&
+                mCommand != DISCONNECT_HFP_OUTGOING) {
+                Log.e(TAG, "Error: OutgoingHandsfree state with command:" + mCommand);
+            }
+            mStatus = processCommand(mCommand);
+            if (!mStatus) {
+                sendMessage(TRANSITION_TO_STABLE);
+                mService.sendProfileStateMessage(BluetoothProfileState.HFP,
+                                                 BluetoothProfileState.TRANSITION_TO_STABLE);
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("OutgoingHandsfree State -> Processing Message: " + message.what);
+            Message deferMsg = new Message();
+            int command = message.what;
+            switch(command) {
+                case CONNECT_HFP_OUTGOING:
+                    if (command != mCommand) {
+                        // Disconnect followed by a connect - defer
+                        deferMessage(message);
+                    }
+                    break;
+                case CONNECT_HFP_INCOMING:
+                    if (mCommand == CONNECT_HFP_OUTGOING) {
+                        // Cancel outgoing connect, accept incoming
+                        cancelCommand(CONNECT_HFP_OUTGOING);
+                        transitionTo(mIncomingHandsfree);
+                    } else {
+                        // We have done the disconnect but we are not
+                        // sure which state we are in at this point.
+                        deferMessage(message);
+                    }
+                    break;
+                case CONNECT_A2DP_INCOMING:
+                    transitionTo(mIncomingA2dp);
+                    break;
+                case CONNECT_A2DP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_HFP_OUTGOING:
+                    if (mCommand == CONNECT_HFP_OUTGOING) {
+                        // Cancel outgoing connect
+                        cancelCommand(CONNECT_HFP_OUTGOING);
+                        processCommand(DISCONNECT_HFP_OUTGOING);
+                    }
+                    // else ignore
+                    break;
+                case DISCONNECT_HFP_INCOMING:
+                    // When this happens the socket would be closed and the headset
+                    // state moved to DISCONNECTED, cancel the outgoing thread.
+                    // if it still is in CONNECTING state
+                    cancelCommand(CONNECT_HFP_OUTGOING);
+                    break;
+                case DISCONNECT_A2DP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_A2DP_INCOMING:
+                    // Bluez will handle the disconnect. If because of this the outgoing
+                    // handsfree connection has failed, then retry.
+                    if (mStatus) {
+                       deferMsg.what = mCommand;
+                       deferMessage(deferMsg);
+                    }
+                    break;
+                case CONNECT_HID_OUTGOING:
+                case DISCONNECT_HID_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case CONNECT_HID_INCOMING:
+                    transitionTo(mIncomingHid);
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case DISCONNECT_HID_INCOMING:
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break; // ignore
+                case DISCONNECT_PBAP_OUTGOING:
+                case UNPAIR:
+                case UNPAIR_COMPLETE:
+                case AUTO_CONNECT_PROFILES:
+                case CONNECT_OTHER_PROFILES:
+                    deferMessage(message);
+                    break;
+                case TRANSITION_TO_STABLE:
+                    transitionTo(mBondedDevice);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    private class IncomingHandsfree extends State {
+        private boolean mStatus = false;
+        private int mCommand;
+
+        @Override
+        public void enter() {
+            Log.i(TAG, "Entering IncomingHandsfree state with: " + getCurrentMessage().what);
+            mCommand = getCurrentMessage().what;
+            if (mCommand != CONNECT_HFP_INCOMING &&
+                mCommand != DISCONNECT_HFP_INCOMING) {
+                Log.e(TAG, "Error: IncomingHandsfree state with command:" + mCommand);
+            }
+            mStatus = processCommand(mCommand);
+            if (!mStatus) {
+                sendMessage(TRANSITION_TO_STABLE);
+                mService.sendProfileStateMessage(BluetoothProfileState.HFP,
+                                                 BluetoothProfileState.TRANSITION_TO_STABLE);
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("IncomingHandsfree State -> Processing Message: " + message.what);
+            switch(message.what) {
+                case CONNECT_HFP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case CONNECT_HFP_INCOMING:
+                    // Ignore
+                    Log.e(TAG, "Error: Incoming connection with a pending incoming connection");
+                    break;
+                case CONNECTION_ACCESS_REQUEST_REPLY:
+                    int val = message.arg1;
+                    mConnectionAccessReplyReceived = true;
+                    boolean value = false;
+                    if (val == BluetoothDevice.CONNECTION_ACCESS_YES) {
+                        value = true;
+                    }
+                    setTrust(val);
+
+                    handleIncomingConnection(CONNECT_HFP_INCOMING, value);
+                    break;
+                case CONNECTION_ACCESS_REQUEST_EXPIRY:
+                    if (!mConnectionAccessReplyReceived) {
+                        handleIncomingConnection(CONNECT_HFP_INCOMING, false);
+                        sendConnectionAccessRemovalIntent();
+                        sendMessage(TRANSITION_TO_STABLE);
+                    }
+                    break;
+                case CONNECT_A2DP_INCOMING:
+                    // Serialize the commands.
+                    deferMessage(message);
+                    break;
+                case CONNECT_A2DP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_HFP_OUTGOING:
+                    // We don't know at what state we are in the incoming HFP connection state.
+                    // We can be changing from DISCONNECTED to CONNECTING, or
+                    // from CONNECTING to CONNECTED, so serializing this command is
+                    // the safest option.
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_HFP_INCOMING:
+                    // Nothing to do here, we will already be DISCONNECTED
+                    // by this point.
+                    break;
+                case DISCONNECT_A2DP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_A2DP_INCOMING:
+                    // Bluez handles incoming A2DP disconnect.
+                    // If this causes incoming HFP to fail, it is more of a headset problem
+                    // since both connections are incoming ones.
+                    break;
+                case CONNECT_HID_OUTGOING:
+                case DISCONNECT_HID_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case CONNECT_HID_INCOMING:
+                case DISCONNECT_HID_INCOMING:
+                     break; // ignore
+                case DISCONNECT_PBAP_OUTGOING:
+                case UNPAIR:
+                case UNPAIR_COMPLETE:
+                case AUTO_CONNECT_PROFILES:
+                case CONNECT_OTHER_PROFILES:
+                    deferMessage(message);
+                    break;
+                case TRANSITION_TO_STABLE:
+                    transitionTo(mBondedDevice);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    private class OutgoingA2dp extends State {
+        private boolean mStatus = false;
+        private int mCommand;
+
+        @Override
+        public void enter() {
+            Log.i(TAG, "Entering OutgoingA2dp state with: " + getCurrentMessage().what);
+            mCommand = getCurrentMessage().what;
+            if (mCommand != CONNECT_A2DP_OUTGOING &&
+                mCommand != DISCONNECT_A2DP_OUTGOING) {
+                Log.e(TAG, "Error: OutgoingA2DP state with command:" + mCommand);
+            }
+            mStatus = processCommand(mCommand);
+            if (!mStatus) {
+                sendMessage(TRANSITION_TO_STABLE);
+                mService.sendProfileStateMessage(BluetoothProfileState.A2DP,
+                                                 BluetoothProfileState.TRANSITION_TO_STABLE);
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("OutgoingA2dp State->Processing Message: " + message.what);
+            Message deferMsg = new Message();
+            switch(message.what) {
+                case CONNECT_HFP_OUTGOING:
+                    processCommand(CONNECT_HFP_OUTGOING);
+
+                    // Don't cancel A2DP outgoing as there is no guarantee it
+                    // will get canceled.
+                    // It might already be connected but we might not have got the
+                    // A2DP_SINK_STATE_CHANGE. Hence, no point disconnecting here.
+                    // The worst case, the connection will fail, retry.
+                    // The same applies to Disconnecting an A2DP connection.
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case CONNECT_HFP_INCOMING:
+                    processCommand(CONNECT_HFP_INCOMING);
+
+                    // Don't cancel A2DP outgoing as there is no guarantee
+                    // it will get canceled.
+                    // The worst case, the connection will fail, retry.
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case CONNECT_A2DP_INCOMING:
+                    // Bluez will take care of conflicts between incoming and outgoing
+                    // connections.
+                    transitionTo(mIncomingA2dp);
+                    break;
+                case CONNECT_A2DP_OUTGOING:
+                    // Ignore
+                    break;
+                case DISCONNECT_HFP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_HFP_INCOMING:
+                    // At this point, we are already disconnected
+                    // with HFP. Sometimes A2DP connection can
+                    // fail due to the disconnection of HFP. So add a retry
+                    // for the A2DP.
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case DISCONNECT_A2DP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_A2DP_INCOMING:
+                    // Ignore, will be handled by Bluez
+                    break;
+                case CONNECT_HID_OUTGOING:
+                case DISCONNECT_HID_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case CONNECT_HID_INCOMING:
+                    transitionTo(mIncomingHid);
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case DISCONNECT_HID_INCOMING:
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break; // ignore
+                case DISCONNECT_PBAP_OUTGOING:
+                case UNPAIR:
+                case UNPAIR_COMPLETE:
+                case AUTO_CONNECT_PROFILES:
+                case CONNECT_OTHER_PROFILES:
+                    deferMessage(message);
+                    break;
+                case TRANSITION_TO_STABLE:
+                    transitionTo(mBondedDevice);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    private class IncomingA2dp extends State {
+        private boolean mStatus = false;
+        private int mCommand;
+
+        @Override
+        public void enter() {
+            Log.i(TAG, "Entering IncomingA2dp state with: " + getCurrentMessage().what);
+            mCommand = getCurrentMessage().what;
+            if (mCommand != CONNECT_A2DP_INCOMING &&
+                mCommand != DISCONNECT_A2DP_INCOMING) {
+                Log.e(TAG, "Error: IncomingA2DP state with command:" + mCommand);
+            }
+            mStatus = processCommand(mCommand);
+            if (!mStatus) {
+                sendMessage(TRANSITION_TO_STABLE);
+                mService.sendProfileStateMessage(BluetoothProfileState.A2DP,
+                                                 BluetoothProfileState.TRANSITION_TO_STABLE);
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("IncomingA2dp State->Processing Message: " + message.what);
+            switch(message.what) {
+                case CONNECT_HFP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case CONNECT_HFP_INCOMING:
+                    // Shouldn't happen, but serialize the commands.
+                    deferMessage(message);
+                    break;
+                case CONNECT_A2DP_INCOMING:
+                    // ignore
+                    break;
+                case CONNECTION_ACCESS_REQUEST_REPLY:
+                    int val = message.arg1;
+                    mConnectionAccessReplyReceived = true;
+                    boolean value = false;
+                    if (val == BluetoothDevice.CONNECTION_ACCESS_YES) {
+                        value = true;
+                    }
+                    setTrust(val);
+                    handleIncomingConnection(CONNECT_A2DP_INCOMING, value);
+                    break;
+                case CONNECTION_ACCESS_REQUEST_EXPIRY:
+                    // The check protects the race condition between REQUEST_REPLY
+                    // and the timer expiry.
+                    if (!mConnectionAccessReplyReceived) {
+                        handleIncomingConnection(CONNECT_A2DP_INCOMING, false);
+                        sendConnectionAccessRemovalIntent();
+                        sendMessage(TRANSITION_TO_STABLE);
+                    }
+                    break;
+                case CONNECT_A2DP_OUTGOING:
+                    // Defer message and retry
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_HFP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_HFP_INCOMING:
+                    // Shouldn't happen but if does, we can handle it.
+                    // Depends if the headset can handle it.
+                    // Incoming A2DP will be handled by Bluez, Disconnect HFP
+                    // the socket would have already been closed.
+                    // ignore
+                    break;
+                case DISCONNECT_A2DP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_A2DP_INCOMING:
+                    // Ignore, will be handled by Bluez
+                    break;
+                case CONNECT_HID_OUTGOING:
+                case DISCONNECT_HID_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case CONNECT_HID_INCOMING:
+                case DISCONNECT_HID_INCOMING:
+                     break; // ignore
+                case DISCONNECT_PBAP_OUTGOING:
+                case UNPAIR:
+                case UNPAIR_COMPLETE:
+                case AUTO_CONNECT_PROFILES:
+                case CONNECT_OTHER_PROFILES:
+                    deferMessage(message);
+                    break;
+                case TRANSITION_TO_STABLE:
+                    transitionTo(mBondedDevice);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+
+    private class OutgoingHid extends State {
+        private boolean mStatus = false;
+        private int mCommand;
+
+        @Override
+        public void enter() {
+            log("Entering OutgoingHid state with: " + getCurrentMessage().what);
+            mCommand = getCurrentMessage().what;
+            if (mCommand != CONNECT_HID_OUTGOING &&
+                mCommand != DISCONNECT_HID_OUTGOING) {
+                Log.e(TAG, "Error: OutgoingHid state with command:" + mCommand);
+            }
+            mStatus = processCommand(mCommand);
+            if (!mStatus) sendMessage(TRANSITION_TO_STABLE);
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("OutgoingHid State->Processing Message: " + message.what);
+            Message deferMsg = new Message();
+            switch(message.what) {
+                // defer all outgoing messages
+                case CONNECT_HFP_OUTGOING:
+                case CONNECT_A2DP_OUTGOING:
+                case CONNECT_HID_OUTGOING:
+                case DISCONNECT_HFP_OUTGOING:
+                case DISCONNECT_A2DP_OUTGOING:
+                case DISCONNECT_HID_OUTGOING:
+                    deferMessage(message);
+                    break;
+
+                case CONNECT_HFP_INCOMING:
+                    transitionTo(mIncomingHandsfree);
+                    break;
+                case CONNECT_A2DP_INCOMING:
+                    transitionTo(mIncomingA2dp);
+
+                    // Don't cancel HID outgoing as there is no guarantee it
+                    // will get canceled.
+                    // It might already be connected but we might not have got the
+                    // INPUT_DEVICE_STATE_CHANGE. Hence, no point disconnecting here.
+                    // The worst case, the connection will fail, retry.
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case CONNECT_HID_INCOMING:
+                  // Bluez will take care of the conflicts
+                    transitionTo(mIncomingHid);
+                    break;
+
+                case DISCONNECT_HFP_INCOMING:
+                case DISCONNECT_A2DP_INCOMING:
+                    // At this point, we are already disconnected
+                    // with HFP. Sometimes HID connection can
+                    // fail due to the disconnection of HFP. So add a retry
+                    // for the HID.
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case DISCONNECT_HID_INCOMING:
+                    // Ignore, will be handled by Bluez
+                    break;
+                case DISCONNECT_PBAP_OUTGOING:
+                case UNPAIR:
+                case AUTO_CONNECT_PROFILES:
+                    deferMessage(message);
+                    break;
+                case TRANSITION_TO_STABLE:
+                    transitionTo(mBondedDevice);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+  private class IncomingHid extends State {
+      private boolean mStatus = false;
+      private int mCommand;
+
+      @Override
+    public void enter() {
+          log("Entering IncomingHid state with: " + getCurrentMessage().what);
+          mCommand = getCurrentMessage().what;
+          if (mCommand != CONNECT_HID_INCOMING &&
+              mCommand != DISCONNECT_HID_INCOMING) {
+              Log.e(TAG, "Error: IncomingHid state with command:" + mCommand);
+          }
+          mStatus = processCommand(mCommand);
+          if (!mStatus) sendMessage(TRANSITION_TO_STABLE);
+      }
+
+      @Override
+    public boolean processMessage(Message message) {
+          log("IncomingHid State->Processing Message: " + message.what);
+          Message deferMsg = new Message();
+          switch(message.what) {
+              case CONNECT_HFP_OUTGOING:
+              case CONNECT_HFP_INCOMING:
+              case DISCONNECT_HFP_OUTGOING:
+              case CONNECT_A2DP_INCOMING:
+              case CONNECT_A2DP_OUTGOING:
+              case DISCONNECT_A2DP_OUTGOING:
+              case CONNECT_HID_OUTGOING:
+              case CONNECT_HID_INCOMING:
+              case DISCONNECT_HID_OUTGOING:
+                  deferMessage(message);
+                  break;
+              case CONNECTION_ACCESS_REQUEST_REPLY:
+                  mConnectionAccessReplyReceived = true;
+                  int val = message.arg1;
+                  setTrust(val);
+                  handleIncomingConnection(CONNECT_HID_INCOMING,
+                      val == BluetoothDevice.CONNECTION_ACCESS_YES);
+                  break;
+              case CONNECTION_ACCESS_REQUEST_EXPIRY:
+                  if (!mConnectionAccessReplyReceived) {
+                      handleIncomingConnection(CONNECT_HID_INCOMING, false);
+                      sendConnectionAccessRemovalIntent();
+                      sendMessage(TRANSITION_TO_STABLE);
+                  }
+                  break;
+              case DISCONNECT_HFP_INCOMING:
+                  // Shouldn't happen but if does, we can handle it.
+                  // Depends if the headset can handle it.
+                  // Incoming HID will be handled by Bluez, Disconnect HFP
+                  // the socket would have already been closed.
+                  // ignore
+                  break;
+              case DISCONNECT_HID_INCOMING:
+              case DISCONNECT_A2DP_INCOMING:
+                  // Ignore, will be handled by Bluez
+                  break;
+              case DISCONNECT_PBAP_OUTGOING:
+              case UNPAIR:
+              case AUTO_CONNECT_PROFILES:
+                  deferMessage(message);
+                  break;
+              case TRANSITION_TO_STABLE:
+                  transitionTo(mBondedDevice);
+                  break;
+              default:
+                  return NOT_HANDLED;
+          }
+          return HANDLED;
+      }
+  }
+
+
+    synchronized void cancelCommand(int command) {
+        if (command == CONNECT_HFP_OUTGOING ) {
+            // Cancel the outgoing thread.
+            if (mHeadsetService != null) {
+                mHeadsetService.cancelConnectThread();
+            }
+            // HeadsetService is down. Phone process most likely crashed.
+            // The thread would have got killed.
+        }
+    }
+
+    synchronized void deferProfileServiceMessage(int command) {
+        Message msg = new Message();
+        msg.what = command;
+        deferMessage(msg);
+    }
+
+    private void updateIncomingAllowedTimer() {
+        // Not doing a perfect exponential backoff because
+        // we want two different rates. For all practical
+        // purposes, this is good enough.
+        if (mIncomingRejectTimer == 0) mIncomingRejectTimer = INIT_INCOMING_REJECT_TIMER;
+
+        mIncomingRejectTimer *= 5;
+        if (mIncomingRejectTimer > MAX_INCOMING_REJECT_TIMER) {
+            mIncomingRejectTimer = MAX_INCOMING_REJECT_TIMER;
+        }
+        writeTimerValue(mIncomingRejectTimer);
+    }
+
+    private boolean handleIncomingConnection(int command, boolean accept) {
+        boolean ret = false;
+        Log.i(TAG, "handleIncomingConnection:" + command + ":" + accept);
+        switch (command) {
+            case CONNECT_HFP_INCOMING:
+                if (!accept) {
+                    ret = mHeadsetService.rejectIncomingConnect(mDevice);
+                    sendMessage(TRANSITION_TO_STABLE);
+                    updateIncomingAllowedTimer();
+                } else if (mHeadsetState == BluetoothHeadset.STATE_CONNECTING) {
+                    writeTimerValue(0);
+                    ret =  mHeadsetService.acceptIncomingConnect(mDevice);
+                } else if (mHeadsetState == BluetoothHeadset.STATE_DISCONNECTED) {
+                    writeTimerValue(0);
+                    if(!mAdapter.isHostPatchRequired(mDevice,
+                         BluetoothAdapter.HOST_PATCH_AVOID_AUTO_CONNECT)) {
+                         Log.d(TAG, "Avoid Connecting Other Profiles Incoming HFP");
+                         handleConnectionOfOtherProfiles(command);
+                    }
+                    ret = mHeadsetService.createIncomingConnect(mDevice);
+                }
+                break;
+            case CONNECT_A2DP_INCOMING:
+                if (!accept) {
+                    ret = mA2dpService.allowIncomingConnect(mDevice, false);
+                    sendMessage(TRANSITION_TO_STABLE);
+                    updateIncomingAllowedTimer();
+                } else {
+                    writeTimerValue(0);
+                    ret = mA2dpService.allowIncomingConnect(mDevice, true);
+                    if(!mAdapter.isHostPatchRequired(mDevice,
+                         BluetoothAdapter.HOST_PATCH_AVOID_AUTO_CONNECT)) {
+                         Log.d(TAG, "Avoid Connecting Other Profiles Incoming A2DP");
+                         handleConnectionOfOtherProfiles(command);
+                    }
+                }
+                break;
+            case CONNECT_HID_INCOMING:
+                if (!accept) {
+                    ret = mService.allowIncomingProfileConnect(mDevice, false);
+                    sendMessage(TRANSITION_TO_STABLE);
+                    updateIncomingAllowedTimer();
+                } else {
+                    writeTimerValue(0);
+                    ret = mService.allowIncomingProfileConnect(mDevice, true);
+                }
+                break;
+            default:
+                Log.e(TAG, "Waiting for incoming connection but state changed to:" + command);
+                break;
+       }
+       return ret;
+    }
+
+    private void sendConnectionAccessIntent() {
+        mConnectionAccessReplyReceived = false;
+
+        if (!mPowerManager.isScreenOn()) mWakeLock.acquire();
+
+        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
+        intent.setClassName(ACCESS_AUTHORITY_PACKAGE, ACCESS_AUTHORITY_CLASS);
+        intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE,
+                        BluetoothDevice.REQUEST_TYPE_PROFILE_CONNECTION);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+    }
+
+    private void sendConnectionAccessRemovalIntent() {
+        mWakeLock.release();
+        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+    }
+
+    private int getTrust() {
+        String address = mDevice.getAddress();
+        if (mIncomingConnections != null) return mIncomingConnections.first;
+        return CONNECTION_ACCESS_UNDEFINED;
+    }
+
+
+    private String getStringValue(long value) {
+        StringBuilder sbr = new StringBuilder();
+        sbr.append(Long.toString(System.currentTimeMillis()));
+        sbr.append("-");
+        sbr.append(Long.toString(value));
+        return sbr.toString();
+    }
+
+    private void setTrust(int value) {
+        String second;
+        if (mIncomingConnections == null) {
+            second = getStringValue(INIT_INCOMING_REJECT_TIMER);
+        } else {
+            second = mIncomingConnections.second;
+        }
+
+        mIncomingConnections = new Pair(value, second);
+        mService.writeIncomingConnectionState(mDevice.getAddress(), mIncomingConnections);
+    }
+
+    private void writeTimerValue(long value) {
+        Integer first;
+        if (mIncomingConnections == null) {
+            first = CONNECTION_ACCESS_UNDEFINED;
+        } else {
+            first = mIncomingConnections.first;
+        }
+        mIncomingConnections = new Pair(first, getStringValue(value));
+        mService.writeIncomingConnectionState(mDevice.getAddress(), mIncomingConnections);
+    }
+
+    private long readTimerValue() {
+        if (mIncomingConnections == null)
+            return 0;
+        String value = mIncomingConnections.second;
+        String[] splits = value.split("-");
+        if (splits != null && splits.length == 2) {
+            return Long.parseLong(splits[1]);
+        }
+        return 0;
+    }
+
+    private boolean readIncomingAllowedValue() {
+        if (readTimerValue() == 0) return true;
+        String value = mIncomingConnections.second;
+        String[] splits = value.split("-");
+        if (splits != null && splits.length == 2) {
+            long val1 = Long.parseLong(splits[0]);
+            long val2 = Long.parseLong(splits[1]);
+            if (val1 + val2 <= System.currentTimeMillis()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    synchronized boolean processCommand(int command) {
+        log("Processing command:" + command);
+        ParcelUuid[] uuids = null;
+        switch(command) {
+            case  CONNECT_HFP_OUTGOING:
+                if (mHeadsetService == null) {
+                    deferProfileServiceMessage(command);
+                } else {
+                    return mHeadsetService.connectHeadsetInternal(mDevice);
+                }
+                break;
+            case CONNECT_HFP_INCOMING:
+                if (mHeadsetService == null) {
+                    deferProfileServiceMessage(command);
+                } else {
+                    uuids = mDevice.getUuids();
+                    if (!BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP) &&
+                        !BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree)) {
+                        mDevice.fetchUuidsWithSdp();
+                    }
+                    processIncomingConnectCommand(command);
+                    return true;
+                }
+                break;
+            case CONNECT_A2DP_OUTGOING:
+                if (mA2dpService != null) {
+                    return mA2dpService.connectSinkInternal(mDevice);
+                }
+                break;
+            case CONNECT_A2DP_INCOMING:
+                uuids = mDevice.getUuids();
+                if (!BluetoothUuid.isUuidPresent(uuids,  BluetoothUuid.AudioSink)) {
+                    mDevice.fetchUuidsWithSdp();
+                }
+                processIncomingConnectCommand(command);
+                return true;
+            case CONNECT_HID_OUTGOING:
+                return mService.connectInputDeviceInternal(mDevice);
+            case CONNECT_HID_INCOMING:
+                uuids = mDevice.getUuids();
+                if (!BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Hid)) {
+                    mDevice.fetchUuidsWithSdp();
+                }
+                processIncomingConnectCommand(command);
+                return true;
+            case DISCONNECT_HFP_OUTGOING:
+                if (mHeadsetService == null) {
+                    deferProfileServiceMessage(command);
+                } else {
+                    // Disconnect PBAP
+                    // TODO(): Add PBAP to the state machine.
+                    Message m = new Message();
+                    m.what = DISCONNECT_PBAP_OUTGOING;
+                    deferMessage(m);
+                    int bluetoothState = mService.getBluetoothState();
+                    if ((mHeadsetService.getPriority(mDevice) ==
+                        BluetoothHeadset.PRIORITY_AUTO_CONNECT) &&
+                        (bluetoothState != BluetoothAdapter.STATE_TURNING_OFF)) {
+                        mHeadsetService.setPriority(mDevice, BluetoothHeadset.PRIORITY_ON);
+                    }
+                    return mHeadsetService.disconnectHeadsetInternal(mDevice);
+                }
+                break;
+            case DISCONNECT_HFP_INCOMING:
+                // ignore
+                return true;
+            case DISCONNECT_A2DP_INCOMING:
+                // ignore
+                return true;
+            case DISCONNECT_A2DP_OUTGOING:
+                if (mA2dpService != null) {
+                    if (mA2dpService.getPriority(mDevice) ==
+                        BluetoothA2dp.PRIORITY_AUTO_CONNECT) {
+                        mA2dpService.setPriority(mDevice, BluetoothHeadset.PRIORITY_ON);
+                    }
+                    return mA2dpService.disconnectSinkInternal(mDevice);
+                }
+                break;
+            case DISCONNECT_HID_INCOMING:
+                // ignore
+                return true;
+            case DISCONNECT_HID_OUTGOING:
+                if (mService.getInputDevicePriority(mDevice) ==
+                    BluetoothInputDevice.PRIORITY_AUTO_CONNECT) {
+                    mService.setInputDevicePriority(mDevice, BluetoothInputDevice.PRIORITY_ON);
+                }
+                return mService.disconnectInputDeviceInternal(mDevice);
+            case DISCONNECT_PBAP_OUTGOING:
+                if (!mPbapServiceConnected) {
+                    deferProfileServiceMessage(command);
+                } else {
+                    return mPbapService.disconnect();
+                }
+                break;
+            case UNPAIR:
+                writeTimerValue(INIT_INCOMING_REJECT_TIMER);
+                setTrust(CONNECTION_ACCESS_UNDEFINED);
+                Message msg = obtainMessage(UNPAIR_COMPLETE);
+                sendMessageDelayed(msg, UNPAIR_COMPLETE_DELAY);
+                mUnpairStarted = true;
+                return mService.removeBondInternal(mDevice.getAddress());
+            case UNPAIR_COMPLETE:
+                // unpair process in bluez will get triggered, unblocking
+                // UI requests
+                mUnpairStarted = false;
+                break;
+            default:
+                Log.e(TAG, "Error: Unknown Command");
+        }
+        return false;
+    }
+
+    private void processIncomingConnectCommand(int command) {
+        // Check if device is already trusted
+        int access = getTrust();
+        if (access == BluetoothDevice.CONNECTION_ACCESS_YES) {
+            handleIncomingConnection(command, true);
+        } else if (access == BluetoothDevice.CONNECTION_ACCESS_NO &&
+                   !readIncomingAllowedValue()) {
+            handleIncomingConnection(command, false);
+        } else {
+            sendConnectionAccessIntent();
+            Message msg = obtainMessage(CONNECTION_ACCESS_REQUEST_EXPIRY);
+            sendMessageDelayed(msg,
+                               CONNECTION_ACCESS_REQUEST_EXPIRY_TIMEOUT);
+        }
+    }
+
+    private void handleConnectionOfOtherProfiles(int command) {
+        // The white paper recommendations mentions that when there is a
+        // link loss, it is the responsibility of the remote device to connect.
+        // Many connect only 1 profile - and they connect the second profile on
+        // some user action (like play being pressed) and so we need this code.
+        // Auto Connect code only connects to the last connected device - which
+        // is useful in cases like when the phone reboots. But consider the
+        // following case:
+        // User is connected to the car's phone and  A2DP profile.
+        // User comes to the desk  and places the phone in the dock
+        // (or any speaker or music system or even another headset) and thus
+        // gets connected to the A2DP profile.  User goes back to the car.
+        // Ideally the car's system is supposed to send incoming connections
+        // from both Handsfree and A2DP profile. But they don't. The Auto
+        // connect code, will not work here because we only auto connect to the
+        // last connected device for that profile which in this case is the dock.
+        // Now suppose a user is using 2 headsets simultaneously, one for the
+        // phone profile one for the A2DP profile. If this is the use case, we
+        // expect the user to use the preference to turn off the A2DP profile in
+        // the Settings screen for the first headset. Else, after link loss,
+        // there can be an incoming connection from the first headset which
+        // might result in the connection of the A2DP profile (if the second
+        // headset is slower) and thus the A2DP profile on the second headset
+        // will never get connected.
+        //
+        // TODO(): Handle other profiles here.
+        switch (command) {
+            case CONNECT_HFP_INCOMING:
+                // Connect A2DP if there is no incoming connection
+                // If the priority is OFF - don't auto connect.
+                if (mA2dpService.getPriority(mDevice) == BluetoothProfile.PRIORITY_ON ||
+                        mA2dpService.getPriority(mDevice) ==
+                            BluetoothProfile.PRIORITY_AUTO_CONNECT) {
+                    List<BluetoothDevice> sinks =
+                        mA2dpService.getDevicesMatchingConnectionStates(
+                                new int[] {BluetoothProfile.STATE_CONNECTED,
+                                           BluetoothProfile.STATE_CONNECTING});
+
+                    if (sinks.contains(mDevice)) {
+                        return; // Already profile connection in progress
+                    }
+                    Message msg = new Message();
+                    msg.what = CONNECT_OTHER_PROFILES;
+                    msg.arg1 = CONNECT_A2DP_OUTGOING;
+                    sendMessageDelayed(msg, CONNECT_OTHER_PROFILES_DELAY);
+                } else if (mExpectingSdpComplete) {
+                    Message msg = new Message();
+                    msg.what = CONNECT_OTHER_PROFILES;
+                    msg.arg1 = CONNECT_A2DP_OUTGOING;
+                    sendMessageDelayed(msg, CONNECT_OTHER_PROFILES_DELAY);
+                }
+                break;
+            case CONNECT_A2DP_INCOMING:
+                // This is again against spec. HFP incoming connections should be made
+                // before A2DP, so we should not hit this case. But many devices
+                // don't follow this.
+                if (mHeadsetService != null &&
+                    (mHeadsetService.getPriority(mDevice) == BluetoothProfile.PRIORITY_ON ||
+                        mHeadsetService.getPriority(mDevice) ==
+                            BluetoothProfile.PRIORITY_AUTO_CONNECT)) {
+                    List<BluetoothDevice> headsets =
+                        mHeadsetService.getDevicesMatchingConnectionStates(
+                                new int[] {BluetoothProfile.STATE_CONNECTED,
+                                           BluetoothProfile.STATE_CONNECTING});
+
+                    if (headsets.contains(mDevice)) {
+                        return; // Already profile connection in progress
+                    }
+                    Message msg = new Message();
+                    msg.what = CONNECT_OTHER_PROFILES;
+                    msg.arg1 = CONNECT_HFP_OUTGOING;
+                    sendMessageDelayed(msg, CONNECT_OTHER_PROFILES_DELAY);
+                } else if (mHeadsetService != null &&
+                           mExpectingSdpComplete) {
+                    Message msg = new Message();
+                    msg.what = CONNECT_OTHER_PROFILES;
+                    msg.arg1 = CONNECT_HFP_OUTGOING;
+                    sendMessageDelayed(msg, CONNECT_OTHER_PROFILES_DELAY);
+                }
+                break;
+            default:
+                break;
+        }
+
+    }
+
+    /*package*/ BluetoothDevice getDevice() {
+        return mDevice;
+    }
+
+    private void log(String message) {
+        if (DBG) {
+            Log.i(TAG, "Device:" + mDevice + " Message:" + message);
+        }
+    }
+    //<MR1 change>
+    public void my_quit() {
+        super.quit();
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothGatt.java b/bluetoothmsm/java/android/bluetooth/BluetoothGatt.java
new file mode 100644
index 0000000..432996e
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothGatt.java
@@ -0,0 +1,635 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.bluetooth;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.ParcelUuid;
+import android.os.ServiceManager;
+import android.os.RemoteException;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Public API for controlling the Bluetooth GATT profile/apps.
+ * Currently, this implementation supports only local GATT server
+ * applications. Client side is handled in BluetoothGattService.
+ * TODO: merge server/client implementations.
+ *
+ * @hide
+ */
+
+public final class BluetoothGatt implements BluetoothProfile {
+
+    private static final String TAG = "BluetoothGatt";
+
+    /**
+     * GATT Profile Server Role
+     */
+    public static final int SERVER_ROLE = 1;
+
+    /**
+     *  GATT Profile Client Role (TODO: needs to be merged)
+     */
+    public static final int CLIENT_ROLE = 2;
+
+
+    /** GATT result codes */
+
+    public static final byte GATT_SUCCESS = 0x0;
+
+    /* ATT spec error codes */
+    public static final int ATT_INVALID_HANDLE       = 0x01;
+    public static final int ATT_READ_NOT_PERM        = 0x02;
+    public static final int ATT_WRITE_NOT_PERM       = 0x03;
+    public static final int ATT_INVALID_PDU          = 0x04;
+    public static final int ATT_AUTHENTICATION       = 0x05;
+    public static final int ATT_REQ_NOT_SUPP         = 0x06;
+    public static final int ATT_INVALID_OFFSET       = 0x07;
+    public static final int ATT_AUTHORIZATION        = 0x08;
+    public static final int ATT_PREP_QUEUE_FULL      = 0x09;
+    public static final int ATT_ATTR_NOT_FOUND       = 0x0A;
+    public static final int ATT_ATTR_NOT_LONG        = 0x0B;
+    public static final int ATT_INSUFF_ENCR_KEY_SIZE = 0x0C;
+    public static final int ATT_INVAL_ATTR_VALUE_LEN = 0x0D;
+    public static final int ATT_UNLIKELY             = 0x0E;
+    public static final int ATT_INSUFF_ENC           = 0x0F;
+    public static final int ATT_UNSUPP_GRP_TYPE      = 0x10;
+    public static final int ATT_INSUFF_RESOURCES     = 0x11;
+
+    /* Reserved   0x12 - 0x7f */
+    /* Application error codes  0x80 - 0xff */
+
+    /* Local status codes */
+    public static final int GATT_FAILURE             = 0x101;
+    public static final int GATT_INVALID_ARGUMENTS   = 0x102;
+    public static final int GATT_CONFIG_REGISTRATION_SUCCESS    = 0x201;
+    public static final int GATT_CONFIG_REGISTRATION_FAILURE    = 0x202;
+    public static final int GATT_CONFIG_UNREGISTRATION_SUCCESS  = 0x203;
+    public static final int GATT_CONFIG_UNREGISTRATION_FAILURE  = 0x204;
+
+
+    private ServiceListener mServiceListener;
+    private BluetoothAdapter mAdapter;
+    private IBluetooth mService;
+
+    /**
+     * Create a BluetoothGatt  proxy object.
+     */
+    /*package*/ BluetoothGatt(Context mContext, ServiceListener l) {
+        IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
+        mServiceListener = l;
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+        if (b != null) {
+            mService = IBluetooth.Stub.asInterface(b);
+            if (mServiceListener != null) {
+                mServiceListener.onServiceConnected(BluetoothProfile.GATT, this);
+            }
+        } else {
+            Log.w(TAG, "Bluetooth Service not available!");
+
+            // Instead of throwing an exception which prevents people from going
+            // into Wireless settings in the emulator. Let it crash later when it is actually used.
+            mService = null;
+        }
+    }
+
+    /*package*/ void close() {
+        mServiceListener = null;
+    }
+
+    /**
+     * Register a GATT server configuration.
+     * This is an asynchronous call and so
+     * the callback is used to notify success or failure if the method returns true.
+     *
+     */
+    public boolean registerServerConfiguration(String name, int range, BluetoothGattCallback callback) {
+       if (!checkAppParam(name, range, callback)) return false;
+
+        Log.d(TAG, "register GATT server application " + name);
+        BluetoothGattCallbackWrapper wrapper = new BluetoothGattCallbackWrapper(callback);
+        BluetoothGattAppConfiguration config = new BluetoothGattAppConfiguration(name, SERVER_ROLE, (int)range);
+        boolean result = false;
+
+        if (mService != null) {
+            try {
+                result = mService.registerGattAppConfiguration(config, wrapper);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+            result = true;
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return result;
+    }
+
+     /**
+     * Unregister a GATT server configuration.
+     * This is an asynchronous call and so
+     * the callback is used to notify success or failure if the method returns true.
+     *
+     */
+   public boolean unregisterServerConfiguration(BluetoothGattAppConfiguration config) {
+       return unregisterAppConfiguration(config);
+   }
+
+   private boolean unregisterAppConfiguration(BluetoothGattAppConfiguration config) {
+        boolean result = false;
+
+        if (config == null)
+            return result;
+
+        if (mService != null) {
+            try {
+                result = mService.unregisterGattAppConfiguration(config);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+            result = true;
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+
+        return result;
+    }
+
+    /**
+     * Establish GATT connection to LE device
+     *
+     * @hide
+     */
+     public int gattConnectLe(
+                                    String address,
+                                    byte prohibitRemoteChg,
+                                    byte filterPolicy,
+                                    int scanInterval,
+                                    int scanWindow,
+                                    int intervalMin,
+                                    int intervalMax,
+                                    int latency,
+                                    int superVisionTimeout,
+                                    int minCeLen,
+                                    int maxCeLen, int connTimeout) {
+
+         Log.d(TAG, "Establish LE GATT Connection");
+
+        if (mService != null) {
+            try {
+                return mService.gattConnect(address, null, prohibitRemoteChg, filterPolicy, scanInterval,
+                                            scanWindow, intervalMin, intervalMax, latency,
+                                            superVisionTimeout, minCeLen, maxCeLen, connTimeout);
+            } catch (RemoteException e) {Log.e(TAG, "", e);}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+
+        return BluetoothDevice.GATT_RESULT_FAIL;
+    }
+
+   /**
+     * Cancel GATT connection creation
+     *
+     * @hide
+     */
+    public boolean gattConnectLeCancel(BluetoothGattAppConfiguration config,
+                                             String address) {
+        Log.d(TAG, "Cancel LE GATT Connection creation");
+
+       if (config == null || address == null)
+            return false;
+
+       if (mService != null) {
+           try {
+               return mService.gattConnectCancel(address, null);
+           } catch (RemoteException e) {Log.e(TAG, "", e);}
+       } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+
+       return false;
+    }
+
+    public boolean closeGattLeConnection(BluetoothGattAppConfiguration config,
+                                         String address) {
+       if (config == null)
+            return false;
+
+        if (mService != null) {
+            try {
+                return mService.closeGattLeConnection(config, address);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+
+        return false;
+    }
+
+    public boolean sendIndication(BluetoothGattAppConfiguration config,
+                                  int handle, byte[] value, boolean notify, int sessionHandle) {
+        boolean result = false;
+
+        if (config == null || !rangeCheck(handle))
+            return false;
+
+        if (mService != null) {
+            try {
+                result = mService.sendIndication(config, (int)handle, value, notify, sessionHandle) ;
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+            result = true;
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+
+        return result;
+    }
+
+    /* Respond with description for just one service */
+    public boolean discoverPrimaryServiceResponse(BluetoothGattAppConfiguration config,
+                                                  int requestHandle, int errorCode, int handle, int end,
+                                                  ParcelUuid uuid) {
+        Log.d(TAG, "discoverPrimaryServiceResponse");
+          boolean result = false;
+
+        Log.d(TAG, "discoverPrimaryServiceResponse");
+        if (config == null)
+            return false;
+
+        if (mService != null) {
+            try {
+                /*Remove this when the api change*/
+                result = mService.discoverPrimaryResponse(config, uuid, handle, end, errorCode, requestHandle);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+            result = true;
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+
+        return result;
+    }
+
+    public boolean discoverPrimaryServiceByUuidResponse(BluetoothGattAppConfiguration config,
+                                                        int requestHandle, int errorCode, int handle, int end,
+                                                        ParcelUuid uuid) {
+        Log.d(TAG, "discoverPrimaryServiceByUuidResponse");
+        boolean result = false;
+
+        if (config == null)
+            return false;
+
+        if (mService != null) {
+            try {
+                /*Remove this when the api change*/
+                result = mService.discoverPrimaryByUuidResponse(config, handle, end,
+                                                                errorCode, requestHandle);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+            result = true;
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+
+        return result;
+    }
+
+    public boolean findIncludedServiceResponse(BluetoothGattAppConfiguration config,
+                                               int requestHandle, int errorCode, int handle, int start, int end,
+                                               ParcelUuid uuid) {
+        Log.d(TAG, "findIncludedServiceResponse");
+        boolean result = false;
+
+        if (config == null)
+            return false;
+
+        if (mService != null) {
+            try {
+                /*Remove this when the api change*/
+                result = mService.findIncludedResponse(config, uuid, handle, start, end,
+                                                       errorCode, requestHandle);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+            result = true;
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+
+        return result;
+
+    }
+
+    public boolean findInfoResponse(BluetoothGattAppConfiguration config,
+                                    int requestHandle, int errorCode, int handle, ParcelUuid uuid) {
+
+        Log.d(TAG, "findInfoResponse");
+        boolean result = false;
+
+        if (config == null)
+            return false;
+
+        if (mService != null) {
+            try {
+                /*Remove this when the api change*/
+                result = mService.findInfoResponse(config, uuid, handle,
+                                                   errorCode, requestHandle);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+            result = true;
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+
+        return result;
+    }
+
+
+    public boolean discoverCharacteristicResponse(BluetoothGattAppConfiguration config, int errorCode,
+                                                  int requestHandle, int handle, byte property, int valueHandle,
+                                                  ParcelUuid uuid) {
+        Log.d(TAG, "discoverCharacteristicResponse");
+        boolean result = false;
+
+        if (config == null)
+            return false;
+
+        if (mService != null) {
+            try {
+                /*Remove this when the api change*/
+                result = mService.discoverCharacteristicResponse(config, uuid, handle, property, valueHandle,
+                                                                 errorCode, requestHandle);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+            result = true;
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+
+        return result;
+    }
+
+    public boolean readByTypeResponse(BluetoothGattAppConfiguration config, int requestHandle,
+                                      int errorCode, ParcelUuid uuid, int handle, byte[] payload) {
+        Log.d(TAG, "readByTypeResponse");
+        boolean result = false;
+
+        if (config == null)
+            return false;
+
+        if (mService != null) {
+            try {
+                /*Remove this when the api change*/
+                result = mService.readByTypeResponse(config, handle, uuid, payload, errorCode, requestHandle);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+            result = true;
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+
+        return result;
+
+    }
+
+    public boolean readResponse(BluetoothGattAppConfiguration config, int requestHandle,
+                                int errorCode, ParcelUuid uuid, byte[] payload) {
+         Log.d(TAG, "readResponse");
+         boolean result = false;
+
+         if (config == null)
+             return false;
+
+         if (mService != null) {
+             try {
+                 /*Remove this when the api change*/
+                 result = mService.readResponse(config, uuid, payload, errorCode, requestHandle);
+             } catch (RemoteException e) {
+                 Log.e(TAG, e.toString());
+             }
+             result = true;
+         } else {
+             Log.w(TAG, "Proxy not attached to service");
+             Log.d(TAG, Log.getStackTraceString(new Throwable()));
+         }
+         return result;
+     }
+
+    public boolean writeResponse(BluetoothGattAppConfiguration config, int requestHandle,
+                                 int errorCode, ParcelUuid uuid) {
+        Log.d(TAG, "writeResponse");
+        boolean result = false;
+
+        if (config == null)
+            return false;
+
+        if (mService != null) {
+            try {
+                /*Remove this when the api change*/
+                result = mService.writeResponse(config, uuid, errorCode, requestHandle);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+            result = true;
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return result;
+    }
+
+    @Override
+    public int getConnectionState(BluetoothDevice device) {
+
+       return STATE_DISCONNECTED;
+    }
+
+    @Override
+    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+        return new ArrayList<BluetoothDevice>();
+    }
+
+    @Override
+    public List<BluetoothDevice> getConnectedDevices() {
+        // TODO
+
+        //if (mService != null) {
+            //try {
+                //return mService.getConnectedGattDevices();
+        //} catch (RemoteException e) {
+        //      Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+        //      return new ArrayList<BluetoothDevice>();
+        //  }
+        //}
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return new ArrayList<BluetoothDevice>();
+    }
+
+    private boolean rangeCheck(int value) {
+        if (value < 1 || value > 0xffff)
+            return false;
+        else
+            return true;
+    }
+
+    private boolean checkAppParam(String name, int range, BluetoothGattCallback callback) {
+        if (name == null || callback == null)
+            return false;
+
+        if (!rangeCheck(range))
+            return false;
+
+        return true;
+    }
+
+    private class BluetoothGattCallbackWrapper extends IBluetoothGattCallback.Stub {
+        private BluetoothGattCallback mCallback;
+
+        public BluetoothGattCallbackWrapper(BluetoothGattCallback callback) {
+            mCallback = callback;
+        }
+
+        @Override
+        public void onGattAppConfigurationStatusChange(BluetoothGattAppConfiguration config,
+                                                      int status) {
+            mCallback.onGattAppConfigurationStatusChange(config, status);
+        }
+
+        @Override
+        public void onGattActionComplete(BluetoothGattAppConfiguration config, String action, int status) {
+            mCallback.onGattActionComplete(config, action, status);
+        }
+
+        @Override
+        public void onGattDiscoverPrimaryServiceRequest(BluetoothGattAppConfiguration config,
+                                                        int start, int end, int requestHandle) {
+            Log.d(TAG, "onGattDiscoverPrimaryServiceRequest callback : " + mCallback);
+            mCallback.onGattDiscoverPrimaryServiceRequest(config, start, end, requestHandle);
+        }
+
+        @Override
+        public void onGattDiscoverPrimaryServiceByUuidRequest(BluetoothGattAppConfiguration config,
+                                                              int start, int end, ParcelUuid uuid, int requestHandle) {
+            Log.d(TAG, "onGattDiscoverPrimaryServiceByUuidRequest callback : " + mCallback);
+            mCallback.onGattDiscoverPrimaryServiceByUuidRequest(config, start, end, uuid, requestHandle);
+        }
+
+        @Override
+        public void onGattFindIncludedServiceRequest(BluetoothGattAppConfiguration config,
+                                                     int start, int end, int requestHandle) {
+            Log.d(TAG, "onGattFindIncludedServiceRequest: " + config + " range " + start + " - " + end);
+            mCallback.onGattFindIncludedServiceRequest(config, start, end, requestHandle);
+        }
+
+        @Override
+        public void onGattFindInfoRequest(BluetoothGattAppConfiguration config,
+                                      int start, int end, int requestHandle) {
+            Log.d(TAG, "onGattFindInfoRequest: " + config + " range " + start + " - " + end);
+            mCallback.onGattFindInfoRequest(config, start, end, requestHandle);
+        }
+
+        @Override
+        public void onGattDiscoverCharacteristicRequest(BluetoothGattAppConfiguration config,
+                                                        int start, int end, int requestHandle) {
+            Log.d(TAG, "onGattDiscoverCharacteristicRequest: " + config + " range " + start + " - " + end);
+            mCallback.onGattDiscoverCharacteristicRequest(config, start, end, requestHandle);
+        }
+
+        @Override
+        public void onGattReadByTypeRequest(BluetoothGattAppConfiguration config,
+                                            ParcelUuid uuid, int start, int end, String authentication, int requestHandle) {
+            Log.d(TAG, "onGattReadByTypeRequest: " + config + ", range " + start + " - "
+                  + end + ", UUID " + uuid.toString() + ", authentication" + authentication);
+            mCallback.onGattReadByTypeRequest(config, uuid, start, end,
+                                              authentication, requestHandle);
+        }
+
+        @Override
+        public void onGattReadRequest(BluetoothGattAppConfiguration config,
+                                      int handle, String authentication, int requestHandle) {
+            Log.d(TAG, "onGattReadRequest: " + config + ", handle " + handle +
+                  ", authentication " + authentication);
+            mCallback.onGattReadRequest(config, handle, authentication, requestHandle);
+        }
+
+        @Override
+        public void onGattWriteCommand(BluetoothGattAppConfiguration config, int handle, byte value[],
+                                       String authentication)  {
+            Log.d(TAG, "onGattWriteCommand: " + config + ", handle " + handle +
+              ", authentication " + authentication);
+            mCallback.onGattWriteCommand(config, handle, value, authentication);
+        }
+
+        @Override
+        public void onGattWriteRequest(BluetoothGattAppConfiguration config, int handle, byte value[],
+                                               String authentication, int sessionHandle, int requestHandle)  {
+            Log.d(TAG, "onGattWriteRequest: " + config + ", handle " + handle +
+              ", authentication " + authentication + ", session " + sessionHandle);
+            mCallback.onGattWriteRequest(config, handle, value, authentication, sessionHandle, requestHandle);
+        }
+
+        @Override
+        public void onGattSetClientConfigDescriptor(BluetoothGattAppConfiguration config, int handle, byte[] value,
+                                                int sessionHandle) {
+            Log.d(TAG, "onGattSetClientConfigDescriptor: " + config + " handle " + handle + " session " + sessionHandle);
+            mCallback.onGattSetClientConfigDescriptor(config, handle, value, sessionHandle);
+        }
+
+        @Override
+        public void onGattIndicateResponse(BluetoothGattAppConfiguration config, boolean result) {
+            Log.d(TAG, "onGattIndicateResponse: " + config + " result " + result);
+            mCallback.onGattIndicateResponse(config, result);
+        }
+
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothGattAppConfiguration.aidl b/bluetoothmsm/java/android/bluetooth/BluetoothGattAppConfiguration.aidl
new file mode 100644
index 0000000..af24b2b
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothGattAppConfiguration.aidl
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.bluetooth;
+
+parcelable BluetoothGattAppConfiguration;
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothGattAppConfiguration.java b/bluetoothmsm/java/android/bluetooth/BluetoothGattAppConfiguration.java
new file mode 100644
index 0000000..b476762
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothGattAppConfiguration.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+package android.bluetooth;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * The Bluetooth GATT Server Application Configuration
+ * @hide
+ */
+public final class BluetoothGattAppConfiguration implements Parcelable {
+    private final String mName;
+    private final int mRole;
+    private final String mPath;
+    private final int mRange;
+
+    /**
+     * Constructor for GATT server application configuration
+     */
+    BluetoothGattAppConfiguration(String name, int range) {
+        mName = name;
+        mRange = range;
+        mRole = BluetoothGatt.SERVER_ROLE;
+        mPath = "/android/bluetooth/gatt/" + name;
+    }
+
+    /**
+     * Generic constructor for GATT application configuration
+     */
+    BluetoothGattAppConfiguration(String name, int role, int range) {
+        mName = name;
+        mRole = role;
+        mRange = range;
+        if (role == BluetoothGatt.SERVER_ROLE)
+            mPath = "/android/bluetooth/gatt/" + name;
+        else
+            mPath = null;
+    }
+
+
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof BluetoothGattAppConfiguration) {
+            BluetoothGattAppConfiguration config = (BluetoothGattAppConfiguration) o;
+            // config.getName() can never be NULL
+            return mName.equals(config.getName()) &&
+                                mRole == config.getRole() &&
+                                mRange == config.getRange();
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = BluetoothProfile.GATT;
+        result = result + (mName != null ? mName.hashCode() : 0);
+        result = 31 * result + mRole;
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "BluetoothGattAppConfiguration [mName = " + mName + "]";
+    }
+
+    public String getName() {
+        return mName;
+    }
+
+    public int getRole() {
+        return mRole;
+    }
+
+    public String getPath() {
+        return mPath;
+    }
+
+    public int getRange() {
+        return mRange;
+    }
+
+    public static final Parcelable.Creator<BluetoothGattAppConfiguration> CREATOR =
+        new Parcelable.Creator<BluetoothGattAppConfiguration>() {
+        @Override
+        public BluetoothGattAppConfiguration createFromParcel(Parcel in) {
+            String name = in.readString();
+            int role = in.readInt();
+            String path = in.readString();
+            int range = in.readInt();
+            return new BluetoothGattAppConfiguration(name, role, range);
+        }
+
+        @Override
+        public BluetoothGattAppConfiguration[] newArray(int size) {
+            return new BluetoothGattAppConfiguration[size];
+        }
+    };
+
+    public void writeToParcel(Parcel out, int flags) {
+        out.writeString(mName);
+        out.writeInt(mRole);
+        out.writeString(mPath);
+        out.writeInt(mRange);
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothGattCallback.java b/bluetoothmsm/java/android/bluetooth/BluetoothGattCallback.java
new file mode 100644
index 0000000..cc60805
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothGattCallback.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.bluetooth;
+
+import android.util.Log;
+import android.os.ParcelUuid;
+
+/**
+ * This abstract class is used to implement BluetoothGatt callbacks.
+ * @hide
+ */
+public abstract class BluetoothGattCallback {
+    private static final String TAG = "BluetoothGattCallback";
+
+    /**
+     * Callback to inform change in registration state of the GATT profile
+     * application.
+     *
+     * @param config Gatt profile app configuration
+     * @param status Success or failure of the registration or unregistration
+     *            calls. Can be one of
+     *            GATT_CONFIG_REGISTRATION_SUCCESS or
+     *            GATT_CONFIG_REGISTRATION_FAILURE or
+     *            GATT_CONFIG_UNREGISTRATION_SUCCESS or
+     *            GATT_CONFIG_UNREGISTRATION_FAILURE
+     */
+    public void onGattAppConfigurationStatusChange(BluetoothGattAppConfiguration config,
+            int status) {
+        Log.d(TAG, "onGattAppConfigurationStatusChange: " + config + "Status: " + status);
+    }
+
+    /**
+     * Callback to inform completion of outstanding GATT profile action
+     *
+     * @param config Gatt profile app configuration
+     * @param status Can be one of
+     *            GATT_SUCCESS or
+     *            GATT_ACTION_FAILURE or
+     *            GATT_ACTION_INVALID_ARGUMENTS
+     */
+    public void onGattActionComplete(BluetoothGattAppConfiguration config, String action,
+                                     int status) {
+        Log.d(TAG, "onGattActionComplete: " + action + "Status: " + status);
+    }
+
+    /* Respond with description for just one service */
+    public void onGattDiscoverPrimaryServiceRequest(BluetoothGattAppConfiguration config,
+                                                    int start, int end, int requestHandle) {
+        Log.d(TAG, "onGattDiscoverPrimaryServiceRequest: " + config + " range " + start + " - " + end);
+    }
+
+    public void onGattDiscoverPrimaryServiceByUuidRequest(BluetoothGattAppConfiguration config,
+                                                          int start, int end, ParcelUuid uuid, int requestHandle) {
+        Log.d(TAG, "onGattDiscoverPrimaryServiceByUuidRequest: " + config + "UUID" + uuid .toString() + " range " + start + " - " + end);
+    }
+
+    /* Respond with description for just one service */
+    public void onGattFindIncludedServiceRequest(BluetoothGattAppConfiguration config,
+                                                 int start, int end, int requestHandle) {
+        Log.d(TAG, "onGattFindIncludedServiceRequest: " + config + " range " + start + " - " + end);
+    }
+
+
+    public void onGattFindInfoRequest(BluetoothGattAppConfiguration config,
+                                      int start, int end, int requestHandle) {
+        Log.d(TAG, "onGattFindInfoRequest: " + config + " range " + start + " - " + end);
+    }
+
+    public void onGattDiscoverCharacteristicRequest(BluetoothGattAppConfiguration config,
+                                             int start, int end, int requestHandle) {
+        Log.d(TAG, "onGattDiscoverCharacteristicRequest: " + config + " range " + start + " - " + end);
+    }
+
+    public void onGattReadByTypeRequest(BluetoothGattAppConfiguration config,
+                                        ParcelUuid uuid, int start, int end, String authentication, int requestHandle) {
+        Log.d(TAG, "onGattReadByTypeRequest: " + config + " range " + start + " - " + end
+              + " link authentication: " + authentication);
+    }
+
+    public void onGattReadRequest(BluetoothGattAppConfiguration config,
+                                  int handle, String authentication, int requestHandle) {
+        Log.d(TAG, "onGattReadRequest: " + config + " handle " + handle +
+              " link authentication: " + authentication);
+    }
+
+    public void onGattWriteCommand(BluetoothGattAppConfiguration config, int handle, byte[] value,
+                                   String authentication) {
+
+        Log.d(TAG, "onGattWriteCommand: " + config + " handle " + handle +
+              " link authentication: " + authentication);
+    }
+
+    public void onGattWriteRequest(BluetoothGattAppConfiguration config, int handle, byte[] value,
+                                   String authentication, int sessionHandle, int requestHandle) {
+
+        Log.d(TAG, "onGattWriteRequest: " + config + " handle " + handle +
+              " link authentication: " + authentication + ", session " + sessionHandle);
+    }
+
+    public void onGattSetClientConfigDescriptor(BluetoothGattAppConfiguration config, int handle, byte[] value,
+                                            int sessionHandle) {
+        Log.d(TAG, "onGattSetClientConfigDescriptor: " + config + " handle " + handle + " session " + sessionHandle);
+    }
+
+    public void onGattIndicateResponse(BluetoothGattAppConfiguration config, boolean result) {
+        Log.d(TAG, "onGattIndicateResponse: " + config + " result " + result);
+    }
+}
\ No newline at end of file
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothGattService.java b/bluetoothmsm/java/android/bluetooth/BluetoothGattService.java
new file mode 100644
index 0000000..3005d9e
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothGattService.java
@@ -0,0 +1,696 @@
+/*
+ * Copyright (c) 2011-2012 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.os.Handler;
+import android.os.ParcelUuid;
+import android.os.RemoteException;
+import android.util.Log;
+
+import java.io.IOException;
+
+import java.util.ArrayList;
+import java.util.UUID;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * Public API for controlling the Bluetooth GATT based services.
+ *
+ * @hide
+ */
+
+public class BluetoothGattService {
+    private static final String TAG = "BluetoothGattService";
+    private ParcelUuid mUuid;
+    private String mObjPath;
+    private int mServiceId;
+    private BluetoothDevice mDevice;
+    private String mName = null;
+    private boolean watcherRegistered = false;
+    private IBluetoothGattProfile profileCallback = null;
+
+    private final HashMap<String, Map<String, String>> mCharacteristicProperties;
+    private final ArrayList<String> mUpdateCharacteristicsTracker;
+    private String[] characteristicPaths = null;
+
+    private static final int DISCOVERY_NONE = 0;
+    private static final int DISCOVERY_FINISHED = 1;
+    private static final int DISCOVERY_IN_PROGRESS = 2;
+
+    private int discoveryState;
+
+    private boolean mClosed;
+    private final ReentrantReadWriteLock mLock;
+
+    private final IBluetooth mService;
+
+    private final ServiceHelper mHelper;
+
+    private final Handler mRemoteGattServiceHandler;
+
+    public BluetoothGattService(BluetoothDevice device, ParcelUuid uuid, String path,
+                                IBluetoothGattProfile callback) {
+        mDevice = device;
+        mUuid = uuid;
+        mObjPath = path;
+        profileCallback = callback;
+        mClosed = false;
+        mLock = new ReentrantReadWriteLock();
+
+        mCharacteristicProperties = new HashMap<String, Map<String, String>>();
+        mUpdateCharacteristicsTracker = new ArrayList<String>();
+
+        mHelper = new ServiceHelper();
+        mService = BluetoothDevice.getService();
+
+        mRemoteGattServiceHandler = new Handler();
+        boolean hasGattServiceStarted = mRemoteGattServiceHandler.postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                Log.d(TAG, "Inside run for disc char");
+                mHelper.startRemoteGattService();
+            }
+        }, 1000);
+        Log.d(TAG, "Remote Gatt service started : " + hasGattServiceStarted);
+    }
+
+    public boolean gattConnect(byte prohibitRemoteChg,
+                               byte filterPolicy,
+                               int scanInterval,
+                               int scanWindow,
+                               int intervalMin,
+                               int intervalMax,
+                               int latency,
+                               int superVisionTimeout,
+                               int minCeLen,
+                               int maxCeLen, int connTimeout) {
+        return mHelper.gattConnect(prohibitRemoteChg, filterPolicy, scanInterval,
+                                 scanWindow, intervalMin, intervalMax, latency,
+                                 superVisionTimeout, minCeLen, maxCeLen, connTimeout);
+    }
+
+    public boolean gattConnectCancel() {
+        return mHelper.gattConnectCancel();
+    }
+
+    public ParcelUuid getServiceUuid() {
+        return mUuid;
+    }
+
+    public String getServiceName() throws Exception {
+
+        if (mName != null)
+            return  mName;
+
+        mLock.readLock().lock();
+        try {
+            if (mClosed) throw new IOException("GATT service closed");
+            return mService.getGattServiceName(mObjPath);
+        } finally {
+            mLock.readLock().unlock();
+        }
+    }
+
+    public String[] getCharacteristics() {
+        if (!mHelper.discoveryDone())
+            return null;
+
+        return characteristicPaths;
+    }
+
+    public boolean discoverCharacteristics() {
+        return mHelper.doDiscovery();
+    }
+
+    public boolean isDiscoveryDone() {
+        return mHelper.discoveryDone();
+    }
+
+    public String[] getCharacteristicPaths() {
+
+            String value = "";
+            String[] paths = null;
+            try {
+                value = mService.getGattServiceProperty(mObjPath, "Characteristics");
+                if (value == null) {
+                    Log.d(TAG, "value is null");
+                    return null;
+                }
+                Log.d(TAG, "value is : " + value);
+
+                // The Charateristic paths are stored as a "," separated string.
+                paths = value.split(",");
+
+            } catch (Exception e) {
+                Log.e(TAG, "!!!Error while calling getGattServiceProperty");
+            }
+            return paths;
+    }
+
+    public ParcelUuid[] getCharacteristicUuids() {
+
+        ArrayList<ParcelUuid>  uuidList = new ArrayList<ParcelUuid>();
+
+        if (!mHelper.discoveryDone())
+            return null;
+
+        if (characteristicPaths == null)
+            return null;
+
+        int count  = characteristicPaths.length;
+
+        for(int i = 0; i< count; i++) {
+
+            String value = getCharacteristicProperty(characteristicPaths[i], "UUID");
+
+            if (value != null)
+                uuidList.add(ParcelUuid.fromString(value));
+
+            Log.d (TAG, "Characteristic UUID: " + value);
+
+        }
+
+        ParcelUuid[] uuids = new ParcelUuid[count];
+
+        uuidList.toArray(uuids);
+
+        return uuids;
+
+    }
+
+    public ParcelUuid getCharacteristicUuid(String path) {
+
+        ParcelUuid uuid = null;
+
+        if (!mHelper.discoveryDone())
+            return null;
+
+        String value = getCharacteristicProperty(path, "UUID");
+
+        if (value != null) {
+                uuid = ParcelUuid.fromString(value);
+
+                Log.d (TAG, "Characteristic UUID: " + value);
+        }
+        return uuid;
+    }
+
+    public String getCharacteristicDescription(String path) {
+        if (!mHelper.discoveryDone())
+            return null;
+
+        return getCharacteristicProperty(path, "Description");
+
+    }
+
+    public byte[] readCharacteristicRaw(String path)
+    {
+        Log.d (TAG, "readCharacteristicValue for " + path);
+
+        if (!mHelper.discoveryDone())
+            return null;
+
+        if (characteristicPaths == null)
+            return null;
+
+        String value = getCharacteristicProperty(path, "Value");
+
+        if (value == null) {
+            return null;
+        }
+        byte[] ret = value.getBytes();
+        return ret;
+    }
+
+    public boolean updateCharacteristicValue(String path) throws Exception {
+        Log.d (TAG, "updateCharacteristicValue for " + path);
+
+        if (!mHelper.discoveryDone())
+            return false;
+
+        if (characteristicPaths == null)
+            return false;
+
+        mLock.readLock().lock();
+        try {
+            if (mClosed) throw new Exception ("GATT service closed");
+            return mHelper.fetchCharValue(path);
+        } finally {
+            mLock.readLock().unlock();
+        }
+    }
+
+    public String getCharacteristicClientConf(String path)
+    {
+        if (!mHelper.discoveryDone())
+            return null;
+
+        if (characteristicPaths == null)
+            return null;
+
+        String value = (String) getCharacteristicProperty(path, "ClientConfiguration");
+
+        if (value == null) {
+            return null;
+        }
+
+        return value;
+    }
+
+    public boolean writeCharacteristicRaw(String path, byte[] value,
+                                          boolean reliable) throws Exception {
+
+        Log.d (TAG, "writeCharacteristicRaw " + path);
+
+        if (!mHelper.discoveryDone())
+            return false;
+
+        if (characteristicPaths == null)
+            return false;
+
+        mLock.readLock().lock();
+        try {
+            if (mClosed) throw new Exception ("GATT service closed");
+            return mHelper.setCharacteristicProperty(path, "Value", value, reliable);
+        }  finally {
+            mLock.readLock().unlock();
+        }
+    }
+
+    public boolean setCharacteristicClientConf(String path, int config) throws Exception {
+
+        if (!mHelper.discoveryDone())
+            return false;
+
+        if (characteristicPaths == null)
+            return false;
+
+        // Client Conf is 2 bytes
+        byte[] value = new byte[2];
+        value[1] = (byte)(config & 0xFF);
+        value[0] = (byte)((config >> 8) & 0xFF);
+
+        mLock.readLock().lock();
+        try {
+            if (mClosed) throw new Exception ("GATT service closed");
+            return mHelper.setCharacteristicProperty(path, "ClientConfiguration", value, true);
+        }  finally {
+            mLock.readLock().unlock();
+        }
+    }
+
+    public boolean registerWatcher() throws Exception {
+        if (watcherRegistered == false) {
+            mLock.readLock().lock();
+            try {
+                if (mClosed) throw new Exception ("GATT service closed");
+
+                watcherRegistered = mHelper.registerCharacteristicsWatcher();
+                return watcherRegistered;
+            }  finally {
+                mLock.readLock().unlock();
+            }
+       } else {
+            return true;
+        }
+    }
+
+    public boolean deregisterWatcher()  throws Exception {
+        if (watcherRegistered == true) {
+            watcherRegistered = false;
+
+            mLock.readLock().lock();
+            try {
+                if (mClosed) throw new Exception ("GATT service closed");
+                return mHelper.deregisterCharacteristicsWatcher();
+            }  finally {
+                mLock.readLock().unlock();
+            }
+        }
+        return true;
+    }
+
+    public void close() throws Exception{
+
+        mLock.writeLock().lock();
+        if (mClosed) {
+            mLock.writeLock().unlock();
+            return;
+        }
+
+        deregisterWatcher();
+
+        try {
+            mClosed = true;
+            mService.closeRemoteGattService(mObjPath, mServiceId);
+        } finally {
+            mLock.writeLock().unlock();
+        }
+    }
+
+    /** @hide */
+    @Override
+    protected void finalize() throws Throwable {
+        try {
+            close();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    private String getCharacteristicProperty(String path, String property) {
+
+        Map<String, String> properties = mCharacteristicProperties.get(path);
+
+        if (properties != null)
+            return properties.get(property);
+
+        return null;
+    }
+
+    private void addCharacteristicProperties(String path, String[] properties) {
+        Map<String, String> propertyValues = mCharacteristicProperties.get(path);
+        if (propertyValues == null) {
+            propertyValues = new HashMap<String, String>();
+        }
+
+        for (int i = 0; i < properties.length; i++) {
+            String name = properties[i];
+            String newValue = null;
+
+            if (name == null) {
+                Log.e(TAG, "Error: Gatt Characterisitc Property at index" + i + "is null");
+                continue;
+            }
+
+            newValue = properties[++i];
+
+            propertyValues.put(name, newValue);
+        }
+
+        mCharacteristicProperties.put(path, propertyValues);
+    }
+
+    private void updateCharacteristicPropertyCache(String path) {
+        String[] properties = null;
+
+        try {
+            properties = mService.getCharacteristicProperties(path);
+        } catch (Exception e) {Log.e(TAG, "", e);}
+
+        if (properties != null) {
+            addCharacteristicProperties(path, properties);
+        }
+    }
+
+    /**
+     * Helper to perform Service Characteristic discovery
+     */
+    private class ServiceHelper extends IBluetoothGattService.Stub {
+
+        private void setDiscoveryState(int state) {
+            Log.d(TAG, "Discovery State " + discoveryState + " to " + state);
+            discoveryState = state;
+        }
+
+        public boolean discoveryDone() {
+            return (discoveryState == DISCOVERY_FINISHED);
+        }
+
+        /**
+         * Throws IOException on failure.
+         */
+        public boolean doDiscovery() {
+
+            Log.d(TAG, "doDiscovery " + mObjPath);
+
+            if(discoveryState == DISCOVERY_IN_PROGRESS) {
+                Log.d(TAG, "Characteristic discovery is already in progress for " + mObjPath);
+                return true;
+            }
+
+            setDiscoveryState(DISCOVERY_IN_PROGRESS);
+
+            try {
+                return mService.discoverCharacteristics(mObjPath, mServiceId);
+            } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+            return false;
+
+        }
+
+        public void startRemoteGattService() {
+            setDiscoveryState(DISCOVERY_NONE);
+
+            try {
+                int servId = mService.startRemoteGattService(mObjPath, this);
+                if(servId >= 0) {
+                    Log.d(TAG, "Received service id :" + servId);
+                    mServiceId = servId;
+                } else {
+                    Log.d(TAG, "Error while starting remote gatt service");
+                    return;
+                }
+
+                int state = mService.getBondState(mDevice.getAddress());
+                Log.d(TAG, "Bond state of remote device : " + mDevice.getAddress() + " is " + state);
+                if(state == BluetoothDevice.BOND_BONDED) {
+                    characteristicPaths =  getCharacteristicPaths();
+                    if(characteristicPaths != null) {
+
+                       for(int i = 0; i< characteristicPaths.length; i++) {
+                           Log.d(TAG, "Update value for characteristics path : " +
+                                 characteristicPaths[i]);
+                           try {
+                               mHelper.fetchCharValue(characteristicPaths[i]);
+                               mUpdateCharacteristicsTracker.add(characteristicPaths[i]);
+                           } catch (Exception e) {Log.e(TAG, "", e);}
+                       }
+
+                    } else {
+                        Log.d(TAG, "doDiscovery for bonded device");
+                        doDiscovery();
+                    }
+                } else {
+                    Log.d(TAG, "doDiscovery as device is not bonded");
+                    doDiscovery();
+                }
+            } catch (RemoteException e) {Log.e(TAG, "", e);}
+        }
+
+        public synchronized void onCharacteristicsDiscovered(String[] paths, boolean result)
+        {
+            Log.d(TAG, "onCharacteristicsDiscovered: " + paths);
+
+            if (mClosed)
+                return;
+
+            if (paths !=null) {
+
+                int count = paths.length;
+
+                Log.d(TAG, "Discovered  " + count + " characteristics for service " + mObjPath + " ( " + mName + " )");
+
+                characteristicPaths = paths;
+
+                for (int i = 0; i < count; i++) {
+
+                    String[] properties = null;
+
+                    try {
+                        properties = mService.getCharacteristicProperties(paths[i]);
+                    } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+                    if (properties != null) {
+                        addCharacteristicProperties(paths[i], properties);
+                    }
+                }
+            }
+
+            setDiscoveryState(DISCOVERY_FINISHED);
+
+            if (profileCallback != null) {
+                try {
+                    profileCallback.onDiscoverCharacteristicsResult(mObjPath, result);
+                } catch (Exception e) {Log.e(TAG, "", e);}
+            }
+
+            this.notify();
+        }
+
+        public synchronized boolean gattConnect(byte prohibitRemoteChg,
+                                          byte filterPolicy,
+                                          int scanInterval,
+                                          int scanWindow,
+                                          int intervalMin,
+                                          int intervalMax,
+                                          int latency,
+                                          int superVisionTimeout,
+                                          int minCeLen,
+                                          int maxCeLen, int connTimeout) {
+             Log.d(TAG, "gattConnect");
+             try {
+                 int result =  mService.gattConnect(mDevice.getAddress(), mObjPath, prohibitRemoteChg, filterPolicy, scanInterval,
+                                  scanWindow, intervalMin, intervalMax, latency,
+                                  superVisionTimeout, minCeLen, maxCeLen, connTimeout);
+                if (result != BluetoothDevice.GATT_RESULT_SUCCESS)
+                     return false;
+                 else return true;
+             } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+             return false;
+        }
+
+        public synchronized boolean gattConnectCancel() {
+             Log.d(TAG, "gattConnectCancel");
+             try {
+                 return mService.gattConnectCancel(mDevice.getAddress(), mObjPath);
+             } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+             return false;
+        }
+
+        public synchronized void onSetCharacteristicProperty(String path, String property, boolean result)
+        {
+            Log.d(TAG, "onSetCharacteristicProperty: " + path + " property " + property + " result " + result);
+            if (mClosed)
+                return;
+
+            if ((path == null) || (property == null)) {
+                return;
+            }
+            if (property.equals("Value")) {
+                try {
+                    if(result) {
+                        updateCharacteristicPropertyCache(path);
+                    }
+                    if (profileCallback != null)
+                        profileCallback.onSetCharacteristicValueResult(path, result);
+                } catch (RemoteException e) {Log.e(TAG, "", e);}
+            }
+            if (property.equals("ClientConfiguration")) {
+                try {
+                    if(result) {
+                        updateCharacteristicPropertyCache(path);
+                    }
+                    if (profileCallback != null)
+                        profileCallback.onSetCharacteristicCliConfResult(path, result);
+                } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+            }
+        }
+
+        public synchronized void onValueChanged(String path, String value)
+        {
+            if (mClosed)
+                return;
+
+            if (path == null) {
+                return;
+            }
+            Log.d(TAG, "WatcherValueChanged = " + path + value);
+
+            if (profileCallback == null) {
+                deregisterCharacteristicsWatcher();
+                return;
+            }
+            try {
+                profileCallback.onValueChanged(path, value);
+            } catch (Exception e) {Log.e(TAG, "", e);}
+        }
+
+        public synchronized boolean setCharacteristicProperty(String path, String key,
+                byte[] value, boolean reliable) {
+            Log.d(TAG, "setCharacteristicProperty");
+            try {
+                return mService.setCharacteristicProperty(path, key, value, reliable, mServiceId);
+            } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+            return false;
+        }
+
+        public synchronized void onCharacteristicValueUpdated(String path, boolean result)
+        {
+
+            if (mClosed)
+                return;
+
+            if (result) {
+                updateCharacteristicPropertyCache(path);
+            }
+
+            if(mUpdateCharacteristicsTracker.contains(path)) {
+                Log.d(TAG, "Char path present in update tracker: " + path);
+                mUpdateCharacteristicsTracker.remove(path);
+                if(mUpdateCharacteristicsTracker.isEmpty() &&
+                   discoveryState == DISCOVERY_NONE) {
+                    Log.d(TAG, "retrieved char Paths from the cache and updated value");
+                    onCharacteristicsDiscovered(getCharacteristicPaths(), true);
+                }
+                return;
+            }
+
+            if (profileCallback != null) {
+                try {
+                    profileCallback.onUpdateCharacteristicValueResult(path, result);
+                } catch (RemoteException e) {Log.e(TAG, "", e);}
+            }
+        }
+
+        public synchronized boolean fetchCharValue(String path) {
+            try {
+                return mService.updateCharacteristicValue(path, mServiceId);
+            } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+            return false;
+        }
+
+        public synchronized boolean registerCharacteristicsWatcher() {
+            Log.d(TAG, "registerCharacteristicsWatcher: ");
+
+            try {
+                if (mService.registerCharacteristicsWatcher(mObjPath,
+                                                            this,
+                                                            mServiceId) == true) {
+                    return true;
+                }
+            } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+            return false;
+        }
+
+        public synchronized boolean deregisterCharacteristicsWatcher() {
+            Log.d(TAG, "deregisterCharacteristicsWatcher: ");
+            try {
+               return mService.deregisterCharacteristicsWatcher(mObjPath, mServiceId);
+             } catch (RemoteException e) {Log.e(TAG, "", e);}
+            return false;
+        }
+
+        public synchronized void waitDiscoveryDone()
+        {
+            try {
+                this.wait(60000);
+            } catch (InterruptedException e) {
+                Log.e(TAG, "Characteristics discovery takes too long");
+            }
+        }
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothHeadset.java b/bluetoothmsm/java/android/bluetooth/BluetoothHeadset.java
new file mode 100644
index 0000000..718ebd6
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothHeadset.java
@@ -0,0 +1,957 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Public API for controlling the Bluetooth Headset Service. This includes both
+ * Bluetooth Headset and Handsfree (v1.5) profiles.
+ *
+ * <p>BluetoothHeadset is a proxy object for controlling the Bluetooth Headset
+ * Service via IPC.
+ *
+ * <p> Use {@link BluetoothAdapter#getProfileProxy} to get
+ * the BluetoothHeadset proxy object. Use
+ * {@link BluetoothAdapter#closeProfileProxy} to close the service connection.
+ *
+ * <p> Android only supports one connected Bluetooth Headset at a time.
+ * Each method is protected with its appropriate permission.
+ */
+public final class BluetoothHeadset implements BluetoothProfile {
+    private static final String TAG = "BluetoothHeadset";
+    private static final boolean DBG = false;
+
+    /**
+     * Intent used to broadcast the change in connection state of the Headset
+     * profile.
+     *
+     * <p>This intent will have 3 extras:
+     * <ul>
+     *   <li> {@link #EXTRA_STATE} - The current state of the profile. </li>
+     *   <li> {@link #EXTRA_PREVIOUS_STATE}- The previous state of the profile. </li>
+     *   <li> {@link BluetoothDevice#EXTRA_DEVICE} - The remote device. </li>
+     * </ul>
+     * <p>{@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} can be any of
+     * {@link #STATE_DISCONNECTED}, {@link #STATE_CONNECTING},
+     * {@link #STATE_CONNECTED}, {@link #STATE_DISCONNECTING}.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission to
+     * receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CONNECTION_STATE_CHANGED =
+        "android.bluetooth.headset.profile.action.CONNECTION_STATE_CHANGED";
+
+    /**
+     * Intent used to broadcast the change in the Audio Connection state of the
+     * A2DP profile.
+     *
+     * <p>This intent will have 3 extras:
+     * <ul>
+     *   <li> {@link #EXTRA_STATE} - The current state of the profile. </li>
+     *   <li> {@link #EXTRA_PREVIOUS_STATE}- The previous state of the profile. </li>
+     *   <li> {@link BluetoothDevice#EXTRA_DEVICE} - The remote device. </li>
+     * </ul>
+     * <p>{@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} can be any of
+     * {@link #STATE_AUDIO_CONNECTED}, {@link #STATE_AUDIO_DISCONNECTED},
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission
+     * to receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_AUDIO_STATE_CHANGED =
+        "android.bluetooth.headset.profile.action.AUDIO_STATE_CHANGED";
+
+
+    /**
+     * Intent used to broadcast that the headset has posted a
+     * vendor-specific event.
+     *
+     * <p>This intent will have 4 extras and 1 category.
+     * <ul>
+     *  <li> {@link BluetoothDevice#EXTRA_DEVICE} - The remote Bluetooth Device
+     *       </li>
+     *  <li> {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD} - The vendor
+     *       specific command </li>
+     *  <li> {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE} - The AT
+     *       command type which can be one of  {@link #AT_CMD_TYPE_READ},
+     *       {@link #AT_CMD_TYPE_TEST}, or {@link #AT_CMD_TYPE_SET},
+     *       {@link #AT_CMD_TYPE_BASIC},{@link #AT_CMD_TYPE_ACTION}. </li>
+     *  <li> {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_ARGS} - Command
+     *       arguments. </li>
+     * </ul>
+     *
+     *<p> The category is the Company ID of the vendor defining the
+     * vendor-specific command. {@link BluetoothAssignedNumbers}
+     *
+     * For example, for Plantronics specific events
+     * Category will be {@link #VENDOR_SPECIFIC_HEADSET_EVENT_COMPANY_ID_CATEGORY}.55
+     *
+     * <p> For example, an AT+XEVENT=foo,3 will get translated into
+     * <ul>
+     *   <li> EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD = +XEVENT </li>
+     *   <li> EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE = AT_CMD_TYPE_SET </li>
+     *   <li> EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_ARGS = foo, 3 </li>
+     * </ul>
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission
+     * to receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_VENDOR_SPECIFIC_HEADSET_EVENT =
+            "android.bluetooth.headset.action.VENDOR_SPECIFIC_HEADSET_EVENT";
+
+    /**
+     * A String extra field in {@link #ACTION_VENDOR_SPECIFIC_HEADSET_EVENT}
+     * intents that contains the name of the vendor-specific command.
+     */
+    public static final String EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD =
+            "android.bluetooth.headset.extra.VENDOR_SPECIFIC_HEADSET_EVENT_CMD";
+
+    /**
+     * An int extra field in {@link #ACTION_VENDOR_SPECIFIC_HEADSET_EVENT}
+     * intents that contains the AT command type of the vendor-specific command.
+     */
+    public static final String EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE =
+            "android.bluetooth.headset.extra.VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE";
+
+    /**
+     * AT command type READ used with
+     * {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE}
+     * For example, AT+VGM?. There are no arguments for this command type.
+     */
+    public static final int AT_CMD_TYPE_READ = 0;
+
+    /**
+     * AT command type TEST used with
+     * {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE}
+     * For example, AT+VGM=?. There are no arguments for this command type.
+     */
+    public static final int AT_CMD_TYPE_TEST = 1;
+
+    /**
+     * AT command type SET used with
+     * {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE}
+     * For example, AT+VGM=<args>.
+     */
+    public static final int AT_CMD_TYPE_SET = 2;
+
+    /**
+     * AT command type BASIC used with
+     * {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE}
+     * For example, ATD. Single character commands and everything following the
+     * character are arguments.
+     */
+    public static final int AT_CMD_TYPE_BASIC = 3;
+
+    /**
+     * AT command type ACTION used with
+     * {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE}
+     * For example, AT+CHUP. There are no arguments for action commands.
+     */
+    public static final int AT_CMD_TYPE_ACTION = 4;
+
+    /**
+     * A Parcelable String array extra field in
+     * {@link #ACTION_VENDOR_SPECIFIC_HEADSET_EVENT} intents that contains
+     * the arguments to the vendor-specific command.
+     */
+    public static final String EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_ARGS =
+            "android.bluetooth.headset.extra.VENDOR_SPECIFIC_HEADSET_EVENT_ARGS";
+
+    /**
+     * The intent category to be used with {@link #ACTION_VENDOR_SPECIFIC_HEADSET_EVENT}
+     * for the companyId
+     */
+    public static final String VENDOR_SPECIFIC_HEADSET_EVENT_COMPANY_ID_CATEGORY  =
+            "android.bluetooth.headset.intent.category.companyid";
+
+    /**
+     * Headset state when SCO audio is not connected.
+     * This state can be one of
+     * {@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} of
+     * {@link #ACTION_AUDIO_STATE_CHANGED} intent.
+     */
+    public static final int STATE_AUDIO_DISCONNECTED = 10;
+
+    /**
+     * Headset state when SCO audio is connecting.
+     * This state can be one of
+     * {@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} of
+     * {@link #ACTION_AUDIO_STATE_CHANGED} intent.
+     */
+    public static final int STATE_AUDIO_CONNECTING = 11;
+
+    /**
+     * Headset state when SCO audio is connected.
+     * This state can be one of
+     * {@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} of
+     * {@link #ACTION_AUDIO_STATE_CHANGED} intent.
+     */
+    public static final int STATE_AUDIO_CONNECTED = 12;
+
+
+    private Context mContext;
+    private ServiceListener mServiceListener;
+    private IBluetoothHeadset mService;
+    BluetoothAdapter mAdapter;
+
+    /**
+     * Create a BluetoothHeadset proxy object.
+     */
+    /*package*/ BluetoothHeadset(Context context, ServiceListener l) {
+        mContext = context;
+        mServiceListener = l;
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+		Log.d(TAG, "BluetoothHeadset is created");
+		if(mServiceListener == null)
+			Log.e(TAG, "ERROR in headset");
+        if (!context.bindService(new Intent(IBluetoothHeadset.class.getName()), mConnection, 0)) {
+            Log.e(TAG, "Could not bind to Bluetooth Headset Service");
+        }
+    }
+
+    /**
+     * Close the connection to the backing service.
+     * Other public functions of BluetoothHeadset will return default error
+     * results once close() has been called. Multiple invocations of close()
+     * are ok.
+     */
+    /*package*/ synchronized void close() {
+        if (DBG) log("BluetoothHeadset close() which makes mServiceListner NULL");
+        if (mConnection != null && mService != null) {
+            mContext.unbindService(mConnection);
+        }
+        mConnection = null;
+        mServiceListener = null;
+    }
+
+    /**
+     * Initiate connection to a profile of the remote bluetooth device.
+     *
+     * <p> Currently, the system supports only 1 connection to the
+     * headset/handsfree profile. The API will automatically disconnect connected
+     * devices before connecting.
+     *
+     * <p> This API returns false in scenarios like the profile on the
+     * device is already connected or Bluetooth is not turned on.
+     * When this API returns true, it is guaranteed that
+     * connection state intent for the profile will be broadcasted with
+     * the state. Users can get the connection state of the profile
+     * from this intent.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Remote Bluetooth Device
+     * @return false on immediate error,
+     *               true otherwise
+     * @hide
+     */
+    public boolean connect(BluetoothDevice device) {
+        if (DBG) log("connect(" + device + ")");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.connect(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Initiate disconnection from a profile
+     *
+     * <p> This API will return false in scenarios like the profile on the
+     * Bluetooth device is not in connected state etc. When this API returns,
+     * true, it is guaranteed that the connection state change
+     * intent will be broadcasted with the state. Users can get the
+     * disconnection state of the profile from this intent.
+     *
+     * <p> If the disconnection is initiated by a remote device, the state
+     * will transition from {@link #STATE_CONNECTED} to
+     * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
+     * host (local) device the state will transition from
+     * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
+     * state {@link #STATE_DISCONNECTED}. The transition to
+     * {@link #STATE_DISCONNECTING} can be used to distinguish between the
+     * two scenarios.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Remote Bluetooth Device
+     * @return false on immediate error,
+     *               true otherwise
+     * @hide
+     */
+    public boolean disconnect(BluetoothDevice device) {
+        if (DBG) log("disconnect(" + device + ")");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.disconnect(device);
+            } catch (RemoteException e) {
+              Log.e(TAG, Log.getStackTraceString(new Throwable()));
+              return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public List<BluetoothDevice> getConnectedDevices() {
+        if (DBG) log("getConnectedDevices()");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.getConnectedDevices();
+            } catch (RemoteException e) {
+                Log.e(TAG, Log.getStackTraceString(new Throwable()));
+                return new ArrayList<BluetoothDevice>();
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return new ArrayList<BluetoothDevice>();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+        if (DBG) log("getDevicesMatchingStates()");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.getDevicesMatchingConnectionStates(states);
+            } catch (RemoteException e) {
+                Log.e(TAG, Log.getStackTraceString(new Throwable()));
+                return new ArrayList<BluetoothDevice>();
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return new ArrayList<BluetoothDevice>();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public int getConnectionState(BluetoothDevice device) {
+        if (DBG) log("getConnectionState(" + device + ")");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.getConnectionState(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, Log.getStackTraceString(new Throwable()));
+                return BluetoothProfile.STATE_DISCONNECTED;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return BluetoothProfile.STATE_DISCONNECTED;
+    }
+
+    /**
+     * Set priority of the profile
+     *
+     * <p> The device should already be paired.
+     *  Priority can be one of {@link #PRIORITY_ON} or
+     * {@link #PRIORITY_OFF},
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Paired bluetooth device
+     * @param priority
+     * @return true if priority is set, false on error
+     * @hide
+     */
+    public boolean setPriority(BluetoothDevice device, int priority) {
+        if (DBG) log("setPriority(" + device + ", " + priority + ")");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            if (priority != BluetoothProfile.PRIORITY_OFF &&
+                priority != BluetoothProfile.PRIORITY_ON) {
+              return false;
+            }
+            try {
+                return mService.setPriority(device, priority);
+            } catch (RemoteException e) {
+                Log.e(TAG, Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Get the priority of the profile.
+     *
+     * <p> The priority can be any of:
+     * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
+     * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param device Bluetooth device
+     * @return priority of the device
+     * @hide
+     */
+    public int getPriority(BluetoothDevice device) {
+        if (DBG) log("getPriority(" + device + ")");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.getPriority(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, Log.getStackTraceString(new Throwable()));
+                return PRIORITY_OFF;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return PRIORITY_OFF;
+    }
+
+    /**
+     * Start Bluetooth voice recognition. This methods sends the voice
+     * recognition AT command to the headset and establishes the
+     * audio connection.
+     *
+     * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.
+     * If this function returns true, this intent will be broadcasted with
+     * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_CONNECTING}.
+     *
+     * <p> {@link #EXTRA_STATE} will transition from
+     * {@link #STATE_AUDIO_CONNECTING} to {@link #STATE_AUDIO_CONNECTED} when
+     * audio connection is established and to {@link #STATE_AUDIO_DISCONNECTED}
+     * in case of failure to establish the audio connection.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param device Bluetooth headset
+     * @return false if there is no headset connected of if the
+     *               connected headset doesn't support voice recognition
+     *               or on error, true otherwise
+     */
+    public boolean startVoiceRecognition(BluetoothDevice device) {
+        if (DBG) log("startVoiceRecognition()");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.startVoiceRecognition(device);
+            } catch (RemoteException e) {
+                Log.e(TAG,  Log.getStackTraceString(new Throwable()));
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Stop Bluetooth Voice Recognition mode, and shut down the
+     * Bluetooth audio path.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param device Bluetooth headset
+     * @return false if there is no headset connected
+     *               or on error, true otherwise
+     */
+    public boolean stopVoiceRecognition(BluetoothDevice device) {
+        if (DBG) log("stopVoiceRecognition()");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.stopVoiceRecognition(device);
+            } catch (RemoteException e) {
+                Log.e(TAG,  Log.getStackTraceString(new Throwable()));
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Check if Bluetooth SCO audio is connected.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param device Bluetooth headset
+     * @return true if SCO is connected,
+     *         false otherwise or on error
+     */
+    public boolean isAudioConnected(BluetoothDevice device) {
+        if (DBG) log("isAudioConnected()");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+              return mService.isAudioConnected(device);
+            } catch (RemoteException e) {
+              Log.e(TAG,  Log.getStackTraceString(new Throwable()));
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Get battery usage hint for Bluetooth Headset service.
+     * This is a monotonically increasing integer. Wraps to 0 at
+     * Integer.MAX_INT, and at boot.
+     * Current implementation returns the number of AT commands handled since
+     * boot. This is a good indicator for spammy headset/handsfree units that
+     * can keep the device awake by polling for cellular status updates. As a
+     * rule of thumb, each AT command prevents the CPU from sleeping for 500 ms
+     *
+     * @param device the bluetooth headset.
+     * @return monotonically increasing battery usage hint, or a negative error
+     *         code on error
+     * @hide
+     */
+    public int getBatteryUsageHint(BluetoothDevice device) {
+        if (DBG) log("getBatteryUsageHint()");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.getBatteryUsageHint(device);
+            } catch (RemoteException e) {
+                Log.e(TAG,  Log.getStackTraceString(new Throwable()));
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return -1;
+    }
+
+    /**
+     * Indicates if current platform supports voice dialing over bluetooth SCO.
+     *
+     * @return true if voice dialing over bluetooth is supported, false otherwise.
+     * @hide
+     */
+    public static boolean isBluetoothVoiceDialingEnabled(Context context) {
+        return context.getResources().getBoolean(
+                com.android.internal.R.bool.config_bluetooth_sco_off_call);
+    }
+
+    /**
+     * Indicates if current device supports voice dialing over bluetooth SCO.
+     *
+     * @return true if voice dialing over bluetooth is supported, false otherwise.
+     * @hide
+     */
+    public boolean isBluetoothVoiceDialingSupported(BluetoothDevice device) {
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.isBluetoothVoiceDialingEnabled(device);
+            } catch (RemoteException e) {
+                Log.e(TAG,  Log.getStackTraceString(new Throwable()));
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Cancel the outgoing connection.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public boolean cancelConnectThread() {
+        if (DBG) log("cancelConnectThread");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.cancelConnectThread();
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Accept the incoming connection.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public boolean acceptIncomingConnect(BluetoothDevice device) {
+        if (DBG) log("acceptIncomingConnect");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.acceptIncomingConnect(device);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Create the connect thread for the incoming connection.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public boolean createIncomingConnect(BluetoothDevice device) {
+        if (DBG) log("createIncomingConnect");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.createIncomingConnect(device);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Reject the incoming connection.
+     * @hide
+     */
+    public boolean rejectIncomingConnect(BluetoothDevice device) {
+        if (DBG) log("rejectIncomingConnect");
+        if (mService != null) {
+            try {
+                return mService.rejectIncomingConnect(device);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Connect to a Bluetooth Headset.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public boolean connectHeadsetInternal(BluetoothDevice device) {
+        if (DBG) log("connectHeadsetInternal");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.connectHeadsetInternal(device);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Disconnect a Bluetooth Headset.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public boolean disconnectHeadsetInternal(BluetoothDevice device) {
+        if (DBG) log("disconnectHeadsetInternal");
+        if (mService != null && !isDisabled()) {
+            try {
+                 return mService.disconnectHeadsetInternal(device);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Set the audio state of the Headset.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public boolean setAudioState(BluetoothDevice device, int state) {
+        if (DBG) log("setAudioState");
+        if (mService != null && !isDisabled()) {
+            try {
+                return mService.setAudioState(device, state);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Get the current audio state of the Headset.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public int getAudioState(BluetoothDevice device) {
+        if (DBG) log("getAudioState");
+        if (mService != null && !isDisabled()) {
+            try {
+                return mService.getAudioState(device);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
+    }
+
+    /**
+     * Check if Bluetooth SCO audio is connected.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @return true if SCO is connected,
+     *         false otherwise or on error
+     * @hide
+     */
+    public boolean isAudioOn() {
+        if (mService != null && isEnabled()) {
+            try {
+              return mService.isAudioOn();
+            } catch (RemoteException e) {
+              Log.e(TAG,  Log.getStackTraceString(new Throwable()));
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+
+    }
+
+    /**
+     * Initiates a connection of headset audio.
+     * It setup SCO channel with remote connected headset device.
+     *
+     * @return true if successful
+     *         false if there was some error such as
+     *               there is no connected headset
+     * @hide
+     */
+    public boolean connectAudio() {
+         if (mService != null && isEnabled()) {
+            try {
+                return mService.connectAudio();
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Initiates a disconnection of headset audio.
+     * It tears down the SCO channel from remote headset device.
+     *
+     * @return true if successful
+     *         false if there was some error such as
+     *               there is no connected SCO channel
+     * @hide
+     */
+    public boolean disconnectAudio() {
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.disconnectAudio();
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Initiates a SCO channel connection with the headset (if connected).
+     * Also initiates a virtual voice call for Handsfree devices as many devices
+     * do not accept SCO audio without a call.
+     * This API allows the handsfree device to be used for routing non-cellular
+     * call audio.
+     *
+     * @param device Remote Bluetooth Device
+     * @return true if successful, false if there was some error.
+     * @hide
+     */
+    public boolean startScoUsingVirtualVoiceCall(BluetoothDevice device) {
+        if (DBG) log("startScoUsingVirtualVoiceCall()");
+        if (mService != null && isEnabled() && isValidDevice(device)) {
+            try {
+                return mService.startScoUsingVirtualVoiceCall(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Terminates an ongoing SCO connection and the associated virtual
+     * call.
+     *
+     * @param device Remote Bluetooth Device
+     * @return true if successful, false if there was some error.
+     * @hide
+     */
+    public boolean stopScoUsingVirtualVoiceCall(BluetoothDevice device) {
+        if (DBG) log("stopScoUsingVirtualVoiceCall()");
+        if (mService != null && isEnabled() && isValidDevice(device)) {
+            try {
+                return mService.stopScoUsingVirtualVoiceCall(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Notify Headset of phone state change.
+     * This is a backdoor for phone app to call BluetoothHeadset since
+     * there is currently not a good way to get precise call state change outside
+     * of phone app.
+     *
+     * @hide
+     */
+    public void phoneStateChanged(int numActive, int numHeld, int callState, String number,
+                                  int type) {
+        if (mService != null && isEnabled()) {
+            try {
+				Log.w(TAG, "headset Proxy attached to service.Phonestatechanged");
+                mService.phoneStateChanged(numActive, numHeld, callState, number, type);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+    }
+
+    /**
+     * Notify Headset of phone roam state change.
+     * This is a backdoor for phone app to call BluetoothHeadset since
+     * there is currently not a good way to get roaming state change outside
+     * of phone app.
+     *
+     * @hide
+     */
+    public void roamChanged(boolean roaming) {
+        if (mService != null && isEnabled()) {
+            try {
+                mService.roamChanged(roaming);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+    }
+
+    /**
+     * Send Headset of CLCC response
+     *
+     * @hide
+     */
+    public void clccResponse(int index, int direction, int status, int mode, boolean mpty,
+                             String number, int type) {
+       if (mService != null && isEnabled()) {
+            try {
+                mService.clccResponse(index, direction, status, mode, mpty, number, type);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+    }
+
+    private ServiceConnection mConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            if (DBG) Log.d(TAG, "HeadsetService Proxy object connected");
+            mService = IBluetoothHeadset.Stub.asInterface(service);
+
+            if (mServiceListener != null) {
+				Log.d(TAG, "HeadsetService Calls the service listeners");
+                mServiceListener.onServiceConnected(BluetoothProfile.HEADSET, BluetoothHeadset.this);
+            }
+        }
+        public void onServiceDisconnected(ComponentName className) {
+            if (DBG) Log.d(TAG, "HeadsetService Proxy object disconnected");
+            mService = null;
+            if (mServiceListener != null) {
+				Log.d(TAG, "HeadsetService Calls the service listeners for dis");
+                mServiceListener.onServiceDisconnected(BluetoothProfile.HEADSET);
+            }
+        }
+    };
+
+    private boolean isEnabled() {
+       if (mAdapter.getState() == BluetoothAdapter.STATE_ON) return true;
+       return false;
+    }
+
+    private boolean isDisabled() {
+       if (mAdapter.getState() == BluetoothAdapter.STATE_OFF) return true;
+       return false;
+    }
+
+    private boolean isValidDevice(BluetoothDevice device) {
+       if (device == null) return false;
+
+       if (BluetoothAdapter.checkBluetoothAddress(device.getAddress())) return true;
+       return false;
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothHealth.java b/bluetoothmsm/java/android/bluetooth/BluetoothHealth.java
new file mode 100644
index 0000000..f850c02
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothHealth.java
@@ -0,0 +1,489 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.ParcelFileDescriptor;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Public API for Bluetooth Health Profile.
+ *
+ * <p>BluetoothHealth is a proxy object for controlling the Bluetooth
+ * Service via IPC.
+ *
+ * <p> How to connect to a health device which is acting in the source role.
+ *  <li> Use {@link BluetoothAdapter#getProfileProxy} to get
+ *  the BluetoothHealth proxy object. </li>
+ *  <li> Create an {@link BluetoothHealth} callback and call
+ *  {@link #registerSinkAppConfiguration} to register an application
+ *  configuration </li>
+ *  <li> Pair with the remote device. This currently needs to be done manually
+ *  from Bluetooth Settings </li>
+ *  <li> Connect to a health device using {@link #connectChannelToSource}. Some
+ *  devices will connect the channel automatically. The {@link BluetoothHealth}
+ *  callback will inform the application of channel state change. </li>
+ *  <li> Use the file descriptor provided with a connected channel to read and
+ *  write data to the health channel. </li>
+ *  <li> The received data needs to be interpreted using a health manager which
+ *  implements the IEEE 11073-xxxxx specifications.
+ *  <li> When done, close the health channel by calling {@link #disconnectChannel}
+ *  and unregister the application configuration calling
+ *  {@link #unregisterAppConfiguration}
+ *
+ */
+public final class BluetoothHealth implements BluetoothProfile {
+    private static final String TAG = "BluetoothHealth";
+    private static final boolean DBG = false;
+
+    /**
+     * Health Profile Source Role - the health device.
+     */
+    public static final int SOURCE_ROLE = 1 << 0;
+
+    /**
+     * Health Profile Sink Role the device talking to the health device.
+     */
+    public static final int SINK_ROLE = 1 << 1;
+
+    /**
+     * Health Profile - Channel Type used - Reliable
+     */
+    public static final int CHANNEL_TYPE_RELIABLE = 10;
+
+    /**
+     * Health Profile - Channel Type used - Streaming
+     */
+    public static final int CHANNEL_TYPE_STREAMING = 11;
+
+    /**
+     * @hide
+     */
+    public static final int CHANNEL_TYPE_ANY = 12;
+
+    /** @hide */
+    public static final int HEALTH_OPERATION_SUCCESS = 6000;
+    /** @hide */
+    public static final int HEALTH_OPERATION_ERROR = 6001;
+    /** @hide */
+    public static final int HEALTH_OPERATION_INVALID_ARGS = 6002;
+    /** @hide */
+    public static final int HEALTH_OPERATION_GENERIC_FAILURE = 6003;
+    /** @hide */
+    public static final int HEALTH_OPERATION_NOT_FOUND = 6004;
+    /** @hide */
+    public static final int HEALTH_OPERATION_NOT_ALLOWED = 6005;
+
+
+    /**
+     * Register an application configuration that acts as a Health SINK.
+     * This is the configuration that will be used to communicate with health devices
+     * which will act as the {@link #SOURCE_ROLE}. This is an asynchronous call and so
+     * the callback is used to notify success or failure if the function returns true.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param name The friendly name associated with the application or configuration.
+     * @param dataType The dataType of the Source role of Health Profile to which
+     *                   the sink wants to connect to.
+     * @param callback A callback to indicate success or failure of the registration and
+     *               all operations done on this application configuration.
+     * @return If true, callback will be called.
+     */
+    public boolean registerSinkAppConfiguration(String name, int dataType,
+            BluetoothHealthCallback callback) {
+        if (!isEnabled() || name == null) return false;
+
+        if (DBG) log("registerSinkApplication(" + name + ":" + dataType + ")");
+        return registerAppConfiguration(name, dataType, SINK_ROLE,
+                CHANNEL_TYPE_ANY, callback);
+    }
+
+    /**
+     * Register an application configuration that acts as a Health SINK or in a Health
+     * SOURCE role.This is an asynchronous call and so
+     * the callback is used to notify success or failure if the function returns true.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param name The friendly name associated with the application or configuration.
+     * @param dataType The dataType of the Source role of Health Profile.
+     * @param channelType The channel type. Will be one of
+     *                              {@link #CHANNEL_TYPE_RELIABLE}  or
+     *                              {@link #CHANNEL_TYPE_STREAMING}
+     * @param callback - A callback to indicate success or failure.
+     * @return If true, callback will be called.
+     * @hide
+     */
+    public boolean registerAppConfiguration(String name, int dataType, int role,
+            int channelType, BluetoothHealthCallback callback) {
+        boolean result = false;
+        if (!isEnabled() || !checkAppParam(name, role, channelType, callback)) return result;
+
+        if (DBG) log("registerApplication(" + name + ":" + dataType + ")");
+        BluetoothHealthCallbackWrapper wrapper = new BluetoothHealthCallbackWrapper(callback);
+        BluetoothHealthAppConfiguration config =
+                new BluetoothHealthAppConfiguration(name, dataType, role, channelType);
+
+        if (mService != null) {
+            try {
+                result = mService.registerAppConfiguration(config, wrapper);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return result;
+    }
+
+    /**
+     * Unregister an application configuration that has been registered using
+     * {@link #registerSinkAppConfiguration}
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param config  The health app configuration
+     * @return Success or failure.
+     */
+    public boolean unregisterAppConfiguration(BluetoothHealthAppConfiguration config) {
+        boolean result = false;
+        if (mService != null && isEnabled() && config != null) {
+            try {
+                result = mService.unregisterAppConfiguration(config);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+
+        return result;
+    }
+
+    /**
+     * Connect to a health device which has the {@link #SOURCE_ROLE}.
+     * This is an asynchronous call. If this function returns true, the callback
+     * associated with the application configuration will be called.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param device The remote Bluetooth device.
+     * @param config The application configuration which has been registered using
+     *        {@link #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
+     * @return If true, the callback associated with the application config will be called.
+     */
+    public boolean connectChannelToSource(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        if (mService != null && isEnabled() && isValidDevice(device) &&
+                config != null) {
+            try {
+                return mService.connectChannelToSource(device, config);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Connect to a health device which has the {@link #SINK_ROLE}.
+     * This is an asynchronous call. If this function returns true, the callback
+     * associated with the application configuration will be called.
+     *
+     *<p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param device The remote Bluetooth device.
+     * @param config The application configuration which has been registered using
+     *        {@link #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
+     * @return If true, the callback associated with the application config will be called.
+     * @hide
+     */
+    public boolean connectChannelToSink(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config, int channelType) {
+        if (mService != null && isEnabled() && isValidDevice(device) &&
+                config != null) {
+            try {
+                return mService.connectChannelToSink(device, config, channelType);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Disconnect a connected health channel.
+     * This is an asynchronous call. If this function returns true, the callback
+     * associated with the application configuration will be called.
+     *
+     *<p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param device The remote Bluetooth device.
+     * @param config The application configuration which has been registered using
+     *        {@link #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
+     * @param channelId The channel id associated with the channel
+     * @return If true, the callback associated with the application config will be called.
+     */
+    public boolean disconnectChannel(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config, int channelId) {
+        if (mService != null && isEnabled() && isValidDevice(device) &&
+                config != null) {
+            try {
+                return mService.disconnectChannel(device, config, channelId);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Get the file descriptor of the main channel associated with the remote device
+     * and application configuration.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * <p> Its the responsibility of the caller to close the ParcelFileDescriptor
+     * when done.
+     *
+     * @param device The remote Bluetooth health device
+     * @param config The application configuration
+     * @return null on failure, ParcelFileDescriptor on success.
+     */
+    public ParcelFileDescriptor getMainChannelFd(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        if (mService != null && isEnabled() && isValidDevice(device) &&
+                config != null) {
+            try {
+                return mService.getMainChannelFd(device, config);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return null;
+    }
+
+    /**
+     * Get the current connection state of the profile.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * This is not specific to any application configuration but represents the connection
+     * state of the local Bluetooth adapter with the remote device. This can be used
+     * by applications like status bar which would just like to know the state of the
+     * local adapter.
+     *
+     * @param device Remote bluetooth device.
+     * @return State of the profile connection. One of
+     *               {@link #STATE_CONNECTED}, {@link #STATE_CONNECTING},
+     *               {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING}
+     */
+    @Override
+    public int getConnectionState(BluetoothDevice device) {
+        if (mService != null && isEnabled() && isValidDevice(device)) {
+            try {
+                return mService.getHealthDeviceConnectionState(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return STATE_DISCONNECTED;
+    }
+
+    /**
+     * Get connected devices for the health profile.
+     *
+     * <p> Return the set of devices which are in state {@link #STATE_CONNECTED}
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * This is not specific to any application configuration but represents the connection
+     * state of the local Bluetooth adapter for this profile. This can be used
+     * by applications like status bar which would just like to know the state of the
+     * local adapter.
+     * @return List of devices. The list will be empty on error.
+     */
+    @Override
+    public List<BluetoothDevice> getConnectedDevices() {
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.getConnectedHealthDevices();
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return new ArrayList<BluetoothDevice>();
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return new ArrayList<BluetoothDevice>();
+    }
+
+    /**
+     * Get a list of devices that match any of the given connection
+     * states.
+     *
+     * <p> If none of the devices match any of the given states,
+     * an empty list will be returned.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     * This is not specific to any application configuration but represents the connection
+     * state of the local Bluetooth adapter for this profile. This can be used
+     * by applications like status bar which would just like to know the state of the
+     * local adapter.
+     *
+     * @param states Array of states. States can be one of
+     *              {@link #STATE_CONNECTED}, {@link #STATE_CONNECTING},
+     *              {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING},
+     * @return List of devices. The list will be empty on error.
+     */
+    @Override
+    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.getHealthDevicesMatchingConnectionStates(states);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return new ArrayList<BluetoothDevice>();
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return new ArrayList<BluetoothDevice>();
+    }
+
+    private static class BluetoothHealthCallbackWrapper extends IBluetoothHealthCallback.Stub {
+        private BluetoothHealthCallback mCallback;
+
+        public BluetoothHealthCallbackWrapper(BluetoothHealthCallback callback) {
+            mCallback = callback;
+        }
+
+        @Override
+        public void onHealthAppConfigurationStatusChange(BluetoothHealthAppConfiguration config,
+                                                         int status) {
+           mCallback.onHealthAppConfigurationStatusChange(config, status);
+        }
+
+        @Override
+        public void onHealthChannelStateChange(BluetoothHealthAppConfiguration config,
+                                       BluetoothDevice device, int prevState, int newState,
+                                       ParcelFileDescriptor fd, int channelId) {
+            mCallback.onHealthChannelStateChange(config, device, prevState, newState, fd,
+                                                 channelId);
+        }
+    }
+
+     /** Health Channel Connection State - Disconnected */
+    public static final int STATE_CHANNEL_DISCONNECTED  = 0;
+    /** Health Channel Connection State - Connecting */
+    public static final int STATE_CHANNEL_CONNECTING    = 1;
+    /** Health Channel Connection State - Connected */
+    public static final int STATE_CHANNEL_CONNECTED     = 2;
+    /** Health Channel Connection State - Disconnecting */
+    public static final int STATE_CHANNEL_DISCONNECTING = 3;
+
+    /** Health App Configuration registration success */
+    public static final int APP_CONFIG_REGISTRATION_SUCCESS = 0;
+    /** Health App Configuration registration failure */
+    public static final int APP_CONFIG_REGISTRATION_FAILURE = 1;
+    /** Health App Configuration un-registration success */
+    public static final int APP_CONFIG_UNREGISTRATION_SUCCESS = 2;
+    /** Health App Configuration un-registration failure */
+    public static final int APP_CONFIG_UNREGISTRATION_FAILURE = 3;
+
+    private ServiceListener mServiceListener;
+    private IBluetooth mService;
+    BluetoothAdapter mAdapter;
+
+    /**
+     * Create a BluetoothHealth proxy object.
+     */
+    /*package*/ BluetoothHealth(Context mContext, ServiceListener l) {
+        IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
+        mServiceListener = l;
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+        if (b != null) {
+            mService = IBluetooth.Stub.asInterface(b);
+            if (mServiceListener != null) {
+                mServiceListener.onServiceConnected(BluetoothProfile.HEALTH, this);
+            }
+        } else {
+            Log.w(TAG, "Bluetooth Service not available!");
+
+            // Instead of throwing an exception which prevents people from going
+            // into Wireless settings in the emulator. Let it crash later when it is actually used.
+            mService = null;
+        }
+    }
+
+    /*package*/ void close() {
+        mServiceListener = null;
+    }
+
+    private boolean isEnabled() {
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+
+        if (adapter != null && adapter.getState() == BluetoothAdapter.STATE_ON) return true;
+        log("Bluetooth is Not enabled");
+        return false;
+    }
+
+    private boolean isValidDevice(BluetoothDevice device) {
+        if (device == null) return false;
+
+        if (BluetoothAdapter.checkBluetoothAddress(device.getAddress())) return true;
+        return false;
+    }
+
+    private boolean checkAppParam(String name, int role, int channelType,
+            BluetoothHealthCallback callback) {
+        if (name == null || (role != SOURCE_ROLE && role != SINK_ROLE) ||
+                (channelType != CHANNEL_TYPE_RELIABLE &&
+                channelType != CHANNEL_TYPE_STREAMING &&
+                channelType != CHANNEL_TYPE_ANY) || callback == null) {
+            return false;
+        }
+        if (role == SOURCE_ROLE && channelType == CHANNEL_TYPE_ANY) return false;
+        return true;
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothHealthAppConfiguration.aidl b/bluetoothmsm/java/android/bluetooth/BluetoothHealthAppConfiguration.aidl
new file mode 100644
index 0000000..bc9e54f
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothHealthAppConfiguration.aidl
@@ -0,0 +1,19 @@
+/*
+** Copyright 2011, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package android.bluetooth;
+
+parcelable BluetoothHealthAppConfiguration;
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothHealthAppConfiguration.java b/bluetoothmsm/java/android/bluetooth/BluetoothHealthAppConfiguration.java
new file mode 100644
index 0000000..15a9101
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothHealthAppConfiguration.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package android.bluetooth;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * The Bluetooth Health Application Configuration that is used in conjunction with
+ * the {@link BluetoothHealth} class. This class represents an application configuration
+ * that the Bluetooth Health third party application will register to communicate with the
+ * remote Bluetooth health device.
+ *
+ */
+public final class BluetoothHealthAppConfiguration implements Parcelable {
+    private final String mName;
+    private final int mDataType;
+    private final int mRole;
+    private final int mChannelType;
+
+    /**
+     * Constructor to register the SINK role
+     *
+     * @param name Friendly name associated with the application configuration
+     * @param dataType Data Type of the remote Bluetooth Health device
+     * @hide
+     */
+    BluetoothHealthAppConfiguration(String name, int dataType) {
+        mName = name;
+        mDataType = dataType;
+        mRole = BluetoothHealth.SINK_ROLE;
+        mChannelType = BluetoothHealth.CHANNEL_TYPE_ANY;
+    }
+
+    /**
+     * Constructor to register the application configuration.
+     *
+     * @param name Friendly name associated with the application configuration
+     * @param dataType Data Type of the remote Bluetooth Health device
+     * @param role {@link BluetoothHealth#SOURCE_ROLE} or
+     *                     {@link BluetoothHealth#SINK_ROLE}
+     * @hide
+     */
+    BluetoothHealthAppConfiguration(String name, int dataType, int role, int
+        channelType) {
+        mName = name;
+        mDataType = dataType;
+        mRole = role;
+        mChannelType = channelType;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof BluetoothHealthAppConfiguration) {
+            BluetoothHealthAppConfiguration config = (BluetoothHealthAppConfiguration) o;
+            // config.getName() can never be NULL
+            return mName.equals(config.getName()) &&
+                    mDataType == config.getDataType() &&
+                    mRole == config.getRole() &&
+                    mChannelType == config.getChannelType();
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = 17;
+        result = 31 * result + (mName != null ? mName.hashCode() : 0);
+        result = 31 * result + mDataType;
+        result = 31 * result + mRole;
+        result = 31 * result + mChannelType;
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "BluetoothHealthAppConfiguration [mName = " + mName +
+            ",mDataType = " + mDataType + ", mRole = " + mRole + ",mChannelType = " +
+            mChannelType + "]";
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Return the data type associated with this application configuration.
+     *
+     * @return dataType
+     */
+    public int getDataType() {
+        return mDataType;
+    }
+
+    /**
+     * Return the name of the application configuration.
+     *
+     * @return String name
+     */
+    public String getName() {
+        return mName;
+    }
+
+    /**
+     * Return the role associated with this application configuration.
+     *
+     * @return One of {@link BluetoothHealth#SOURCE_ROLE} or
+     *                         {@link BluetoothHealth#SINK_ROLE}
+     */
+    public int getRole() {
+        return mRole;
+    }
+
+    /**
+     * Return the channel type associated with this application configuration.
+     *
+     * @return One of {@link BluetoothHealth#CHANNEL_TYPE_RELIABLE} or
+     *                         {@link BluetoothHealth#CHANNEL_TYPE_STREAMING} or
+     *                         {@link BluetoothHealth#CHANNEL_TYPE_ANY}.
+     * @hide
+     */
+    public int getChannelType() {
+        return mChannelType;
+    }
+
+    public static final Parcelable.Creator<BluetoothHealthAppConfiguration> CREATOR =
+        new Parcelable.Creator<BluetoothHealthAppConfiguration>() {
+        @Override
+        public BluetoothHealthAppConfiguration createFromParcel(Parcel in) {
+            String name = in.readString();
+            int type = in.readInt();
+            int role = in.readInt();
+            int channelType = in.readInt();
+            return new BluetoothHealthAppConfiguration(name, type, role,
+                channelType);
+        }
+
+        @Override
+        public BluetoothHealthAppConfiguration[] newArray(int size) {
+            return new BluetoothHealthAppConfiguration[size];
+        }
+    };
+
+    public void writeToParcel(Parcel out, int flags) {
+        out.writeString(mName);
+        out.writeInt(mDataType);
+        out.writeInt(mRole);
+        out.writeInt(mChannelType);
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothHealthCallback.java b/bluetoothmsm/java/android/bluetooth/BluetoothHealthCallback.java
new file mode 100644
index 0000000..baf2ade
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothHealthCallback.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package android.bluetooth;
+
+import android.os.ParcelFileDescriptor;
+import android.util.Log;
+
+/**
+ * This abstract class is used to implement {@link BluetoothHealth} callbacks.
+ */
+public abstract class BluetoothHealthCallback {
+    private static final String TAG = "BluetoothHealthCallback";
+
+    /**
+     * Callback to inform change in registration state of the health
+     * application.
+     * <p> This callback is called on the binder thread (not on the UI thread)
+     *
+     * @param config Bluetooth Health app configuration
+     * @param status Success or failure of the registration or unregistration
+     *            calls. Can be one of
+     *            {@link BluetoothHealth#APP_CONFIG_REGISTRATION_SUCCESS} or
+     *            {@link BluetoothHealth#APP_CONFIG_REGISTRATION_FAILURE} or
+     *            {@link BluetoothHealth#APP_CONFIG_UNREGISTRATION_SUCCESS} or
+     *            {@link BluetoothHealth#APP_CONFIG_UNREGISTRATION_FAILURE}
+     */
+    public void onHealthAppConfigurationStatusChange(BluetoothHealthAppConfiguration config,
+            int status) {
+        Log.d(TAG, "onHealthAppConfigurationStatusChange: " + config + "Status: " + status);
+    }
+
+    /**
+     * Callback to inform change in channel state.
+     * <p> Its the responsibility of the implementor of this callback to close the
+     * parcel file descriptor when done. This callback is called on the Binder
+     * thread (not the UI thread)
+     *
+     * @param config The Health app configutation
+     * @param device The Bluetooth Device
+     * @param prevState The previous state of the channel
+     * @param newState The new state of the channel.
+     * @param fd The Parcel File Descriptor when the channel state is connected.
+     * @param channelId The id associated with the channel. This id will be used
+     *            in future calls like when disconnecting the channel.
+     */
+    public void onHealthChannelStateChange(BluetoothHealthAppConfiguration config,
+            BluetoothDevice device, int prevState, int newState, ParcelFileDescriptor fd,
+            int channelId) {
+        Log.d(TAG, "onHealthChannelStateChange: " + config + "Device: " + device +
+              "prevState:" + prevState + "newState:" + newState + "ParcelFd:" + fd +
+              "ChannelId:" + channelId);
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothInputDevice.java b/bluetoothmsm/java/android/bluetooth/BluetoothInputDevice.java
new file mode 100644
index 0000000..1a9e011
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothInputDevice.java
@@ -0,0 +1,330 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * This class provides the public APIs to control the Bluetooth Input
+ * Device Profile.
+ *
+ *<p>BluetoothInputDevice is a proxy object for controlling the Bluetooth
+ * Service via IPC. Use {@link BluetoothAdapter#getProfileProxy} to get
+ * the BluetoothInputDevice proxy object.
+ *
+ *<p>Each method is protected with its appropriate permission.
+ *@hide
+ */
+public final class BluetoothInputDevice implements BluetoothProfile {
+    private static final String TAG = "BluetoothInputDevice";
+    private static final boolean DBG = false;
+
+    /**
+     * Intent used to broadcast the change in connection state of the Input
+     * Device profile.
+     *
+     * <p>This intent will have 3 extras:
+     * <ul>
+     *   <li> {@link #EXTRA_STATE} - The current state of the profile. </li>
+     *   <li> {@link #EXTRA_PREVIOUS_STATE}- The previous state of the profile.</li>
+     *   <li> {@link BluetoothDevice#EXTRA_DEVICE} - The remote device. </li>
+     * </ul>
+     *
+     * <p>{@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} can be any of
+     * {@link #STATE_DISCONNECTED}, {@link #STATE_CONNECTING},
+     * {@link #STATE_CONNECTED}, {@link #STATE_DISCONNECTING}.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission to
+     * receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CONNECTION_STATE_CHANGED =
+        "android.bluetooth.input.profile.action.CONNECTION_STATE_CHANGED";
+
+    /**
+     * Return codes for the connect and disconnect Bluez / Dbus calls.
+     * @hide
+     */
+    public static final int INPUT_DISCONNECT_FAILED_NOT_CONNECTED = 5000;
+
+    /**
+     * @hide
+     */
+    public static final int INPUT_CONNECT_FAILED_ALREADY_CONNECTED = 5001;
+
+    /**
+     * @hide
+     */
+    public static final int INPUT_CONNECT_FAILED_ATTEMPT_FAILED = 5002;
+
+    /**
+     * @hide
+     */
+    public static final int INPUT_OPERATION_GENERIC_FAILURE = 5003;
+
+    /**
+     * @hide
+     */
+    public static final int INPUT_OPERATION_SUCCESS = 5004;
+
+    private ServiceListener mServiceListener;
+    private BluetoothAdapter mAdapter;
+    private IBluetooth mService;
+
+    /**
+     * Create a BluetoothInputDevice proxy object for interacting with the local
+     * Bluetooth Service which handles the InputDevice profile
+     *
+     */
+    /*package*/ BluetoothInputDevice(Context mContext, ServiceListener l) {
+        IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
+        mServiceListener = l;
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+        if (b != null) {
+            mService = IBluetooth.Stub.asInterface(b);
+            if (mServiceListener != null) {
+                mServiceListener.onServiceConnected(BluetoothProfile.INPUT_DEVICE, this);
+            }
+        } else {
+            Log.w(TAG, "Bluetooth Service not available!");
+
+            // Instead of throwing an exception which prevents people from going
+            // into Wireless settings in the emulator. Let it crash later when it is actually used.
+            mService = null;
+        }
+    }
+
+    /*package*/ void close() {
+        mServiceListener = null;
+    }
+
+    /**
+     * Initiate connection to a profile of the remote bluetooth device.
+     *
+     * <p> The system supports connection to multiple input devices.
+     *
+     * <p> This API returns false in scenarios like the profile on the
+     * device is already connected or Bluetooth is not turned on.
+     * When this API returns true, it is guaranteed that
+     * connection state intent for the profile will be broadcasted with
+     * the state. Users can get the connection state of the profile
+     * from this intent.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Remote Bluetooth Device
+     * @return false on immediate error,
+     *               true otherwise
+     * @hide
+     */
+    public boolean connect(BluetoothDevice device) {
+        if (DBG) log("connect(" + device + ")");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.connectInputDevice(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Initiate disconnection from a profile
+     *
+     * <p> This API will return false in scenarios like the profile on the
+     * Bluetooth device is not in connected state etc. When this API returns,
+     * true, it is guaranteed that the connection state change
+     * intent will be broadcasted with the state. Users can get the
+     * disconnection state of the profile from this intent.
+     *
+     * <p> If the disconnection is initiated by a remote device, the state
+     * will transition from {@link #STATE_CONNECTED} to
+     * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
+     * host (local) device the state will transition from
+     * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
+     * state {@link #STATE_DISCONNECTED}. The transition to
+     * {@link #STATE_DISCONNECTING} can be used to distinguish between the
+     * two scenarios.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Remote Bluetooth Device
+     * @return false on immediate error,
+     *               true otherwise
+     * @hide
+     */
+    public boolean disconnect(BluetoothDevice device) {
+        if (DBG) log("disconnect(" + device + ")");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.disconnectInputDevice(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public List<BluetoothDevice> getConnectedDevices() {
+        if (DBG) log("getConnectedDevices()");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.getConnectedInputDevices();
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return new ArrayList<BluetoothDevice>();
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return new ArrayList<BluetoothDevice>();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+        if (DBG) log("getDevicesMatchingStates()");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.getInputDevicesMatchingConnectionStates(states);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return new ArrayList<BluetoothDevice>();
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return new ArrayList<BluetoothDevice>();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public int getConnectionState(BluetoothDevice device) {
+        if (DBG) log("getState(" + device + ")");
+        if (mService != null && isEnabled()
+            && isValidDevice(device)) {
+            try {
+                return mService.getInputDeviceConnectionState(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return BluetoothProfile.STATE_DISCONNECTED;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return BluetoothProfile.STATE_DISCONNECTED;
+    }
+
+    /**
+     * Set priority of the profile
+     *
+     * <p> The device should already be paired.
+     *  Priority can be one of {@link #PRIORITY_ON} or
+     * {@link #PRIORITY_OFF},
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Paired bluetooth device
+     * @param priority
+     * @return true if priority is set, false on error
+     * @hide
+     */
+    public boolean setPriority(BluetoothDevice device, int priority) {
+        if (DBG) log("setPriority(" + device + ", " + priority + ")");
+        if (mService != null && isEnabled()
+            && isValidDevice(device)) {
+            if (priority != BluetoothProfile.PRIORITY_OFF &&
+                priority != BluetoothProfile.PRIORITY_ON) {
+              return false;
+            }
+            try {
+                return mService.setInputDevicePriority(device, priority);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Get the priority of the profile.
+     *
+     * <p> The priority can be any of:
+     * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
+     * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param device Bluetooth device
+     * @return priority of the device
+     * @hide
+     */
+    public int getPriority(BluetoothDevice device) {
+        if (DBG) log("getPriority(" + device + ")");
+        if (mService != null && isEnabled()
+            && isValidDevice(device)) {
+            try {
+                return mService.getInputDevicePriority(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return BluetoothProfile.PRIORITY_OFF;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return BluetoothProfile.PRIORITY_OFF;
+    }
+
+    private boolean isEnabled() {
+       if (mAdapter.getState() == BluetoothAdapter.STATE_ON) return true;
+       return false;
+    }
+
+    private boolean isValidDevice(BluetoothDevice device) {
+       if (device == null) return false;
+
+       if (BluetoothAdapter.checkBluetoothAddress(device.getAddress())) return true;
+       return false;
+    }
+
+    private static void log(String msg) {
+      Log.d(TAG, msg);
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothInputStream.java b/bluetoothmsm/java/android/bluetooth/BluetoothInputStream.java
new file mode 100644
index 0000000..03af953
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothInputStream.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * BluetoothInputStream.
+ *
+ * Used to write to a Bluetooth socket.
+ *
+ * @hide
+ */
+/*package*/ final class BluetoothInputStream extends InputStream {
+    private BluetoothSocket mSocket;
+
+    /*package*/ BluetoothInputStream(BluetoothSocket s) {
+        mSocket = s;
+    }
+
+    /**
+     * Return number of bytes available before this stream will block.
+     */
+    public int available() throws IOException {
+        return mSocket.available();
+    }
+
+    public void close() throws IOException {
+        mSocket.close();
+    }
+
+    /**
+     * Reads a single byte from this stream and returns it as an integer in the
+     * range from 0 to 255. Returns -1 if the end of the stream has been
+     * reached. Blocks until one byte has been read, the end of the source
+     * stream is detected or an exception is thrown.
+     *
+     * @return the byte read or -1 if the end of stream has been reached.
+     * @throws IOException
+     *             if the stream is closed or another IOException occurs.
+     * @since Android 1.5
+     */
+    public int read() throws IOException {
+        byte b[] = new byte[1];
+        int ret = mSocket.read(b, 0, 1);
+        if (ret == 1) {
+            return (int)b[0] & 0xff;
+        } else {
+            return -1;
+        }
+    }
+
+    /**
+     * Reads at most {@code length} bytes from this stream and stores them in
+     * the byte array {@code b} starting at {@code offset}.
+     *
+     * @param b
+     *            the byte array in which to store the bytes read.
+     * @param offset
+     *            the initial position in {@code buffer} to store the bytes
+     *            read from this stream.
+     * @param length
+     *            the maximum number of bytes to store in {@code b}.
+     * @return the number of bytes actually read or -1 if the end of the stream
+     *         has been reached.
+     * @throws IndexOutOfBoundsException
+     *             if {@code offset < 0} or {@code length < 0}, or if
+     *             {@code offset + length} is greater than the length of
+     *             {@code b}.
+     * @throws IOException
+     *             if the stream is closed or another IOException occurs.
+     * @since Android 1.5
+     */
+    public int read(byte[] b, int offset, int length) throws IOException {
+        if (b == null) {
+            throw new NullPointerException("byte array is null");
+        }
+        if ((offset | length) < 0 || length > b.length - offset) {
+            throw new ArrayIndexOutOfBoundsException("invalid offset or length");
+        }
+        return mSocket.read(b, offset, length);
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothOutputStream.java b/bluetoothmsm/java/android/bluetooth/BluetoothOutputStream.java
new file mode 100644
index 0000000..9180f38
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothOutputStream.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * BluetoothOutputStream.
+ *
+ * Used to read from a Bluetooth socket.
+ *
+ * @hide
+ */
+/*package*/ final class BluetoothOutputStream extends OutputStream {
+    private BluetoothSocket mSocket;
+
+    /*package*/ BluetoothOutputStream(BluetoothSocket s) {
+        mSocket = s;
+    }
+
+    /**
+     * Close this output stream and the socket associated with it.
+     */
+    public void close() throws IOException {
+        mSocket.close();
+    }
+
+    /**
+     * Writes a single byte to this stream. Only the least significant byte of
+     * the integer {@code oneByte} is written to the stream.
+     *
+     * @param oneByte
+     *            the byte to be written.
+     * @throws IOException
+     *             if an error occurs while writing to this stream.
+     * @since Android 1.0
+     */
+    public void write(int oneByte) throws IOException {
+        byte b[] = new byte[1];
+        b[0] = (byte)oneByte;
+        mSocket.write(b, 0, 1);
+    }
+
+    /**
+     * Writes {@code count} bytes from the byte array {@code buffer} starting
+     * at position {@code offset} to this stream.
+     *
+     * @param b
+     *            the buffer to be written.
+     * @param offset
+     *            the start position in {@code buffer} from where to get bytes.
+     * @param count
+     *            the number of bytes from {@code buffer} to write to this
+     *            stream.
+     * @throws IOException
+     *             if an error occurs while writing to this stream.
+     * @throws IndexOutOfBoundsException
+     *             if {@code offset < 0} or {@code count < 0}, or if
+     *             {@code offset + count} is bigger than the length of
+     *             {@code buffer}.
+     * @since Android 1.0
+     */
+    public void write(byte[] b, int offset, int count) throws IOException {
+        if (b == null) {
+            throw new NullPointerException("buffer is null");
+        }
+        if ((offset | count) < 0 || count > b.length - offset) {
+            throw new IndexOutOfBoundsException("invalid offset or length");
+        }
+
+        /* Ensure that everything is written out... */
+        int written = 0;
+        while (written < count) {
+            written += mSocket.write(b, offset + written, count - written);
+        }
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothPan.java b/bluetoothmsm/java/android/bluetooth/BluetoothPan.java
new file mode 100644
index 0000000..5d9d8be
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothPan.java
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * This class provides the APIs to control the Bluetooth Pan
+ * Profile.
+ *
+ *<p>BluetoothPan is a proxy object for controlling the Bluetooth
+ * Service via IPC. Use {@link BluetoothAdapter#getProfileProxy} to get
+ * the BluetoothPan proxy object.
+ *
+ *<p>Each method is protected with its appropriate permission.
+ *@hide
+ */
+public final class BluetoothPan implements BluetoothProfile {
+    private static final String TAG = "BluetoothPan";
+    private static final boolean DBG = false;
+
+    /**
+     * Intent used to broadcast the change in connection state of the Pan
+     * profile.
+     *
+     * <p>This intent will have 4 extras:
+     * <ul>
+     *   <li> {@link #EXTRA_STATE} - The current state of the profile. </li>
+     *   <li> {@link #EXTRA_PREVIOUS_STATE}- The previous state of the profile.</li>
+     *   <li> {@link BluetoothDevice#EXTRA_DEVICE} - The remote device. </li>
+     *   <li> {@link #EXTRA_LOCAL_ROLE} - Which local role the remote device is
+     *   bound to. </li>
+     * </ul>
+     *
+     * <p>{@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} can be any of
+     * {@link #STATE_DISCONNECTED}, {@link #STATE_CONNECTING},
+     * {@link #STATE_CONNECTED}, {@link #STATE_DISCONNECTING}.
+     *
+     * <p> {@link #EXTRA_LOCAL_ROLE} can be one of {@link #LOCAL_NAP_ROLE} or
+     * {@link #LOCAL_PANU_ROLE}
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission to
+     * receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CONNECTION_STATE_CHANGED =
+        "android.bluetooth.pan.profile.action.CONNECTION_STATE_CHANGED";
+
+    /**
+     * Extra for {@link #ACTION_CONNECTION_STATE_CHANGED} intent
+     * The local role of the PAN profile that the remote device is bound to.
+     * It can be one of {@link #LOCAL_NAP_ROLE} or {@link #LOCAL_PANU_ROLE}.
+     */
+    public static final String EXTRA_LOCAL_ROLE = "android.bluetooth.pan.extra.LOCAL_ROLE";
+
+    /**
+     * The local device is acting as a Network Access Point.
+     */
+    public static final int LOCAL_NAP_ROLE = 1;
+
+    /**
+     * The local device is acting as a PAN User.
+     */
+    public static final int LOCAL_PANU_ROLE = 2;
+
+    /**
+     * Return codes for the connect and disconnect Bluez / Dbus calls.
+     * @hide
+     */
+    public static final int PAN_DISCONNECT_FAILED_NOT_CONNECTED = 1000;
+
+    /**
+     * @hide
+     */
+    public static final int PAN_CONNECT_FAILED_ALREADY_CONNECTED = 1001;
+
+    /**
+     * @hide
+     */
+    public static final int PAN_CONNECT_FAILED_ATTEMPT_FAILED = 1002;
+
+    /**
+     * @hide
+     */
+    public static final int PAN_OPERATION_GENERIC_FAILURE = 1003;
+
+    /**
+     * @hide
+     */
+    public static final int PAN_OPERATION_SUCCESS = 1004;
+
+    private ServiceListener mServiceListener;
+    private BluetoothAdapter mAdapter;
+    private IBluetooth mService;
+
+    /**
+     * Create a BluetoothPan proxy object for interacting with the local
+     * Bluetooth Service which handles the Pan profile
+     *
+     */
+    /*package*/ BluetoothPan(Context mContext, ServiceListener l) {
+        IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
+        mServiceListener = l;
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+        if (b != null) {
+            mService = IBluetooth.Stub.asInterface(b);
+            if (mServiceListener != null) {
+                mServiceListener.onServiceConnected(BluetoothProfile.PAN, this);
+            }
+        } else {
+            Log.w(TAG, "Bluetooth Service not available!");
+
+            // Instead of throwing an exception which prevents people from going
+            // into Wireless settings in the emulator. Let it crash later when it is actually used.
+            mService = null;
+        }
+    }
+
+    /*package*/ void close() {
+        mServiceListener = null;
+    }
+
+    /**
+     * Initiate connection to a profile of the remote bluetooth device.
+     *
+     * <p> This API returns false in scenarios like the profile on the
+     * device is already connected or Bluetooth is not turned on.
+     * When this API returns true, it is guaranteed that
+     * connection state intent for the profile will be broadcasted with
+     * the state. Users can get the connection state of the profile
+     * from this intent.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Remote Bluetooth Device
+     * @return false on immediate error,
+     *               true otherwise
+     * @hide
+     */
+    public boolean connect(BluetoothDevice device) {
+        if (DBG) log("connect(" + device + ")");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.connectPanDevice(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Initiate disconnection from a profile
+     *
+     * <p> This API will return false in scenarios like the profile on the
+     * Bluetooth device is not in connected state etc. When this API returns,
+     * true, it is guaranteed that the connection state change
+     * intent will be broadcasted with the state. Users can get the
+     * disconnection state of the profile from this intent.
+     *
+     * <p> If the disconnection is initiated by a remote device, the state
+     * will transition from {@link #STATE_CONNECTED} to
+     * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
+     * host (local) device the state will transition from
+     * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
+     * state {@link #STATE_DISCONNECTED}. The transition to
+     * {@link #STATE_DISCONNECTING} can be used to distinguish between the
+     * two scenarios.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Remote Bluetooth Device
+     * @return false on immediate error,
+     *               true otherwise
+     * @hide
+     */
+    public boolean disconnect(BluetoothDevice device) {
+        if (DBG) log("disconnect(" + device + ")");
+        if (mService != null && isEnabled() &&
+            isValidDevice(device)) {
+            try {
+                return mService.disconnectPanDevice(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public List<BluetoothDevice> getConnectedDevices() {
+        if (DBG) log("getConnectedDevices()");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.getConnectedPanDevices();
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return new ArrayList<BluetoothDevice>();
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return new ArrayList<BluetoothDevice>();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+        if (DBG) log("getDevicesMatchingStates()");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.getPanDevicesMatchingConnectionStates(states);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return new ArrayList<BluetoothDevice>();
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return new ArrayList<BluetoothDevice>();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public int getConnectionState(BluetoothDevice device) {
+        if (DBG) log("getState(" + device + ")");
+        if (mService != null && isEnabled()
+            && isValidDevice(device)) {
+            try {
+                return mService.getPanDeviceConnectionState(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return BluetoothProfile.STATE_DISCONNECTED;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return BluetoothProfile.STATE_DISCONNECTED;
+    }
+
+    public void setBluetoothTethering(boolean value) {
+        if (DBG) log("setBluetoothTethering(" + value + ")");
+        try {
+            mService.setBluetoothTethering(value);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+        }
+    }
+
+    public boolean isTetheringOn() {
+        if (DBG) log("isTetheringOn()");
+        try {
+            return mService.isTetheringOn();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+            return false;
+        }
+    }
+
+    private boolean isEnabled() {
+       if (mAdapter.getState() == BluetoothAdapter.STATE_ON) return true;
+       return false;
+    }
+
+    private boolean isValidDevice(BluetoothDevice device) {
+       if (device == null) return false;
+
+       if (BluetoothAdapter.checkBluetoothAddress(device.getAddress())) return true;
+       return false;
+    }
+
+    private static void log(String msg) {
+      Log.d(TAG, msg);
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothPbap.java b/bluetoothmsm/java/android/bluetooth/BluetoothPbap.java
new file mode 100644
index 0000000..7187e2b
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothPbap.java
@@ -0,0 +1,263 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.RemoteException;
+import android.os.IBinder;
+import android.os.ServiceManager;
+import android.util.Log;
+
+/**
+ * The Android Bluetooth API is not finalized, and *will* change. Use at your
+ * own risk.
+ *
+ * Public API for controlling the Bluetooth Pbap Service. This includes
+ * Bluetooth Phone book Access profile.
+ * BluetoothPbap is a proxy object for controlling the Bluetooth Pbap
+ * Service via IPC.
+ *
+ * Creating a BluetoothPbap object will create a binding with the
+ * BluetoothPbap service. Users of this object should call close() when they
+ * are finished with the BluetoothPbap, so that this proxy object can unbind
+ * from the service.
+ *
+ * This BluetoothPbap object is not immediately bound to the
+ * BluetoothPbap service. Use the ServiceListener interface to obtain a
+ * notification when it is bound, this is especially important if you wish to
+ * immediately call methods on BluetoothPbap after construction.
+ *
+ * Android only supports one connected Bluetooth Pce at a time.
+ *
+ * @hide
+ */
+public class BluetoothPbap {
+
+    private static final String TAG = "BluetoothPbap";
+    private static final boolean DBG = false;
+
+    /** int extra for PBAP_STATE_CHANGED_ACTION */
+    public static final String PBAP_STATE =
+        "android.bluetooth.pbap.intent.PBAP_STATE";
+    /** int extra for PBAP_STATE_CHANGED_ACTION */
+    public static final String PBAP_PREVIOUS_STATE =
+        "android.bluetooth.pbap.intent.PBAP_PREVIOUS_STATE";
+
+    /** Indicates the state of a pbap connection state has changed.
+     *  This intent will always contain PBAP_STATE, PBAP_PREVIOUS_STATE and
+     *  BluetoothIntent.ADDRESS extras.
+     */
+    public static final String PBAP_STATE_CHANGED_ACTION =
+        "android.bluetooth.pbap.intent.action.PBAP_STATE_CHANGED";
+
+    private IBluetoothPbap mService;
+    private final Context mContext;
+    private ServiceListener mServiceListener;
+
+    /** There was an error trying to obtain the state */
+    public static final int STATE_ERROR        = -1;
+    /** No client currently connected */
+    public static final int STATE_DISCONNECTED = 0;
+    /** Connection attempt in progress */
+    public static final int STATE_CONNECTING   = 1;
+    /** Client is currently connected */
+    public static final int STATE_CONNECTED    = 2;
+
+    public static final int RESULT_FAILURE = 0;
+    public static final int RESULT_SUCCESS = 1;
+    /** Connection canceled before completion. */
+    public static final int RESULT_CANCELED = 2;
+
+    /**
+     * An interface for notifying Bluetooth PCE IPC clients when they have
+     * been connected to the BluetoothPbap service.
+     */
+    public interface ServiceListener {
+        /**
+         * Called to notify the client when this proxy object has been
+         * connected to the BluetoothPbap service. Clients must wait for
+         * this callback before making IPC calls on the BluetoothPbap
+         * service.
+         */
+        public void onServiceConnected();
+
+        /**
+         * Called to notify the client that this proxy object has been
+         * disconnected from the BluetoothPbap service. Clients must not
+         * make IPC calls on the BluetoothPbap service after this callback.
+         * This callback will currently only occur if the application hosting
+         * the BluetoothPbap service, but may be called more often in future.
+         */
+        public void onServiceDisconnected();
+    }
+
+    /**
+     * Create a BluetoothPbap proxy object.
+     */
+    public BluetoothPbap(Context context, ServiceListener l) {
+        mContext = context;
+        mServiceListener = l;
+        if (!context.bindService(new Intent(IBluetoothPbap.class.getName()), mConnection, 0)) {
+            Log.e(TAG, "Could not bind to Bluetooth Pbap Service");
+        }
+    }
+
+    protected void finalize() throws Throwable {
+        try {
+            close();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    /**
+     * Close the connection to the backing service.
+     * Other public functions of BluetoothPbap will return default error
+     * results once close() has been called. Multiple invocations of close()
+     * are ok.
+     */
+    public synchronized void close() {
+        if (mConnection != null && mService != null) {
+            mContext.unbindService(mConnection);
+        }
+        mConnection = null;
+        mServiceListener = null;
+    }
+
+    /**
+     * Get the current state of the BluetoothPbap service.
+     * @return One of the STATE_ return codes, or STATE_ERROR if this proxy
+     *         object is currently not connected to the Pbap service.
+     */
+    public int getState() {
+        if (DBG) log("getState()");
+        if (mService != null) {
+            try {
+                return mService.getState();
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) log(Log.getStackTraceString(new Throwable()));
+        }
+        return BluetoothPbap.STATE_ERROR;
+    }
+
+    /**
+     * Get the currently connected remote Bluetooth device (PCE).
+     * @return The remote Bluetooth device, or null if not in connected or
+     *         connecting state, or if this proxy object is not connected to
+     *         the Pbap service.
+     */
+    public BluetoothDevice getClient() {
+        if (DBG) log("getClient()");
+        if (mService != null) {
+            try {
+                return mService.getClient();
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) log(Log.getStackTraceString(new Throwable()));
+        }
+        return null;
+    }
+
+    /**
+     * Returns true if the specified Bluetooth device is connected (does not
+     * include connecting). Returns false if not connected, or if this proxy
+     * object is not currently connected to the Pbap service.
+     */
+    public boolean isConnected(BluetoothDevice device) {
+        if (DBG) log("isConnected(" + device + ")");
+        if (mService != null) {
+            try {
+                return mService.isConnected(device);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) log(Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Disconnects the current Pbap client (PCE). Currently this call blocks,
+     * it may soon be made asynchronous. Returns false if this proxy object is
+     * not currently connected to the Pbap service.
+     */
+    public boolean disconnect() {
+        if (DBG) log("disconnect()");
+        if (mService != null) {
+            try {
+                mService.disconnect();
+                return true;
+            } catch (RemoteException e) {Log.e(TAG, e.toString());
+            } catch (NullPointerException e) {
+                Log.w(TAG, "Pbap Service is already disconnected");
+            }
+
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) log(Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Check class bits for possible PBAP support.
+     * This is a simple heuristic that tries to guess if a device with the
+     * given class bits might support PBAP. It is not accurate for all
+     * devices. It tries to err on the side of false positives.
+     * @return True if this device might support PBAP.
+     */
+    public static boolean doesClassMatchSink(BluetoothClass btClass) {
+        // TODO optimize the rule
+        switch (btClass.getDeviceClass()) {
+        case BluetoothClass.Device.COMPUTER_DESKTOP:
+        case BluetoothClass.Device.COMPUTER_LAPTOP:
+        case BluetoothClass.Device.COMPUTER_SERVER:
+        case BluetoothClass.Device.COMPUTER_UNCATEGORIZED:
+            return true;
+        default:
+            return false;
+        }
+    }
+
+    private ServiceConnection mConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            if (DBG) log("Proxy object connected");
+            mService = IBluetoothPbap.Stub.asInterface(service);
+            if (mServiceListener != null) {
+                mServiceListener.onServiceConnected();
+            }
+        }
+        public void onServiceDisconnected(ComponentName className) {
+            if (DBG) log("Proxy object disconnected");
+            mService = null;
+            if (mServiceListener != null) {
+                mServiceListener.onServiceDisconnected();
+            }
+        }
+    };
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothProfile.java b/bluetoothmsm/java/android/bluetooth/BluetoothProfile.java
new file mode 100644
index 0000000..d789a9e
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothProfile.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package android.bluetooth;
+
+import java.util.List;
+
+/**
+ * Public APIs for the Bluetooth Profiles.
+ *
+ * <p> Clients should call {@link BluetoothAdapter#getProfileProxy},
+ * to get the Profile Proxy. Each public profile implements this
+ * interface.
+ */
+public interface BluetoothProfile {
+
+    /**
+     * Extra for the connection state intents of the individual profiles.
+     *
+     * This extra represents the current connection state of the profile of the
+     * Bluetooth device.
+     */
+    public static final String EXTRA_STATE = "android.bluetooth.profile.extra.STATE";
+
+    /**
+     * Extra for the connection state intents of the individual profiles.
+     *
+     * This extra represents the previous connection state of the profile of the
+     * Bluetooth device.
+     */
+    public static final String EXTRA_PREVIOUS_STATE =
+        "android.bluetooth.profile.extra.PREVIOUS_STATE";
+
+    /** The profile is in disconnected state */
+    public static final int STATE_DISCONNECTED  = 0;
+    /** The profile is in connecting state */
+    public static final int STATE_CONNECTING    = 1;
+    /** The profile is in connected state */
+    public static final int STATE_CONNECTED     = 2;
+    /** The profile is in disconnecting state */
+    public static final int STATE_DISCONNECTING = 3;
+
+    /**
+     * Headset and Handsfree profile
+     */
+    public static final int HEADSET = 1;
+
+    /**
+     * A2DP profile.
+     */
+    public static final int A2DP = 2;
+
+    /**
+     * Health Profile
+     */
+    public static final int HEALTH = 3;
+
+    /**
+     * Input Device Profile
+     * @hide
+     */
+    public static final int INPUT_DEVICE = 4;
+
+    /**
+     * PAN Profile
+     * @hide
+     */
+    public static final int PAN = 5;
+
+    /**
+     * PBAP
+     * @hide
+     */
+    public static final int PBAP = 6;
+
+    /**
+     * SAP
+     * @hide
+     */
+    public static final int SAP = 7;
+
+    /**
+     * GATT
+     * @hide
+     */
+    public static final int GATT = 1001;
+
+    /**
+     * Default priority for devices that we try to auto-connect to and
+     * and allow incoming connections for the profile
+     * @hide
+     **/
+    public static final int PRIORITY_AUTO_CONNECT = 1000;
+
+    /**
+     *  Default priority for devices that allow incoming
+     * and outgoing connections for the profile
+     * @hide
+     **/
+    public static final int PRIORITY_ON = 100;
+
+    /**
+     * Default priority for devices that does not allow incoming
+     * connections and outgoing connections for the profile.
+     * @hide
+     **/
+    public static final int PRIORITY_OFF = 0;
+
+    /**
+     * Default priority when not set or when the device is unpaired
+     * @hide
+     * */
+    public static final int PRIORITY_UNDEFINED = -1;
+
+    /**
+     * Get connected devices for this specific profile.
+     *
+     * <p> Return the set of devices which are in state {@link #STATE_CONNECTED}
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @return List of devices. The list will be empty on error.
+     */
+    public List<BluetoothDevice> getConnectedDevices();
+
+    /**
+     * Get a list of devices that match any of the given connection
+     * states.
+     *
+     * <p> If none of the devices match any of the given states,
+     * an empty list will be returned.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param states Array of states. States can be one of
+     *              {@link #STATE_CONNECTED}, {@link #STATE_CONNECTING},
+     *              {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING},
+     * @return List of devices. The list will be empty on error.
+     */
+    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states);
+
+    /**
+     * Get the current connection state of the profile
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param device Remote bluetooth device.
+     * @return State of the profile connection. One of
+     *               {@link #STATE_CONNECTED}, {@link #STATE_CONNECTING},
+     *               {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING}
+     */
+    public int getConnectionState(BluetoothDevice device);
+
+    /**
+     * An interface for notifying BluetoothProfile IPC clients when they have
+     * been connected or disconnected to the service.
+     */
+    public interface ServiceListener {
+        /**
+         * Called to notify the client when the proxy object has been
+         * connected to the service.
+         * @param profile - One of {@link #HEALTH}, {@link #HEADSET} or
+         *                  {@link #A2DP}
+         * @param proxy - One of {@link BluetoothHealth}, {@link BluetoothHeadset} or
+         *                {@link BluetoothA2dp}
+         */
+        public void onServiceConnected(int profile, BluetoothProfile proxy);
+
+        /**
+         * Called to notify the client that this proxy object has been
+         * disconnected from the service.
+         * @param profile - One of {@link #HEALTH}, {@link #HEADSET} or
+         *                  {@link #A2DP}
+         */
+        public void onServiceDisconnected(int profile);
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothProfileState.java b/bluetoothmsm/java/android/bluetooth/BluetoothProfileState.java
new file mode 100644
index 0000000..b0c0a0b
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothProfileState.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.bluetooth;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Message;
+import android.util.Log;
+
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+
+/**
+ * This state machine is used to serialize the connections
+ * to a particular profile. Currently, we only allow one device
+ * to be connected to a particular profile.
+ * States:
+ *      {@link StableState} : No pending commands. Send the
+ *      command to the appropriate remote device specific state machine.
+ *
+ *      {@link PendingCommandState} : A profile connection / disconnection
+ *      command is being executed. This will result in a profile state
+ *      change. Defer all commands.
+ * @hide
+ */
+
+public class BluetoothProfileState extends StateMachine {
+    private static final boolean DBG = true;
+    private static final String TAG = "BluetoothProfileState";
+
+    public static final int HFP = 0;
+    public static final int A2DP = 1;
+    public static final int HID = 2;
+
+    static final int TRANSITION_TO_STABLE = 100;
+
+    private int mProfile;
+    private BluetoothDevice mPendingDevice;
+    private PendingCommandState mPendingCommandState = new PendingCommandState();
+    private StableState mStableState = new StableState();
+
+    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            if (device == null) {
+                return;
+            }
+            if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
+                int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                if (mProfile == HFP && (newState == BluetoothProfile.STATE_CONNECTED ||
+                    newState == BluetoothProfile.STATE_DISCONNECTED)) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            } else if (action.equals(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED)) {
+                int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                if (mProfile == A2DP && (newState == BluetoothProfile.STATE_CONNECTED ||
+                    newState == BluetoothProfile.STATE_DISCONNECTED)) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            } else if (action.equals(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED)) {
+                int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                if (mProfile == HID && (newState == BluetoothProfile.STATE_CONNECTED ||
+                    newState == BluetoothProfile.STATE_DISCONNECTED)) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            } else if (action.equals(BluetoothDevice.ACTION_ACL_DISCONNECTED)) {
+                if (device.equals(mPendingDevice)) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            }
+        }
+    };
+
+    public BluetoothProfileState(Context context, int profile) {
+        super("BluetoothProfileState:" + profile);
+        mProfile = profile;
+        addState(mStableState);
+        addState(mPendingCommandState);
+        setInitialState(mStableState);
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
+        context.registerReceiver(mBroadcastReceiver, filter);
+    }
+
+    private class StableState extends State {
+        @Override
+        public void enter() {
+            log("Entering Stable State");
+            mPendingDevice = null;
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            if (msg.what != TRANSITION_TO_STABLE) {
+                transitionTo(mPendingCommandState);
+            }
+            return true;
+        }
+    }
+
+    private class PendingCommandState extends State {
+        @Override
+        public void enter() {
+            log("Entering PendingCommandState State");
+            dispatchMessage(getCurrentMessage());
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            if (msg.what == TRANSITION_TO_STABLE) {
+                transitionTo(mStableState);
+            } else {
+                dispatchMessage(msg);
+            }
+            return true;
+        }
+
+        private void dispatchMessage(Message msg) {
+            BluetoothDeviceProfileState deviceProfileMgr =
+              (BluetoothDeviceProfileState)msg.obj;
+            int cmd = msg.arg1;
+            if (mPendingDevice == null || mPendingDevice.equals(deviceProfileMgr.getDevice())) {
+                mPendingDevice = deviceProfileMgr.getDevice();
+                deviceProfileMgr.sendMessage(cmd);
+            } else {
+                Message deferMsg = new Message();
+                deferMsg.arg1 = cmd;
+                deferMsg.obj = deviceProfileMgr;
+                deferMessage(deferMsg);
+            }
+        }
+    }
+
+    private void log(String message) {
+        if (DBG) {
+            Log.i(TAG, "Message:" + message);
+        }
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothSap.java b/bluetoothmsm/java/android/bluetooth/BluetoothSap.java
new file mode 100644
index 0000000..0178c1f
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothSap.java
@@ -0,0 +1,102 @@
+/*
+* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*        * Redistributions of source code must retain the above copyright
+*            notice, this list of conditions and the following disclaimer.
+*        * Redistributions in binary form must reproduce the above copyright
+*            notice, this list of conditions and the following disclaimer in the
+*            documentation and/or other materials provided with the distribution.
+*        * Neither the name of Code Aurora nor
+*            the names of its contributors may be used to endorse or promote
+*            products derived from this software without specific prior written
+*            permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+package android.bluetooth;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.RemoteException;
+import android.os.IBinder;
+import android.os.ServiceManager;
+import android.util.Log;
+
+/**
+ *
+ * Public API for controlling the Bluetooth Sap Service.
+ *
+ * @hide
+ */
+public class BluetoothSap {
+
+    private static final String TAG = "BluetoothSap";
+    private static final boolean DBG = false;
+
+    /**
+     * Intent used to broadcast the change in connection state of the A2DP
+     * profile.
+     *
+     * <p>This intent will have 3 extras:
+     * <ul>
+     *   <li> {@link #EXTRA_STATE} - The current state of the profile. </li>
+     *   <li> {@link #EXTRA_PREVIOUS_STATE}- The previous state of the profile.</li>
+     *   <li> {@link BluetoothDevice#EXTRA_DEVICE} - The remote device. </li>
+     * </ul>
+     *
+     * <p>{@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} can be any of
+     * {@link #STATE_DISCONNECTED}, {@link #STATE_CONNECTING},
+     * {@link #STATE_CONNECTED}, {@link #STATE_DISCONNECTING}.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission to
+     * receive.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CONNECTION_STATE_CHANGED =
+	    "android.bluetooth.sap.profile.action.CONNECTION_STATE_CHANGED";
+
+
+    private IBluetooth mService;
+
+    public BluetoothSap() {
+        IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
+        if (b != null) {
+            mService = IBluetooth.Stub.asInterface(b);
+        } else {
+            Log.i(TAG, "Failed to get the Bluetooth Interface");
+        }
+    }
+     /**
+     * Initiate the disconnection from SAP server.
+     * Status of the SAP server can be determined by the signal emitted
+     * from org.qcom.sap
+     */
+    public boolean disconnect() {
+        Log.i(TAG, "->disconnect");
+        try {
+            mService.disconnectSap();
+            return true;
+        } catch(RemoteException e) {
+            Log.e(TAG, "", e);
+        }
+
+        return false;
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothServerSocket.java b/bluetoothmsm/java/android/bluetooth/BluetoothServerSocket.java
new file mode 100644
index 0000000..4021f7b
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothServerSocket.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.os.Handler;
+
+import java.io.Closeable;
+import java.io.IOException;
+
+/**
+ * A listening Bluetooth socket.
+ *
+ * <p>The interface for Bluetooth Sockets is similar to that of TCP sockets:
+ * {@link java.net.Socket} and {@link java.net.ServerSocket}. On the server
+ * side, use a {@link BluetoothServerSocket} to create a listening server
+ * socket. When a connection is accepted by the {@link BluetoothServerSocket},
+ * it will return a new {@link BluetoothSocket} to manage the connection.
+ * On the client side, use a single {@link BluetoothSocket} to both initiate
+ * an outgoing connection and to manage the connection.
+ *
+ * <p>The most common type of Bluetooth socket is RFCOMM, which is the type
+ * supported by the Android APIs. RFCOMM is a connection-oriented, streaming
+ * transport over Bluetooth. It is also known as the Serial Port Profile (SPP).
+ *
+ * <p>To create a listening {@link BluetoothServerSocket} that's ready for
+ * incoming connections, use
+ * {@link BluetoothAdapter#listenUsingRfcommWithServiceRecord
+ * BluetoothAdapter.listenUsingRfcommWithServiceRecord()}. Then call
+ * {@link #accept()} to listen for incoming connection requests. This call
+ * will block until a connection is established, at which point, it will return
+ * a {@link BluetoothSocket} to manage the connection. Once the {@link
+ * BluetoothSocket} is acquired, it's a good idea to call {@link #close()} on
+ * the {@link BluetoothServerSocket} when it's no longer needed for accepting
+ * connections. Closing the {@link BluetoothServerSocket} will <em>not</em>
+ * close the returned {@link BluetoothSocket}.
+ *
+ * <p>{@link BluetoothServerSocket} is thread
+ * safe. In particular, {@link #close} will always immediately abort ongoing
+ * operations and close the server socket.
+ *
+ * <p class="note"><strong>Note:</strong>
+ * Requires the {@link android.Manifest.permission#BLUETOOTH} permission.
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For more information about using Bluetooth, read the
+ * <a href="{@docRoot}guide/topics/wireless/bluetooth.html">Bluetooth</a> developer guide.</p>
+ * </div>
+ *
+ * {@see BluetoothSocket}
+ */
+public final class BluetoothServerSocket implements Closeable {
+
+    /*package*/ final BluetoothSocket mSocket;
+    private Handler mHandler;
+    private int mMessage;
+    private final int mChannel;
+
+    /**
+     * Construct a socket for incoming connections.
+     * @param type    type of socket
+     * @param auth    require the remote device to be authenticated
+     * @param encrypt require the connection to be encrypted
+     * @param port    remote port
+     * @throws IOException On error, for example Bluetooth not available, or
+     *                     insufficient privileges
+     */
+    /*package*/ BluetoothServerSocket(int type, boolean auth, boolean encrypt, int port)
+            throws IOException {
+        mChannel = port;
+        mSocket = new BluetoothSocket(type, -1, auth, encrypt, null, port, null);
+    }
+
+    /**
+     * Block until a connection is established.
+     * <p>Returns a connected {@link BluetoothSocket} on successful connection.
+     * <p>Once this call returns, it can be called again to accept subsequent
+     * incoming connections.
+     * <p>{@link #close} can be used to abort this call from another thread.
+     * @return a connected {@link BluetoothSocket}
+     * @throws IOException on error, for example this call was aborted, or
+     *                     timeout
+     */
+    public BluetoothSocket accept() throws IOException {
+        return accept(-1);
+    }
+
+    /**
+     * Block until a connection is established, with timeout.
+     * <p>Returns a connected {@link BluetoothSocket} on successful connection.
+     * <p>Once this call returns, it can be called again to accept subsequent
+     * incoming connections.
+     * <p>{@link #close} can be used to abort this call from another thread.
+     * @return a connected {@link BluetoothSocket}
+     * @throws IOException on error, for example this call was aborted, or
+     *                     timeout
+     */
+    public BluetoothSocket accept(int timeout) throws IOException {
+        return mSocket.accept(timeout);
+    }
+
+    /**
+     * Immediately close this socket, and release all associated resources.
+     * <p>Causes blocked calls on this socket in other threads to immediately
+     * throw an IOException.
+     * <p>Closing the {@link BluetoothServerSocket} will <em>not</em>
+     * close any {@link BluetoothSocket} received from {@link #accept()}.
+     */
+    public void close() throws IOException {
+        synchronized (this) {
+            if (mHandler != null) {
+                mHandler.obtainMessage(mMessage).sendToTarget();
+            }
+        }
+        mSocket.close();
+    }
+
+    /*package*/ synchronized void setCloseHandler(Handler handler, int message) {
+        mHandler = handler;
+        mMessage = message;
+    }
+
+    /**
+     * Returns the channel on which this socket is bound.
+     * @hide
+     */
+    public int getChannel() {
+        return mChannel;
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothSocket.java b/bluetoothmsm/java/android/bluetooth/BluetoothSocket.java
new file mode 100644
index 0000000..3f7f4b4
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothSocket.java
@@ -0,0 +1,530 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.bluetooth.IBluetoothCallback;
+import android.os.ParcelUuid;
+import android.os.RemoteException;
+import android.util.Log;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * A connected or connecting Bluetooth socket.
+ *
+ * <p>The interface for Bluetooth Sockets is similar to that of TCP sockets:
+ * {@link java.net.Socket} and {@link java.net.ServerSocket}. On the server
+ * side, use a {@link BluetoothServerSocket} to create a listening server
+ * socket. When a connection is accepted by the {@link BluetoothServerSocket},
+ * it will return a new {@link BluetoothSocket} to manage the connection.
+ * On the client side, use a single {@link BluetoothSocket} to both initiate
+ * an outgoing connection and to manage the connection.
+ *
+ * <p>The most common type of Bluetooth socket is RFCOMM, which is the type
+ * supported by the Android APIs. RFCOMM is a connection-oriented, streaming
+ * transport over Bluetooth. It is also known as the Serial Port Profile (SPP).
+ *
+ * <p>To create a {@link BluetoothSocket} for connecting to a known device, use
+ * {@link BluetoothDevice#createRfcommSocketToServiceRecord
+ * BluetoothDevice.createRfcommSocketToServiceRecord()}.
+ * Then call {@link #connect()} to attempt a connection to the remote device.
+ * This call will block until a connection is established or the connection
+ * fails.
+ *
+ * <p>To create a {@link BluetoothSocket} as a server (or "host"), see the
+ * {@link BluetoothServerSocket} documentation.
+ *
+ * <p>Once the socket is connected, whether initiated as a client or accepted
+ * as a server, open the IO streams by calling {@link #getInputStream} and
+ * {@link #getOutputStream} in order to retrieve {@link java.io.InputStream}
+ * and {@link java.io.OutputStream} objects, respectively, which are
+ * automatically connected to the socket.
+ *
+ * <p>{@link BluetoothSocket} is thread
+ * safe. In particular, {@link #close} will always immediately abort ongoing
+ * operations and close the socket.
+ *
+ * <p class="note"><strong>Note:</strong>
+ * Requires the {@link android.Manifest.permission#BLUETOOTH} permission.
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For more information about using Bluetooth, read the
+ * <a href="{@docRoot}guide/topics/wireless/bluetooth.html">Bluetooth</a> developer guide.</p>
+ * </div>
+ *
+ * {@see BluetoothServerSocket}
+ * {@see java.io.InputStream}
+ * {@see java.io.OutputStream}
+ */
+public final class BluetoothSocket implements Closeable {
+    private static final String TAG = "BluetoothSocket";
+
+    /** @hide */
+    public static final int MAX_RFCOMM_CHANNEL = 30;
+
+    /** Keep TYPE_ fields in sync with BluetoothSocket.cpp */
+    /*package*/ static final int TYPE_RFCOMM = 1;
+    /*package*/ static final int TYPE_SCO = 2;
+    /*package*/ static final int TYPE_L2CAP = 3;
+    /*package*/ static final int TYPE_EL2CAP = 4;
+    /*package*/ static final int TYPE_SCO_WBS = 5;
+
+    /** Keep BT_AMP_POLICY fields in sync with bluetooth/bluetooth.h */
+    /** @hide */ public static final int BT_AMP_POLICY_REQUIRE_BR_EDR = 0;
+    /** @hide */ public static final int BT_AMP_POLICY_PREFER_BR_EDR = 1;
+    /** @hide */ public static final int BT_AMP_POLICY_PREFER_AMP = 2;
+
+    /*package*/ static final int EBADFD = 77;
+    /*package*/ static final int EADDRINUSE = 98;
+
+    private final int mType;  /* one of TYPE_RFCOMM etc */
+    private final BluetoothDevice mDevice;    /* remote device */
+    private final String mAddress;    /* remote address */
+    private final boolean mAuth;
+    private final boolean mEncrypt;
+    private final BluetoothInputStream mInputStream;
+    private final BluetoothOutputStream mOutputStream;
+    private final SdpHelper mSdp;
+    private final AmpPolicyHelper mAmpPolicy;
+
+    private int mPort;  /* RFCOMM channel or L2CAP psm */
+
+    private enum SocketState {
+        INIT,
+        CONNECTED,
+        CLOSED
+    }
+
+    /** prevents all native calls after destroyNative() */
+    private SocketState mSocketState;
+
+    /** protects mSocketState */
+    private final ReentrantReadWriteLock mLock;
+
+    /** used by native code only */
+    private int mSocketData;
+
+    /**
+     * Construct a BluetoothSocket.
+     * @param type    type of socket
+     * @param fd      fd to use for connected socket, or -1 for a new socket
+     * @param auth    require the remote device to be authenticated
+     * @param encrypt require the connection to be encrypted
+     * @param device  remote device that this socket can connect to
+     * @param port    remote port
+     * @param uuid    SDP uuid
+     * @throws IOException On error, for example Bluetooth not available, or
+     *                     insufficient privileges
+     */
+    /*package*/ BluetoothSocket(int type, int fd, boolean auth, boolean encrypt,
+            BluetoothDevice device, int port, ParcelUuid uuid) throws IOException {
+        if (type == BluetoothSocket.TYPE_RFCOMM && uuid == null && fd == -1) {
+            if (port < 1 || port > MAX_RFCOMM_CHANNEL) {
+                throw new IOException("Invalid RFCOMM channel: " + port);
+            }
+        }
+        if (uuid == null) {
+            mPort = port;
+            mSdp = null;
+        } else {
+            mSdp = new SdpHelper(device, uuid);
+            mPort = -1;
+        }
+        mType = type;
+        mAuth = auth;
+        mEncrypt = encrypt;
+        mDevice = device;
+        if (device == null) {
+            mAddress = null;
+        } else {
+            mAddress = device.getAddress();
+        }
+        if (fd == -1) {
+            initSocketNative();
+        } else {
+            initSocketFromFdNative(fd);
+        }
+        /* Register with the Bluetooth connection manager
+         * and set the initial socket AMP policy
+         */
+        if (type == BluetoothSocket.TYPE_EL2CAP) {
+            mAmpPolicy = new AmpPolicyHelper(BT_AMP_POLICY_REQUIRE_BR_EDR);
+        } else {
+            mAmpPolicy = null;
+        }
+        mInputStream = new BluetoothInputStream(this);
+        mOutputStream = new BluetoothOutputStream(this);
+        mSocketState = SocketState.INIT;
+        mLock = new ReentrantReadWriteLock();
+    }
+
+    /**
+     * Construct a BluetoothSocket from address. Used by native code.
+     * @param type    type of socket
+     * @param fd      fd to use for connected socket, or -1 for a new socket
+     * @param auth    require the remote device to be authenticated
+     * @param encrypt require the connection to be encrypted
+     * @param address remote device that this socket can connect to
+     * @param port    remote port
+     * @throws IOException On error, for example Bluetooth not available, or
+     *                     insufficient privileges
+     */
+    private BluetoothSocket(int type, int fd, boolean auth, boolean encrypt, String address,
+            int port) throws IOException {
+        this(type, fd, auth, encrypt, new BluetoothDevice(address), port, null);
+    }
+
+    /** @hide */
+    @Override
+    protected void finalize() throws Throwable {
+        try {
+            close();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    /**
+     * Attempt to connect to a remote device.
+     * <p>This method will block until a connection is made or the connection
+     * fails. If this method returns without an exception then this socket
+     * is now connected.
+     * <p>Creating new connections to
+     * remote Bluetooth devices should not be attempted while device discovery
+     * is in progress. Device discovery is a heavyweight procedure on the
+     * Bluetooth adapter and will significantly slow a device connection.
+     * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
+     * discovery. Discovery is not managed by the Activity,
+     * but is run as a system service, so an application should always call
+     * {@link BluetoothAdapter#cancelDiscovery()} even if it
+     * did not directly request a discovery, just to be sure.
+     * <p>{@link #close} can be used to abort this call from another thread.
+     * @throws IOException on error, for example connection failure
+     */
+    public void connect() throws IOException {
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) throw new IOException("socket closed");
+
+            if (mSdp != null) {
+                mPort = mSdp.doSdp();  // blocks
+            }
+
+            connectNative();  // blocks
+            mSocketState = SocketState.CONNECTED;
+        } finally {
+            mLock.readLock().unlock();
+        }
+    }
+
+    /**
+     * Immediately close this socket, and release all associated resources.
+     * <p>Causes blocked calls on this socket in other threads to immediately
+     * throw an IOException.
+     */
+    public void close() throws IOException {
+        // abort blocking operations on the socket
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) return;
+            if (mSdp != null) {
+                mSdp.cancel();
+            }
+            if (mAmpPolicy != null) {
+                mAmpPolicy.deregister();
+            }
+            abortNative();
+        } finally {
+            mLock.readLock().unlock();
+        }
+
+        // all native calls are guaranteed to immediately return after
+        // abortNative(), so this lock should immediately acquire
+        mLock.writeLock().lock();
+        try {
+            mSocketState = SocketState.CLOSED;
+            destroyNative();
+        } finally {
+            mLock.writeLock().unlock();
+        }
+    }
+
+    /**
+     * Set the desired AMP Policy for EL2CAP type sockets
+     *
+     * @hide
+     */
+    public boolean setDesiredAmpPolicy(int policy) {
+        boolean result = false;
+        if (mAmpPolicy != null) {
+            IBluetooth service = BluetoothDevice.getService();
+            try {
+                result = service.setDesiredAmpPolicy(mAmpPolicy.mHandle, policy);
+            } catch (RemoteException e) {Log.e(TAG, "", e);}
+        }
+        return result;
+    }
+
+    /**
+     * Get the remote device this socket is connecting, or connected, to.
+     * @return remote device
+     */
+    public BluetoothDevice getRemoteDevice() {
+        return mDevice;
+    }
+
+    /**
+     * Get the input stream associated with this socket.
+     * <p>The input stream will be returned even if the socket is not yet
+     * connected, but operations on that stream will throw IOException until
+     * the associated socket is connected.
+     * @return InputStream
+     */
+    public InputStream getInputStream() throws IOException {
+        return mInputStream;
+    }
+
+    /**
+     * Get the output stream associated with this socket.
+     * <p>The output stream will be returned even if the socket is not yet
+     * connected, but operations on that stream will throw IOException until
+     * the associated socket is connected.
+     * @return OutputStream
+     */
+    public OutputStream getOutputStream() throws IOException {
+        return mOutputStream;
+    }
+
+    /**
+     * Get the connection status of this socket, ie, whether there is an active connection with
+     * remote device.
+     * @return true if connected
+     *         false if not connected
+     */
+    public boolean isConnected() {
+        return (mSocketState == SocketState.CONNECTED);
+    }
+
+    /**
+     * Gets the MTU for the socket (if RFCOMM, returns 65K)
+     *
+     * @hide
+     */
+    public int getMtu() {
+        int ret = 0;
+        try {
+            ret = getMtuNative();
+        } catch (IOException e) {
+            Log.e(TAG, "", e);
+        }
+
+        Log.d(TAG, "getMtu " + Integer.toString(ret));
+        return ret;
+    }
+
+    /**
+     * Currently returns unix errno instead of throwing IOException,
+     * so that BluetoothAdapter can check the error code for EADDRINUSE
+     */
+    /*package*/ int bindListen() {
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) return EBADFD;
+            return bindListenNative();
+        } finally {
+            mLock.readLock().unlock();
+        }
+    }
+
+    /*package*/ BluetoothSocket accept(int timeout) throws IOException {
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) throw new IOException("socket closed");
+
+            BluetoothSocket acceptedSocket = acceptNative(timeout);
+            mSocketState = SocketState.CONNECTED;
+            return acceptedSocket;
+        } finally {
+            mLock.readLock().unlock();
+        }
+    }
+
+    /*package*/ int available() throws IOException {
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) throw new IOException("socket closed");
+            return availableNative();
+        } finally {
+            mLock.readLock().unlock();
+        }
+    }
+
+    /*package*/ int read(byte[] b, int offset, int length) throws IOException {
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) throw new IOException("socket closed");
+            return readNative(b, offset, length);
+        } catch (IOException e) {
+            Log.e(TAG, "", e);
+            throw e;
+        } finally {
+            mLock.readLock().unlock();
+        }
+    }
+
+    /*package*/ int write(byte[] b, int offset, int length) throws IOException {
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) throw new IOException("socket closed");
+            return writeNative(b, offset, length);
+        } catch (IOException e) {
+            Log.e(TAG, "", e);
+            throw e;
+        } finally {
+            mLock.readLock().unlock();
+        }
+    }
+
+    private native void initSocketNative() throws IOException;
+    private native void initSocketFromFdNative(int fd) throws IOException;
+    private native void connectNative() throws IOException;
+    private native int bindListenNative();
+    private native BluetoothSocket acceptNative(int timeout) throws IOException;
+    private native int availableNative() throws IOException;
+    private native int readNative(byte[] b, int offset, int length) throws IOException;
+    private native int writeNative(byte[] b, int offset, int length) throws IOException;
+    private native void abortNative() throws IOException;
+    private native void destroyNative() throws IOException;
+    private native void setAmpPolicyNative(int amppol) throws IOException;
+    private native int getMtuNative() throws IOException;
+
+    /**
+     * Throws an IOException for given posix errno. Done natively so we can
+     * use strerr to convert to string error.
+     */
+    /*package*/ native void throwErrnoNative(int errno) throws IOException;
+
+    /**
+     * Helper to perform blocking SDP lookup.
+     */
+    private static class SdpHelper extends IBluetoothCallback.Stub {
+        private final IBluetooth service;
+        private final ParcelUuid uuid;
+        private final BluetoothDevice device;
+        private int channel;
+        private boolean canceled;
+        public SdpHelper(BluetoothDevice device, ParcelUuid uuid) {
+            service = BluetoothDevice.getService();
+            this.device = device;
+            this.uuid = uuid;
+            canceled = false;
+        }
+        /**
+         * Returns the RFCOMM channel for the UUID, or throws IOException
+         * on failure.
+         */
+        public synchronized int doSdp() throws IOException {
+            if (canceled) throw new IOException("Service discovery canceled");
+            channel = -1;
+
+            boolean inProgress = false;
+            try {
+                inProgress = service.fetchRemoteUuids(device.getAddress(), uuid, this);
+            } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+            if (!inProgress) throw new IOException("Unable to start Service Discovery");
+
+            try {
+                /* 12 second timeout as a precaution - onRfcommChannelFound
+                 * should always occur before the timeout */
+                wait(12000);   // block
+
+            } catch (InterruptedException e) {}
+
+            if (canceled) throw new IOException("Service discovery canceled");
+            if (channel < 1) throw new IOException("Service discovery failed");
+
+            return channel;
+        }
+        /** Object cannot be re-used after calling cancel() */
+        public synchronized void cancel() {
+            if (!canceled) {
+                canceled = true;
+                channel = -1;
+                notifyAll();  // unblock
+            }
+        }
+        public synchronized void onRfcommChannelFound(int channel) {
+            if (!canceled) {
+                this.channel = channel;
+                notifyAll();  // unblock
+            }
+        }
+        /** Stub function, unused for SDP lookup */
+        public synchronized void onAmpPolicyChange(int newPolicy) {
+        }
+    }
+
+    /**
+     * Helper to handle AMP policy changes from Bluetooth connection manager
+     */
+    private class AmpPolicyHelper extends IBluetoothCallback.Stub {
+        private final IBluetooth service;
+        private int mHandle = 0;
+
+        public AmpPolicyHelper(int initialPolicy) {
+            service = BluetoothDevice.getService();
+
+            try {
+                mHandle = service.registerEl2capConnection(this, initialPolicy);
+
+                // Configure initial AMP policy.  Note: this
+                // assumes the socket has been initialized.
+                setAmpPolicyNative(service.getEffectiveAmpPolicy(initialPolicy));
+            } catch (RemoteException e) {
+                Log.e(TAG, "", e);
+            } catch (IOException e) {
+                Log.e(TAG, "", e);
+            }
+        }
+
+        public synchronized void deregister() {
+            try {
+                service.deregisterEl2capConnection(mHandle);
+            } catch (RemoteException e) {Log.e(TAG, "", e);}
+        }
+
+
+        public synchronized void onAmpPolicyChange(int newPolicy) {
+            try {
+                setAmpPolicyNative(newPolicy);
+            } catch (IOException e) {
+                Log.e(TAG, "", e);
+            }
+        }
+
+        /** Stub function, unused for AMP policy changes */
+        public synchronized void onRfcommChannelFound(int channel) {
+        }
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothTetheringDataTracker.java b/bluetoothmsm/java/android/bluetooth/BluetoothTetheringDataTracker.java
new file mode 100644
index 0000000..60064f3
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothTetheringDataTracker.java
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.DhcpInfoInternal;
+import android.net.LinkCapabilities;
+import android.net.LinkProperties;
+import android.net.NetworkInfo;
+import android.net.NetworkInfo.DetailedState;
+import android.net.NetworkStateTracker;
+import android.net.NetworkUtils;
+import android.os.Handler;
+import android.os.Message;
+import android.util.Log;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * This class tracks the data connection associated with Bluetooth
+ * reverse tethering. This is a singleton class and an instance will be
+ * created by ConnectivityService. BluetoothService will call into this
+ * when a reverse tethered connection needs to be activated.
+ *
+ * @hide
+ */
+public class BluetoothTetheringDataTracker implements NetworkStateTracker {
+    private static final String NETWORKTYPE = "BLUETOOTH_TETHER";
+    private static final String TAG = "BluetoothTethering";
+
+    private AtomicBoolean mTeardownRequested = new AtomicBoolean(false);
+    private AtomicBoolean mPrivateDnsRouteSet = new AtomicBoolean(false);
+    private AtomicInteger mDefaultGatewayAddr = new AtomicInteger(0);
+    private AtomicBoolean mDefaultRouteSet = new AtomicBoolean(false);
+
+    private LinkProperties mLinkProperties;
+    private LinkCapabilities mLinkCapabilities;
+    private NetworkInfo mNetworkInfo;
+
+    private BluetoothPan mBluetoothPan;
+    private BluetoothDevice mDevice;
+    private static String mIface;
+
+    /* For sending events to connectivity service handler */
+    private Handler mCsHandler;
+    private Context mContext;
+    public static BluetoothTetheringDataTracker sInstance;
+
+    private BluetoothTetheringDataTracker() {
+        mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_BLUETOOTH, 0, NETWORKTYPE, "");
+        mLinkProperties = new LinkProperties();
+        mLinkCapabilities = new LinkCapabilities();
+
+        mNetworkInfo.setIsAvailable(false);
+        setTeardownRequested(false);
+    }
+
+    public static synchronized BluetoothTetheringDataTracker getInstance() {
+        if (sInstance == null) sInstance = new BluetoothTetheringDataTracker();
+        return sInstance;
+    }
+
+    public Object Clone() throws CloneNotSupportedException {
+        throw new CloneNotSupportedException();
+    }
+
+    public void setTeardownRequested(boolean isRequested) {
+        mTeardownRequested.set(isRequested);
+    }
+
+    public boolean isTeardownRequested() {
+        return mTeardownRequested.get();
+    }
+
+    /**
+     * Begin monitoring connectivity
+     */
+    public void startMonitoring(Context context, Handler target) {
+        mContext = context;
+        mCsHandler = target;
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        if (adapter != null) {
+            adapter.getProfileProxy(mContext, mProfileServiceListener, BluetoothProfile.PAN);
+        }
+    }
+
+    private BluetoothProfile.ServiceListener mProfileServiceListener =
+        new BluetoothProfile.ServiceListener() {
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            mBluetoothPan = (BluetoothPan) proxy;
+        }
+        public void onServiceDisconnected(int profile) {
+            mBluetoothPan = null;
+        }
+    };
+
+    /**
+     * Disable connectivity to a network
+     * TODO: do away with return value after making MobileDataStateTracker async
+     */
+    public boolean teardown() {
+        mTeardownRequested.set(true);
+        if (mBluetoothPan != null) {
+            for (BluetoothDevice device: mBluetoothPan.getConnectedDevices()) {
+                mBluetoothPan.disconnect(device);
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public void captivePortalCheckComplete() {
+        // Not implemented
+    }
+
+    /**
+     * Re-enable connectivity to a network after a {@link #teardown()}.
+     */
+    public boolean reconnect() {
+        mTeardownRequested.set(false);
+        //Ignore
+        return true;
+    }
+
+    /**
+     * Turn the wireless radio off for a network.
+     * @param turnOn {@code true} to turn the radio on, {@code false}
+     */
+    public boolean setRadio(boolean turnOn) {
+        return true;
+    }
+
+    /**
+     * @return true - If are we currently tethered with another device.
+     */
+    public synchronized boolean isAvailable() {
+        return mNetworkInfo.isAvailable();
+    }
+
+    /**
+     * Tells the underlying networking system that the caller wants to
+     * begin using the named feature. The interpretation of {@code feature}
+     * is completely up to each networking implementation.
+     * @param feature the name of the feature to be used
+     * @param callingPid the process ID of the process that is issuing this request
+     * @param callingUid the user ID of the process that is issuing this request
+     * @return an integer value representing the outcome of the request.
+     * The interpretation of this value is specific to each networking
+     * implementation+feature combination, except that the value {@code -1}
+     * always indicates failure.
+     * TODO: needs to go away
+     */
+    public int startUsingNetworkFeature(String feature, int callingPid, int callingUid) {
+        return -1;
+    }
+
+    /**
+     * Tells the underlying networking system that the caller is finished
+     * using the named feature. The interpretation of {@code feature}
+     * is completely up to each networking implementation.
+     * @param feature the name of the feature that is no longer needed.
+     * @param callingPid the process ID of the process that is issuing this request
+     * @param callingUid the user ID of the process that is issuing this request
+     * @return an integer value representing the outcome of the request.
+     * The interpretation of this value is specific to each networking
+     * implementation+feature combination, except that the value {@code -1}
+     * always indicates failure.
+     * TODO: needs to go away
+     */
+    public int stopUsingNetworkFeature(String feature, int callingPid, int callingUid) {
+        return -1;
+    }
+
+    @Override
+    public void setUserDataEnable(boolean enabled) {
+        Log.w(TAG, "ignoring setUserDataEnable(" + enabled + ")");
+    }
+
+    @Override
+    public void setPolicyDataEnable(boolean enabled) {
+        Log.w(TAG, "ignoring setPolicyDataEnable(" + enabled + ")");
+    }
+
+    /**
+     * Check if private DNS route is set for the network
+     */
+    public boolean isPrivateDnsRouteSet() {
+        return mPrivateDnsRouteSet.get();
+    }
+
+    /**
+     * Set a flag indicating private DNS route is set
+     */
+    public void privateDnsRouteSet(boolean enabled) {
+        mPrivateDnsRouteSet.set(enabled);
+    }
+
+    /**
+     * Fetch NetworkInfo for the network
+     */
+    public synchronized NetworkInfo getNetworkInfo() {
+        return mNetworkInfo;
+    }
+
+    /**
+     * Fetch LinkProperties for the network
+     */
+    public synchronized LinkProperties getLinkProperties() {
+        return new LinkProperties(mLinkProperties);
+    }
+
+   /**
+     * A capability is an Integer/String pair, the capabilities
+     * are defined in the class LinkSocket#Key.
+     *
+     * @return a copy of this connections capabilities, may be empty but never null.
+     */
+    public LinkCapabilities getLinkCapabilities() {
+        return new LinkCapabilities(mLinkCapabilities);
+    }
+
+    /**
+     * Fetch default gateway address for the network
+     */
+    public int getDefaultGatewayAddr() {
+        return mDefaultGatewayAddr.get();
+    }
+
+    /**
+     * Check if default route is set
+     */
+    public boolean isDefaultRouteSet() {
+        return mDefaultRouteSet.get();
+    }
+
+    /**
+     * Set a flag indicating default route is set for the network
+     */
+    public void defaultRouteSet(boolean enabled) {
+        mDefaultRouteSet.set(enabled);
+    }
+
+    /**
+     * Return the system properties name associated with the tcp buffer sizes
+     * for this network.
+     */
+    public String getTcpBufferSizesPropName() {
+        return "net.tcp.buffersize.wifi";
+    }
+
+
+    public synchronized void startReverseTether(String iface) {
+        // Dummy function for Bluedroid dependent common code compilation
+        Log.e(TAG, "ERROR : Not expected to be called");
+    }
+
+    public synchronized void startReverseTether(String iface, BluetoothDevice device) {
+        mIface = iface;
+        mDevice = device;
+        Thread dhcpThread = new Thread(new Runnable() {
+            public void run() {
+                //TODO(): Add callbacks for failure and success case.
+                //Currently this thread runs independently.
+                DhcpInfoInternal dhcpInfoInternal = new DhcpInfoInternal();
+                if (!NetworkUtils.runDhcp(mIface, dhcpInfoInternal)) {
+                    Log.e(TAG, "DHCP request error:" + NetworkUtils.getDhcpError());
+                    return;
+                }
+                mLinkProperties = dhcpInfoInternal.makeLinkProperties();
+                mLinkProperties.setInterfaceName(mIface);
+
+                mNetworkInfo.setIsAvailable(true);
+                mNetworkInfo.setDetailedState(DetailedState.CONNECTED, null, null);
+
+                Message msg = mCsHandler.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
+                msg.sendToTarget();
+
+                msg = mCsHandler.obtainMessage(EVENT_STATE_CHANGED, mNetworkInfo);
+                msg.sendToTarget();
+            }
+        });
+        dhcpThread.start();
+    }
+
+    public synchronized void stopReverseTether() {
+        // Dummy function for Bluedroid dependent common code compilation
+        Log.e(TAG, "ERROR : Not expected to be called");
+    }
+
+    public synchronized void stopReverseTether(String iface) {
+        if (iface == null) {
+            Log.e(TAG, "ERROR : iface is null");
+            return;
+        }
+        NetworkUtils.stopDhcp(iface);
+
+        mLinkProperties.clear();
+        mNetworkInfo.setIsAvailable(false);
+        mNetworkInfo.setDetailedState(DetailedState.DISCONNECTED, null, null);
+
+        Message msg = mCsHandler.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
+        msg.sendToTarget();
+
+        msg = mCsHandler.obtainMessage(EVENT_STATE_CHANGED, mNetworkInfo);
+        msg.sendToTarget();
+    }
+
+    public void setDependencyMet(boolean met) {
+        // not supported on this network
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/BluetoothUuid.java b/bluetoothmsm/java/android/bluetooth/BluetoothUuid.java
new file mode 100644
index 0000000..a984364
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/BluetoothUuid.java
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.os.ParcelUuid;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.UUID;
+
+/**
+* Static helper methods and constants to decode the ParcelUuid of remote devices.
+*  @hide
+*/
+public final class BluetoothUuid {
+
+    /* See Bluetooth Assigned Numbers document - SDP section, to get the values of UUIDs
+     * for the various services.
+     *
+     * The following 128 bit values are calculated as:
+     *  uuid * 2^96 + BASE_UUID
+     */
+    public static final ParcelUuid AudioSink =
+            ParcelUuid.fromString("0000110B-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid AudioSource =
+            ParcelUuid.fromString("0000110A-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid AdvAudioDist =
+            ParcelUuid.fromString("0000110D-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid HSP =
+            ParcelUuid.fromString("00001108-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid HSP_AG =
+            ParcelUuid.fromString("00001112-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid Handsfree =
+            ParcelUuid.fromString("0000111E-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid Handsfree_AG =
+            ParcelUuid.fromString("0000111F-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid AvrcpController =
+            ParcelUuid.fromString("0000110E-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid AvrcpTarget =
+            ParcelUuid.fromString("0000110C-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid ObexObjectPush =
+            ParcelUuid.fromString("00001105-0000-1000-8000-00805f9b34fb");
+    public static final ParcelUuid Hid =
+            ParcelUuid.fromString("00001124-0000-1000-8000-00805f9b34fb");
+    public static final ParcelUuid PANU =
+            ParcelUuid.fromString("00001115-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid NAP =
+            ParcelUuid.fromString("00001116-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid BNEP =
+            ParcelUuid.fromString("0000000f-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid PBAP_PSE =
+            ParcelUuid.fromString("0000112f-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid DirectPrinting =
+            ParcelUuid.fromString("00001118-0000-1000-8000-00805f9b34fb");
+    public static final ParcelUuid ReferencePrinting =
+            ParcelUuid.fromString("00001119-0000-1000-8000-00805f9b34fb");
+    public static final ParcelUuid PrintingStatus =
+            ParcelUuid.fromString("00001123-0000-1000-8000-00805f9b34fb");
+    public static final ParcelUuid DUN =
+            ParcelUuid.fromString("00001103-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid SAP =
+            ParcelUuid.fromString("0000112D-0000-1000-8000-00805F9B34FB");
+    public static final ParcelUuid FileTransfer =
+            ParcelUuid.fromString("00001106-0000-1000-8000-00805f9b34fb");
+    public static final ParcelUuid MessageAccessServer =
+            ParcelUuid.fromString("00001132-0000-1000-8000-00805f9b34fb");
+    public static final ParcelUuid MessageNotificationServer =
+            ParcelUuid.fromString("00001133-0000-1000-8000-00805f9b34fb");
+
+
+    public static final ParcelUuid[] RESERVED_UUIDS = {
+        AudioSink, AudioSource, AdvAudioDist, HSP, Handsfree, AvrcpController, AvrcpTarget,
+        ObexObjectPush, PANU, NAP, DirectPrinting, ReferencePrinting, PrintingStatus,
+        DUN, SAP, MessageAccessServer, MessageNotificationServer, FileTransfer};
+
+    public static boolean isAudioSource(ParcelUuid uuid) {
+        return uuid.equals(AudioSource);
+    }
+
+    public static boolean isAudioSink(ParcelUuid uuid) {
+        return uuid.equals(AudioSink);
+    }
+
+    public static boolean isAdvAudioDist(ParcelUuid uuid) {
+        return uuid.equals(AdvAudioDist);
+    }
+
+    public static boolean isHandsfree(ParcelUuid uuid) {
+        return uuid.equals(Handsfree);
+    }
+
+    public static boolean isHeadset(ParcelUuid uuid) {
+        return uuid.equals(HSP);
+    }
+
+    public static boolean isAvrcpController(ParcelUuid uuid) {
+        return uuid.equals(AvrcpController);
+    }
+
+    public static boolean isAvrcpTarget(ParcelUuid uuid) {
+        return uuid.equals(AvrcpTarget);
+    }
+
+    public static boolean isInputDevice(ParcelUuid uuid) {
+        return uuid.equals(Hid);
+    }
+
+    public static boolean isPanu(ParcelUuid uuid) {
+        return uuid.equals(PANU);
+    }
+
+    public static boolean isNap(ParcelUuid uuid) {
+        return uuid.equals(NAP);
+    }
+
+    public static boolean isBnep(ParcelUuid uuid) {
+        return uuid.equals(BNEP);
+    }
+
+    public static boolean isPrintingStatus(ParcelUuid uuid) {
+        return uuid.equals(PrintingStatus);
+    }
+
+    public static boolean isDirectPrinting(ParcelUuid uuid) {
+        return uuid.equals(DirectPrinting);
+    }
+
+    public static boolean isMessageAccessServer(ParcelUuid uuid) {
+        return uuid.equals(MessageAccessServer);
+    }
+
+    public static boolean isMessageNotificationServer(ParcelUuid uuid) {
+        return uuid.equals(MessageNotificationServer);
+    }
+
+    public static boolean isFileTransfer(ParcelUuid uuid) {
+        return uuid.equals(FileTransfer);
+    }
+
+    public static boolean isDun(ParcelUuid uuid) {
+        return uuid.equals(DUN);
+    }
+
+    public static boolean isSap(ParcelUuid uuid) {
+        return uuid.equals(SAP);
+    }
+
+    /**
+     * Returns true if ParcelUuid is present in uuidArray
+     *
+     * @param uuidArray - Array of ParcelUuids
+     * @param uuid
+     */
+    public static boolean isUuidPresent(ParcelUuid[] uuidArray, ParcelUuid uuid) {
+        if ((uuidArray == null || uuidArray.length == 0) && uuid == null)
+            return true;
+
+        if (uuidArray == null)
+            return false;
+
+        for (ParcelUuid element: uuidArray) {
+            if (element.equals(uuid)) return true;
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if there any common ParcelUuids in uuidA and uuidB.
+     *
+     * @param uuidA - List of ParcelUuids
+     * @param uuidB - List of ParcelUuids
+     *
+     */
+    public static boolean containsAnyUuid(ParcelUuid[] uuidA, ParcelUuid[] uuidB) {
+        if (uuidA == null && uuidB == null) return true;
+
+        if (uuidA == null) {
+            return uuidB.length == 0 ? true : false;
+        }
+
+        if (uuidB == null) {
+            return uuidA.length == 0 ? true : false;
+        }
+
+        HashSet<ParcelUuid> uuidSet = new HashSet<ParcelUuid> (Arrays.asList(uuidA));
+        for (ParcelUuid uuid: uuidB) {
+            if (uuidSet.contains(uuid)) return true;
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if all the ParcelUuids in ParcelUuidB are present in
+     * ParcelUuidA
+     *
+     * @param uuidA - Array of ParcelUuidsA
+     * @param uuidB - Array of ParcelUuidsB
+     *
+     */
+    public static boolean containsAllUuids(ParcelUuid[] uuidA, ParcelUuid[] uuidB) {
+        if (uuidA == null && uuidB == null) return true;
+
+        if (uuidA == null) {
+            return uuidB.length == 0 ? true : false;
+        }
+
+        if (uuidB == null) return true;
+
+        HashSet<ParcelUuid> uuidSet = new HashSet<ParcelUuid> (Arrays.asList(uuidA));
+        for (ParcelUuid uuid: uuidB) {
+            if (!uuidSet.contains(uuid)) return false;
+        }
+        return true;
+    }
+
+    /**
+     * Extract the Service Identifier or the actual uuid from the Parcel Uuid.
+     * For example, if 0000110B-0000-1000-8000-00805F9B34FB is the parcel Uuid,
+     * this function will return 110B
+     * @param parcelUuid
+     * @return the service identifier.
+     */
+    public static int getServiceIdentifierFromParcelUuid(ParcelUuid parcelUuid) {
+        UUID uuid = parcelUuid.getUuid();
+        long value = (uuid.getMostSignificantBits() & 0x0000FFFF00000000L) >>> 32;
+        return (int)value;
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/HeadsetBase.java b/bluetoothmsm/java/android/bluetooth/HeadsetBase.java
new file mode 100644
index 0000000..9ef2eb5
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/HeadsetBase.java
@@ -0,0 +1,298 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.os.Handler;
+import android.os.PowerManager;
+import android.os.PowerManager.WakeLock;
+import android.util.Log;
+
+/**
+ * The Android Bluetooth API is not finalized, and *will* change. Use at your
+ * own risk.
+ *
+ * The base RFCOMM (service) connection for a headset or handsfree device.
+ *
+ * In the future this class will be removed.
+ *
+ * @hide
+ */
+public final class HeadsetBase {
+    private static final String TAG = "Bluetooth HeadsetBase";
+    private static final boolean DBG = false;
+
+    public static final int RFCOMM_DISCONNECTED = 1;
+
+    public static final int DIRECTION_INCOMING = 1;
+    public static final int DIRECTION_OUTGOING = 2;
+
+    private static int sAtInputCount = 0;  /* TODO: Consider not using a static variable */
+
+    private final BluetoothAdapter mAdapter;
+    private final BluetoothDevice mRemoteDevice;
+    private final String mAddress;  // for native code
+    private final int mRfcommChannel;
+    private int mNativeData;
+    private Thread mEventThread;
+    private volatile boolean mEventThreadInterrupted;
+    private Handler mEventThreadHandler;
+    private int mTimeoutRemainingMs;
+    private final int mDirection;
+    private final long mConnectTimestamp;
+
+    protected AtParser mAtParser;
+
+    private WakeLock mWakeLock;  // held while processing an AT command
+
+    private native static void classInitNative();
+    static {
+        classInitNative();
+    }
+
+    protected void finalize() throws Throwable {
+        try {
+            cleanupNativeDataNative();
+            releaseWakeLock();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    private native void cleanupNativeDataNative();
+
+    public HeadsetBase(PowerManager pm, BluetoothAdapter adapter,
+                       BluetoothDevice device, int rfcommChannel) {
+        mDirection = DIRECTION_OUTGOING;
+        mConnectTimestamp = System.currentTimeMillis();
+        mAdapter = adapter;
+        mRemoteDevice = device;
+        mAddress = device.getAddress();
+        mRfcommChannel = rfcommChannel;
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "HeadsetBase");
+        mWakeLock.setReferenceCounted(false);
+        initializeAtParser();
+        // Must be called after this.mAddress is set.
+        initializeNativeDataNative(-1);
+    }
+
+    /* Create from an existing rfcomm connection */
+    public HeadsetBase(PowerManager pm, BluetoothAdapter adapter,
+                       BluetoothDevice device,
+                       int socketFd, int rfcommChannel, Handler handler) {
+        mDirection = DIRECTION_INCOMING;
+        mConnectTimestamp = System.currentTimeMillis();
+        mAdapter = adapter;
+        mRemoteDevice = device;
+        mAddress = device.getAddress();
+        mRfcommChannel = rfcommChannel;
+        mEventThreadHandler = handler;
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "HeadsetBase");
+        mWakeLock.setReferenceCounted(false);
+        initializeAtParser();
+        // Must be called after this.mAddress is set.
+        initializeNativeDataNative(socketFd);
+    }
+
+    private native void initializeNativeDataNative(int socketFd);
+
+    /* Process an incoming AT command line
+     */
+    protected void handleInput(String input) {
+        acquireWakeLock();
+        long timestamp;
+
+        synchronized(HeadsetBase.class) {
+            if (sAtInputCount == Integer.MAX_VALUE) {
+                sAtInputCount = 0;
+            } else {
+                sAtInputCount++;
+            }
+        }
+
+        if (DBG) timestamp = System.currentTimeMillis();
+        AtCommandResult result = mAtParser.process(input);
+        if (DBG) Log.d(TAG, "Processing " + input + " took " +
+                       (System.currentTimeMillis() - timestamp) + " ms");
+
+        if (result.getResultCode() == AtCommandResult.ERROR) {
+            Log.i(TAG, "Error processing <" + input + ">");
+        }
+
+        sendURC(result.toString());
+
+        releaseWakeLock();
+    }
+
+    /**
+     * Register AT commands that are common to all Headset / Handsets. This
+     * function is called by the HeadsetBase constructor.
+     */
+    protected void initializeAtParser() {
+        mAtParser = new AtParser();
+
+        //TODO(): Get rid of this as there are no parsers registered. But because of dependencies
+        // it needs to be done as part of refactoring HeadsetBase and BluetoothHandsfree
+    }
+
+    public AtParser getAtParser() {
+        return mAtParser;
+    }
+
+    public void startEventThread() {
+        mEventThread =
+            new Thread("HeadsetBase Event Thread") {
+                public void run() {
+                    int last_read_error;
+                    while (!mEventThreadInterrupted) {
+                        String input = readNative(500);
+                        if (input != null) {
+                            handleInput(input);
+                        } else {
+                            last_read_error = getLastReadStatusNative();
+                            if (last_read_error != 0) {
+                                Log.i(TAG, "headset read error " + last_read_error);
+                                if (mEventThreadHandler != null) {
+                                    mEventThreadHandler.obtainMessage(RFCOMM_DISCONNECTED)
+                                            .sendToTarget();
+                                }
+                                disconnectNative();
+                                break;
+                            }
+                        }
+                    }
+                }
+            };
+        mEventThreadInterrupted = false;
+        mEventThread.start();
+    }
+
+    private native String readNative(int timeout_ms);
+    private native int getLastReadStatusNative();
+
+    private void stopEventThread() {
+        mEventThreadInterrupted = true;
+        mEventThread.interrupt();
+        try {
+            mEventThread.join();
+        } catch (java.lang.InterruptedException e) {
+            // FIXME: handle this,
+        }
+        mEventThread = null;
+    }
+
+    public boolean connect(Handler handler) {
+        if (mEventThread == null) {
+            if (!connectNative()) return false;
+            mEventThreadHandler = handler;
+        }
+        return true;
+    }
+    private native boolean connectNative();
+
+    /*
+     * Returns true when either the asynchronous connect is in progress, or
+     * the connect is complete.  Call waitForAsyncConnect() to find out whether
+     * the connect is actually complete, or disconnect() to cancel.
+     */
+
+    public boolean connectAsync() {
+        int ret = connectAsyncNative();
+        return (ret == 0) ? true : false;
+    }
+    private native int connectAsyncNative();
+
+    public int getRemainingAsyncConnectWaitingTimeMs() {
+        return mTimeoutRemainingMs;
+    }
+
+    /*
+     * Returns 1 when an async connect is complete, 0 on timeout, and -1 on
+     * error.  On error, handler will be called, and you need to re-initiate
+     * the async connect.
+     */
+    public int waitForAsyncConnect(int timeout_ms, Handler handler) {
+        int res = waitForAsyncConnectNative(timeout_ms);
+        if (res > 0) {
+            mEventThreadHandler = handler;
+        }
+        return res;
+    }
+    private native int waitForAsyncConnectNative(int timeout_ms);
+
+    public void disconnect() {
+        if (mEventThread != null) {
+            stopEventThread();
+        }
+        disconnectNative();
+    }
+    private native void disconnectNative();
+
+
+    /*
+     * Note that if a remote side disconnects, this method will still return
+     * true until disconnect() is called.  You know when a remote side
+     * disconnects because you will receive the intent
+     * IBluetoothService.REMOTE_DEVICE_DISCONNECTED_ACTION.  If, when you get
+     * this intent, method isConnected() returns true, you know that the
+     * disconnect was initiated by the remote device.
+     */
+
+    public boolean isConnected() {
+        return mEventThread != null;
+    }
+
+    public BluetoothDevice getRemoteDevice() {
+        return mRemoteDevice;
+    }
+
+    public int getDirection() {
+        return mDirection;
+    }
+
+    public long getConnectTimestamp() {
+        return mConnectTimestamp;
+    }
+
+    public synchronized boolean sendURC(String urc) {
+        if (urc.length() > 0) {
+            boolean ret = sendURCNative(urc);
+            return ret;
+        }
+        return true;
+    }
+    private native boolean sendURCNative(String urc);
+
+    private synchronized void acquireWakeLock() {
+        if (!mWakeLock.isHeld()) {
+            mWakeLock.acquire();
+        }
+    }
+
+    private synchronized void releaseWakeLock() {
+        if (mWakeLock.isHeld()) {
+            mWakeLock.release();
+        }
+    }
+
+    public static int getAtInputCount() {
+        return sAtInputCount;
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetooth.aidl b/bluetoothmsm/java/android/bluetooth/IBluetooth.aidl
new file mode 100644
index 0000000..c2a1c9d
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetooth.aidl
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2008, The Android Open Source Project
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.bluetooth.IBluetoothCallback;
+import android.bluetooth.IBluetoothStateChangeCallback;
+import android.bluetooth.IBluetoothHealthCallback;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHealthAppConfiguration;
+import android.os.ParcelUuid;
+import android.os.ParcelFileDescriptor;
+import android.bluetooth.IBluetoothGattService;
+import  android.bluetooth.IBluetoothGattCallback;
+import android.bluetooth.BluetoothGattAppConfiguration;
+import android.bluetooth.IBluetoothPreferredDeviceListCallback;
+
+/**
+ * System private API for talking with the Bluetooth service.
+ *
+ * {@hide}
+ */
+interface IBluetooth
+{
+    boolean isEnabled();
+    boolean isServiceRegistered(in ParcelUuid uuid);
+    boolean registerService(in ParcelUuid uuid, boolean enable);
+
+    int getBluetoothState();
+    boolean enable();
+    boolean enableNoAutoConnect();
+    boolean disable(boolean persistSetting);
+
+    String getAddress();
+    String getName();
+    String getCOD();
+    boolean setName(in String name);
+    ParcelUuid[] getUuids();
+
+    int getScanMode();
+    boolean setScanMode(int mode, int duration);
+
+    int getDiscoverableTimeout();
+    boolean setDiscoverableTimeout(int timeout);
+
+    boolean startDiscovery();
+    boolean cancelDiscovery();
+    boolean isDiscovering();
+    byte[] readOutOfBandData();
+
+    int getAdapterConnectionState();
+    int getProfileConnectionState(int profile);
+    boolean changeApplicationBluetoothState(boolean on,
+                                in IBluetoothStateChangeCallback callback, in
+                                IBinder b);
+
+    boolean createBond(in String address);
+    boolean createBondOutOfBand(in String address, in byte[] hash, in byte[] randomizer);
+    boolean cancelBondProcess(in String address);
+    boolean removeBond(in String address);
+    String[] listBonds();
+    int getBondState(in String address);
+    boolean setDeviceOutOfBandData(in String address, in byte[] hash, in byte[] randomizer);
+    boolean setBluetoothClass(String address, int classOfDevice);
+    boolean registerRssiUpdateWatcher(in String address, in int rssiThreshold, in int interval,
+                                      in boolean updateOnThreshExceed);
+    boolean unregisterRssiUpdateWatcher(in String address);
+    boolean setLEConnectionParams(in String address, in byte prohibitRemoteChg, in byte filterPolicy,
+    in int scanInterval, in int scanWindow, in int intervalMin, in int intervalMax, in int latency,
+    in int superVisionTimeout, in int minCeLen, in int maxCeLen, in int connTimeOut);
+    boolean updateLEConnectionParams(in String address, in byte prohibitRemoteChg,
+    in int intervalMin, in int intervalMax, in int slaveLatency, in int supervisionTimeout);
+    String getRemoteName(in String address);
+    String getRemoteAlias(in String address);
+    boolean setRemoteAlias(in String address, in String name);
+    int getRemoteClass(in String address);
+    ParcelUuid[] getRemoteUuids(in String address);
+    boolean fetchRemoteUuids(in String address, in ParcelUuid uuid, in IBluetoothCallback callback);
+    int getRemoteServiceChannel(in String address, in ParcelUuid uuid);
+    int getRemoteL2capPsm(in String address, in ParcelUuid uuid);
+    String getRemoteFeature(String address, String feature);
+    boolean setPin(in String address, in byte[] pin);
+    boolean setPasskey(in String address, int passkey);
+    boolean setPairingConfirmation(in String address, boolean confirm);
+    boolean setRemoteOutOfBandData(in String addres);
+    boolean cancelPairingUserInput(in String address);
+
+    boolean setTrust(in String address, in boolean value);
+    boolean getTrustState(in String address);
+    boolean isBluetoothDock(in String address);
+
+    int addRfcommServiceRecord(in String serviceName, in ParcelUuid uuid, int channel, IBinder b);
+    void removeServiceRecord(int handle);
+    boolean allowIncomingProfileConnect(in BluetoothDevice device, boolean value);
+
+    boolean connectHeadset(String address);
+    boolean disconnectHeadset(String address);
+    boolean notifyIncomingConnection(String address, boolean rejected);
+
+    // HID profile APIs
+    boolean connectInputDevice(in BluetoothDevice device);
+    boolean disconnectInputDevice(in BluetoothDevice device);
+    List<BluetoothDevice> getConnectedInputDevices();
+    List<BluetoothDevice> getInputDevicesMatchingConnectionStates(in int[] states);
+    int getInputDeviceConnectionState(in BluetoothDevice device);
+    boolean setInputDevicePriority(in BluetoothDevice device, int priority);
+    int getInputDevicePriority(in BluetoothDevice device);
+
+    boolean isTetheringOn();
+    void setBluetoothTethering(boolean value);
+    int getPanDeviceConnectionState(in BluetoothDevice device);
+    List<BluetoothDevice> getConnectedPanDevices();
+    List<BluetoothDevice> getPanDevicesMatchingConnectionStates(in int[] states);
+    boolean connectPanDevice(in BluetoothDevice device);
+    boolean disconnectPanDevice(in BluetoothDevice device);
+
+    // HDP profile APIs
+    boolean registerAppConfiguration(in BluetoothHealthAppConfiguration config,
+        in IBluetoothHealthCallback callback);
+    boolean unregisterAppConfiguration(in BluetoothHealthAppConfiguration config);
+    boolean connectChannelToSource(in BluetoothDevice device, in BluetoothHealthAppConfiguration config);
+    boolean connectChannelToSink(in BluetoothDevice device, in BluetoothHealthAppConfiguration config,
+        int channelType);
+    boolean disconnectChannel(in BluetoothDevice device, in BluetoothHealthAppConfiguration config, int id);
+    ParcelFileDescriptor getMainChannelFd(in BluetoothDevice device, in BluetoothHealthAppConfiguration config);
+    List<BluetoothDevice> getConnectedHealthDevices();
+    List<BluetoothDevice> getHealthDevicesMatchingConnectionStates(in int[] states);
+    int getHealthDeviceConnectionState(in BluetoothDevice device);
+
+    void sendConnectionStateChange(in BluetoothDevice device, int profile, int state, int prevState);
+    int registerEl2capConnection(in IBluetoothCallback callback, in int ampPolicy);
+    void deregisterEl2capConnection(in int handle);
+    int getEffectiveAmpPolicy(in int policy);
+    boolean setDesiredAmpPolicy(in int handle, in int policy);
+    void setUseWifiForBtTransfers(in boolean useWifi);
+
+    // GATT client APIs
+    boolean getGattServices(in String address, in ParcelUuid uuid);
+    int gattConnect(in String address, in String path, in byte prohibitRemoteChg, in byte filterPolicy,
+     in int scanInterval, in int scanWindow, in int intervalMin, in int intervalMax, in int latency,
+     in int superVisionTimeout, in int minCeLen, in int maxCeLen, in int connTimeOut);
+    boolean gattConnectCancel(in String address, in String path);
+    String getGattServiceName(in String path);
+    boolean discoverCharacteristics(in String path, in int serviceId);
+    String getGattServiceProperty(in String path, in String property);
+    String[] getCharacteristicProperties(in String path);
+    boolean setCharacteristicProperty(in String path, in String key, in byte[] value,
+        boolean reliable, in int serviceId);
+    boolean registerCharacteristicsWatcher(in String path, in IBluetoothGattService gattCallback,
+    in int serviceId);
+    boolean updateCharacteristicValue(in String path, in int serviceId);
+    boolean deregisterCharacteristicsWatcher(in String path, in int serviceId);
+    int startRemoteGattService(in String path, in IBluetoothGattService gattCallback);
+    void closeRemoteGattService(in String path, in int serviceId);
+
+    // GATT server APIs
+    boolean registerGattAppConfiguration(in BluetoothGattAppConfiguration config,
+                                         in IBluetoothGattCallback callback);
+    boolean unregisterGattAppConfiguration(in BluetoothGattAppConfiguration config);
+    boolean closeGattLeConnection(in BluetoothGattAppConfiguration config, String address);
+    boolean sendIndication(in BluetoothGattAppConfiguration config,
+                           in int handle, in byte[] value, in boolean notify, in int sessionHandle);
+    boolean discoverPrimaryResponse(in BluetoothGattAppConfiguration config, in ParcelUuid uuid,
+                        in int handle, in int end, in int status, in int reqHandle);
+    boolean discoverPrimaryByUuidResponse(in BluetoothGattAppConfiguration config,
+                        in int handle, in int end, in int status, in int reqHandle);
+    boolean findIncludedResponse(in BluetoothGattAppConfiguration config, in ParcelUuid uuid,
+                        in int handle, in int start, in int end, in int status, in int reqHandle);
+    boolean discoverCharacteristicResponse(in BluetoothGattAppConfiguration config, in ParcelUuid uuid,
+                        in int handle, in byte property, in int valueHandle, in int status, in int reqHandle);
+    boolean findInfoResponse(in BluetoothGattAppConfiguration config, in ParcelUuid uuid,
+                        in int handle, in int status, in int reqHandle);
+    boolean readByTypeResponse(in BluetoothGattAppConfiguration config, in int handle, in ParcelUuid uuid,
+                        in byte[] payload, in int status, in int reqHandle);
+    boolean readResponse(in BluetoothGattAppConfiguration config, in ParcelUuid uuid,
+                        in byte[] payload, in int status, in int reqHandle);
+    boolean writeResponse(in BluetoothGattAppConfiguration config, in ParcelUuid uuid,
+                        in int status, in int reqHandle);
+    void disconnectSap();
+    boolean isHostPatchRequired(in BluetoothDevice btDevice, in int patch_id);
+    void disconnectDUN();
+    boolean disableDUN();
+    boolean enableDUN();
+    // WhiteList APIs
+    boolean addToPreferredDeviceList(in String address, in IBluetoothPreferredDeviceListCallback pListCallBack);
+    boolean removeFromPreferredDeviceList(in String address, in IBluetoothPreferredDeviceListCallback pListCallBack);
+    boolean clearPreferredDeviceList(in IBluetoothPreferredDeviceListCallback pListCallBack);
+    boolean gattConnectToPreferredDeviceList(in IBluetoothPreferredDeviceListCallback pListCallBack);
+    boolean gattCancelConnectToPreferredDeviceList(in IBluetoothPreferredDeviceListCallback pListCallBack);
+    boolean addToPreferredDeviceListWrapper(in BluetoothDevice btDevObj, in IBluetoothPreferredDeviceListCallback pListCallBack,
+            in String caller);
+    boolean gattCancelConnectToPreferredDeviceListWrapper(in IBluetoothPreferredDeviceListCallback pListCallBack,
+            in BluetoothDevice btDevice, in String caller);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothA2dp.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothA2dp.aidl
new file mode 100644
index 0000000..444dd1e
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothA2dp.aidl
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.bluetooth.BluetoothDevice;
+
+/**
+ * APIs for Bluetooth A2DP service
+ *
+ * @hide
+ */
+interface IBluetoothA2dp {
+    // Public API
+    boolean connect(in BluetoothDevice device);
+    boolean disconnect(in BluetoothDevice device);
+    List<BluetoothDevice> getConnectedDevices();
+    List<BluetoothDevice> getDevicesMatchingConnectionStates(in int[] states);
+    int getConnectionState(in BluetoothDevice device);
+    boolean setPriority(in BluetoothDevice device, int priority);
+    int getPriority(in BluetoothDevice device);
+    boolean isA2dpPlaying(in BluetoothDevice device);
+
+    // Internal APIs
+    boolean suspendSink(in BluetoothDevice device);
+    boolean resumeSink(in BluetoothDevice device);
+    boolean connectSinkInternal(in BluetoothDevice device);
+    boolean disconnectSinkInternal(in BluetoothDevice device);
+    boolean allowIncomingConnect(in BluetoothDevice device, boolean value);
+
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothCallback.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothCallback.aidl
new file mode 100644
index 0000000..01c90cb
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothCallback.aidl
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2009, The Android Open Source Project
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+/**
+ * System private API for Bluetooth service callbacks.
+ *
+ * {@hide}
+ */
+interface IBluetoothCallback
+{
+    void onRfcommChannelFound(int channel);
+    void onAmpPolicyChange(int newAmpPolicy);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothGattCallback.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothGattCallback.aidl
new file mode 100644
index 0000000..8c17095
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothGattCallback.aidl
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.bluetooth;
+
+import android.bluetooth.BluetoothGattAppConfiguration;
+import android.os.ParcelUuid;
+
+/**
+ *@hide
+ */
+interface IBluetoothGattCallback
+{
+    void onGattAppConfigurationStatusChange(in BluetoothGattAppConfiguration config, in int status);
+    void onGattActionComplete(in BluetoothGattAppConfiguration config, in String action, in int status);
+    void onGattDiscoverPrimaryServiceRequest(in BluetoothGattAppConfiguration config,
+                                             in int start, in int end, in int requestHandle);
+    void onGattDiscoverPrimaryServiceByUuidRequest(in BluetoothGattAppConfiguration config,
+                                                   in int start, in int end, in ParcelUuid uuid, in int requestHandle);
+    void onGattFindIncludedServiceRequest(in BluetoothGattAppConfiguration config,
+                                          in int start, in int end, in int requestHandle);
+    void onGattFindInfoRequest(in BluetoothGattAppConfiguration config,
+                               in int start, in int end, in int requestHandle);
+    void onGattDiscoverCharacteristicRequest(in BluetoothGattAppConfiguration config,
+                                             in int start, in int end, in int requestHandle);
+    void onGattReadByTypeRequest(in BluetoothGattAppConfiguration config,
+                                 in ParcelUuid uuid, in int start, in int end, in String authentication, in int requestHandle);
+    void onGattReadRequest(in BluetoothGattAppConfiguration config,
+                           in int handle, in String authentication, in int requestHandle);
+    void onGattWriteCommand(in BluetoothGattAppConfiguration config, in int handle, in byte[] value,
+                            in String authentication);
+    void onGattWriteRequest(in BluetoothGattAppConfiguration config, in int handle, in byte[] value,
+                            in String authentication, in int sessionHandle, in int requestHandle);
+    void onGattSetClientConfigDescriptor(in BluetoothGattAppConfiguration config, in int handle, in byte[] value,
+                                     in int sessionHandle);
+    void onGattIndicateResponse(in BluetoothGattAppConfiguration config, in boolean result);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothGattProfile.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothGattProfile.aidl
new file mode 100644
index 0000000..812fedf
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothGattProfile.aidl
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+/**
+ * System private API for Bluetooth GATT service
+ *
+ * {@hide}
+ */
+interface IBluetoothGattProfile {
+    void onDiscoverCharacteristicsResult(in String path, in boolean result);
+    void onSetCharacteristicValueResult(in String path, in boolean result);
+    void onSetCharacteristicCliConfResult(in String path, in boolean result);
+    void onUpdateCharacteristicValueResult(in String path, in boolean result);
+    void onValueChanged(in String path, in String value);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothGattService.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothGattService.aidl
new file mode 100644
index 0000000..c4cd872
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothGattService.aidl
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+/**
+ * System private API for Bluetooth GATT service
+ *
+ * {@hide}
+ */
+interface IBluetoothGattService {
+    void onCharacteristicsDiscovered(in String[] paths, in boolean result);
+    void onSetCharacteristicProperty(in String path, in String property, in boolean result);
+    void onValueChanged(in String path, in String value);
+    void onCharacteristicValueUpdated(in String path, in boolean result);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothHeadset.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothHeadset.aidl
new file mode 100644
index 0000000..e90d926
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothHeadset.aidl
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2013 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.bluetooth.BluetoothDevice;
+
+/**
+ * API for Bluetooth Headset service
+ *
+ * {@hide}
+ */
+interface IBluetoothHeadset {
+    // Public API
+    boolean connect(in BluetoothDevice device);
+    boolean disconnect(in BluetoothDevice device);
+    List<BluetoothDevice> getConnectedDevices();
+    List<BluetoothDevice> getDevicesMatchingConnectionStates(in int[] states);
+    int getConnectionState(in BluetoothDevice device);
+    boolean setPriority(in BluetoothDevice device, int priority);
+    int getPriority(in BluetoothDevice device);
+    boolean startVoiceRecognition(in BluetoothDevice device);
+    boolean stopVoiceRecognition(in BluetoothDevice device);
+    boolean isAudioConnected(in BluetoothDevice device);
+    boolean isBluetoothVoiceDialingEnabled(in BluetoothDevice device);
+
+    // APIs that can be made public in future
+    int getBatteryUsageHint(in BluetoothDevice device);
+
+    // Internal functions, not be made public
+    boolean createIncomingConnect(in BluetoothDevice device);
+    boolean acceptIncomingConnect(in BluetoothDevice device);
+    boolean rejectIncomingConnect(in BluetoothDevice device);
+    boolean cancelConnectThread();
+    boolean connectHeadsetInternal(in BluetoothDevice device);
+    boolean disconnectHeadsetInternal(in BluetoothDevice device);
+    boolean setAudioState(in BluetoothDevice device, int state);
+    int getAudioState(in BluetoothDevice device);
+    boolean isAudioOn();
+    boolean connectAudio();
+    boolean disconnectAudio();
+    void phoneStateChanged(int numActive, int numHeld, int callState, String number, int type);
+    void roamChanged(boolean roam);
+    void clccResponse(int index, int direction, int status, int mode, boolean mpty, String number, int type);
+    boolean startScoUsingVirtualVoiceCall(in BluetoothDevice device);
+    boolean stopScoUsingVirtualVoiceCall(in BluetoothDevice device);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothHeadsetPhone.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothHeadsetPhone.aidl
new file mode 100644
index 0000000..d5e64f6
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothHeadsetPhone.aidl
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+/**
+ * API for Bluetooth Headset Phone Service in phone app
+ *
+ * {@hide}
+ */
+interface IBluetoothHeadsetPhone {
+  // Internal functions, not be made public
+  boolean answerCall();
+  boolean hangupCall();
+  boolean sendDtmf(int dtmf);
+  boolean processChld(int chld);
+  String getNetworkOperator();
+  String getSubscriberNumber();
+  boolean listCurrentCalls();
+  boolean queryPhoneState();
+
+  // Internal for phone app to call
+  void updateBtHandsfreeAfterRadioTechnologyChange();
+  void cdmaSwapSecondCallState();
+  void cdmaSetSecondCallState(boolean state);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothHealthCallback.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothHealthCallback.aidl
new file mode 100644
index 0000000..0ace9fe
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothHealthCallback.aidl
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2011, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHealthAppConfiguration;
+import android.os.ParcelFileDescriptor;
+
+/**
+ *@hide
+ */
+interface IBluetoothHealthCallback
+{
+    void onHealthAppConfigurationStatusChange(in BluetoothHealthAppConfiguration config, int status);
+    void onHealthChannelStateChange(in BluetoothHealthAppConfiguration config,
+        in BluetoothDevice device, int prevState, int newState, in
+        ParcelFileDescriptor fd, int id);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothLEFindMeServices.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothLEFindMeServices.aidl
new file mode 100644
index 0000000..4c18d0b
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothLEFindMeServices.aidl
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Linux Foundation nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.bluetooth;
+
+import android.os.ParcelUuid;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.IBluetoothThermometerCallBack;
+
+/**
+ * System private API for Bluetooth LE FindMe service
+ *
+ * {@hide}
+ */
+interface IBluetoothLEFindMeServices {
+    boolean startFindMeService(in BluetoothDevice btDevice,
+                               in ParcelUuid serviceUuid,
+                               in IBluetoothThermometerCallBack callBack);
+    boolean writeCharacteristicsValue(in ParcelUuid charUuuid,
+                                      in ParcelUuid srvUuid, in String value);
+    boolean closeFindMeService(in ParcelUuid serviceUuid);
+    boolean gattConnectCancel();
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothLEProximityServices.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothLEProximityServices.aidl
new file mode 100644
index 0000000..237c0f1
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothLEProximityServices.aidl
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.bluetooth;
+
+import android.os.ParcelUuid;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.IBluetoothThermometerCallBack;
+
+/**
+ * System private API for Bluetooth LE proximity service
+ *
+ * {@hide}
+ */
+interface IBluetoothLEProximityServices {
+    boolean startProximityService(in BluetoothDevice btDevice,
+                                  in ParcelUuid serviceUuid,
+                                  in IBluetoothThermometerCallBack callBack);
+    /** The value is available through the IBluetoothThermometerCallBack */
+    void readCharacteristicsValue(in ParcelUuid charUuid,
+                                  in ParcelUuid srvUuid);
+    boolean writeCharacteristicsValue(in ParcelUuid charUuuid,
+                                      in ParcelUuid srvUuid, in String value);
+    void registerRssiUpdates(in BluetoothDevice btDevice, in int rssiThresh,
+                             in int interval);
+    void unregisterRssiUpdates(in BluetoothDevice btDevice);
+    boolean closeProximityService(in BluetoothDevice btDevice, in ParcelUuid serviceUuid);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothManager.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothManager.aidl
new file mode 100644
index 0000000..af13615
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothManager.aidl
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (c) 2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+/**
+ * System private API for talking with the Bluetooth service.
+ *
+ * {@hide}
+ */
+interface IBluetoothManager
+{
+    boolean isEnabled();
+    boolean disable(boolean saveSetting);
+    boolean enableNoAutoConnect();
+    String getAddress();
+    String getName();
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothPbap.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothPbap.aidl
new file mode 100644
index 0000000..7cc77d1
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothPbap.aidl
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.bluetooth.BluetoothDevice;
+
+/**
+ * System private API for Bluetooth pbap service
+ *
+ * {@hide}
+ */
+interface IBluetoothPbap {
+    int getState();
+    BluetoothDevice getClient();
+    boolean connect(in BluetoothDevice device);
+    void disconnect();
+    boolean isConnected(in BluetoothDevice device);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothPreferredDeviceListCallback.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothPreferredDeviceListCallback.aidl
new file mode 100644
index 0000000..dce4fba
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothPreferredDeviceListCallback.aidl
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.bluetooth;
+
+/**
+ *@hide
+ */
+interface IBluetoothPreferredDeviceListCallback
+{
+    //WhiteList APIs
+    void onAddDeviceToPreferredList(in int result);
+    void onRemoveDeviceFromPreferredList(in int result);
+    void onClearPreferredDeviceList(in int result);
+    void onGattConnectToPreferredDeviceList(in int result);
+    void onGattCancelConnectToPreferredDeviceList(in int result);
+    void onGattAutoConnect(in int result);
+    void onGattAutoConnectCancel(in int result);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothStateChangeCallback.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothStateChangeCallback.aidl
new file mode 100644
index 0000000..feccdce
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothStateChangeCallback.aidl
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2011, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+/**
+ * System private API for Bluetooth state change callback.
+ *
+ * {@hide}
+ */
+interface IBluetoothStateChangeCallback
+{
+    void onBluetoothStateChange(boolean on);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothThermometerCallBack.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothThermometerCallBack.aidl
new file mode 100644
index 0000000..c04c0c5
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothThermometerCallBack.aidl
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.bluetooth;
+
+import android.os.Bundle;
+
+/**
+ *@hide
+ */
+oneway interface IBluetoothThermometerCallBack {
+    /**
+    * Call from Thermometer service on operation status and value changed
+    * This callback contains below data:
+    * - {#THERMOMETER_SERVICE_CHAR_UUID} (ParcelUuid):
+    * - {#THERMOMETER_SERVICE_OPERATION} (String): operation(read, write,
+    *                              set configuration, notify
+    * - {#THERMOMETER_SERVICE_OP_STATUS} (boolean): operation success or fail
+    * - {#THERMOMETER_SERVICE_OP_VALUE} (ArrayList<string>): operation
+    *                              result. can be more than one value. e.g,
+    *                              temperature measurement has value, date and
+    *                              temperature type.
+    */
+    void sendResult(in Bundle value);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/IBluetoothThermometerServices.aidl b/bluetoothmsm/java/android/bluetooth/IBluetoothThermometerServices.aidl
new file mode 100644
index 0000000..7b340f3
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/IBluetoothThermometerServices.aidl
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.bluetooth;
+
+import android.os.ParcelUuid;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.IBluetoothThermometerCallBack;
+
+/**
+ *@hide
+ */
+interface IBluetoothThermometerServices {
+    boolean startThermometerService(in BluetoothDevice btDevice, in ParcelUuid serviceUuid, in IBluetoothThermometerCallBack callBack);
+    String getServiceName(in ParcelUuid serviceUuid);
+    /** The value is available through the IBluetoothThermometerCallBack */
+    void readCharacteristicsValue(in ParcelUuid charUuid);
+    int readClientCharConf(in ParcelUuid charUuid);
+    /** The date value should be in java ISO format string "yyyy-MM-dd HH:mm:ss" */
+    boolean writeCharacteristicsValue(in ParcelUuid charUuuid, String value);
+    boolean notifyIndicateValue(in ParcelUuid charUuid);
+    boolean clearNotifyIndicate(in ParcelUuid charUuid);
+    boolean closeThermometerService(in BluetoothDevice btDevice, in ParcelUuid serviceUuid);
+}
diff --git a/bluetoothmsm/java/android/bluetooth/package.html b/bluetoothmsm/java/android/bluetooth/package.html
new file mode 100644
index 0000000..ba75034
--- /dev/null
+++ b/bluetoothmsm/java/android/bluetooth/package.html
@@ -0,0 +1,31 @@
+<HTML>
+<BODY>
+<p>Provides classes that manage Bluetooth functionality, such as scanning for
+devices, connecting with devices, and managing data transfer between devices.</p>
+
+<p>For more information, see the
+<a href="{@docRoot}guide/topics/connectivity/bluetooth.html">Bluetooth</a> guide.</p>
+{@more}
+
+<p>The Bluetooth APIs let applications:</p>
+<ul>
+  <li>Scan for other Bluetooth devices</li>
+  <li>Query the local Bluetooth adapter for paired Bluetooth devices</li>
+  <li>Establish RFCOMM channels/sockets</li>
+  <li>Connect to specified sockets on other devices</li>
+  <li>Transfer data to and from other devices</li>
+</ul>
+
+<p>
+To perform Bluetooth communication using these APIs, an application must
+declare the {@link android.Manifest.permission#BLUETOOTH} permission. Some
+additional functionality, such as requesting device discovery,
+also requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+permission.
+</p>
+
+<p class="note"><strong>Note:</strong>
+Not all Android-powered devices provide Bluetooth functionality.</p>
+
+</BODY>
+</HTML>
diff --git a/bluetoothmsm/java/android/server/BluetoothA2dpService.java b/bluetoothmsm/java/android/server/BluetoothA2dpService.java
new file mode 100755
index 0000000..949b19d
--- /dev/null
+++ b/bluetoothmsm/java/android/server/BluetoothA2dpService.java
@@ -0,0 +1,1444 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * TODO: Move this to services.jar
+ * and make the constructor package private again.
+ * @hide
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothUuid;
+import android.media.Metadata;
+import android.media.MediaPlayer;
+import android.bluetooth.IBluetoothA2dp;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.media.AudioManager;
+import android.os.Handler;
+import android.os.Message;
+import android.os.ParcelUuid;
+import android.os.PowerManager;
+import android.os.PowerManager.WakeLock;
+import android.provider.Settings;
+import android.util.Log;
+import android.net.Uri;
+import android.telephony.TelephonyManager;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.ArrayList;
+
+import android.database.Cursor;
+import android.provider.MediaStore;
+import android.media.MediaMetadataRetriever;
+
+
+public class BluetoothA2dpService extends IBluetoothA2dp.Stub {
+    private static final String TAG = "BluetoothA2dpService";
+    private static final boolean DBG = true;
+
+    public static final String BLUETOOTH_A2DP_SERVICE = "bluetooth_a2dp";
+
+    private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
+    private static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
+
+    private static final String BLUETOOTH_ENABLED = "bluetooth_enabled";
+
+    private static final String PROPERTY_STATE = "State";
+
+    private final Context mContext;
+    private final IntentFilter mIntentFilter;
+    private HashMap<BluetoothDevice, Integer> mAudioDevices;
+    private final AudioManager mAudioManager;
+    private final BluetoothService mBluetoothService;
+    private final BluetoothAdapter mAdapter;
+    private int   mTargetA2dpState;
+    private BluetoothDevice mPlayingA2dpDevice;
+    private IntentBroadcastHandler mIntentBroadcastHandler;
+    private final WakeLock mWakeLock;
+
+    private static final int MSG_CONNECTION_STATE_CHANGED = 0;
+    private boolean mIsMusicAppPlaying = false;
+
+    /* AVRCP1.3 Metadata variables */
+    private String mTrackName = DEFAULT_METADATA_STRING;
+    private String mArtistName = DEFAULT_METADATA_STRING;
+    private String mAlbumName = DEFAULT_METADATA_STRING;
+    private String mMediaNumber = DEFAULT_METADATA_NUMBER;
+    private String mMediaCount = DEFAULT_METADATA_NUMBER;
+    private String mDuration = DEFAULT_METADATA_NUMBER;
+    private String mGenre = DEFAULT_METADATA_STRING;
+    private Long mReportTime = System.currentTimeMillis();
+    private Uri mUri = null;
+    private int mPlayStatus = STATUS_STOPPED;
+    private long mPosition = (long)Long.valueOf(DEFAULT_METADATA_NUMBER);
+
+    /* AVRCP1.3 Events */
+    private final static int EVENT_PLAYSTATUS_CHANGED = 0x1;
+    private final static int EVENT_TRACK_CHANGED = 0x2;
+
+    /*AVRCP 1.3 Music App Intents */
+    private static final String PLAYSTATE_CHANGED = "com.android.music.playstatechanged";
+    private static final String META_CHANGED = "com.android.music.metachanged";
+    private static final String PLAYSTATUS_REQUEST = "com.qualcomm.music.playstatusrequest";
+    private static final String PLAYSTATUS_RESPONSE = "com.qualcomm.music.playstatusresponse";
+
+    private final static String DEFAULT_METADATA_STRING = "Unknown";
+    private final static String DEFAULT_METADATA_NUMBER = "0";
+
+    /* AVRCP 1.3 PlayStatus */
+    private final static int STATUS_STOPPED = 0X00;
+    private final static int STATUS_PLAYING = 0X01;
+    private final static int STATUS_PAUSED = 0X02;
+    private final static int STATUS_FWD_SEEK = 0X03;
+    private final static int STATUS_REV_SEEK = 0X04;
+    private final static int STATUS_ERROR = 0XFF;
+    private String mPlayStatusRequestPath = "/";
+
+    private final static int MESSAGE_PLAYSTATUS_TIMEOUT = 1;
+    private final static int MESSAGE_PLAYERSETTINGS_TIMEOUT = 2;
+
+    private String[] mCursorCols = new String[] {
+            MediaStore.Audio.Media._ID,
+            MediaStore.Audio.Media.ARTIST,
+            MediaStore.Audio.Media.ALBUM,
+            MediaStore.Audio.Media.TITLE,
+    };
+
+    TelephonyManager tmgr;
+    private static final String ACTION_METADATA_CHANGED  =
+        "com.qualcomm.MediaPlayer.action.METADATA_CHANGED";
+
+    private static final String PLAYERSETTINGS_REQUEST = "com.qualcomm.music.playersettingsrequest";
+    private static final String PLAYERSETTINGS_RESPONSE =
+        "com.qualcomm.music.playersettingsresponse";
+
+    private class PlayerSettings {
+        public byte attr;
+        public byte [] attrIds;
+        public String path;
+    };
+
+    private PlayerSettings mPlayerSettings = new PlayerSettings();
+    private class localPlayerSettings {
+        public byte eq_value;
+        public byte repeat_value;
+        public byte shuffle_value;
+        public byte scan_value;
+    };
+    private localPlayerSettings settingValues = new localPlayerSettings();
+    private static final String COMMAND = "command";
+    private static final String CMDGET = "get";
+    private static final String CMDSET = "set";
+    private static final String EXTRA_GET_COMMAND = "commandExtra";
+    private static final String EXTRA_GET_RESPONSE = "Response";
+
+    private static final int GET_ATTRIBUTE_IDS = 0;
+    private static final int GET_VALUE_IDS = 1;
+    private static final int GET_ATTRIBUTE_TEXT = 2;
+    private static final int GET_VALUE_TEXT     = 3;
+    private static final int GET_ATTRIBUTE_VALUES = 4;
+    private static final int NOTIFY_ATTRIBUTE_VALUES = 5;
+    private static final int GET_INVALID = 0xff;
+
+    private static final String EXTRA_ATTRIBUTE_ID = "Attribute";
+    private static final String EXTRA_VALUE_STRING_ARRAY = "ValueStrings";
+    private static final String EXTRA_ATTRIB_VALUE_PAIRS = "AttribValuePairs";
+    private static final String EXTRA_ATTRIBUTE_STRING_ARRAY = "AttributeStrings";
+    private static final String EXTRA_VALUE_ID_ARRAY = "Values";
+    private static final String EXTRA_ATTIBUTE_ID_ARRAY = "Attributes";
+
+    public static final int VALUE_SHUFFLEMODE_OFF = 1;
+    public static final int VALUE_SHUFFLEMODE_ALL = 2;
+    public static final int VALUE_REPEATMODE_OFF = 1;
+    public static final int VALUE_REPEATMODE_SINGLE = 2;
+    public static final int VALUE_REPEATMODE_ALL = 3;
+    public static final int VALUE_INVALID = 0;
+
+    public static final int ATTRIBUTE_EQUALIZER = 1;
+    public static final int ATTRIBUTE_REPEATMODE = 2;
+    public static final int ATTRIBUTE_SHUFFLEMODE = 3;
+    public static final int ATTRIBUTE_SCANMODE = 4;
+
+
+    private byte [] def_attrib = new byte [] {ATTRIBUTE_REPEATMODE, ATTRIBUTE_SHUFFLEMODE};
+    private byte [] value_repmode = new byte [] { VALUE_REPEATMODE_OFF,
+                                                  VALUE_REPEATMODE_SINGLE,
+                                                  VALUE_REPEATMODE_ALL };
+
+    private byte [] value_shufmode = new byte [] { VALUE_SHUFFLEMODE_OFF,
+                                                  VALUE_SHUFFLEMODE_ALL };
+    private byte [] value_default = new byte [] {0};
+    private final String UPDATE_ATTRIBUTES = "UpdateSupportedAttributes";
+    private final String UPDATE_VALUES = "UpdateSupportedValues";
+    private final String UPDATE_ATTRIB_VALUE = "UpdateCurrentValues";
+    private final String UPDATE_ATTRIB_TEXT = "UpdateAttributesText";
+    private final String UPDATE_VALUE_TEXT = "UpdateValuesText";
+    private ArrayList <Integer> mPendingCmds;
+
+
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MESSAGE_PLAYSTATUS_TIMEOUT:
+                    Log.i(TAG, "Timed outM - Sending Playstatus");
+                    sendPlayStatus(mPlayStatusRequestPath);
+                    break;
+                case MESSAGE_PLAYERSETTINGS_TIMEOUT:
+                    synchronized (mPendingCmds) {
+                        Integer val = new Integer(msg.arg1);
+                        if (!mPendingCmds.contains(val)) {
+                            break;
+                        }
+                        mPendingCmds.remove(val);
+                    }
+                    switch (msg.arg1) {
+                        case GET_ATTRIBUTE_IDS:
+                            if (mPlayerSettings.path != null) {
+                                sendPlayerSettingsNative(mPlayerSettings.path,
+                                     UPDATE_ATTRIBUTES, def_attrib.length, def_attrib);
+                            }
+                            break;
+                        case GET_VALUE_IDS:
+                            switch (mPlayerSettings.attr) {
+                                case ATTRIBUTE_REPEATMODE:
+                                    if (mPlayerSettings.path != null) {
+                                        sendPlayerSettingsNative(mPlayerSettings.path,
+                                          UPDATE_VALUES, value_repmode.length, value_repmode);
+                                    }
+                                    break;
+                                case ATTRIBUTE_SHUFFLEMODE:
+                                    if (mPlayerSettings.path != null) {
+                                        sendPlayerSettingsNative(mPlayerSettings.path,
+                                             UPDATE_VALUES, value_shufmode.length, value_shufmode);
+                                    }
+                                    break;
+                                default:
+                                    if (mPlayerSettings.path != null) {
+                                        sendPlayerSettingsNative(mPlayerSettings.path,
+                                            UPDATE_VALUES, value_default.length, value_default);
+                                    }
+                                    break;
+                            }
+                        break;
+                        case GET_ATTRIBUTE_VALUES:
+                            int j = 0;
+                            byte [] retVal = new byte [mPlayerSettings.attrIds.length*2];
+                            for (int i = 0; i < mPlayerSettings.attrIds.length; i++) {
+                                 retVal[j++] = mPlayerSettings.attrIds[i];
+                                 if (mPlayerSettings.attrIds[i] == ATTRIBUTE_REPEATMODE) {
+                                     retVal[j++] = settingValues.repeat_value;
+                                 } else if (mPlayerSettings.attrIds[i] == ATTRIBUTE_SHUFFLEMODE) {
+                                     retVal[j++] = settingValues.shuffle_value;
+                                 } else {
+                                     retVal[j++] = 0x0;
+                                 }
+                            }
+                            if (mPlayerSettings.path != null) {
+                                sendPlayerSettingsNative(mPlayerSettings.path,
+                                          UPDATE_ATTRIB_VALUE, retVal.length, retVal);
+                            }
+                        break;
+                        case GET_ATTRIBUTE_TEXT:
+                        case GET_VALUE_TEXT:
+                            String [] values = new String [mPlayerSettings.attrIds.length];
+                            String msgVal = (msg.what == GET_ATTRIBUTE_TEXT) ? UPDATE_ATTRIB_TEXT :
+                                             UPDATE_VALUE_TEXT;
+                            for (int i = 0; i < mPlayerSettings.attrIds.length; i++) {
+                                values[i] = "";
+                            }
+                            if (mPlayerSettings.path != null) {
+                                sendSettingsTextNative(mPlayerSettings.path,
+                                                   msgVal, values.length,
+                                                   mPlayerSettings.attrIds, values);
+                            }
+                        break;
+                    }
+                    break;
+                default :
+                    break;
+            }
+        }
+    };
+
+    private String getValidUtf8String ( String str)
+    {
+        int Char, i;
+        String temp;
+
+        if (str == null) {
+            return null;
+        }
+
+        for (i = 0; i < str.length(); i++) {
+            Char = str.codePointAt(i);
+            if ((Char > 0x10FFFF) ||
+                ((Char & 0xFFFFF800) == 0xD800) ||
+                ((Char >= 0xFDD0) && (Char <= 0xFDEF)) ||
+                ((Char & 0xFFFE) == 0xFFFE)) {
+                break;
+            }
+        }
+
+        if (i != str.length()) {
+            try {
+                temp = new String(str.getBytes(), 0, i, "UTF-8");
+                str = temp;
+            } catch (Exception e) {
+                Log.e(TAG, "Exception" + e);
+            }
+        }
+        return str;
+    }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            BluetoothDevice device =
+                    intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
+                int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
+                                               BluetoothAdapter.ERROR);
+                switch (state) {
+                case BluetoothAdapter.STATE_ON:
+                    onBluetoothEnable();
+                    break;
+                case BluetoothAdapter.STATE_TURNING_OFF:
+                    onBluetoothDisable();
+                    break;
+                }
+            } else if (action.equals(BluetoothDevice.ACTION_ACL_DISCONNECTED)) {
+                synchronized (this) {
+                    if (device == null) {
+                        Log.e(TAG, "Error! device is null");
+                        return;
+                    }
+                    if (mAudioDevices.containsKey(device)) {
+                        int state = mAudioDevices.get(device);
+                        handleSinkStateChange(device, state, BluetoothA2dp.STATE_DISCONNECTED);
+                    }
+                }
+            } else if (action.equals(AudioManager.VOLUME_CHANGED_ACTION)) {
+                int streamType = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1);
+                if (streamType == AudioManager.STREAM_MUSIC) {
+                    List<BluetoothDevice> sinks = getConnectedDevices();
+
+                    if (sinks.size() != 0 && isPhoneDocked(sinks.get(0))) {
+                        String address = sinks.get(0).getAddress();
+                        int newVolLevel =
+                          intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, 0);
+                        int oldVolLevel =
+                          intent.getIntExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, 0);
+                        String path = mBluetoothService.getObjectPathFromAddress(address);
+                        if (newVolLevel > oldVolLevel) {
+                            avrcpVolumeUpNative(path);
+                        } else if (newVolLevel < oldVolLevel) {
+                            avrcpVolumeDownNative(path);
+                        }
+                    }
+                }
+            } else if (action.equals(META_CHANGED)) {
+                mTrackName = intent.getStringExtra("track");
+                mArtistName = intent.getStringExtra("artist");
+                mAlbumName = intent.getStringExtra("album");
+                if (mTrackName == null)
+                    mTrackName = DEFAULT_METADATA_STRING;
+                if (mArtistName == null)
+                    mArtistName = DEFAULT_METADATA_STRING;
+                if (mAlbumName == null)
+                    mAlbumName = DEFAULT_METADATA_STRING;
+                long extra = intent.getLongExtra("id", 0);
+                if (extra < 0)
+                    extra = 0;
+                mMediaNumber = String.valueOf(extra);
+                extra = intent.getLongExtra("ListSize", 0);;
+                if (extra < 0)
+                    extra = 0;
+                mMediaCount = String.valueOf(extra);
+                extra = intent.getLongExtra("duration", 0);
+                if (extra < 0)
+                    extra = 0;
+                mDuration = String.valueOf(extra);
+                extra = intent.getLongExtra("position", 0);
+                if (extra < 0)
+                    extra = 0;
+                mPosition = extra;
+                if(DBG) {
+                    Log.d(TAG, "Meta data info is trackname: "+ mTrackName+" artist: "+mArtistName);
+                    Log.d(TAG, "mMediaNumber: "+mMediaNumber+" mediaCount "+mMediaCount);
+                    Log.d(TAG, "mPostion "+ mPosition+" album: "+mAlbumName+ "duration "+mDuration);
+                }
+                for (String path: getConnectedSinksPaths()) {
+                    sendMetaData(path);
+                    sendEvent(path, EVENT_TRACK_CHANGED, Long.valueOf(mMediaNumber));
+                }
+            } else if (action.equals(PLAYSTATE_CHANGED)) {
+                log("Received PLAYSTATE_CHANGED");
+                /*Update the current play state of Music App.*/
+                mIsMusicAppPlaying = intent.getBooleanExtra("playing", false);
+                log("Playing Status" + mIsMusicAppPlaying);
+            } else if (action.equals(PLAYSTATUS_RESPONSE)) {
+                if(DBG) Log.d(TAG, "Received PLAYSTATUS_RESPONSE");
+                long extra = intent.getLongExtra("duration", 0);
+                if (extra < 0)
+                    extra = 0;
+                mDuration = String.valueOf(extra);
+                mPosition = intent.getLongExtra("position", 0);
+                if (mPosition < 0)
+                    mPosition = 0;
+                boolean playStatus = intent.getBooleanExtra("playing", false);
+                mPlayStatus = convertedPlayStatus(playStatus, mPosition);
+                if(DBG) Log.d(TAG, "Sending Playstatus");
+                sendPlayStatus(mPlayStatusRequestPath);
+            } else if (action.equals(ACTION_METADATA_CHANGED)) {
+                log("Received ACTION_METADATA_CHANGED");
+                Uri uri = intent.getParcelableExtra("uripath");
+                log("uri is " + uri + "mUri is " + mUri);
+
+                if (uri == null)
+                    return;
+                /*Check if MusicApp is not playing state and previous Playstatus of
+                  Music App is not equal to PLAYING before we update the PLAYSTATUS
+                  or Metadata to Remote device.*/
+                if ((mIsMusicAppPlaying == false) && (mPlayStatus != STATUS_PLAYING)) {
+                    log("Internal audio file data, ignoring");
+                    return;
+                }
+
+                String tempMediaNumber = mMediaNumber;
+
+                mReportTime = intent.getLongExtra("time", 0);
+                mDuration = String.valueOf(intent.getIntExtra("duration", 0));
+                mPosition = intent.getIntExtra("position", 0);
+                int playStatus = intent.getIntExtra("playstate", 0);
+                log("PlaySatus is " + playStatus);
+
+                if (playStatus != mPlayStatus) {
+                    mPlayStatus = playStatus;
+                    for (String path: getConnectedSinksPaths()) {
+                        sendEvent(path, EVENT_PLAYSTATUS_CHANGED, (long)mPlayStatus);
+                    }
+                }
+
+                log("Metadata received");
+                log("Duration " + mDuration);
+                log("position " + mPosition);
+                log("playstate is " + mPlayStatus);
+
+                if (uri.equals(mUri)) {
+                    log("Update for same Uri, ignoring");
+                    return;
+                }
+
+                mUri = uri;
+                Cursor mCursor = null;
+                try {
+                    String temp;
+                    mCursor = mContext.getContentResolver().query(mUri, mCursorCols,
+                                        MediaStore.Audio.Media.IS_MUSIC + "=1", null,
+                                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);
+                    mCursor.moveToFirst();
+                    temp = mCursor.getString(
+                        mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE));
+
+                    mTrackName = getValidUtf8String(temp);
+                    temp = mCursor.getString(
+                        mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST));
+
+                    mArtistName = getValidUtf8String(temp);
+                    temp = mCursor.getString(
+                        mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM));
+                    mAlbumName = getValidUtf8String(temp);
+
+                    long mediaNumber = mCursor.getLong(
+                        mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID));
+                    mMediaNumber = String.valueOf(mediaNumber);
+                    log("Title is " + mTrackName);
+                    log("Artist is " + mArtistName);
+                    log("Album is " + mAlbumName);
+                    log("ID is " + mMediaNumber);
+                    mCursor.close();
+                    mCursor = null;
+                    Long tmpId = (Long)getTrackId(mTrackName);
+                    log("tmpId is " + tmpId);
+                    mMediaNumber = String.valueOf(tmpId);
+                    log("ID is " + mMediaNumber);
+                    if (!tempMediaNumber.equals(mMediaNumber)) {
+                        /* file change happened */
+                        MediaMetadataRetriever mmr = new MediaMetadataRetriever();
+                        mmr.setDataSource(mContext, mUri);
+                        temp = mmr.extractMetadata(mmr.METADATA_KEY_GENRE);
+                        mGenre = getValidUtf8String(temp);
+                        log("Genre is " + mGenre);
+                    }
+                    mCursor = mContext.getContentResolver().query(
+                                            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                                            new String [] { MediaStore.Audio.Media._ID},
+                                            MediaStore.Audio.Media.IS_MUSIC + "=1", null,
+                                            MediaStore.Audio.Media.DEFAULT_SORT_ORDER);
+                    mMediaCount = String.valueOf(mCursor.getCount());
+                    mCursor.close();
+                    mCursor = null;
+                    log("Track count is " + mMediaCount);
+                } catch(Exception e) {
+                    log("Exc is " + e);
+                    // e.printStackTrace(); for debugging enable this
+                    if (mCursor != null) {
+                        mCursor.close();
+                    }
+                    mTrackName = null;
+                    mArtistName = null;
+                    mAlbumName = null;
+                    mGenre = null;
+                }
+
+                log("end of parsing mData");
+                for (String path: getConnectedSinksPaths()) {
+                    sendMetaData(path);
+                    sendEvent(path, EVENT_TRACK_CHANGED, Long.valueOf(mMediaNumber));
+                }
+            } else if (action.equals(PLAYERSETTINGS_RESPONSE)) {
+                int getResponse = intent.getIntExtra(EXTRA_GET_RESPONSE,
+                                                      GET_INVALID);
+                byte [] data;
+                String [] text;
+                synchronized (mPendingCmds) {
+                    Integer val = new Integer(getResponse);
+                    if (mPendingCmds.contains(val)) {
+                        mHandler.removeMessages(MESSAGE_PLAYERSETTINGS_TIMEOUT);
+                        mPendingCmds.remove(val);
+                    }
+                }
+                switch (getResponse) {
+                    case GET_ATTRIBUTE_IDS:
+                        data = intent.getByteArrayExtra(EXTRA_ATTIBUTE_ID_ARRAY);
+                        if (mPlayerSettings.path != null) {
+                            sendPlayerSettingsNative(mPlayerSettings.path,
+                                           UPDATE_ATTRIBUTES, data.length, data);
+                        }
+                    break;
+                    case GET_VALUE_IDS:
+                        data = intent.getByteArrayExtra(EXTRA_VALUE_ID_ARRAY);
+                        if (mPlayerSettings.path != null) {
+                            sendPlayerSettingsNative(mPlayerSettings.path,
+                                               UPDATE_VALUES, data.length, data);
+                        }
+                    break;
+                    case GET_ATTRIBUTE_VALUES:
+                    case NOTIFY_ATTRIBUTE_VALUES:
+                        data = intent.getByteArrayExtra(EXTRA_ATTRIB_VALUE_PAIRS);
+                        updateLocalPlayerSettings(data);
+                        if (mPlayerSettings.path != null) {
+                            sendPlayerSettingsNative(mPlayerSettings.path,
+                                             UPDATE_ATTRIB_VALUE, data.length, data);
+                        } else { //only for notification there can be no path set
+                            for (String path: getConnectedSinksPaths()) {
+                                sendPlayerSettingsNative(path,
+                                             UPDATE_ATTRIB_VALUE, data.length, data);
+                            }
+                        }
+                    break;
+                    case GET_ATTRIBUTE_TEXT:
+                        text = intent.getStringArrayExtra(EXTRA_ATTRIBUTE_STRING_ARRAY);
+                        if (mPlayerSettings.path != null) {
+                           sendSettingsTextNative(mPlayerSettings.path,
+                                            UPDATE_ATTRIB_TEXT, text.length,
+                                            mPlayerSettings.attrIds, text);
+                        }
+                    break;
+                    case GET_VALUE_TEXT:
+                        text = intent.getStringArrayExtra(EXTRA_VALUE_STRING_ARRAY);
+                        if (mPlayerSettings.path != null) {
+                            sendSettingsTextNative(mPlayerSettings.path,
+                                             UPDATE_VALUE_TEXT, text.length,
+                                             mPlayerSettings.attrIds, text);
+                        }
+                    break;
+                }
+            }
+        }
+    };
+
+    private synchronized int convertedPlayStatus(boolean playing, long position) {
+        if (playing == false && position == 0)
+            return STATUS_STOPPED;
+        if (playing == false)
+            return STATUS_PAUSED;
+        if (playing == true)
+            return STATUS_PLAYING;
+        return STATUS_ERROR;
+    }
+
+    private synchronized void sendMetaData(String path) {
+
+        if (mTrackName == null || mTrackName.isEmpty())
+            mTrackName = DEFAULT_METADATA_STRING;
+        if (mArtistName == null || mArtistName.isEmpty())
+            mArtistName = DEFAULT_METADATA_STRING;
+        if (mAlbumName == null || mAlbumName.isEmpty())
+            mAlbumName = DEFAULT_METADATA_STRING;
+        if (mGenre == null || mGenre.isEmpty())
+            mGenre = DEFAULT_METADATA_STRING;
+
+        if(DBG) {
+            Log.d(TAG, "sendMetaData "+ path);
+            Log.d(TAG, "Meta data info is trackname: "+ mTrackName+" artist: "+mArtistName);
+            Log.d(TAG, "mMediaNumber: "+mMediaNumber+" mediaCount "+mMediaCount);
+            Log.d(TAG, "mPostion "+ mPosition+" album: "+mAlbumName+ "duration "+mDuration);
+            Log.d(TAG, "mGenre "+ mGenre);
+        }
+        sendMetaDataNative(path);
+    }
+
+    private synchronized void sendEvent(String path, int eventId, long data) {
+        if(DBG) Log.d(TAG, "sendEvent "+path+ " data "+ data);
+        sendEventNative(path, eventId, data);
+    }
+
+    private synchronized void sendPlayStatus(String path) {
+        if(DBG) Log.d(TAG, "sendPlayStatus"+ path);
+        sendPlayStatusNative(path, (int)Integer.valueOf(mDuration), (int)mPosition, mPlayStatus);
+    }
+
+    private void onGetPlayStatusRequest(String path) {
+        if(DBG) Log.d(TAG, "onGetPlayStatusRequest"+path);
+        mPlayStatusRequestPath = path;
+        int playStatus = mPlayStatus;
+        log("onGetPlayStatus Request position is " + mPosition);
+        if ((mPlayingA2dpDevice == null) && (mPlayStatus == STATUS_PLAYING)) {
+            log("Some error in Player to update proper status");
+            playStatus = STATUS_PAUSED;
+        } else if (mPlayStatus == STATUS_PLAYING) {
+            long curTime = System.currentTimeMillis();
+            long timeElapsed = curTime - mReportTime;
+            log("TimeElapsed is " + timeElapsed);
+            mPosition += timeElapsed;
+            mReportTime = curTime;
+        }
+        log("Updated position " + mPosition);
+        sendPlayStatusNative(path, (int)Integer.valueOf(mDuration), (int)mPosition, playStatus);
+    }
+
+    private void onListPlayerAttributeRequest(String path) {
+        if(DBG) Log.d(TAG, "onListPlayerAttributeRequest"+path);
+        mPlayerSettings.path = path;
+        Intent intent = new Intent(PLAYERSETTINGS_REQUEST);
+        intent.putExtra(COMMAND, CMDGET);
+        intent.putExtra(EXTRA_GET_COMMAND, GET_ATTRIBUTE_IDS);
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+
+        Message msg = mHandler.obtainMessage();
+        msg.what = MESSAGE_PLAYERSETTINGS_TIMEOUT;
+        msg.arg1 = GET_ATTRIBUTE_IDS;
+        mPendingCmds.add(new Integer(msg.arg1));
+        mHandler.sendMessageDelayed(msg, 130);
+    }
+
+    private void onListPlayerAttributeValues(String path, byte attr ) {
+        if(DBG) Log.d(TAG, "onListPlayerAttributeValues"+path);
+        mPlayerSettings.path = path;
+        mPlayerSettings.attr = attr;
+
+        Intent intent = new Intent(PLAYERSETTINGS_REQUEST);
+        Message msg = mHandler.obtainMessage();
+
+        intent.putExtra(COMMAND, CMDGET);
+        intent.putExtra(EXTRA_GET_COMMAND, GET_VALUE_IDS);
+        intent.putExtra(EXTRA_ATTRIBUTE_ID, attr);
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+
+        msg.what = MESSAGE_PLAYERSETTINGS_TIMEOUT;
+        msg.arg1 = GET_VALUE_IDS;
+        mPendingCmds.add(new Integer(msg.arg1));
+        mHandler.sendMessageDelayed(msg, 130);
+    }
+
+    private void onGetPlayerAttributeValues(String path, byte[] attrIds ) {
+        if(DBG) Log.d(TAG, "onGetPlayerAttributeValues"+path);
+        mPlayerSettings.path = path;
+        mPlayerSettings.attrIds = new byte [attrIds.length];
+
+        Intent intent = new Intent(PLAYERSETTINGS_REQUEST);
+        Message msg = mHandler.obtainMessage();
+
+        intent.putExtra(COMMAND, CMDGET);
+        intent.putExtra(EXTRA_GET_COMMAND, GET_ATTRIBUTE_VALUES);
+        intent.putExtra(EXTRA_ATTIBUTE_ID_ARRAY, attrIds);
+        for (int i = 0; i < attrIds.length; i++)
+            mPlayerSettings.attrIds[i] = attrIds[i];
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+
+        msg.what = MESSAGE_PLAYERSETTINGS_TIMEOUT;
+        msg.arg1 = GET_ATTRIBUTE_VALUES;
+        mPendingCmds.add(new Integer(msg.arg1));
+        mHandler.sendMessageDelayed(msg, 130);
+    }
+
+    private void onSetPlayerAttributeValues(String path, byte[] attrValues ) {
+        if(DBG) Log.d(TAG, "onListPlayerAttributeValues"+path);
+        Intent intent = new Intent(PLAYERSETTINGS_REQUEST);
+        Message msg = mHandler.obtainMessage();
+
+        intent.putExtra(COMMAND, CMDSET);
+        intent.putExtra(EXTRA_ATTRIB_VALUE_PAIRS, attrValues);
+        mPlayerSettings.path = path;
+
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+    }
+
+    private void onListPlayerAttributesText(String path, byte[] attrIds ) {
+        if(DBG) Log.d(TAG, "onListPlayerAttributesText"+path);
+        Intent intent = new Intent(PLAYERSETTINGS_REQUEST);
+        Message msg = mHandler.obtainMessage();
+
+        intent.putExtra(COMMAND, CMDGET);
+        intent.putExtra(EXTRA_GET_COMMAND, GET_ATTRIBUTE_TEXT);
+        intent.putExtra(EXTRA_ATTIBUTE_ID_ARRAY, attrIds);
+        mPlayerSettings.path = path;
+        mPlayerSettings.attrIds = new byte [attrIds.length];
+        for (int i = 0; i < attrIds.length; i++)
+            mPlayerSettings.attrIds[i] = attrIds[i];
+
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        msg.what = MESSAGE_PLAYERSETTINGS_TIMEOUT;
+        msg.arg1 = GET_ATTRIBUTE_TEXT;
+        mPendingCmds.add(new Integer(msg.arg1));
+        mHandler.sendMessageDelayed(msg, 130);
+    }
+
+    private void onListAttributeValuesText(String path, byte attr, byte[] valIds ) {
+        if(DBG) Log.d(TAG, "onListattributeValuesText"+path);
+        Intent intent = new Intent(PLAYERSETTINGS_REQUEST);
+        Message msg = mHandler.obtainMessage();
+
+        intent.putExtra(COMMAND, CMDGET);
+        intent.putExtra(EXTRA_GET_COMMAND, GET_VALUE_TEXT);
+        intent.putExtra(EXTRA_ATTRIBUTE_ID, attr);
+        intent.putExtra(EXTRA_VALUE_ID_ARRAY, valIds);
+        mPlayerSettings.path = path;
+        mPlayerSettings.attrIds = new byte [valIds.length];
+        for (int i = 0; i < valIds.length; i++)
+            mPlayerSettings.attrIds[i] = valIds[i];
+
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        msg.what = MESSAGE_PLAYERSETTINGS_TIMEOUT;
+        msg.arg1 = GET_VALUE_TEXT;
+        mPendingCmds.add(new Integer(msg.arg1));
+        mHandler.sendMessageDelayed(msg, 130);
+    }
+
+    private boolean isPhoneDocked(BluetoothDevice device) {
+        // This works only because these broadcast intents are "sticky"
+        Intent i = mContext.registerReceiver(null, new IntentFilter(Intent.ACTION_DOCK_EVENT));
+        if (i != null) {
+            int state = i.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
+            if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
+                BluetoothDevice dockDevice = i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                if (dockDevice != null && device.equals(dockDevice)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public BluetoothA2dpService(Context context, BluetoothService bluetoothService) {
+        mContext = context;
+
+        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "BluetoothA2dpService");
+
+        mIntentBroadcastHandler = new IntentBroadcastHandler();
+
+        mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
+
+        mBluetoothService = bluetoothService;
+        if (mBluetoothService == null) {
+            throw new RuntimeException("Platform does not support Bluetooth");
+        }
+
+        if (!initNative()) {
+            throw new RuntimeException("Could not init BluetoothA2dpService");
+        }
+
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+
+        mIntentFilter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
+        mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
+        mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
+        mIntentFilter.addAction(AudioManager.VOLUME_CHANGED_ACTION);
+        mIntentFilter.addAction(PLAYSTATE_CHANGED);
+        mIntentFilter.addAction(ACTION_METADATA_CHANGED);
+        mIntentFilter.addAction(PLAYERSETTINGS_RESPONSE);
+        mContext.registerReceiver(mReceiver, mIntentFilter);
+
+        mAudioDevices = new HashMap<BluetoothDevice, Integer>();
+        mPendingCmds = new ArrayList<Integer>();
+
+        if (mBluetoothService.isEnabled())
+            onBluetoothEnable();
+        mTargetA2dpState = -1;
+        tmgr = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
+        mBluetoothService.setA2dpService(this);
+        settingValues.repeat_value = 1;
+        settingValues.shuffle_value = 1;
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        try {
+            cleanupNative();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    private int convertBluezSinkStringToState(String value) {
+        if (value.equalsIgnoreCase("disconnected"))
+            return BluetoothA2dp.STATE_DISCONNECTED;
+        if (value.equalsIgnoreCase("connecting"))
+            return BluetoothA2dp.STATE_CONNECTING;
+        if (value.equalsIgnoreCase("connected"))
+            return BluetoothA2dp.STATE_CONNECTED;
+        if (value.equalsIgnoreCase("playing"))
+            return BluetoothA2dp.STATE_PLAYING;
+        if (value.equalsIgnoreCase("disconnecting"))
+            return BluetoothA2dp.STATE_DISCONNECTING;
+        return -1;
+    }
+
+    private boolean isSinkDevice(BluetoothDevice device) {
+        ParcelUuid[] uuids = mBluetoothService.getRemoteUuids(device.getAddress());
+        if (uuids != null && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSink)) {
+            return true;
+        }
+        return false;
+    }
+
+    private synchronized void addAudioSink(BluetoothDevice device) {
+        if (mAudioDevices.get(device) == null) {
+            mAudioDevices.put(device, BluetoothA2dp.STATE_DISCONNECTED);
+        }
+    }
+
+    private synchronized void onBluetoothEnable() {
+        String devices = mBluetoothService.getProperty("Devices", true);
+        if (devices != null) {
+            String [] paths = devices.split(",");
+            for (String path: paths) {
+                String address = mBluetoothService.getAddressFromObjectPath(path);
+                BluetoothDevice device = mAdapter.getRemoteDevice(address);
+                ParcelUuid[] remoteUuids = mBluetoothService.getRemoteUuids(address);
+                if (remoteUuids != null)
+                    if (BluetoothUuid.containsAnyUuid(remoteUuids,
+                            new ParcelUuid[] {BluetoothUuid.AudioSink,
+                                                BluetoothUuid.AdvAudioDist})) {
+                        addAudioSink(device);
+                    }
+                }
+        }
+        mAudioManager.setParameters(BLUETOOTH_ENABLED+"=true");
+        mAudioManager.setParameters("A2dpSuspended=false");
+        mPlayingA2dpDevice = null;
+    }
+
+    private synchronized void onBluetoothDisable() {
+        mAudioManager.setParameters(BLUETOOTH_ENABLED + "=false");
+        if (!mAudioDevices.isEmpty()) {
+            BluetoothDevice[] devices = new BluetoothDevice[mAudioDevices.size()];
+            devices = mAudioDevices.keySet().toArray(devices);
+            for (BluetoothDevice device : devices) {
+                int state = getConnectionState(device);
+                switch (state) {
+                    case BluetoothA2dp.STATE_CONNECTING:
+                    case BluetoothA2dp.STATE_CONNECTED:
+                    case BluetoothA2dp.STATE_PLAYING:
+                        disconnectSinkNative(mBluetoothService.getObjectPathFromAddress(
+                                device.getAddress()));
+                        handleSinkStateChange(device, state,
+                                              BluetoothA2dp.STATE_DISCONNECTING);
+                        break;
+                    case BluetoothA2dp.STATE_DISCONNECTING:
+                        handleSinkStateChange(device, BluetoothA2dp.STATE_DISCONNECTING,
+                                              BluetoothA2dp.STATE_DISCONNECTED);
+                        mAudioDevices.clear();
+                        break;
+                }
+            }
+        }
+
+    }
+
+    private synchronized boolean isConnectSinkFeasible(BluetoothDevice device) {
+        if (!mBluetoothService.isEnabled() || !isSinkDevice(device) ||
+                getPriority(device) == BluetoothA2dp.PRIORITY_OFF) {
+            return false;
+        }
+
+        addAudioSink(device);
+
+        String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (path == null) {
+            return false;
+        }
+        return true;
+    }
+
+    public synchronized boolean isA2dpPlaying(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+            "Need BLUETOOTH_ADMIN permission");
+        if (DBG) log("isA2dpPlaying(" + device + ")");
+        if (device.equals(mPlayingA2dpDevice)) return true;
+        return false;
+    }
+
+    public synchronized boolean connect(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (DBG) log("connectSink(" + device + ")");
+        if (!isConnectSinkFeasible(device)) return false;
+
+        int state;
+        for (BluetoothDevice sinkDevice : mAudioDevices.keySet()) {
+            state = getConnectionState(sinkDevice);
+            if (state != BluetoothProfile.STATE_DISCONNECTED) {
+                if (device.equals(sinkDevice) &&
+                    ((state == BluetoothProfile.STATE_CONNECTING) ||
+                     (state == BluetoothProfile.STATE_CONNECTED))) {
+                     return true; // already connecting to same device.
+                }
+                disconnect(sinkDevice);
+            }
+        }
+
+        return mBluetoothService.connectSink(device.getAddress());
+    }
+
+    public synchronized boolean connectSinkInternal(BluetoothDevice device) {
+        if (!mBluetoothService.isEnabled()) return false;
+
+        int state = mAudioDevices.get(device);
+        // ignore if there are any active sinks
+        if (getDevicesMatchingConnectionStates(new int[] {
+                BluetoothA2dp.STATE_CONNECTING,
+                BluetoothA2dp.STATE_CONNECTED,
+                BluetoothA2dp.STATE_DISCONNECTING}).size() != 0) {
+            return false;
+        }
+
+        switch (state) {
+        case BluetoothA2dp.STATE_CONNECTED:
+        case BluetoothA2dp.STATE_DISCONNECTING:
+            return false;
+        case BluetoothA2dp.STATE_CONNECTING:
+            return true;
+        }
+
+        String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+
+        // State is DISCONNECTED and we are connecting.
+        if (getPriority(device) < BluetoothA2dp.PRIORITY_AUTO_CONNECT) {
+            setPriority(device, BluetoothA2dp.PRIORITY_AUTO_CONNECT);
+        }
+        handleSinkStateChange(device, state, BluetoothA2dp.STATE_CONNECTING);
+
+        if (!connectSinkNative(path)) {
+            // Restore previous state
+            handleSinkStateChange(device, mAudioDevices.get(device), state);
+            return false;
+        }
+        return true;
+    }
+
+    private synchronized boolean isDisconnectSinkFeasible(BluetoothDevice device) {
+        String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (path == null) {
+            return false;
+        }
+
+        int state = getConnectionState(device);
+        switch (state) {
+        case BluetoothA2dp.STATE_DISCONNECTED:
+        case BluetoothA2dp.STATE_DISCONNECTING:
+            return false;
+        }
+        return true;
+    }
+
+    public synchronized boolean disconnect(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (DBG) log("disconnectSink(" + device + ")");
+        if (!isDisconnectSinkFeasible(device)) return false;
+        return mBluetoothService.disconnectSink(device.getAddress());
+    }
+
+    public synchronized boolean disconnectSinkInternal(BluetoothDevice device) {
+        int state = getConnectionState(device);
+        String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+
+        switch (state) {
+            case BluetoothA2dp.STATE_DISCONNECTED:
+                return false;
+              // already in disconnecting state not a failure case.
+            case BluetoothA2dp.STATE_DISCONNECTING:
+                return true;
+        }
+        // State is CONNECTING or CONNECTED or PLAYING
+        handleSinkStateChange(device, state, BluetoothA2dp.STATE_DISCONNECTING);
+        if (!disconnectSinkNative(path)) {
+            // Restore previous state
+            handleSinkStateChange(device, mAudioDevices.get(device), state);
+            return false;
+        }
+        return true;
+    }
+
+    public synchronized boolean suspendSink(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                            "Need BLUETOOTH_ADMIN permission");
+        if (DBG) log("suspendSink(" + device + "), mTargetA2dpState: "+mTargetA2dpState);
+        if (device == null || mAudioDevices == null) {
+            return false;
+        }
+        String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        Integer state = mAudioDevices.get(device);
+        if (path == null || state == null) {
+            return false;
+        }
+        // device state will not reflect playback state
+        if(isA2dpPlaying(device)) {
+                state = BluetoothA2dp.STATE_PLAYING;
+        }
+
+        mTargetA2dpState = BluetoothA2dp.STATE_CONNECTED;
+        return checkSinkSuspendState(state.intValue());
+    }
+
+    public synchronized boolean resumeSink(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                            "Need BLUETOOTH_ADMIN permission");
+        if (DBG) log("resumeSink(" + device + "), mTargetA2dpState: "+mTargetA2dpState);
+        if (device == null || mAudioDevices == null) {
+            return false;
+        }
+        String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        Integer state = mAudioDevices.get(device);
+        if (path == null || state == null) {
+            return false;
+        }
+        // device state will not reflect playback state
+        if(isA2dpPlaying(device)) {
+                state = BluetoothA2dp.STATE_PLAYING;
+        }
+
+        mTargetA2dpState = BluetoothA2dp.STATE_PLAYING;
+        return checkSinkSuspendState(state.intValue());
+    }
+
+    public synchronized int getConnectionState(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        Integer state = mAudioDevices.get(device);
+        if (state == null)
+            return BluetoothA2dp.STATE_DISCONNECTED;
+        return state;
+    }
+
+    public synchronized String[] getConnectedSinksPaths() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        List<BluetoothDevice> btDevices = getConnectedDevices();
+        String[] paths = new String[btDevices.size()];
+        int index = 0;
+        for(BluetoothDevice device:btDevices) {
+            paths[index++] = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        }
+        return paths;
+    }
+
+    public synchronized List<BluetoothDevice> getConnectedDevices() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        List<BluetoothDevice> sinks = getDevicesMatchingConnectionStates(
+                new int[] {BluetoothA2dp.STATE_CONNECTED});
+        return sinks;
+    }
+
+    public synchronized List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        ArrayList<BluetoothDevice> sinks = new ArrayList<BluetoothDevice>();
+        for (BluetoothDevice device: mAudioDevices.keySet()) {
+            int sinkState = getConnectionState(device);
+            for (int state : states) {
+                if (state == sinkState) {
+                    sinks.add(device);
+                    break;
+                }
+            }
+        }
+        return sinks;
+    }
+    // MR1 Change
+    public synchronized int getPriority(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        return Settings.Secure.getInt(mContext.getContentResolver(),
+                Settings.Global.getBluetoothA2dpSinkPriorityKey(device.getAddress()),
+                BluetoothA2dp.PRIORITY_UNDEFINED);
+    }
+    // MR1 Change
+    public synchronized boolean setPriority(BluetoothDevice device, int priority) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        return Settings.Secure.putInt(mContext.getContentResolver(),
+                Settings.Global.getBluetoothA2dpSinkPriorityKey(device.getAddress()), priority);
+    }
+
+    public synchronized boolean allowIncomingConnect(BluetoothDevice device, boolean value) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        String address = device.getAddress();
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        Integer data = mBluetoothService.getAuthorizationAgentRequestData(address);
+        if (data == null) {
+            Log.w(TAG, "allowIncomingConnect(" + device + ") called but no native data available");
+            return false;
+        }
+        log("allowIncomingConnect: A2DP: " + device + ":" + value);
+        return mBluetoothService.setAuthorizationNative(address, value, data.intValue());
+    }
+
+    /**
+     * Called by native code on a PropertyChanged signal from
+     * org.bluez.AudioSink.
+     *
+     * @param path the object path for the changed device
+     * @param propValues a string array containing the key and one or more
+     *  values.
+     */
+    private synchronized void onSinkPropertyChanged(String path, String[] propValues) {
+        if (!mBluetoothService.isEnabled()) {
+            return;
+        }
+
+        String name = propValues[0];
+        String address = mBluetoothService.getAddressFromObjectPath(path);
+        if (address == null) {
+            Log.e(TAG, "onSinkPropertyChanged: Address of the remote device in null");
+            return;
+        }
+
+        BluetoothDevice device = mAdapter.getRemoteDevice(address);
+
+        if (name.equals(PROPERTY_STATE)) {
+            int state = convertBluezSinkStringToState(propValues[1]);
+            log("A2DP: onSinkPropertyChanged newState is: " + state + "mPlayingA2dpDevice: " + mPlayingA2dpDevice);
+
+            if (mAudioDevices.get(device) == null) {
+                // This is for an incoming connection for a device not known to us.
+                // We have authorized it and bluez state has changed.
+                addAudioSink(device);
+                handleSinkStateChange(device, BluetoothA2dp.STATE_DISCONNECTED, state);
+            } else {
+                if (state == BluetoothA2dp.STATE_PLAYING && mPlayingA2dpDevice == null) {
+                    if (tmgr.getCallState() == TelephonyManager.CALL_STATE_IDLE) {
+                        mPlayingA2dpDevice = device;
+                        handleSinkPlayingStateChange(device, state, BluetoothA2dp.STATE_NOT_PLAYING);
+                    } else {
+                       log("suspend Sink");
+                       // During call active a2dp device is in suspended state
+                       // so audio will not be routed to A2dp. To avoid IOP
+                       // issues send a SUSPEND on A2dp if remote device asks
+                       // for PLAY during call active state.
+                       suspendSinkNative(mBluetoothService.getObjectPathFromAddress(
+                                device.getAddress()));
+                    }
+                } else if (state == BluetoothA2dp.STATE_CONNECTED && mPlayingA2dpDevice != null) {
+                    mPlayingA2dpDevice = null;
+                    handleSinkPlayingStateChange(device, BluetoothA2dp.STATE_NOT_PLAYING,
+                        BluetoothA2dp.STATE_PLAYING);
+                } else {
+                   mPlayingA2dpDevice = null;
+                   int prevState = mAudioDevices.get(device);
+                   handleSinkStateChange(device, prevState, state);
+                }
+            }
+        }
+    }
+
+    private void handleSinkStateChange(BluetoothDevice device, int prevState, int state) {
+        if (state != prevState) {
+            mAudioDevices.put(device, state);
+
+            checkSinkSuspendState(state);
+            mTargetA2dpState = -1;
+
+            if (getPriority(device) > BluetoothA2dp.PRIORITY_OFF &&
+                    state == BluetoothA2dp.STATE_CONNECTED) {
+                // We have connected or attempting to connect.
+                // Bump priority
+                setPriority(device, BluetoothA2dp.PRIORITY_AUTO_CONNECT);
+                // We will only have 1 device with AUTO_CONNECT priority
+                // To be backward compatible set everyone else to have PRIORITY_ON
+                adjustOtherSinkPriorities(device);
+                mPlayerSettings.path =
+                  mBluetoothService.getObjectPathFromAddress(device.getAddress());
+                updateLocalSettingsToBluez();
+            }
+
+            int delay = mAudioManager.setBluetoothA2dpDeviceConnectionState(device, state);
+
+            mWakeLock.acquire();
+            mIntentBroadcastHandler.sendMessageDelayed(mIntentBroadcastHandler.obtainMessage(
+                                                            MSG_CONNECTION_STATE_CHANGED,
+                                                            prevState,
+                                                            state,
+                                                            device),
+                                                       delay);
+        }
+        if (prevState == BluetoothA2dp.STATE_CONNECTING &&
+             state == BluetoothA2dp.STATE_CONNECTED) {
+            for (String path: getConnectedSinksPaths()) {
+                sendMetaData(path);
+                sendEvent(path, EVENT_PLAYSTATUS_CHANGED, (long)mPlayStatus);
+            }
+        }
+    }
+
+    private void handleSinkPlayingStateChange(BluetoothDevice device, int state, int prevState) {
+        Intent intent = new Intent(BluetoothA2dp.ACTION_PLAYING_STATE_CHANGED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+        intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
+        intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+
+        if (DBG) log("A2DP Playing state : device: " + device + " State:" + prevState + "->" + state);
+    }
+
+    private void adjustOtherSinkPriorities(BluetoothDevice connectedDevice) {
+        for (BluetoothDevice device : mAdapter.getBondedDevices()) {
+            if (getPriority(device) >= BluetoothA2dp.PRIORITY_AUTO_CONNECT &&
+                !device.equals(connectedDevice)) {
+                setPriority(device, BluetoothA2dp.PRIORITY_ON);
+            }
+        }
+    }
+
+    private boolean checkSinkSuspendState(int state) {
+        boolean result = true;
+
+        if (state != mTargetA2dpState) {
+            if (state == BluetoothA2dp.STATE_PLAYING &&
+                mTargetA2dpState == BluetoothA2dp.STATE_CONNECTED) {
+                mAudioManager.setParameters("A2dpSuspended=true");
+            } else if (state == BluetoothA2dp.STATE_CONNECTED &&
+                mTargetA2dpState == BluetoothA2dp.STATE_PLAYING) {
+                mAudioManager.setParameters("A2dpSuspended=false");
+            } else {
+                result = false;
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Called by native code for the async response to a Connect
+     * method call to org.bluez.AudioSink.
+     *
+     * @param deviceObjectPath the object path for the connecting device
+     * @param result true on success; false on error
+     */
+    private void onConnectSinkResult(String deviceObjectPath, boolean result) {
+        // If the call was a success, ignore we will update the state
+        // when we a Sink Property Change
+        if (!result) {
+            if (deviceObjectPath != null) {
+                String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+                if (address == null) return;
+                BluetoothDevice device = mAdapter.getRemoteDevice(address);
+                int state = getConnectionState(device);
+                handleSinkStateChange(device, state, BluetoothA2dp.STATE_DISCONNECTED);
+            }
+        }
+    }
+
+    /** Handles A2DP connection state change intent broadcasts. */
+    private class IntentBroadcastHandler extends Handler {
+
+        private void onConnectionStateChanged(BluetoothDevice device, int prevState, int state) {
+            Intent intent = new Intent(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
+            intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+
+            if (DBG) log("A2DP state : device: " + device + " State:" + prevState + "->" + state);
+
+            mBluetoothService.sendConnectionStateChange(device, BluetoothProfile.A2DP, state,
+                                                        prevState);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_CONNECTION_STATE_CHANGED:
+                    onConnectionStateChanged((BluetoothDevice) msg.obj, msg.arg1, msg.arg2);
+                    mWakeLock.release();
+                    break;
+            }
+        }
+    }
+
+    private long getTrackId(String trackName) {
+        long trackId = 0;
+
+        if (trackName == null)
+            return trackId;
+
+        try {
+            Cursor musicCursor = mContext.getContentResolver().query(
+                                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                                    new String[] {MediaStore.Audio.Media.TITLE},
+                                    MediaStore.Audio.Media.IS_MUSIC + "=1",
+                                    null, null);
+            int totalTracks = musicCursor.getCount();
+            musicCursor.moveToFirst();
+            int index = 0;
+            for (; index < totalTracks; index++){
+                trackId++;
+                String title = musicCursor.getString(
+                        musicCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE));
+                if (title == null)
+                    continue;
+
+                if(title.equals(trackName)){
+                    musicCursor.close();
+                    break;
+                }
+                musicCursor.moveToNext();
+            }
+            if (index == totalTracks) {
+                log("Record not found");
+                musicCursor.close();
+                trackId = 0;
+            }
+        } catch(Exception e) {log("Exception is " + e);}
+        log("trackId is " + trackId);
+        return trackId;
+    }
+
+    private void updateLocalPlayerSettings( byte[] data) {
+        for (int i = 0; i < data.length; i += 2) {
+           switch (data[i]) {
+               case ATTRIBUTE_EQUALIZER:
+                    settingValues.eq_value = data[i+1];
+               break;
+               case ATTRIBUTE_REPEATMODE:
+                    settingValues.repeat_value = data[i+1];
+               break;
+               case ATTRIBUTE_SHUFFLEMODE:
+                    settingValues.shuffle_value = data[i+1];
+               break;
+               case ATTRIBUTE_SCANMODE:
+                    settingValues.scan_value = data[i+1];
+               break;
+           }
+        }
+    }
+
+    private void updateLocalSettingsToBluez() {
+       int validSettings = 0;
+       if (settingValues.eq_value > VALUE_INVALID)  validSettings++;
+       if (settingValues.repeat_value > VALUE_REPEATMODE_OFF)  validSettings++;
+       if (settingValues.shuffle_value > VALUE_SHUFFLEMODE_OFF)  validSettings++;
+       if (settingValues.scan_value > VALUE_INVALID)  validSettings++;
+       if (validSettings == 0) return;
+
+       byte [] retValarray = new byte[validSettings * 2];
+       int i = 0;
+
+       if (settingValues.repeat_value > VALUE_REPEATMODE_OFF) {
+           retValarray[i++] = ATTRIBUTE_REPEATMODE;
+           retValarray[i++] = settingValues.repeat_value;
+       }
+       if (settingValues.shuffle_value > VALUE_SHUFFLEMODE_OFF) {
+           retValarray[i++] = ATTRIBUTE_SHUFFLEMODE;
+           retValarray[i++] = settingValues.shuffle_value;
+       }
+       if (settingValues.eq_value > VALUE_INVALID) {
+           retValarray[i++] = ATTRIBUTE_EQUALIZER;
+           retValarray[i++] = settingValues.eq_value;
+       }
+       if (settingValues.scan_value > VALUE_INVALID) {
+           retValarray[i++] = ATTRIBUTE_SCANMODE;
+           retValarray[i++] = settingValues.scan_value;
+       }
+       Intent updateIntent = new Intent(PLAYERSETTINGS_RESPONSE);
+       updateIntent.putExtra(EXTRA_GET_RESPONSE, NOTIFY_ATTRIBUTE_VALUES);
+       updateIntent.putExtra(EXTRA_ATTRIB_VALUE_PAIRS, retValarray);
+       mContext.sendBroadcast(updateIntent);
+    }
+
+
+    @Override
+    protected synchronized void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
+
+        if (mAudioDevices.isEmpty()) return;
+        pw.println("Cached audio devices:");
+        for (BluetoothDevice device : mAudioDevices.keySet()) {
+            int state = mAudioDevices.get(device);
+            pw.println(device + " " + BluetoothA2dp.stateToString(state));
+        }
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+
+    private native boolean initNative();
+    private native void cleanupNative();
+    private synchronized native boolean connectSinkNative(String path);
+    private synchronized native boolean disconnectSinkNative(String path);
+    private synchronized native boolean suspendSinkNative(String path);
+    private synchronized native boolean resumeSinkNative(String path);
+    private synchronized native Object []getSinkPropertiesNative(String path);
+    private synchronized native boolean avrcpVolumeUpNative(String path);
+    private synchronized native boolean avrcpVolumeDownNative(String path);
+    private synchronized native boolean sendMetaDataNative(String path);
+    private synchronized native boolean sendEventNative(String path, int eventId, long data);
+    private synchronized native boolean sendPlayStatusNative(String path, int duration,
+                                                             int position, int playStatus);
+    private synchronized native boolean sendPlayerSettingsNative(String path,
+                                                           String response, int len, byte [] data);
+    private synchronized native boolean sendSettingsTextNative(String path,
+                                                      String response, int len, byte [] data, String []text);
+}
diff --git a/bluetoothmsm/java/android/server/BluetoothAdapterProperties.java b/bluetoothmsm/java/android/server/BluetoothAdapterProperties.java
new file mode 100644
index 0000000..9723f60
--- /dev/null
+++ b/bluetoothmsm/java/android/server/BluetoothAdapterProperties.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.content.Context;
+import android.util.Log;
+
+import java.util.HashMap;
+import java.util.Map;
+
+class BluetoothAdapterProperties {
+
+    private static final String TAG = "BluetoothAdapterProperties";
+
+    private final Map<String, String> mPropertiesMap;
+    private final Context mContext;
+    private final BluetoothService mService;
+
+    BluetoothAdapterProperties(Context context, BluetoothService service) {
+        mPropertiesMap = new HashMap<String, String>();
+        mContext = context;
+        mService = service;
+    }
+
+    synchronized String getProperty(String name) {
+        if (mPropertiesMap.isEmpty()) {
+            getAllProperties();
+        }
+        return mPropertiesMap.get(name);
+    }
+
+    String getObjectPath() {
+        return getProperty("ObjectPath");
+    }
+
+    synchronized void clear() {
+        mPropertiesMap.clear();
+    }
+
+    synchronized boolean isEmpty() {
+        return mPropertiesMap.isEmpty();
+    }
+
+    synchronized void setProperty(String name, String value) {
+        mPropertiesMap.put(name, value);
+    }
+
+    synchronized void getAllProperties() {
+        mContext.enforceCallingOrSelfPermission(
+                BluetoothService.BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        mPropertiesMap.clear();
+
+        String properties[] = (String[]) mService
+                .getAdapterPropertiesNative();
+        // The String Array consists of key-value pairs.
+        if (properties == null) {
+            Log.e(TAG, "*Error*: GetAdapterProperties returned NULL");
+            return;
+        }
+
+        for (int i = 0; i < properties.length; i++) {
+            String name = properties[i];
+            String newValue = null;
+            if (name == null) {
+                Log.e(TAG, "Error:Adapter Property at index " + i + " is null");
+                continue;
+            }
+            if (name.equals("Devices") || name.equals("UUIDs")) {
+                StringBuilder str = new StringBuilder();
+                int len = Integer.valueOf(properties[++i]);
+                for (int j = 0; j < len; j++) {
+                    str.append(properties[++i]);
+                    str.append(",");
+                }
+                if (len > 0) {
+                    newValue = str.toString();
+                }
+            } else {
+                newValue = properties[++i];
+            }
+            mPropertiesMap.put(name, newValue);
+        }
+
+        // Add adapter object path property.
+        String adapterPath = mService.getAdapterPathNative();
+        if (adapterPath != null) {
+            mPropertiesMap.put("ObjectPath", adapterPath + "/dev_");
+        }
+    }
+}
diff --git a/bluetoothmsm/java/android/server/BluetoothAdapterStateMachine.java b/bluetoothmsm/java/android/server/BluetoothAdapterStateMachine.java
new file mode 100644
index 0000000..ebe9c08
--- /dev/null
+++ b/bluetoothmsm/java/android/server/BluetoothAdapterStateMachine.java
@@ -0,0 +1,921 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.IBluetoothStateChangeCallback;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Binder;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+import android.os.SystemService;
+import android.provider.Settings;
+import android.util.Log;
+import android.os.SystemProperties;
+
+import com.android.internal.util.IState;
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+
+import java.io.PrintWriter;
+
+/**
+ * Bluetooth Adapter StateMachine
+ * All the states are at the same level, ie, no hierarchy.
+ *                         (BluetootOn)<----------------------<-
+ *                           |    ^    -------------------->-  |
+ *                           |    |                         |  |
+ *                 TURN_OFF  |    | SCAN_MODE_CHANGED    m1 |  | USER_TURN_ON
+ *         AIRPLANE_MODE_ON  |    |                         |  |
+ *                           V    |                         |  |
+ *                         (Switching)                   (PerProcessState)
+ *                           |    ^                         |  |
+ *     POWER_STATE_CHANGED & |    | TURN_ON(_CONTINUE)      |  |
+ * ALL_DEVICES_DISCONNECTED  |    |                     m2  |  |
+ *                           V    |------------------------<   | SCAN_MODE_CHANGED
+ *                          (HotOff)-------------------------->- PER_PROCESS_TURN_ON
+ *                           /    ^
+ *                          /     |  POWER_STATE_CHANGED
+ *                         |      |
+ *              TURN_COLD  |   (Warmup)
+ *                         |      ^
+ *                         |      |  SERVICE_RECORD_LOADED
+ *                         |      |
+ *                         | (PreWarmUp)
+ *                         \      ^
+ *                          \     |  TURN_HOT/TURN_ON
+ *                           |    |  AIRPLANE_MODE_OFF(when Bluetooth was on before)
+ *                           V    |
+ *                           (PowerOff)   <----- initial state
+ *
+ * Legend:
+ * m1 = TURN_HOT
+ * m2 = Transition to HotOff when number of process wanting BT on is 0.
+ *      POWER_STATE_CHANGED will make the transition.
+ * Note:
+ * The diagram above shows all the states and messages that trigger normal state changes.
+ * The diagram above does not capture everything:
+ *   The diagram does not capture following messages.
+ *   - messages that do not trigger state changes
+ *     For example, PER_PROCESS_TURN_ON received in BluetoothOn state
+ *   - unhandled messages
+ *     For example, USER_TURN_ON received in BluetoothOn state
+ *   - timeout messages
+ *   The diagram does not capture error conditions and state recoveries.
+ *   - For example POWER_STATE_CHANGED received in BluetoothOn state
+ */
+final class BluetoothAdapterStateMachine extends StateMachine {
+    private static final String TAG = "BluetoothAdapterStateMachine";
+    private static final boolean DBG = false;
+
+    // Message(what) to take an action
+    //
+    // We get this message when user tries to turn on BT
+    static final int USER_TURN_ON = 1;
+    // We get this message when user tries to turn off BT
+    static final int USER_TURN_OFF = 2;
+    // Per process enable / disable messages
+    static final int PER_PROCESS_TURN_ON = 3;
+    static final int PER_PROCESS_TURN_OFF = 4;
+
+    // Turn on Bluetooth Module, Load firmware, and do all the preparation
+    // needed to get the Bluetooth Module ready but keep it not discoverable
+    // and not connectable. This way the Bluetooth Module can be quickly
+    // switched on if needed
+    static final int TURN_HOT = 5;
+
+    // Message(what) to report a event that the state machine need to respond to
+    //
+    // Event indicates sevice records have been loaded
+    static final int SERVICE_RECORD_LOADED = 51;
+    // Event indicates all the remote Bluetooth devices has been disconnected
+    static final int ALL_DEVICES_DISCONNECTED = 52;
+    // Event indicates the Bluetooth scan mode has changed
+    static final int SCAN_MODE_CHANGED = 53;
+    // Event indicates the powered state has changed
+    static final int POWER_STATE_CHANGED = 54;
+    // Event indicates airplane mode is turned on
+    static final int AIRPLANE_MODE_ON = 55;
+    // Event indicates airplane mode is turned off
+    static final int AIRPLANE_MODE_OFF = 56;
+
+    // private internal messages
+    //
+    // USER_TURN_ON is changed to TURN_ON_CONTINUE after we broadcast the
+    // state change intent so that we will not broadcast the intent again in
+    // other state
+    private static final int TURN_ON_CONTINUE = 101;
+    // Unload firmware, turning off Bluetooth module power
+    private static final int TURN_COLD = 102;
+    // Device disconnecting timeout happens
+    private static final int DEVICES_DISCONNECT_TIMEOUT = 103;
+    // Prepare Bluetooth timeout happens
+    private static final int PREPARE_BLUETOOTH_TIMEOUT = 104;
+    // Bluetooth Powerdown timeout happens
+    private static final int POWER_DOWN_TIMEOUT = 105;
+
+    private Context mContext;
+    private BluetoothService mBluetoothService;
+    private BluetoothEventLoop mEventLoop;
+
+    private BluetoothOn mBluetoothOn;
+    private Switching mSwitching;
+    private HotOff mHotOff;
+    private WarmUp mWarmUp;
+    private PreWarmUp mPreWarmUp;
+    private PowerOff mPowerOff;
+    private PerProcessState mPerProcessState;
+
+    // this is the BluetoothAdapter state that reported externally
+    private int mPublicState;
+
+    // timeout value waiting for all the devices to be disconnected
+    private static final int DEVICES_DISCONNECT_TIMEOUT_TIME = 3000;
+
+    private static final int PREPARE_BLUETOOTH_TIMEOUT_TIME = 10000;
+
+    private static final int POWER_DOWN_TIMEOUT_TIME = 5000;
+
+    BluetoothAdapterStateMachine(Context context, BluetoothService bluetoothService,
+                                 BluetoothAdapter bluetoothAdapter) {
+        super(TAG);
+        mContext = context;
+        mBluetoothService = bluetoothService;
+        mEventLoop = new BluetoothEventLoop(context, bluetoothAdapter, bluetoothService, this);
+
+        mBluetoothOn = new BluetoothOn();
+        mSwitching = new Switching();
+        mHotOff = new HotOff();
+        mWarmUp = new WarmUp();
+        mPreWarmUp = new PreWarmUp();
+        mPowerOff = new PowerOff();
+        mPerProcessState = new PerProcessState();
+
+        addState(mBluetoothOn);
+        addState(mSwitching);
+        addState(mHotOff);
+        addState(mWarmUp);
+        addState(mPreWarmUp);
+        addState(mPowerOff);
+        addState(mPerProcessState);
+
+        setInitialState(mPowerOff);
+        mPublicState = BluetoothAdapter.STATE_OFF;
+    }
+
+    /**
+     * Bluetooth module's power is off, firmware is not loaded.
+     */
+    private class PowerOff extends State {
+        @Override
+        public void enter() {
+            if (DBG) log("Enter PowerOff: " + getCurrentMessage().what);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            log("PowerOff process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch(message.what) {
+                case USER_TURN_ON:
+                    // starts turning on BT module, broadcast this out
+                    broadcastState(BluetoothAdapter.STATE_TURNING_ON);
+                    transitionTo(mPreWarmUp);
+                    if (prepareBluetooth()) {
+                        // this is user request, save the setting
+                        if ((Boolean) message.obj) {
+                            persistSwitchSetting(true);
+                        }
+                        // We will continue turn the BT on all the way to the BluetoothOn state
+                        deferMessage(obtainMessage(TURN_ON_CONTINUE));
+                    } else {
+                        Log.e(TAG, "failed to prepare bluetooth, abort turning on");
+                        transitionTo(mPowerOff);
+                        broadcastState(BluetoothAdapter.STATE_OFF);
+                    }
+                    break;
+                case TURN_HOT:
+                    if (prepareBluetooth()) {
+                        transitionTo(mPreWarmUp);
+                    }
+                    break;
+                case AIRPLANE_MODE_OFF:
+                    if (getBluetoothPersistedSetting()) {
+                        // starts turning on BT module, broadcast this out
+                        broadcastState(BluetoothAdapter.STATE_TURNING_ON);
+                        if (prepareBluetooth()) {
+                            // We will continue turn the BT on all the way to the BluetoothOn state
+                            deferMessage(obtainMessage(TURN_ON_CONTINUE));
+                            transitionTo(mPreWarmUp);
+                        } else {
+                            Log.e(TAG, "failed to prepare bluetooth, abort turning on");
+                            transitionTo(mPowerOff);
+                            broadcastState(BluetoothAdapter.STATE_OFF);
+                        }
+                    } else if (mContext.getResources().getBoolean
+                            (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch) &&
+                            is_hot_off_enabled()) {
+                        sendMessage(TURN_HOT);
+                    }
+                    break;
+                case PER_PROCESS_TURN_ON:
+                    if (prepareBluetooth()) {
+                        transitionTo(mPreWarmUp);
+                    }
+                    deferMessage(obtainMessage(PER_PROCESS_TURN_ON));
+                    break;
+                case PER_PROCESS_TURN_OFF:
+                    perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
+                    break;
+                case USER_TURN_OFF:
+                    Log.w(TAG, "PowerOff received: " + message.what);
+                case AIRPLANE_MODE_ON: // ignore
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+
+        /**
+         * Turn on Bluetooth Module, Load firmware, and do all the preparation
+         * needed to get the Bluetooth Module ready but keep it not discoverable
+         * and not connectable.
+         * The last step of this method sets up the local service record DB.
+         * There will be a event reporting the status of the SDP setup.
+         */
+        private boolean prepareBluetooth() {
+            if (mBluetoothService.enableNative() != 0) {
+                return false;
+            }
+
+            // try to start event loop, give 2 attempts
+            int retryCount = 2;
+            boolean eventLoopStarted = false;
+            while ((retryCount-- > 0) && !eventLoopStarted) {
+                mEventLoop.start();
+                // it may take a moment for the other thread to do its
+                // thing.  Check periodically for a while.
+                int pollCount = 5;
+                while ((pollCount-- > 0) && !eventLoopStarted) {
+                    if (mEventLoop.isEventLoopRunning()) {
+                        eventLoopStarted = true;
+                        break;
+                    }
+                    try {
+                        Thread.sleep(100);
+                    } catch (InterruptedException e) {
+                        log("prepareBluetooth sleep interrupted: " + pollCount);
+                        break;
+                    }
+                }
+            }
+
+            if (!eventLoopStarted) {
+                mBluetoothService.disableNative();
+                return false;
+            }
+
+            // get BluetoothService ready
+            if (!mBluetoothService.prepareBluetooth()) {
+                mEventLoop.stop();
+                mBluetoothService.disableNative();
+                return false;
+            }
+
+            sendMessageDelayed(PREPARE_BLUETOOTH_TIMEOUT, PREPARE_BLUETOOTH_TIMEOUT_TIME);
+            startHcidump();
+            return true;
+        }
+    }
+
+    /**
+     * Turning on Bluetooth module's power, loading firmware, starting
+     * event loop thread to listen on Bluetooth module event changes.
+     */
+    private class PreWarmUp extends State {
+
+        @Override
+        public void enter() {
+            if (DBG) log("Enter PreWarmUp: " + getCurrentMessage().what);
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("PreWarmUp process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch(message.what) {
+                case SERVICE_RECORD_LOADED:
+                    transitionTo(mWarmUp);
+                    break;
+                case PREPARE_BLUETOOTH_TIMEOUT:
+                    Log.e(TAG, "Bluetooth adapter SDP failed to load");
+                    shutoffBluetooth();
+                    transitionTo(mPowerOff);
+                    broadcastState(BluetoothAdapter.STATE_OFF);
+                    break;
+                case USER_TURN_ON: // handle this at HotOff state
+                case TURN_ON_CONTINUE: // Once in HotOff state, continue turn bluetooth
+                                       // on to the BluetoothOn state
+                case AIRPLANE_MODE_ON:
+                case AIRPLANE_MODE_OFF:
+                case PER_PROCESS_TURN_ON:
+                case PER_PROCESS_TURN_OFF:
+                case POWER_STATE_CHANGED: // handle this at WarmUp state
+                    deferMessage(message);
+                    break;
+                case USER_TURN_OFF:
+                    Log.w(TAG, "WarmUp received: " + message.what);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+
+    }
+
+    /**
+     * Turn on Bluetooth Module, Load firmware, and SDP loaded.
+     */
+    private class WarmUp extends State {
+
+        @Override
+        public void enter() {
+            if (DBG) log("Enter WarmUp: " + getCurrentMessage().what);
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("WarmUp process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch(message.what) {
+                case POWER_STATE_CHANGED:
+                    if (!((Boolean) message.obj)) {
+                        removeMessages(PREPARE_BLUETOOTH_TIMEOUT);
+                        try {
+                            Thread.sleep(100);
+                        } catch (InterruptedException e) {
+                            e.printStackTrace();
+                        }
+                        transitionTo(mHotOff);
+                    }
+                    break;
+                case PREPARE_BLUETOOTH_TIMEOUT:
+                    Log.e(TAG, "Bluetooth switch not connectable failed");
+                    shutoffBluetooth();
+                    transitionTo(mPowerOff);
+                    broadcastState(BluetoothAdapter.STATE_OFF);
+                    break;
+                case USER_TURN_ON: // handle this at HotOff state
+                case TURN_ON_CONTINUE: // Once in HotOff state, continue turn bluetooth
+                                       // on to the BluetoothOn state
+                case AIRPLANE_MODE_ON:
+                case AIRPLANE_MODE_OFF:
+                case PER_PROCESS_TURN_ON:
+                case PER_PROCESS_TURN_OFF:
+                    deferMessage(message);
+                    break;
+                case USER_TURN_OFF:
+                    Log.w(TAG, "WarmUp received: " + message.what);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+
+    }
+
+    /**
+     * Bluetooth Module has powered, firmware loaded, event loop started,
+     * SDP loaded, but the modules stays non-discoverable and
+     * non-connectable.
+     */
+    private class HotOff extends State {
+        @Override
+        public void enter() {
+            if (DBG) log("Enter HotOff: " + getCurrentMessage().what);
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("HotOff process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch(message.what) {
+                case USER_TURN_ON:
+                    broadcastState(BluetoothAdapter.STATE_TURNING_ON);
+                    if ((Boolean) message.obj) {
+                        persistSwitchSetting(true);
+                    }
+                    // let it fall to TURN_ON_CONTINUE:
+                    //$FALL-THROUGH$
+                case TURN_ON_CONTINUE:
+                    // Start the BTC module and wait for it to come up
+                    SystemProperties.set("bluetooth.isEnabled","true");
+                    try {
+                         Thread.sleep(200);
+                    } catch (InterruptedException e) {
+                         log("Sleep interrupted: BTC is not yet up, might miss some of the events");
+                    }
+                    mBluetoothService.switchConnectable(true);
+                    transitionTo(mSwitching);
+                    break;
+                case AIRPLANE_MODE_ON:
+                case TURN_COLD:
+                    finishSwitchingOff();
+                    shutoffBluetooth();
+                    transitionTo(mPowerOff);
+                    broadcastState(BluetoothAdapter.STATE_OFF);
+                    break;
+                case AIRPLANE_MODE_OFF:
+                    if (getBluetoothPersistedSetting()) {
+                        broadcastState(BluetoothAdapter.STATE_TURNING_ON);
+                        transitionTo(mSwitching);
+                        mBluetoothService.switchConnectable(true);
+                    }
+                    break;
+                case PER_PROCESS_TURN_ON:
+                    transitionTo(mPerProcessState);
+
+                    // Resend the PER_PROCESS_TURN_ON message so that the callback
+                    // can be sent through.
+                    deferMessage(message);
+
+                    mBluetoothService.switchConnectable(true);
+                    break;
+                case PER_PROCESS_TURN_OFF:
+                    perProcessCallback(false, (IBluetoothStateChangeCallback)message.obj);
+                    break;
+                case USER_TURN_OFF: // ignore
+                    break;
+                case POWER_STATE_CHANGED:
+                    if ((Boolean) message.obj) {
+                        recoverStateMachine(TURN_HOT, null);
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+
+    }
+
+    private class Switching extends State {
+
+        @Override
+        public void enter() {
+            if (DBG) log("Enter Switching: " + getCurrentMessage().what);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            log("Switching process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch(message.what) {
+                case SCAN_MODE_CHANGED:
+                    // This event matches mBluetoothService.switchConnectable action
+                    if (mPublicState == BluetoothAdapter.STATE_TURNING_ON) {
+                        // set pairable if it's not
+                        mBluetoothService.setPairable();
+                        mBluetoothService.initBluetoothAfterTurningOn();
+                        transitionTo(mBluetoothOn);
+                        broadcastState(BluetoothAdapter.STATE_ON);
+                        // run bluetooth now that it's turned on
+                        // Note runBluetooth should be called only in adapter STATE_ON
+                        mBluetoothService.runBluetooth();
+                    }
+                    break;
+                case POWER_STATE_CHANGED:
+                    removeMessages(POWER_DOWN_TIMEOUT);
+                    if (!((Boolean) message.obj)) {
+                        if (mPublicState == BluetoothAdapter.STATE_TURNING_OFF) {
+                            finishSwitchingOff();
+                            transitionTo(mHotOff);
+                            if (!mContext.getResources().getBoolean
+                            (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch) ||
+                            !is_hot_off_enabled()) {
+                                deferMessage(obtainMessage(TURN_COLD));
+                            } else {
+                                broadcastState(BluetoothAdapter.STATE_OFF);
+                            }
+                        }
+                    } else {
+                        if (mPublicState != BluetoothAdapter.STATE_TURNING_ON) {
+                            if (mContext.getResources().getBoolean
+                            (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch) &&
+                            is_hot_off_enabled()) {
+                                recoverStateMachine(TURN_HOT, null);
+                            } else {
+                                recoverStateMachine(TURN_COLD, null);
+                            }
+                        }
+                    }
+                    break;
+                case ALL_DEVICES_DISCONNECTED:
+                    if (mPublicState == BluetoothAdapter.STATE_TURNING_OFF) {
+                        removeMessages(DEVICES_DISCONNECT_TIMEOUT);
+                        mBluetoothService.switchConnectable(false);
+                        sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
+                    } else {
+                        log("Ignore unexpected devices disconnected message");
+                    }
+                    break;
+                case DEVICES_DISCONNECT_TIMEOUT:
+                    sendMessage(ALL_DEVICES_DISCONNECTED);
+                    // reset the hardware for error recovery
+                    Log.e(TAG, "Devices failed to disconnect, reseting...");
+                    deferMessage(obtainMessage(TURN_COLD));
+                    if (mContext.getResources().getBoolean
+                        (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch) &&
+                        is_hot_off_enabled()) {
+                        deferMessage(obtainMessage(TURN_HOT));
+                    }
+                    break;
+                case POWER_DOWN_TIMEOUT:
+                    transitionTo(mHotOff);
+                    // reset the hardware for error recovery
+                    Log.e(TAG, "Devices failed to power down, reseting...");
+                    deferMessage(obtainMessage(TURN_COLD));
+                    if (mContext.getResources().getBoolean
+                        (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch) &&
+                        is_hot_off_enabled()) {
+                        deferMessage(obtainMessage(TURN_HOT));
+                    }
+                    break;
+                case USER_TURN_ON:
+                case AIRPLANE_MODE_OFF:
+                case AIRPLANE_MODE_ON:
+                case PER_PROCESS_TURN_ON:
+                case PER_PROCESS_TURN_OFF:
+                case USER_TURN_OFF:
+                    deferMessage(message);
+                    break;
+
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+    }
+
+    private class BluetoothOn extends State {
+
+        @Override
+        public void enter() {
+            if (DBG) log("Enter BluetoothOn: " + getCurrentMessage().what);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            log("BluetoothOn process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch(message.what) {
+                case USER_TURN_OFF:
+                    // Broadcast intermediate state updates earlier then any operations
+                    broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
+                    if ((Boolean) message.obj) {
+                        persistSwitchSetting(false);
+                    }
+
+                    if (mBluetoothService.isDiscovering()) {
+                        mBluetoothService.cancelDiscovery();
+                    }
+                    if (!mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
+                        transitionTo(mPerProcessState);
+                        deferMessage(obtainMessage(TURN_HOT));
+                        break;
+                    }
+                    //$FALL-THROUGH$ to AIRPLANE_MODE_ON
+                case AIRPLANE_MODE_ON:
+                    broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
+                    transitionTo(mSwitching);
+                    //Checks for ACL connections count and Adapter connection state.
+                    if ((mBluetoothService.getAdapterConnectionState()
+                         != BluetoothAdapter.STATE_DISCONNECTED) ||
+                         (mBluetoothService.getAdapterConnectionCount() > 0)) {
+                        mBluetoothService.disconnectDevices();
+                        sendMessageDelayed(DEVICES_DISCONNECT_TIMEOUT,
+                                           DEVICES_DISCONNECT_TIMEOUT_TIME);
+                    } else {
+                        mBluetoothService.switchConnectable(false);
+                        sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
+                    }
+
+                    // we turn all the way to PowerOff with AIRPLANE_MODE_ON
+                    if (message.what == AIRPLANE_MODE_ON || mBluetoothService.isAirplaneModeOn()) {
+                        // We inform all the per process callbacks
+                        allProcessesCallback(false);
+                        deferMessage(obtainMessage(AIRPLANE_MODE_ON));
+                    }
+                    break;
+                case AIRPLANE_MODE_OFF:
+                case USER_TURN_ON:
+                    Log.w(TAG, "BluetoothOn received: " + message.what);
+                    break;
+                case PER_PROCESS_TURN_ON:
+                    perProcessCallback(true, (IBluetoothStateChangeCallback)message.obj);
+                    break;
+                case PER_PROCESS_TURN_OFF:
+                    perProcessCallback(false, (IBluetoothStateChangeCallback)message.obj);
+                    break;
+                case POWER_STATE_CHANGED:
+                    if ((Boolean) message.obj) {
+                        // reset the state machine and send it TURN_ON_CONTINUE message
+                        recoverStateMachine(USER_TURN_ON, false);
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+
+    }
+
+
+    private class PerProcessState extends State {
+        IBluetoothStateChangeCallback mCallback = null;
+        boolean isTurningOn = false;
+
+        @Override
+        public void enter() {
+            int what = getCurrentMessage().what;
+            if (DBG) log("Enter PerProcessState: " + what);
+
+            if (what == PER_PROCESS_TURN_ON) {
+                isTurningOn = true;
+            } else if (what == USER_TURN_OFF) {
+                isTurningOn = false;
+            } else {
+                Log.e(TAG, "enter PerProcessState: wrong msg: " + what);
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("PerProcessState process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch (message.what) {
+                case PER_PROCESS_TURN_ON:
+                    mCallback = (IBluetoothStateChangeCallback)getCurrentMessage().obj;
+
+                    // If this is not the first application call the callback.
+                    if (mBluetoothService.getNumberOfApplicationStateChangeTrackers() > 1) {
+                        perProcessCallback(true, mCallback);
+                    }
+                    break;
+                case SCAN_MODE_CHANGED:
+                    if (isTurningOn) {
+                        perProcessCallback(true, mCallback);
+                        isTurningOn = false;
+                    }
+                    break;
+                case POWER_STATE_CHANGED:
+                    removeMessages(POWER_DOWN_TIMEOUT);
+                    if (!((Boolean) message.obj)) {
+                        transitionTo(mHotOff);
+                        if (!mContext.getResources().getBoolean
+                            (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch) ||
+                            !is_hot_off_enabled()) {
+                            deferMessage(obtainMessage(TURN_COLD));
+                        }
+                    } else {
+                        if (!isTurningOn) {
+                            recoverStateMachine(TURN_COLD, null);
+                            for (IBluetoothStateChangeCallback c:
+                                     mBluetoothService.getApplicationStateChangeCallbacks()) {
+                                perProcessCallback(false, c);
+                                deferMessage(obtainMessage(PER_PROCESS_TURN_ON, c));
+                            }
+                        }
+                    }
+                    break;
+                case POWER_DOWN_TIMEOUT:
+                    transitionTo(mHotOff);
+                    Log.e(TAG, "Power-down timed out, resetting...");
+                    deferMessage(obtainMessage(TURN_COLD));
+                    if (mContext.getResources().getBoolean
+                        (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch) &&
+                        is_hot_off_enabled()) {
+                        deferMessage(obtainMessage(TURN_HOT));
+                    }
+                    break;
+                case USER_TURN_ON:
+                    broadcastState(BluetoothAdapter.STATE_TURNING_ON);
+                    persistSwitchSetting(true);
+                    mBluetoothService.initBluetoothAfterTurningOn();
+                    transitionTo(mBluetoothOn);
+                    broadcastState(BluetoothAdapter.STATE_ON);
+                    // run bluetooth now that it's turned on
+                    mBluetoothService.runBluetooth();
+                    break;
+                case TURN_HOT:
+                    broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
+                    if ((mBluetoothService.getAdapterConnectionState()
+                         != BluetoothAdapter.STATE_DISCONNECTED) ||
+                         (mBluetoothService.getAdapterConnectionCount() > 0)) {
+                        mBluetoothService.disconnectDevices();
+                        sendMessageDelayed(DEVICES_DISCONNECT_TIMEOUT,
+                                           DEVICES_DISCONNECT_TIMEOUT_TIME);
+                        break;
+                    }
+                    //$FALL-THROUGH$ all devices are already disconnected
+                case ALL_DEVICES_DISCONNECTED:
+                    removeMessages(DEVICES_DISCONNECT_TIMEOUT);
+                    finishSwitchingOff();
+                    broadcastState(BluetoothAdapter.STATE_OFF);
+                    break;
+                case DEVICES_DISCONNECT_TIMEOUT:
+                    Log.e(TAG, "Devices fail to disconnect, reseting...");
+                    transitionTo(mHotOff);
+                    deferMessage(obtainMessage(TURN_COLD));
+                    for (IBluetoothStateChangeCallback c:
+                             mBluetoothService.getApplicationStateChangeCallbacks()) {
+                        perProcessCallback(false, c);
+                        deferMessage(obtainMessage(PER_PROCESS_TURN_ON, c));
+                    }
+                    break;
+                case PER_PROCESS_TURN_OFF:
+                    perProcessCallback(false, (IBluetoothStateChangeCallback)message.obj);
+                    if (mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
+                        mBluetoothService.switchConnectable(false);
+                        sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
+                    }
+                    break;
+                case AIRPLANE_MODE_ON:
+                    mBluetoothService.switchConnectable(false);
+                    sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
+                    allProcessesCallback(false);
+                    // we turn all the way to PowerOff with AIRPLANE_MODE_ON
+                    deferMessage(obtainMessage(AIRPLANE_MODE_ON));
+                    break;
+                case USER_TURN_OFF:
+                    Log.w(TAG, "PerProcessState received: " + message.what);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+    }
+
+    private static final String HCIDUMP_PROP = "bluetooth.hcidump.enabled";
+    private void startHcidump() {
+        if (SystemProperties.getBoolean(HCIDUMP_PROP, false)) {
+            SystemService.start("hcidump");
+        }
+    }
+
+    private void stopHcidump() {
+        if (SystemProperties.getBoolean(HCIDUMP_PROP, false)) {
+            SystemService.stop("hcidump");
+        }
+    }
+
+    private void finishSwitchingOff() {
+        if (mPublicState == BluetoothAdapter.STATE_OFF) {
+            Log.i(TAG, "Already switched Off");
+            return;
+        }
+        mBluetoothService.finishDisable();
+        mBluetoothService.cleanupAfterFinishDisable();
+    }
+
+    private void shutoffBluetooth() {
+        // Stop event loop before Bluetooth Service shutoff to avoid
+        // race condition during tearing down eventloop and accessing
+        // eventloop from BluetoothService.
+        mEventLoop.stop();
+        mBluetoothService.shutoffBluetooth();
+        mBluetoothService.cleanNativeAfterShutoffBluetooth();
+        stopHcidump();
+    }
+
+    private void perProcessCallback(boolean on, IBluetoothStateChangeCallback c) {
+        if (c == null) return;
+
+        try {
+            c.onBluetoothStateChange(on);
+        } catch (RemoteException e) {}
+    }
+
+    private void allProcessesCallback(boolean on) {
+        for (IBluetoothStateChangeCallback c:
+             mBluetoothService.getApplicationStateChangeCallbacks()) {
+            perProcessCallback(on, c);
+        }
+        if (!on) {
+            mBluetoothService.clearApplicationStateChangeTracker();
+        }
+    }
+
+    /**
+     * Return the public BluetoothAdapter state
+     */
+    int getBluetoothAdapterState() {
+        return mPublicState;
+    }
+    /**
+    *Return if HOT OFF is enabled.
+    */
+    boolean is_hot_off_enabled() {
+        if (("smd".equals(SystemProperties.get("ro.qualcomm.bt.hci_transport"))) &&
+           !("ath3k".equals(SystemProperties.get("qcom.bluetooth.soc")))) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    BluetoothEventLoop getBluetoothEventLoop() {
+        return mEventLoop;
+    }
+
+    private void persistSwitchSetting(boolean setOn) {
+        long origCallerIdentityToken = Binder.clearCallingIdentity();
+        Settings.Secure.putInt(mContext.getContentResolver(),
+                               Settings.Secure.BLUETOOTH_ON,
+                               setOn ? 1 : 0);
+        Binder.restoreCallingIdentity(origCallerIdentityToken);
+    }
+
+    private boolean getBluetoothPersistedSetting() {
+        ContentResolver contentResolver = mContext.getContentResolver();
+        return (Settings.Secure.getInt(contentResolver,
+                                       Settings.Secure.BLUETOOTH_ON, 0) > 0);
+    }
+
+    private void broadcastState(int newState) {
+
+        log("Bluetooth state " + mPublicState + " -> " + newState);
+        if (mPublicState == newState) {
+            return;
+        }
+
+        Intent intent = new Intent(BluetoothAdapter.ACTION_STATE_CHANGED);
+        intent.putExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, mPublicState);
+        intent.putExtra(BluetoothAdapter.EXTRA_STATE, newState);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mPublicState = newState;
+
+        mContext.sendBroadcast(intent, BluetoothService.BLUETOOTH_PERM);
+    }
+
+    /**
+     * bluetoothd has crashed and recovered, the adapter state machine has to
+     * reset itself and try to return to previous state
+     */
+    private void recoverStateMachine(int what, Object obj) {
+        Log.e(TAG, "Get unexpected power on event, reset with: " + what);
+        transitionTo(mHotOff);
+        deferMessage(obtainMessage(TURN_COLD));
+        deferMessage(obtainMessage(what, obj));
+    }
+
+    private void dump(PrintWriter pw) {
+        IState currentState = getCurrentState();
+        if (currentState == mPowerOff) {
+            pw.println("Bluetooth OFF - power down\n");
+        } else if (currentState == mPreWarmUp) {
+            pw.println("Bluetooth OFF - pre warm up\n");
+        } else if (currentState == mWarmUp) {
+            pw.println("Bluetooth OFF - warm up\n");
+        } else if (currentState == mHotOff) {
+            pw.println("Bluetooth OFF - hot but off\n");
+        } else if (currentState == mSwitching) {
+            pw.println("Bluetooth Switching\n");
+        } else if (currentState == mBluetoothOn) {
+            pw.println("Bluetooth ON\n");
+        } else {
+            pw.println("ERROR: Bluetooth UNKNOWN STATE ");
+        }
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+}
diff --git a/bluetoothmsm/java/android/server/BluetoothBondState.java b/bluetoothmsm/java/android/server/BluetoothBondState.java
new file mode 100644
index 0000000..b5f123b
--- /dev/null
+++ b/bluetoothmsm/java/android/server/BluetoothBondState.java
@@ -0,0 +1,533 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2013 Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothHeadset;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.provider.Settings;
+import android.util.Log;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.DataInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Local cache of bonding state.
+ * We keep our own state to track the intermediate state BONDING, which
+ * bluez does not track.
+ * All addresses must be passed in upper case.
+ */
+class BluetoothBondState {
+    private static final String TAG = "BluetoothBondState";
+    private static final boolean DBG =  true;
+
+    private final HashMap<String, Integer> mState = new HashMap<String, Integer>();
+    private final HashMap<String, Integer> mPinAttempt = new HashMap<String, Integer>();
+
+    private static final String AUTO_PAIRING_BLACKLIST =
+        "/etc/bluetooth/auto_pairing.conf";
+    private static final String DYNAMIC_AUTO_PAIRING_BLACKLIST =
+        "/data/misc/bluetooth/dynamic_auto_pairing.conf";
+    private ArrayList<String> mAutoPairingAddressBlacklist;
+    private ArrayList<String> mAutoPairingExactNameBlacklist;
+    private ArrayList<String> mAutoPairingPartialNameBlacklist;
+    private ArrayList<String> mAutoPairingFixedPinZerosKeyboardList;
+    // Addresses added to blacklist dynamically based on usage.
+    private ArrayList<String> mAutoPairingDynamicAddressBlacklist;
+
+    // If this is an outgoing connection, store the address.
+    // There can be only 1 pending outgoing connection at a time,
+    private String mPendingOutgoingBonding;
+
+    private final Context mContext;
+    private final BluetoothService mService;
+    private final BluetoothInputProfileHandler mBluetoothInputProfileHandler;
+    private BluetoothA2dp mA2dpProxy;
+    private BluetoothHeadset mHeadsetProxy;
+
+    private ArrayList<String> mPairingRequestRcvd = new ArrayList<String>();
+
+    BluetoothBondState(Context context, BluetoothService service) {
+        mContext = context;
+        mService = service;
+        mBluetoothInputProfileHandler =
+            BluetoothInputProfileHandler.getInstance(mContext, mService);
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        mContext.registerReceiver(mReceiver, filter);
+        readAutoPairingData();
+    }
+
+    synchronized void setPendingOutgoingBonding(String address) {
+        mPendingOutgoingBonding = address;
+    }
+
+    public synchronized String getPendingOutgoingBonding() {
+        return mPendingOutgoingBonding;
+    }
+
+    public synchronized void initBondState() {
+        getProfileProxy();
+        loadBondState();
+    }
+
+    public synchronized void deinitBondState() {
+        closeProfileProxy();
+    }
+
+    private void loadBondState() {
+        if (mService.getBluetoothStateInternal() !=
+                BluetoothAdapter.STATE_TURNING_ON) {
+            return;
+        }
+        String val = mService.getAdapterProperties().getProperty("Devices");
+        if (val == null) {
+            return;
+        }
+        String[] bonds = val.split(",");
+        if (bonds == null) {
+            return;
+        }
+        String address = null;
+        mState.clear();
+        if (DBG) Log.d(TAG, "found " + bonds.length + " bonded devices");
+        for (String device : bonds) {
+            address = mService.getAddressFromObjectPath(device);
+            if (address == null) {
+                Log.e(TAG, "error! address is null");
+                continue;
+            }
+            String pairState = mService.getUpdatedRemoteDeviceProperty(address, "Paired");
+            Log.d(TAG, "The paired state of the remote device is " + pairState);
+            if (pairState == null) {
+                Log.e(TAG, "error! pairState is null");
+                continue;
+            }
+            if(pairState.equals("true")) {
+                Log.d(TAG, "The paired state of the remote device is true");
+                mState.put(address.toUpperCase(), BluetoothDevice.BOND_BONDED);
+            } else {
+                BluetoothClass btClass = new BluetoothClass(mService.getRemoteClass(address));
+                int btDeviceClass = btClass.getDeviceClass();
+                if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_POINTING) {
+                    Log.d(TAG, "Its a HID pointing device, updating bond state as bonded");
+                    mState.put(address.toUpperCase(), BluetoothDevice.BOND_BONDED);
+                }
+            }
+        }
+    }
+
+    public synchronized void setBondState(String address, int state) {
+        setBondState(address, state, 0);
+    }
+
+    /** reason is ignored unless state == BOND_NOT_BONDED */
+    public synchronized void setBondState(String address, int state, int reason) {
+        if (DBG) Log.d(TAG, "setBondState " + "address" + " " + state + "reason: " + reason);
+
+        int oldState = getBondState(address);
+        if (oldState == state) {
+            return;
+        }
+
+        // Check if this was a pending outgoing bonding.
+        // If yes, reset the state.
+        if (oldState == BluetoothDevice.BOND_BONDING) {
+            if (address.equals(mPendingOutgoingBonding)) {
+                mPendingOutgoingBonding = null;
+            }
+        }
+
+        if (state == BluetoothDevice.BOND_BONDED) {
+            boolean setTrust = false;
+            if (mPairingRequestRcvd.contains(address)) setTrust = true;
+
+            mService.addProfileState(address, setTrust);
+            mPairingRequestRcvd.remove(address);
+
+        } else if (state == BluetoothDevice.BOND_BONDING) {
+            if (mA2dpProxy == null || mHeadsetProxy == null) {
+                getProfileProxy();
+            }
+        } else if (state == BluetoothDevice.BOND_NONE) {
+            mPairingRequestRcvd.remove(address);
+            mService.removeProfileState(address);
+        }
+
+        setProfilePriorities(address, state);
+
+        if (DBG) {
+            Log.d(TAG, address + " bond state " + oldState + " -> " + state
+                + " (" + reason + ")");
+        }
+        Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mService.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, state);
+        intent.putExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, oldState);
+        if (state == BluetoothDevice.BOND_NONE) {
+            if (reason <= 0) {
+                Log.w(TAG, "setBondState() called to unbond device, but reason code is " +
+                      "invalid. Overriding reason code with BOND_RESULT_REMOVED");
+                reason = BluetoothDevice.UNBOND_REASON_REMOVED;
+            }
+            intent.putExtra(BluetoothDevice.EXTRA_REASON, reason);
+            mState.remove(address);
+        } else {
+            mState.put(address, state);
+        }
+
+        mContext.sendBroadcast(intent, BluetoothService.BLUETOOTH_PERM);
+    }
+
+    public boolean isAutoPairingBlacklisted(String address) {
+        if (mAutoPairingAddressBlacklist != null) {
+            for (String blacklistAddress : mAutoPairingAddressBlacklist) {
+                if (address.startsWith(blacklistAddress)) return true;
+            }
+        }
+
+        if (mAutoPairingDynamicAddressBlacklist != null) {
+            for (String blacklistAddress: mAutoPairingDynamicAddressBlacklist) {
+                if (address.equals(blacklistAddress)) return true;
+            }
+        }
+
+        String name = mService.getRemoteName(address);
+        if (name != null) {
+            if (mAutoPairingExactNameBlacklist != null) {
+                for (String blacklistName : mAutoPairingExactNameBlacklist) {
+                    if (name.equals(blacklistName)) return true;
+                }
+            }
+
+            if (mAutoPairingPartialNameBlacklist != null) {
+                for (String blacklistName : mAutoPairingPartialNameBlacklist) {
+                    if (name.startsWith(blacklistName)) return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public boolean isFixedPinZerosAutoPairKeyboard(String address) {
+        // Note: the meaning of blacklist is reversed in this case.
+        // If its in the list, we can go ahead and auto pair since
+        // by default keyboard should have a variable PIN that we don't
+        // auto pair using 0000.
+        if (mAutoPairingFixedPinZerosKeyboardList != null) {
+            for (String blacklistAddress : mAutoPairingFixedPinZerosKeyboardList) {
+                if (address.startsWith(blacklistAddress)) return true;
+            }
+        }
+        return false;
+    }
+
+    public synchronized int getBondState(String address) {
+        Integer state = mState.get(address);
+        if (state == null) {
+            return BluetoothDevice.BOND_NONE;
+        }
+        return state.intValue();
+    }
+
+    /*package*/ synchronized String[] listInState(int state) {
+        ArrayList<String> result = new ArrayList<String>(mState.size());
+        for (Map.Entry<String, Integer> e : mState.entrySet()) {
+            if (e.getValue().intValue() == state) {
+                result.add(e.getKey());
+            }
+        }
+        return result.toArray(new String[result.size()]);
+    }
+
+    public synchronized void addAutoPairingFailure(String address) {
+        if (mAutoPairingDynamicAddressBlacklist == null) {
+            mAutoPairingDynamicAddressBlacklist = new ArrayList<String>();
+        }
+
+        updateAutoPairingData(address);
+        mAutoPairingDynamicAddressBlacklist.add(address);
+    }
+
+    public synchronized boolean isAutoPairingAttemptsInProgress(String address) {
+        return getAttempt(address) != 0;
+    }
+
+    public synchronized void clearPinAttempts(String address) {
+        if (DBG) Log.d(TAG, "clearPinAttempts: " + address);
+
+        mPinAttempt.remove(address);
+    }
+
+    public synchronized boolean hasAutoPairingFailed(String address) {
+        if (mAutoPairingDynamicAddressBlacklist == null) return false;
+
+        return mAutoPairingDynamicAddressBlacklist.contains(address);
+    }
+
+    public synchronized int getAttempt(String address) {
+        Integer attempt = mPinAttempt.get(address);
+        if (attempt == null) {
+            return 0;
+        }
+        return attempt.intValue();
+    }
+
+    public synchronized void attempt(String address) {
+        Integer attempt = mPinAttempt.get(address);
+        int newAttempt;
+        if (attempt == null) {
+            newAttempt = 1;
+        } else {
+            newAttempt = attempt.intValue() + 1;
+        }
+        if (DBG) Log.d(TAG, "attemp newAttempt: " + newAttempt);
+
+        mPinAttempt.put(address, new Integer(newAttempt));
+    }
+
+    private void getProfileProxy() {
+        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+
+        if (mA2dpProxy == null) {
+            bluetoothAdapter.getProfileProxy(mContext, mProfileServiceListener,
+                                             BluetoothProfile.A2DP);
+        }
+
+        if (mHeadsetProxy == null) {
+            bluetoothAdapter.getProfileProxy(mContext, mProfileServiceListener,
+                                             BluetoothProfile.HEADSET);
+        }
+    }
+
+    private void closeProfileProxy() {
+        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+
+        if (mA2dpProxy != null) {
+            bluetoothAdapter.closeProfileProxy(BluetoothProfile.A2DP, mA2dpProxy);
+        }
+
+        if (mHeadsetProxy != null) {
+            bluetoothAdapter.closeProfileProxy(BluetoothProfile.HEADSET, mHeadsetProxy);
+        }
+    }
+
+    private BluetoothProfile.ServiceListener mProfileServiceListener =
+        new BluetoothProfile.ServiceListener() {
+
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            if (profile == BluetoothProfile.A2DP) {
+                mA2dpProxy = (BluetoothA2dp) proxy;
+            } else if (profile == BluetoothProfile.HEADSET) {
+                mHeadsetProxy = (BluetoothHeadset) proxy;
+            }
+        }
+
+        public void onServiceDisconnected(int profile) {
+            if (profile == BluetoothProfile.A2DP) {
+                if (mA2dpProxy != null) {
+                    BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+                    bluetoothAdapter.closeProfileProxy(BluetoothProfile.A2DP, mA2dpProxy);
+                    mA2dpProxy = null;
+                }
+            } else if (profile == BluetoothProfile.HEADSET) {
+                if (mHeadsetProxy != null) {
+                    BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+                    bluetoothAdapter.closeProfileProxy(BluetoothProfile.HEADSET, mHeadsetProxy);
+                    mHeadsetProxy = null;
+                }
+            }
+        }
+    };
+
+    private void copyAutoPairingData() {
+        FileInputStream in = null;
+        FileOutputStream out = null;
+        try {
+            File file = new File(DYNAMIC_AUTO_PAIRING_BLACKLIST);
+            if (file.exists()) return;
+
+            in = new FileInputStream(AUTO_PAIRING_BLACKLIST);
+            out= new FileOutputStream(DYNAMIC_AUTO_PAIRING_BLACKLIST);
+
+            byte[] buf = new byte[1024];
+            int len;
+            while ((len = in.read(buf)) > 0) {
+                out.write(buf, 0, len);
+            }
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "FileNotFoundException: copyAutoPairingData " + e);
+        } catch (IOException e) {
+            Log.e(TAG, "IOException: copyAutoPairingData " + e);
+        } finally {
+             try {
+                 if (in != null) in.close();
+                 if (out != null) out.close();
+             } catch (IOException e) {}
+        }
+    }
+
+    synchronized public void readAutoPairingData() {
+        if (mAutoPairingAddressBlacklist != null) return;
+        copyAutoPairingData();
+        FileInputStream fstream = null;
+        try {
+            fstream = new FileInputStream(DYNAMIC_AUTO_PAIRING_BLACKLIST);
+            DataInputStream in = new DataInputStream(fstream);
+            BufferedReader file = new BufferedReader(new InputStreamReader(in));
+            String line;
+            while((line = file.readLine()) != null) {
+                line = line.trim();
+                if (line.length() == 0 || line.startsWith("//")) continue;
+                String[] value = line.split("=");
+                if (value != null && value.length == 2) {
+                    String[] val = value[1].split(",");
+                    if (value[0].equalsIgnoreCase("AddressBlacklist")) {
+                        mAutoPairingAddressBlacklist =
+                            new ArrayList<String>(Arrays.asList(val));
+                    } else if (value[0].equalsIgnoreCase("ExactNameBlacklist")) {
+                        mAutoPairingExactNameBlacklist =
+                            new ArrayList<String>(Arrays.asList(val));
+                    } else if (value[0].equalsIgnoreCase("PartialNameBlacklist")) {
+                        mAutoPairingPartialNameBlacklist =
+                            new ArrayList<String>(Arrays.asList(val));
+                    } else if (value[0].equalsIgnoreCase("FixedPinZerosKeyboardBlacklist")) {
+                        mAutoPairingFixedPinZerosKeyboardList =
+                            new ArrayList<String>(Arrays.asList(val));
+                    } else if (value[0].equalsIgnoreCase("DynamicAddressBlacklist")) {
+                        mAutoPairingDynamicAddressBlacklist =
+                            new ArrayList<String>(Arrays.asList(val));
+                    } else {
+                        Log.e(TAG, "Error parsing Auto pairing blacklist file");
+                    }
+                }
+            }
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "FileNotFoundException: readAutoPairingData " + e);
+        } catch (IOException e) {
+            Log.e(TAG, "IOException: readAutoPairingData " + e);
+        } finally {
+            if (fstream != null) {
+                try {
+                    fstream.close();
+                } catch (IOException e) {
+                    // Ignore
+                }
+            }
+        }
+    }
+
+    // This function adds a bluetooth address to the auto pairing blacklist
+    // file. These addresses are added to DynamicAddressBlacklistSection
+    private void updateAutoPairingData(String address) {
+        BufferedWriter out = null;
+        try {
+            out = new BufferedWriter(new FileWriter(DYNAMIC_AUTO_PAIRING_BLACKLIST, true));
+            StringBuilder str = new StringBuilder();
+            if (mAutoPairingDynamicAddressBlacklist.size() == 0) {
+                str.append("DynamicAddressBlacklist=");
+            }
+            str.append(address);
+            str.append(",");
+            out.write(str.toString());
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "FileNotFoundException: updateAutoPairingData " + e);
+        } catch (IOException e) {
+            Log.e(TAG, "IOException: updateAutoPairingData " + e);
+        } finally {
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException e) {
+                    // Ignore
+                }
+            }
+        }
+    }
+
+    // Set service priority of Hid, A2DP and Headset profiles depending on
+    // the bond state change
+    private void setProfilePriorities(String address, int state) {
+        BluetoothDevice remoteDevice = mService.getRemoteDevice(address);
+        // HID is handled by BluetoothService
+        mBluetoothInputProfileHandler.setInitialInputDevicePriority(remoteDevice, state);
+
+        // Set service priority of A2DP and Headset
+        // We used to do the priority change in the 2 services after the broadcast
+        //   intent reach them. But that left a small time gap that could reject
+        //   incoming connection due to undefined priorities.
+        if (state == BluetoothDevice.BOND_BONDED) {
+            if (mA2dpProxy != null &&
+                  mA2dpProxy.getPriority(remoteDevice) == BluetoothProfile.PRIORITY_UNDEFINED) {
+                mA2dpProxy.setPriority(remoteDevice, BluetoothProfile.PRIORITY_ON);
+            }
+
+            if (mHeadsetProxy != null &&
+                  mHeadsetProxy.getPriority(remoteDevice) == BluetoothProfile.PRIORITY_UNDEFINED) {
+                mHeadsetProxy.setPriority(remoteDevice, BluetoothProfile.PRIORITY_ON);
+            }
+        } else if (state == BluetoothDevice.BOND_NONE) {
+            if (mA2dpProxy != null) {
+                mA2dpProxy.setPriority(remoteDevice, BluetoothProfile.PRIORITY_UNDEFINED);
+            }
+            if (mHeadsetProxy != null) {
+                mHeadsetProxy.setPriority(remoteDevice, BluetoothProfile.PRIORITY_UNDEFINED);
+            }
+        }
+
+        if (mA2dpProxy == null || mHeadsetProxy == null) {
+            Log.e(TAG, "Proxy is null:" + mA2dpProxy + ":" + mHeadsetProxy);
+        }
+    }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent == null) return;
+
+            String action = intent.getAction();
+            if (action.equals(BluetoothDevice.ACTION_PAIRING_REQUEST)) {
+                BluetoothDevice dev = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                String address = dev.getAddress();
+                mPairingRequestRcvd.add(address);
+            }
+        }
+    };
+}
diff --git a/bluetoothmsm/java/android/server/BluetoothDeviceProperties.java b/bluetoothmsm/java/android/server/BluetoothDeviceProperties.java
new file mode 100644
index 0000000..75b6d93
--- /dev/null
+++ b/bluetoothmsm/java/android/server/BluetoothDeviceProperties.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.os.ParcelUuid;
+import android.util.Log;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+class BluetoothDeviceProperties {
+
+    private static final String TAG = "BluetoothDeviceProperties";
+
+    private final HashMap<String, Map<String, String>> mPropertiesMap;
+    private final BluetoothService mService;
+
+    BluetoothDeviceProperties(BluetoothService service) {
+        mPropertiesMap = new HashMap<String, Map<String, String>>();
+        mService = service;
+    }
+
+    Map<String, String> addProperties(String address,
+                         String[] properties, boolean isNewDevice) {
+        /*
+         * We get a DeviceFound signal every time RSSI changes or name changes.
+         * Don't create a new Map object every time.
+         */
+        Map<String, String> propertyValues;
+        synchronized(mPropertiesMap) {
+            propertyValues = mPropertiesMap.get(address);
+            if (propertyValues == null) {
+                propertyValues = new HashMap<String, String>();
+            }
+
+            for (int i = 0; i < properties.length; i++) {
+                String name = properties[i];
+                String newValue = null;
+                int len;
+                if (name == null) {
+                    Log.e(TAG, "Error: Remote Device Property at index "
+                        + i + " is null");
+                    continue;
+                }
+                if (name.equals("UUIDs") || name.equals("Nodes") || name.equals("Services")) {
+                    StringBuilder str = new StringBuilder();
+                    len = Integer.valueOf(properties[++i]);
+                    for (int j = 0; j < len; j++) {
+                        str.append(properties[++i]);
+                        str.append(",");
+                    }
+                    if (len > 0) {
+                        newValue = str.toString();
+                    }
+                } else {
+                    newValue = properties[++i];
+                }
+
+                propertyValues.put(name, newValue);
+            }
+            mPropertiesMap.put(address, propertyValues);
+        }
+        // We have added a new remote device or updated its properties.
+        // Also update the serviceChannel cache in case of update only.
+        if (!isNewDevice) {
+            mService.updateDeviceServiceChannelCache(address);
+        }
+        return propertyValues;
+    }
+
+    void setProperty(String address, String name, String value) {
+        synchronized(mPropertiesMap) {
+            Map <String, String> propVal = mPropertiesMap.get(address);
+            if (propVal != null) {
+                propVal.put(name, value);
+                mPropertiesMap.put(address, propVal);
+            } else {
+                Log.e(TAG, "setRemoteDeviceProperty for a device not in cache:" + address);
+            }
+        }
+    }
+
+    boolean isInCache(String address) {
+        synchronized (mPropertiesMap) {
+            return (mPropertiesMap.get(address) != null);
+        }
+    }
+
+    boolean isEmpty() {
+        synchronized (mPropertiesMap) {
+            return mPropertiesMap.isEmpty();
+        }
+    }
+
+    Set<String> keySet() {
+        synchronized (mPropertiesMap) {
+            return mPropertiesMap.keySet();
+        }
+    }
+
+    String getProperty(String address, String property) {
+        synchronized(mPropertiesMap) {
+            Map<String, String> properties = mPropertiesMap.get(address);
+            if (properties != null) {
+                return properties.get(property);
+            } else {
+                // Query for remote device properties, again.
+                // We will need to reload the cache when we switch Bluetooth on / off
+                // or if we crash.
+                properties = updateCache(address);
+                if (properties != null) {
+                    return properties.get(property);
+                }
+            }
+        }
+        Log.e(TAG, "getRemoteDeviceProperty: " + property + " not present: " + address);
+        return null;
+    }
+
+    Map<String, String> updateCache(String address) {
+        String[] propValues = mService.getRemoteDeviceProperties(address);
+        if (propValues != null) {
+            return addProperties(address, propValues, false);
+        }
+        return null;
+    }
+}
diff --git a/bluetoothmsm/java/android/server/BluetoothEventLoop.java b/bluetoothmsm/java/android/server/BluetoothEventLoop.java
new file mode 100644
index 0000000..b4e75e1
--- /dev/null
+++ b/bluetoothmsm/java/android/server/BluetoothEventLoop.java
@@ -0,0 +1,1610 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2010-2012 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHealth;
+import android.bluetooth.BluetoothInputDevice;
+import android.bluetooth.BluetoothPan;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothUuid;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Handler;
+import android.os.Message;
+import android.os.ParcelUuid;
+import android.os.PowerManager;
+import android.util.Log;
+import android.content.IntentFilter;
+import android.content.BroadcastReceiver;
+
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.ArrayList;
+
+
+/**
+ * @hide
+ */
+class BluetoothEventLoop {
+    private static final String TAG = "BluetoothEventLoop";
+    private static final boolean DBG = true;
+
+    private int mNativeData;
+    private Thread mThread;
+    private boolean mStarted;
+    private boolean mInterrupted;
+
+    private final HashMap<String, Integer> mPasskeyAgentRequestData;
+    private final HashMap<String, Integer> mAuthorizationAgentRequestData;
+    private final HashMap<String, Integer> mAuthorizationRequestData;
+    private final List<Integer> mGattRequestData;
+    private final BluetoothService mBluetoothService;
+    private final BluetoothAdapter mAdapter;
+    private final BluetoothAdapterStateMachine mBluetoothState;
+    private BluetoothA2dp mA2dp;
+    private final Context mContext;
+    // The WakeLock is used for bringing up the LCD during a pairing request
+    // from remote device when Android is in Suspend state.
+    private PowerManager.WakeLock mWakeLock;
+
+    private static final int EVENT_PAIRING_CONSENT_DELAYED_ACCEPT = 1;
+    private static final int EVENT_AGENT_CANCEL = 2;
+    private static final int EVENT_PAIRING_TIMEOUT = 3;
+    private static final int EVENT_SAP_USER_TIMEOUT = 4;
+    private static final int EVENT_DUN_USER_TIMEOUT = 5;
+
+    private static final int CREATE_DEVICE_ALREADY_EXISTS = 1;
+    private static final int CREATE_DEVICE_SUCCESS = 0;
+    private static final int CREATE_DEVICE_FAILED = -1;
+
+    // The 1.2/2.0 incoming pairing request would timeout in 30 seconds at LMP since LMP
+    // Response time out is 30 seconds. Setting the INCOMING_PAIRING_TIMEOUT to 26 seconds
+    // to make sure that the pairing clean up happens from the HOST side.
+    private static final int INCOMING_PAIRING_TIMEOUT = 26000;
+    private static final int USER_CONFIRM_TIMEOUT = 30000;
+    private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
+    private static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
+
+    // package and class name to which we send intent to check sap access permission
+    private static final String ACCESS_REQUEST_PACKAGE = "com.android.settings";
+    private static final String ACCESS_REQUEST_CLASS =
+                         "com.android.settings.bluetooth.BluetoothPermissionRequest";
+
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            String address = null;
+            switch (msg.what) {
+            case EVENT_PAIRING_CONSENT_DELAYED_ACCEPT:
+                address = (String)msg.obj;
+                if (address != null) {
+                    mBluetoothService.setPairingConfirmation(address, true);
+                }
+                break;
+            case EVENT_AGENT_CANCEL:
+                // Set the Bond State to BOND_NONE.
+                // We always have only 1 device in BONDING state.
+                String[] devices = mBluetoothService.listInState(BluetoothDevice.BOND_BONDING);
+                if (devices.length == 0) {
+                    break;
+                } else if (devices.length > 1) {
+                    Log.e(TAG, " There is more than one device in the Bonding State");
+                    break;
+                }
+                address = devices[0];
+                mBluetoothService.setBondState(address,
+                        BluetoothDevice.BOND_NONE,
+                        BluetoothDevice.UNBOND_REASON_REMOTE_AUTH_CANCELED);
+                break;
+            case EVENT_PAIRING_TIMEOUT:
+                address = (String) msg.obj;
+                Log.d(TAG, "Cancelling bond process");
+                mBluetoothService.cancelBondProcess(address);
+                break;
+            case EVENT_SAP_USER_TIMEOUT:
+                Log.d(TAG, "SAP user Authorization timeout");
+                Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL);
+                intent.setClassName(ACCESS_REQUEST_PACKAGE, ACCESS_REQUEST_CLASS);
+                      intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE,
+                      BluetoothDevice.REQUEST_TYPE_SIM_ACCESS);
+                mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+                break;
+          case EVENT_DUN_USER_TIMEOUT:
+                Log.d(TAG, "DUN user Authorization timeout");
+
+                Intent intent1 = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL);
+                intent1.setClassName(ACCESS_REQUEST_PACKAGE, ACCESS_REQUEST_CLASS);
+                      intent1.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE,
+                      BluetoothDevice. REQUEST_TYPE_DUN_ACCESS);
+                mContext.sendBroadcast(intent1, BLUETOOTH_ADMIN_PERM);
+
+                break;
+            }
+        }
+    };
+
+    static { classInitNative(); }
+    private static native void classInitNative();
+
+    /* package */ BluetoothEventLoop(Context context, BluetoothAdapter adapter,
+                                     BluetoothService bluetoothService,
+                                     BluetoothAdapterStateMachine bluetoothState) {
+        mBluetoothService = bluetoothService;
+        mContext = context;
+        mBluetoothState = bluetoothState;
+        mPasskeyAgentRequestData = new HashMap<String, Integer>();
+        mAuthorizationAgentRequestData = new HashMap<String, Integer>();
+        mAuthorizationRequestData = new HashMap<String, Integer>();
+        mGattRequestData = new ArrayList<Integer>();
+        mAdapter = adapter;
+        //WakeLock instantiation in BluetoothEventLoop class
+        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP
+                | PowerManager.ON_AFTER_RELEASE, TAG);
+        mWakeLock.setReferenceCounted(false);
+        initializeNativeDataNative();
+    }
+
+    /*package*/ void getProfileProxy() {
+        mAdapter.getProfileProxy(mContext, mProfileServiceListener, BluetoothProfile.A2DP);
+        mAdapter.getProfileProxy(mContext, mProfileServiceListener, BluetoothProfile.INPUT_DEVICE);
+    }
+
+    private BluetoothProfile.ServiceListener mProfileServiceListener =
+        new BluetoothProfile.ServiceListener() {
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            if (profile == BluetoothProfile.A2DP) {
+                mA2dp = (BluetoothA2dp) proxy;
+            }
+        }
+        public void onServiceDisconnected(int profile) {
+            if (profile == BluetoothProfile.A2DP) {
+                mA2dp = null;
+            }
+        }
+    };
+
+
+    protected void finalize() throws Throwable {
+        try {
+            cleanupNativeDataNative();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    /* package */ HashMap<String, Integer> getPasskeyAgentRequestData() {
+        return mPasskeyAgentRequestData;
+    }
+
+    /* package */ HashMap<String, Integer> getAuthorizationAgentRequestData() {
+        return mAuthorizationAgentRequestData;
+    }
+
+    /* package */ HashMap<String, Integer> getAuthorizationRequestData() {
+        return mAuthorizationRequestData;
+    }
+
+    /* package */ List<Integer> getGattRequestData() {
+        return mGattRequestData;
+    }
+
+    /* package */ void start() {
+
+        if (!isEventLoopRunningNative()) {
+            if (DBG) log("Starting Event Loop thread");
+            startEventLoopNative();
+        }
+    }
+
+    public void stop() {
+        if (isEventLoopRunningNative()) {
+            if (DBG) log("Stopping Event Loop thread");
+            stopEventLoopNative();
+        }
+    }
+
+    public boolean isEventLoopRunning() {
+        return isEventLoopRunningNative();
+    }
+
+    private void addDevice(String address, String[] properties) {
+        BluetoothDeviceProperties deviceProperties =
+                mBluetoothService.getDeviceProperties();
+        deviceProperties.addProperties(address, properties, true);
+        String rssi = deviceProperties.getProperty(address, "RSSI");
+        String broadcaster = deviceProperties.getProperty(address, "Broadcaster");
+        String classValue = deviceProperties.getProperty(address, "Class");
+        String devType = deviceProperties.getProperty(address, "Type");
+        String name = deviceProperties.getProperty(address, "Name");
+        String addr = deviceProperties.getProperty(address, "Address");
+        String uuids = deviceProperties.getProperty(address, "UUIDs");
+        short rssiValue;
+        // For incoming connections, we don't get the RSSI value. Use a default of MIN_VALUE.
+        // If we accept the pairing, we will automatically show it at the top of the list.
+        if (rssi != null) {
+            rssiValue = (short)Integer.valueOf(rssi).intValue();
+        } else {
+            rssiValue = Short.MIN_VALUE;
+        }
+        if (classValue != null) {
+            Intent intent = new Intent(BluetoothDevice.ACTION_FOUND);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+            intent.putExtra(BluetoothDevice.EXTRA_CLASS,
+                    new BluetoothClass(Integer.valueOf(classValue)));
+            intent.putExtra(BluetoothDevice.EXTRA_RSSI, rssiValue);
+            intent.putExtra(BluetoothDevice.EXTRA_NAME, name);
+            if(uuids != null) {
+                intent.putExtra(BluetoothDevice.EXTRA_UUIDS, uuids);
+            }
+
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (devType != null) {
+            if (DBG) log("Device " + addr + " type: " + devType + " Broadcaster: " + broadcaster);
+            if ("LE".equals(devType) && "false".equals(broadcaster)) {
+                Intent intent = new Intent(BluetoothDevice.ACTION_FOUND);
+                intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+                intent.putExtra(BluetoothDevice.EXTRA_RSSI, rssiValue);
+                intent.putExtra(BluetoothDevice.EXTRA_NAME, name);
+                if(uuids != null) {
+                    intent.putExtra(BluetoothDevice.EXTRA_UUIDS, uuids);
+                }
+
+                mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+            }
+        } else {
+            log ("ClassValue: " + classValue + " for remote device: " + address + " is null");
+        }
+    }
+
+    /**
+     * Called by native code on a DeviceFound signal from org.bluez.Adapter.
+     *
+     * @param address the MAC address of the new device
+     * @param properties an array of property keys and value strings
+     *
+     * @see BluetoothDeviceProperties#addProperties(String, String[])
+     */
+    private void onDeviceFound(String address, String[] properties) {
+        if (properties == null) {
+            Log.e(TAG, "ERROR: Remote device properties are null");
+            return;
+        }
+        if (!mBluetoothService.isEnabled()) {
+            Log.e(TAG, "Bluetooth is not on");
+            return;
+        }
+
+        addDevice(address, properties);
+    }
+
+    /**
+     * Called by native code on a DeviceDisappeared signal from
+     * org.bluez.Adapter.
+     *
+     * @param address the MAC address of the disappeared device
+     */
+    private void onDeviceDisappeared(String address) {
+        Intent intent = new Intent(BluetoothDevice.ACTION_DISAPPEARED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+    }
+
+    /**
+     * Called by native code on a DisconnectRequested signal from
+     * org.bluez.Device.
+     *
+     * @param deviceObjectPath the object path for the disconnecting device
+     */
+    private void onDeviceDisconnectRequested(String deviceObjectPath) {
+        String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+        if (address == null) {
+            Log.e(TAG, "onDeviceDisconnectRequested: Address of the remote device in null");
+            return;
+        }
+        Intent intent = new Intent(BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+    }
+
+    /**
+     * Called by native code for the async response to a CreatePairedDevice
+     * method call to org.bluez.Adapter.
+     *
+     * @param address the MAC address of the device to pair
+     * @param result success or error result for the pairing operation
+     */
+    private void onCreatePairedDeviceResult(String address, int result) {
+        address = address.toUpperCase();
+        mBluetoothService.onCreatePairedDeviceResult(address, result);
+    }
+
+    /**
+     * Called by native code on a DeviceCreated signal from org.bluez.Adapter.
+     *
+     * @param deviceObjectPath the object path for the created device
+     */
+    private void onDeviceCreated(String deviceObjectPath) {
+        String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+        if (address == null) {
+            Log.e(TAG, "onDeviceCreated: device address null!" + " deviceObjectPath: " +
+                  deviceObjectPath);
+            return;
+        }
+        if (!mBluetoothService.isRemoteDeviceInCache(address)) {
+            // Incoming connection, we haven't seen this device, add to cache.
+
+            String[] properties = mBluetoothService.getRemoteDeviceProperties(address);
+            if (properties != null) {
+                addDevice(address, properties);
+            }
+        }
+    }
+
+    /**
+     * Called by native code on a DeviceRemoved signal from org.bluez.Adapter.
+     *
+     * @param deviceObjectPath the object path for the removed device
+     */
+    private void onDeviceRemoved(String deviceObjectPath) {
+        String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+        if (address != null) {
+            mBluetoothService.setBondState(address.toUpperCase(), BluetoothDevice.BOND_NONE,
+                BluetoothDevice.UNBOND_REASON_REMOVED);
+            mBluetoothService.clearRemoteDeviceGattServices(address);
+            mBluetoothService.setRemoteDeviceProperty(address, "UUIDs", null);
+            mBluetoothService.setRemoteDeviceProperty(address, "Services", null);
+            mBluetoothService.setRemoteDeviceProperty(address, "Trusted", "false");
+        }
+    }
+
+    /**
+     * Called by native code on a PropertyChanged signal from
+     * org.bluez.Adapter. This method is also called from
+     * {@link BluetoothAdapterStateMachine} to set the "Pairable"
+     * property when Bluetooth is enabled.
+     *
+     * @param propValues a string array containing the key and one or more
+     *  values.
+     */
+    /*package*/ void onPropertyChanged(String[] propValues) {
+        BluetoothAdapterProperties adapterProperties =
+                mBluetoothService.getAdapterProperties();
+
+        if (adapterProperties.isEmpty()) {
+            // We have got a property change before
+            // we filled up our cache.
+            adapterProperties.getAllProperties();
+        }
+        log("Property Changed: " + propValues[0] + " : " + propValues[1]);
+        String name = propValues[0];
+
+        if (name.equals("Name")) {
+            adapterProperties.setProperty(name, propValues[1]);
+            Intent intent = new Intent(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
+            intent.putExtra(BluetoothAdapter.EXTRA_LOCAL_NAME, propValues[1]);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("Pairable") || name.equals("Discoverable")) {
+            adapterProperties.setProperty(name, propValues[1]);
+
+            if (name.equals("Discoverable")) {
+                mBluetoothState.sendMessage(BluetoothAdapterStateMachine.SCAN_MODE_CHANGED);
+            }
+
+            String pairable = name.equals("Pairable") ? propValues[1] :
+                adapterProperties.getProperty("Pairable");
+            String discoverable = name.equals("Discoverable") ? propValues[1] :
+                adapterProperties.getProperty("Discoverable");
+
+            // This shouldn't happen, unless Adapter Properties are null.
+            if (pairable == null || discoverable == null)
+                return;
+
+            int mode = BluetoothService.bluezStringToScanMode(
+                    pairable.equals("true"),
+                    discoverable.equals("true"));
+            if (mode >= 0) {
+                Intent intent = new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
+                intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE, mode);
+                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+                mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+            }
+        } else if (name.equals("Discovering")) {
+            Intent intent;
+            adapterProperties.setProperty(name, propValues[1]);
+            if (propValues[1].equals("true")) {
+                intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
+            } else {
+                // Stop the discovery.
+                mBluetoothService.cancelDiscovery();
+                intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
+            }
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("Devices") || name.equals("UUIDs")) {
+            String value = null;
+            int len = Integer.valueOf(propValues[1]);
+            if (len > 0) {
+                StringBuilder str = new StringBuilder();
+                for (int i = 2; i < propValues.length; i++) {
+                    str.append(propValues[i]);
+                    str.append(",");
+                }
+                value = str.toString();
+            }
+            String adapterObjectPath = adapterProperties.getObjectPath();
+            if ((value != null)  && name.equals("UUIDs")) {
+                adapterProperties.setProperty(name, value);
+                mBluetoothService.updateBluetoothState(value);
+            } else if ((value != null) && (value.startsWith(adapterObjectPath))) {
+                // Devices Prop expect value starts with obj path
+                adapterProperties.setProperty(name, value);
+            }
+        } else if (name.equals("Powered")) {
+            mBluetoothState.sendMessage(BluetoothAdapterStateMachine.POWER_STATE_CHANGED,
+                propValues[1].equals("true") ? new Boolean(true) : new Boolean(false));
+        } else if (name.equals("DiscoverableTimeout")) {
+            adapterProperties.setProperty(name, propValues[1]);
+        } else if (name.equals("Class")) {
+            adapterProperties.setProperty(name, propValues[1]);
+        }
+    }
+
+    /**
+     * Called by native code on a PropertyChanged signal from
+     * org.bluez.Device.
+     *
+     * @param deviceObjectPath the object path for the changed device
+     * @param propValues a string array containing the key and one or more
+     *  values.
+     */
+    private void onDevicePropertyChanged(String deviceObjectPath, String[] propValues) {
+        String name = propValues[0];
+        byte[] connProp = null;
+        String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+        if (address == null) {
+            Log.e(TAG, "onDevicePropertyChanged: Address of the remote device in null");
+            return;
+        }
+
+        if (name.equals("Connected")) {
+            int strLen = propValues[1].length();
+            connProp = new byte[strLen/2];
+            for(int i = 0; i < connProp.length; i++) {
+                int pos = i * 2;
+                int value = Integer.parseInt(propValues[1].substring(pos, pos+2), 16);
+                connProp[i] = (byte) value;
+                Log.d(TAG, " Connected property at index : "
+                      + i + "is :" + connProp[i]);
+            }
+        }
+
+        if (!mBluetoothService.isEnabled()) {
+            Log.e(TAG, "Bluetooth is not enabled");
+
+            if (name.equals("Connected") && (connProp[0] == 0)) {
+                Intent intent = new Intent(BluetoothDevice.ACTION_ACL_DISCONNECTED);
+                BluetoothDevice device = mAdapter.getRemoteDevice(address);
+                mBluetoothService.sendDeviceConnectionStateChange(
+                    device, BluetoothAdapter.STATE_DISCONNECTED);
+                intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+                intent.putExtra(BluetoothDevice.EXTRA_REASON, connProp[1]);
+                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+                mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+            }
+            return;
+        }
+
+        log("Device property changed: " + address + " property: "
+            + name + " value: " + propValues[1]);
+
+        BluetoothDevice device = mAdapter.getRemoteDevice(address);
+        if (name.equals("Name")) {
+            mBluetoothService.setRemoteDeviceProperty(address, name, propValues[1]);
+            Intent intent = new Intent(BluetoothDevice.ACTION_NAME_CHANGED);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.putExtra(BluetoothDevice.EXTRA_NAME, propValues[1]);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("Alias")) {
+            mBluetoothService.setRemoteDeviceProperty(address, name, propValues[1]);
+            Intent intent = new Intent(BluetoothDevice.ACTION_ALIAS_CHANGED);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("Class")) {
+            mBluetoothService.setRemoteDeviceProperty(address, name, propValues[1]);
+            Intent intent = new Intent(BluetoothDevice.ACTION_CLASS_CHANGED);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.putExtra(BluetoothDevice.EXTRA_CLASS,
+                    new BluetoothClass(Integer.valueOf(propValues[1])));
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("RSSI")) {
+            mBluetoothService.setRemoteDeviceProperty(address, name, propValues[1]);
+            Intent intent = new Intent(BluetoothDevice.ACTION_RSSI_UPDATE);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.putExtra(BluetoothDevice.EXTRA_RSSI, propValues[1]);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("Connected")) {
+            Log.d(TAG, "Device property Connected: " + propValues[1]);
+
+            if(connProp[0] == 0)
+                mBluetoothService.setRemoteDeviceProperty(address, name, "false");
+            else
+                mBluetoothService.setRemoteDeviceProperty(address, name, "true");
+
+            Intent intent = null;
+            if (connProp[0] == 1) {
+                intent = new Intent(BluetoothDevice.ACTION_ACL_CONNECTED);
+                // Set the link timeout to 8000 slots (5 sec timeout)
+                // for bluetooth docks.
+                if (mBluetoothService.isBluetoothDock(address)) {
+                    mBluetoothService.setLinkTimeout(address, 8000);
+                }
+                mBluetoothService.sendDeviceConnectionStateChange
+                    (device, BluetoothAdapter.STATE_CONNECTED);
+            } else {
+                // Check and clean-up if bonding is in progress
+                if (mBluetoothService.getBondState(address) ==
+                        BluetoothDevice.BOND_BONDING) {
+                    mBluetoothService.setBondState(address,
+                          BluetoothDevice.BOND_NONE);
+                }
+
+                mBluetoothService.clearGattServicesRefCount(address);
+
+                if (mBluetoothService.getBondState(address) == BluetoothDevice.BOND_NONE)
+                    mBluetoothService.clearRemoteDeviceGattServices(address);
+
+                intent = new Intent(BluetoothDevice.ACTION_ACL_DISCONNECTED);
+                mBluetoothService.sendDeviceConnectionStateChange(
+                    device, BluetoothAdapter.STATE_DISCONNECTED);
+            }
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.putExtra(BluetoothDevice.EXTRA_REASON, connProp[1]);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("UUIDs")) {
+            String uuid = null;
+            int len = Integer.valueOf(propValues[1]);
+            if (len > 0) {
+                StringBuilder str = new StringBuilder();
+                for (int i = 2; i < propValues.length; i++) {
+                    str.append(propValues[i]);
+                    str.append(",");
+                }
+                uuid = str.toString();
+            }
+            mBluetoothService.setRemoteDeviceProperty(address, name, uuid);
+
+            // UUIDs have changed, query remote service channel and update cache.
+            mBluetoothService.updateDeviceServiceChannelCache(address);
+
+            mBluetoothService.sendUuidIntent(address);
+        } else if (name.equals("Services")) {
+            String services = null;
+            int len = Integer.valueOf(propValues[1]);
+            if (len > 0) {
+                StringBuilder str = new StringBuilder();
+                for (int i = 2; i < propValues.length; i++) {
+                    str.append(propValues[i]);
+                    str.append(",");
+                }
+                services = str.toString();
+            }
+            mBluetoothService.setRemoteDeviceProperty(address, name, services);
+
+            mBluetoothService.sendGattIntent(address, BluetoothDevice.GATT_RESULT_SUCCESS);
+
+        } else if (name.equals("Paired")) {
+            if (propValues[1].equals("true")) {
+                // If locally initiated pairing, we will
+                // not go to BOND_BONDED state until we have received a
+                // successful return value in onCreatePairedDeviceResult
+
+                // There can be one outgoing and one incoming pairing at the same time
+                if (!address.equals(mBluetoothService.getPendingOutgoingBonding())) {
+                    mBluetoothService.setBondState(address, BluetoothDevice.BOND_BONDED);
+                }
+            } else {
+                mBluetoothService.setBondState(address, BluetoothDevice.BOND_NONE);
+                mBluetoothService.setRemoteDeviceProperty(address, "Trusted", "false");
+            }
+        } else if (name.equals("Trusted")) {
+            if (DBG)
+                log("set trust state succeeded, value is: " + propValues[1]);
+            mBluetoothService.setRemoteDeviceProperty(address, name, propValues[1]);
+        } else if (name.equals("LeConnParams")) {
+            mBluetoothService.setRemoteDeviceProperty(address, name, propValues[1]);
+            Intent intent = new Intent(BluetoothDevice.ACTION_LE_CONN_PARAMS);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.putExtra(BluetoothDevice.EXTRA_CONN_INTERVAL, Integer.valueOf(propValues[1]));
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        }
+    }
+
+    /**
+     * Called by native code on a PropertyChanged signal from
+     * org.bluez.Input.
+     *
+     * @param path the object path for the changed input device
+     * @param propValues a string array containing the key and one or more
+     *  values.
+     */
+    private void onInputDevicePropertyChanged(String path, String[] propValues) {
+        String address = mBluetoothService.getAddressFromObjectPath(path);
+        if (address == null) {
+            Log.e(TAG, "onInputDevicePropertyChanged: Address of the remote device is null");
+            return;
+        }
+        log("Input Device : Name of Property is: " + propValues[0]);
+        boolean state = false;
+        if (propValues[1].equals("true")) {
+            state = true;
+        }
+        mBluetoothService.handleInputDevicePropertyChange(address, state);
+    }
+
+    /**
+     * Called by native code on a PropertyChanged signal from
+     * org.bluez.Network.
+     *
+     * @param deviceObjectPath the object path for the changed PAN device
+     * @param propValues a string array containing the key and one or more
+     *  values.
+     */
+    private void onPanDevicePropertyChanged(String deviceObjectPath, String[] propValues) {
+        String name = propValues[0];
+        String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+        if (address == null) {
+            Log.e(TAG, "onPanDevicePropertyChanged: Address of the remote device in null");
+            return;
+        }
+        if (DBG) {
+            log("Pan Device property changed: " + address + "  property: "
+                    + name + " value: "+ propValues[1]);
+        }
+        BluetoothDevice device = mAdapter.getRemoteDevice(address);
+        if (name.equals("Connected")) {
+            if (propValues[1].equals("false")) {
+                mBluetoothService.handlePanDeviceStateChange(device,
+                                          BluetoothPan.STATE_DISCONNECTED,
+                                          BluetoothPan.LOCAL_PANU_ROLE);
+            }
+        } else if (name.equals("Interface")) {
+            String iface = propValues[1];
+            if (!iface.equals("")) {
+                mBluetoothService.handlePanDeviceStateChange(device, iface,
+                                              BluetoothPan.STATE_CONNECTED,
+                                              BluetoothPan.LOCAL_PANU_ROLE);
+            }
+        }
+    }
+
+    private String checkAuthorizationRequestAndGetAddress(String objectPath, int nativeData) {
+        String address = mBluetoothService.getAddressFromObjectPath(objectPath);
+        if (address == null) {
+            Log.e(TAG, "Unable to get device address in checkAuthorizationRequestAndGetAddress, " +
+                  "returning null");
+            return null;
+        }
+        address = address.toUpperCase();
+        mAuthorizationRequestData.put(address, new Integer(nativeData));
+
+        if (mBluetoothService.getBluetoothState() == BluetoothAdapter.STATE_TURNING_OFF) {
+            // shutdown path
+            return null;
+        }
+        return address;
+    }
+
+    private String checkPairingRequestAndGetAddress(String objectPath, int nativeData) {
+        String address = mBluetoothService.getAddressFromObjectPath(objectPath);
+        if (address == null) {
+            Log.e(TAG, "Unable to get device address in checkPairingRequestAndGetAddress, " +
+                  "returning null");
+            return null;
+        }
+        address = address.toUpperCase();
+        mPasskeyAgentRequestData.put(address, new Integer(nativeData));
+
+        if (mBluetoothService.getBluetoothState() == BluetoothAdapter.STATE_TURNING_OFF) {
+            // shutdown path
+            mBluetoothService.cancelPairingUserInput(address);
+            return null;
+        }
+        // Set state to BONDING. For incoming connections it will be set here.
+        // For outgoing connections, it gets set when we call createBond.
+        // Also set it only when the state is not already Bonded, we can sometimes
+        // get an authorization request from the remote end if it doesn't have the link key
+        // while we still have it.
+        if (mBluetoothService.getBondState(address) != BluetoothDevice.BOND_BONDED)
+            mBluetoothService.setBondState(address, BluetoothDevice.BOND_BONDING);
+        return address;
+    }
+
+    /**
+     * Called by native code on a RequestPairingConsent method call to
+     * org.bluez.Agent.
+     *
+     * @param objectPath the path of the device to request pairing consent for
+     * @param nativeData a native pointer to the original D-Bus message
+     */
+    private void onRequestPairingConsent(String objectPath, int nativeData) {
+        String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) return;
+
+        /* The link key will not be stored if the incoming request has MITM
+         * protection switched on. Unfortunately, some devices have MITM
+         * switched on even though their capabilities are NoInputNoOutput,
+         * so we may get this request many times. Also if we respond immediately,
+         * the other end is unable to handle it. Delay sending the message.
+         */
+        if (mBluetoothService.getBondState(address) == BluetoothDevice.BOND_BONDED) {
+            Message message = mHandler.obtainMessage(EVENT_PAIRING_CONSENT_DELAYED_ACCEPT);
+            message.obj = address;
+            mHandler.sendMessageDelayed(message, 1500);
+            return;
+        }
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                        BluetoothDevice.PAIRING_VARIANT_CONSENT);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        // Release wakelock to allow the LCD to go off after the PIN popup notification.
+        mWakeLock.release();
+        return;
+    }
+
+    /**
+     * Called by native code on a RequestConfirmation method call to
+     * org.bluez.Agent.
+     *
+     * @param objectPath the path of the device to confirm the passkey for
+     * @param passkey an integer containing the 6-digit passkey to confirm
+     * @param nativeData a native pointer to the original D-Bus message
+     */
+    private void onRequestPasskeyConfirmation(String objectPath, int passkey, int nativeData) {
+        String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) return;
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_KEY, passkey);
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.PAIRING_VARIANT_PASSKEY_CONFIRMATION);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        // Release wakelock to allow the LCD to go off after the PIN popup notification.
+        mWakeLock.release();
+        return;
+    }
+
+    /**
+     * Called by native code on a RequestPasskey method call to
+     * org.bluez.Agent.
+     *
+     * @param objectPath the path of the device requesting a passkey
+     * @param nativeData a native pointer to the original D-Bus message
+     */
+    private void onRequestPasskey(String objectPath, int nativeData) {
+        String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) return;
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.PAIRING_VARIANT_PASSKEY);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        // Release wakelock to allow the LCD to go off after the PIN popup notification.
+        mWakeLock.release();
+        return;
+    }
+
+    private void onSapAuthorize(String objectPath, String uuid, int nativeData) {
+        Log.i(TAG, "onSapAuthorize" + objectPath + uuid);
+        String address = checkAuthorizationRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) {
+            Log.e(TAG, "address is null");
+            mBluetoothService.sapAuthorize(address, false);
+            return;
+        }
+        /*Get the Trust state of the device*/
+        boolean trusted = mBluetoothService.getTrustState(address);
+        if (trusted) {
+            /*Say as authorized to lower layers without popping up to
+            user*/
+            mBluetoothService.sapAuthorize(address, true);
+        } else {
+            BluetoothDevice remoteDevice = mBluetoothService.getRemoteDevice(address);
+            Intent intent = new
+                Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
+            intent.setClassName(ACCESS_REQUEST_PACKAGE, ACCESS_REQUEST_CLASS);
+            intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE,
+                            BluetoothDevice.REQUEST_TYPE_SIM_ACCESS);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, remoteDevice);
+            intent.putExtra("uuid", uuid);
+            intent.putExtra("name", mBluetoothService.getRemoteName(address));
+            intent.putExtra("address", address);
+            mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+            mHandler.sendMessageDelayed(mHandler
+                   .obtainMessage(EVENT_SAP_USER_TIMEOUT),
+                    USER_CONFIRM_TIMEOUT);
+
+        }
+    }
+
+    private void onDUNAuthorize(String objectPath, String uuid, int nativeData) {
+        Log.i(TAG, "onDUNAuthorize" + objectPath + uuid);
+        String address = checkAuthorizationRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) {
+            Log.e(TAG, "address is null");
+            mBluetoothService.DUNAuthorize(address, false);
+            return;
+        }
+        /*Get the Trust state of the device*/
+        boolean trusted = mBluetoothService.getTrustState(address);
+        if (trusted) {
+            /*Say as authorized to lower layers without popping up to
+            user*/
+            Log.d(TAG,"Trusted device connection");
+            mBluetoothService.DUNAuthorize(address, true);
+        } else {
+            Log.v(TAG,"Get the remote address");
+            BluetoothDevice remoteDevice = mBluetoothService.getRemoteDevice(address);
+            Intent intent = new
+                Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
+            intent.setClassName(ACCESS_REQUEST_PACKAGE, ACCESS_REQUEST_CLASS);
+            intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE,
+                            BluetoothDevice. REQUEST_TYPE_DUN_ACCESS);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, remoteDevice);
+            intent.putExtra("name", mBluetoothService.getRemoteName(address));
+            intent.putExtra("address", address);
+            intent.putExtra("uuid", uuid);
+            mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+            mHandler.sendMessageDelayed(mHandler
+                 .obtainMessage(EVENT_DUN_USER_TIMEOUT),
+                 USER_CONFIRM_TIMEOUT);
+
+        }
+    }
+    private void onSapStateChanged(String objectPath, String state, int nativeData) {
+        Log.i(TAG, "onSapStateChanged" + objectPath + state);
+
+        String address = mBluetoothService.getAddressFromObjectPath(objectPath);
+        if (address == null) {
+            Log.e(TAG, "Unable to get device address , " +
+                  "returning null");
+            return;
+        }
+        address = address.toUpperCase();
+
+        int sapState;
+        if(state.equals("Connected")) {
+                /*2 corresponds to CONNECTED*/
+                sapState = 2;
+        } else  {
+                sapState = 0;
+        }
+        Intent intent = new Intent(BluetoothService.SAP_STATECHANGE_INTENT);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE,  mAdapter.getRemoteDevice(address));
+        intent.putExtra("state", sapState);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+    }
+
+    private void onDUNStateChanged(String objectPath, String state, int nativeData) {
+        Log.i(TAG, "onDUNStateChanged" + objectPath + state);
+
+        String address = mBluetoothService.getAddressFromObjectPath(objectPath);
+        if (address == null) {
+            Log.e(TAG, "Unable to get device address , " +
+                  "returning null");
+            return;
+        }
+        address = address.toUpperCase();
+
+        int DUNState;
+        if(state.equals("Connected")) {
+                Log.v(TAG,"On DUN state changed ");
+                /*2 corresponds to CONNECTED*/
+                DUNState = 2;
+        } else  {
+                DUNState = 0;
+        }
+        Intent intent = new Intent(BluetoothService.DUN_STATECHANGE_INTENT);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE,  mAdapter.getRemoteDevice(address));
+        intent.putExtra("state", DUNState);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+    }
+
+    private void onRequestPinCode(String objectPath, int nativeData, boolean secure) {
+        String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) return;
+        Log.i(TAG, "Secure pairing is "+ secure);
+        String pendingOutgoingAddress =
+                mBluetoothService.getPendingOutgoingBonding();
+        BluetoothClass btClass = new BluetoothClass(mBluetoothService.getRemoteClass(address));
+        int btDeviceClass = btClass.getDeviceClass();
+
+        if (address.equals(pendingOutgoingAddress)) {
+            // we initiated the bonding
+
+            // Check if its a dock
+            if (mBluetoothService.isBluetoothDock(address)) {
+                String pin = mBluetoothService.getDockPin();
+                mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes(pin));
+                return;
+            }
+
+            // try 0000 once if the device looks dumb
+            switch (btDeviceClass) {
+            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
+            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
+            case BluetoothClass.Device.AUDIO_VIDEO_HEADPHONES:
+            case BluetoothClass.Device.AUDIO_VIDEO_PORTABLE_AUDIO:
+            case BluetoothClass.Device.AUDIO_VIDEO_HIFI_AUDIO:
+                if (mBluetoothService.attemptAutoPair(address)) return;
+           }
+        }
+
+        if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD ||
+            btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD_POINTING) {
+            // Its a keyboard. Follow the HID spec recommendation of creating the
+            // passkey and displaying it to the user. If the keyboard doesn't follow
+            // the spec recommendation, check if the keyboard has a fixed PIN zero
+            // and pair.
+            if (mBluetoothService.isFixedPinZerosAutoPairKeyboard(address)) {
+                mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes("0000"));
+                return;
+            }
+
+            // Generate a variable PIN. This is not truly random but good enough.
+            int pin = (int) Math.floor(Math.random() * 10000);
+            mBluetoothService.setBondState(address, BluetoothDevice.BOND_BONDING);
+            sendDisplayPinIntent(address, pin);
+            return;
+        }
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, BluetoothDevice.PAIRING_VARIANT_PIN);
+        intent.putExtra(BluetoothDevice.EXTRA_SECURE_PAIRING, secure);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        // Release wakelock to allow the LCD to go off after the PIN popup notification.
+        mWakeLock.release();
+        if (mHandler.hasMessages(EVENT_PAIRING_TIMEOUT)) {
+            Log.d(TAG, "Ther is EVENT_PAIRING_TIMEOUT message");
+            mHandler.removeMessages(EVENT_PAIRING_TIMEOUT);
+        }
+        if (!(address.equals(pendingOutgoingAddress))) {
+            Message msg = mHandler.obtainMessage(EVENT_PAIRING_TIMEOUT);
+            msg.obj = address;
+            mHandler.sendMessageDelayed(msg, INCOMING_PAIRING_TIMEOUT);
+            Log.d(TAG, "Queuing INCOMING_PAIRING_TIMEOUT msg");
+        }
+
+        return;
+    }
+
+    /**
+     * Called by native code on a DisplayPasskey method call to
+     * org.bluez.Agent.
+     *
+     * @param objectPath the path of the device to display the passkey for
+     * @param passkey an integer containing the 6-digit passkey
+     * @param nativeData a native pointer to the original D-Bus message
+     */
+    private void onDisplayPasskey(String objectPath, int passkey, int nativeData) {
+        String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) return;
+
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_KEY, passkey);
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                        BluetoothDevice.PAIRING_VARIANT_DISPLAY_PASSKEY);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        //Release wakelock to allow the LCD to go off after the PIN popup notification.
+        mWakeLock.release();
+    }
+
+    private void sendDisplayPinIntent(String address, int pin) {
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_KEY, pin);
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                        BluetoothDevice.PAIRING_VARIANT_DISPLAY_PIN);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        //Release wakelock to allow the LCD to go off after the PIN popup notifcation.
+        mWakeLock.release();
+    }
+
+    /**
+     * Called by native code on a RequestOobData method call to
+     * org.bluez.Agent.
+     *
+     * @param objectPath the path of the device requesting OOB data
+     * @param nativeData a native pointer to the original D-Bus message
+     */
+    private void onRequestOobData(String objectPath, int nativeData) {
+        String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) return;
+
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.PAIRING_VARIANT_OOB_CONSENT);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+    }
+
+    /**
+     * Called by native code on an Authorize method call to org.bluez.Agent.
+     *
+     * @param objectPath the path of the device requesting to be authorized
+     * @param deviceUuid the UUID of the requesting device
+     * @param nativeData reference for native data
+     */
+    private void  onAgentAuthorize(String objectPath, String deviceUuid, int nativeData) {
+        if (!mBluetoothService.isEnabled()) return;
+
+        String address = mBluetoothService.getAddressFromObjectPath(objectPath);
+        if (address == null) {
+            Log.e(TAG, "Unable to get device address in onAuthAgentAuthorize");
+            return;
+        }
+
+        boolean authorized = false;
+        ParcelUuid uuid = ParcelUuid.fromString(deviceUuid);
+
+        BluetoothDevice device = mAdapter.getRemoteDevice(address);
+        mAuthorizationAgentRequestData.put(address, new Integer(nativeData));
+
+        // Bluez sends the UUID of the local service being accessed, _not_ the
+        // remote service
+        if (mA2dp != null &&
+            (BluetoothUuid.isAudioSource(uuid) || BluetoothUuid.isAvrcpTarget(uuid)
+              || BluetoothUuid.isAdvAudioDist(uuid)) &&
+              !isOtherSinkInNonDisconnectedState(address)) {
+            authorized = mA2dp.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
+            if (authorized && !BluetoothUuid.isAvrcpTarget(uuid)) {
+                Log.i(TAG, "First check pass for incoming A2DP / AVRCP connection from " + address);
+                // Some headsets try to connect AVCTP before AVDTP - against the recommendation
+                // If AVCTP connection fails, we get stuck in IncomingA2DP state in the state
+                // machine.  We don't handle AVCTP signals currently. We only send
+                // intents for AVDTP state changes. We need to handle both of them in
+                // some cases. For now, just don't move to incoming state in this case.
+                mBluetoothService.notifyIncomingA2dpConnection(address, false);
+            } else {
+                // The below change will make sure A2DP connection is
+                // established. If the remote device sends AVRCP connection
+                // first DUT will accept the AVRCP connection and initiates
+                // A2DP connection from handset.
+                Log.i(TAG, "" + authorized +
+                      "Incoming A2DP / AVRCP connection from " + address);
+                mA2dp.allowIncomingConnect(device, authorized);
+                mBluetoothService.notifyIncomingA2dpConnection(address, true);
+            }
+        } else if (BluetoothUuid.isInputDevice(uuid)) {
+            // We can have more than 1 input device connected.
+            authorized = mBluetoothService.getInputDevicePriority(device) >
+                    BluetoothInputDevice.PRIORITY_OFF;
+            if (authorized) {
+                Log.i(TAG, "First check pass for incoming HID connection from " + address);
+                // notify profile state change
+                mBluetoothService.notifyIncomingHidConnection(address);
+            } else {
+                Log.i(TAG, "Rejecting incoming HID connection from " + address);
+                mBluetoothService.allowIncomingProfileConnect(device, authorized);
+            }
+        } else if (BluetoothUuid.isBnep(uuid)) {
+            // PAN doesn't go to the state machine, accept or reject from here
+            authorized = mBluetoothService.allowIncomingTethering();
+            mBluetoothService.allowIncomingProfileConnect(device, authorized);
+        } else {
+            Log.i(TAG, "Rejecting incoming " + deviceUuid + " connection from " + address);
+            mBluetoothService.allowIncomingProfileConnect(device, authorized);
+        }
+        log("onAgentAuthorize(" + objectPath + ", " + deviceUuid + ") = " + authorized);
+    }
+
+    private boolean onAgentOutOfBandDataAvailable(String objectPath) {
+        if (!mBluetoothService.isEnabled()) return false;
+
+        String address = mBluetoothService.getAddressFromObjectPath(objectPath);
+        if (address == null) return false;
+
+        if (mBluetoothService.getDeviceOutOfBandData(
+            mAdapter.getRemoteDevice(address)) != null) {
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isOtherSinkInNonDisconnectedState(String address) {
+        List<BluetoothDevice> devices =
+            mA2dp.getDevicesMatchingConnectionStates(new int[] {BluetoothA2dp.STATE_CONNECTED,
+                                                     BluetoothA2dp.STATE_CONNECTING,
+                                                     BluetoothA2dp.STATE_DISCONNECTING});
+
+        if (devices.size() == 0) return false;
+        for (BluetoothDevice dev: devices) {
+            if (!dev.getAddress().equals(address)) return true;
+        }
+        return false;
+    }
+
+    /**
+     * Called by native code on a Cancel method call to org.bluez.Agent.
+     */
+    private void onAgentCancel() {
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_CANCEL);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+
+        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_AGENT_CANCEL),
+                   1500);
+
+        return;
+    }
+
+    /**
+     * Called by native code for the async response to a DiscoverServices
+     * method call to org.bluez.Adapter.
+     *
+     * @param deviceObjectPath the path for the specified device
+     * @param result true for success; false on error
+     */
+    private void onDiscoverServicesResult(String deviceObjectPath, boolean result) {
+        if (!mBluetoothService.isEnabled()) {
+            log("Bluetooth is not on");
+            return;
+        }
+
+        String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+        if (address == null) return;
+
+        // We don't parse the xml here, instead just query Bluez for the properties.
+        if (address == null) {
+            Log.e(TAG, "Unexpected error! address is null");
+            return;
+        }
+        if (result) {
+            mBluetoothService.updateRemoteDevicePropertiesCache(address);
+        }
+        mBluetoothService.sendUuidIntent(address);
+        mBluetoothService.makeServiceChannelCallbacks(address);
+    }
+
+    /**
+     * Called by native code for the async response to a CreateDevice
+     * method call to org.bluez.Adapter.
+     *
+     * @param address the MAC address of the device to create
+     * @param result {@link #CREATE_DEVICE_SUCCESS},
+     *  {@link #CREATE_DEVICE_ALREADY_EXISTS} or {@link #CREATE_DEVICE_FAILED}}
+     */
+    private void onCreateDeviceResult(String address, int result) {
+        if (DBG) log("Result of onCreateDeviceResult:" + result);
+        BluetoothClass btClass = new BluetoothClass(mBluetoothService.getRemoteClass(address));
+        int btDeviceClass = btClass.getDeviceClass();
+
+        switch (result) {
+        case CREATE_DEVICE_ALREADY_EXISTS:
+            String path = mBluetoothService.getObjectPathFromAddress(address);
+            Log.d(TAG, "Device exists " + path);
+            if (path != null) {
+                Log.d(TAG, "Start service discovery " + path);
+                String devType = mBluetoothService.getUpdatedRemoteDeviceProperty(address, "Type");
+                if ((devType != null)  && "LE".equals(devType))
+                    mBluetoothService.discoverPrimaryServicesNative(path);
+                else {
+                    mBluetoothService.discoverServicesNative(path, "");
+                    if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_POINTING) {
+                        log("The device is HID pointing device,moving pairing state");
+                        mBluetoothService.setBondState(address, BluetoothDevice.BOND_BONDED);
+                    }
+                }
+                break;
+            }
+            Log.w(TAG, "Device exists, but we don't have the bluez path, failing");
+            // fall-through
+        case CREATE_DEVICE_FAILED:
+            mBluetoothService.sendUuidIntent(address);
+            mBluetoothService.sendGattIntent(address, BluetoothDevice.GATT_RESULT_FAIL);
+            mBluetoothService.makeServiceChannelCallbacks(address);
+            if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_POINTING) {
+                log("The device is HID pointing device,moving pairing state to BOND_NONE");
+                mBluetoothService.setBondState(address, BluetoothDevice.BOND_NONE);
+            }
+
+            break;
+        case CREATE_DEVICE_SUCCESS:
+            // nothing to do, UUID intent's will be sent via property changed
+            if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_POINTING) {
+                log("The device is HID pointing device,moving pairing state");
+                mBluetoothService.setBondState(address, BluetoothDevice.BOND_BONDED);
+            }
+        }
+    }
+
+    private void onAddToPreferredDeviceListResult(int result) {
+        Log.d(TAG,"Result of onAddToPreferredDeviceListResult callback event loop java:"+result);
+        try {
+            mBluetoothService.onAddToPreferredDeviceListResult(result);
+        }
+        catch(Exception e) {
+            {Log.e(TAG, "", e);}
+        }
+    }
+    private void onRemoveFromPreferredDeviceListResult(int result) {
+        Log.d(TAG,"Result of onRemoveFromPreferredDeviceListResult callback event loop java:"+result);
+        try {
+            mBluetoothService.onRemoveFromPreferredDeviceListResult(result);
+        }
+        catch(Exception e) {
+            {Log.e(TAG, "", e);}
+        }
+    }
+    private void onClearPreferredDeviceListResult(int result) {
+        Log.d(TAG,"Result of onClearPreferredDeviceListResult callback event loop java:"+result);
+        try {
+            mBluetoothService.onClearPreferredDeviceListResult(result);
+        }
+        catch(Exception e) {
+            {Log.e(TAG, "", e);}
+        }
+    }
+    private void onGattConnectToPreferredDeviceListResult(int result) {
+        Log.d(TAG,"Result of onGattConnectToPreferredDeviceListResult callback event loop java:"+result);
+        try {
+            mBluetoothService.onGattConnectToPreferredDeviceListResult(result);
+        }
+        catch(Exception e) {
+            {Log.e(TAG, "", e);}
+        }
+    }
+    private void onGattCancelConnectToPreferredDeviceListResult(int result) {
+        Log.d(TAG,"Result of onGattCancelConnectToPreferredDeviceListResult callback event loop java:"+result);
+        try {
+            mBluetoothService.onGattCancelConnectToPreferredDeviceListResult(result);
+        }
+        catch(Exception e) {
+            {Log.e(TAG, "", e);}
+        }
+    }
+
+    /**
+     * Called by native code for the async response to a Connect
+     * method call to org.bluez.Input.
+     *
+     * @param path the path of the specified input device
+     * @param result Result code of the operation.
+     */
+    private void onInputDeviceConnectionResult(String path, int result) {
+        // Success case gets handled by Property Change signal
+        if (result != BluetoothInputDevice.INPUT_OPERATION_SUCCESS) {
+            String address = mBluetoothService.getAddressFromObjectPath(path);
+            if (address == null) return;
+
+            boolean connected = false;
+            BluetoothDevice device = mAdapter.getRemoteDevice(address);
+            int state = mBluetoothService.getInputDeviceConnectionState(device);
+            if (state == BluetoothInputDevice.STATE_CONNECTING) {
+                if (result == BluetoothInputDevice.INPUT_CONNECT_FAILED_ALREADY_CONNECTED) {
+                    connected = true;
+                } else {
+                    connected = false;
+                }
+            } else if (state == BluetoothInputDevice.STATE_DISCONNECTING) {
+                if (result == BluetoothInputDevice.INPUT_DISCONNECT_FAILED_NOT_CONNECTED) {
+                    connected = false;
+                } else {
+                    // There is no better way to handle this, this shouldn't happen
+                    connected = true;
+                }
+            } else {
+                Log.e(TAG, "Error onInputDeviceConnectionResult. State is:" + state);
+            }
+            mBluetoothService.handleInputDevicePropertyChange(address, connected);
+        }
+    }
+
+    /**
+     * Called by native code for the async response to a Connect
+     * method call to org.bluez.Network.
+     *
+     * @param path the path of the specified PAN device
+     * @param result Result code of the operation.
+     */
+    private void onPanDeviceConnectionResult(String path, int result) {
+        log ("onPanDeviceConnectionResult " + path + " " + result);
+        // Success case gets handled by Property Change signal
+        if (result != BluetoothPan.PAN_OPERATION_SUCCESS) {
+            String address = mBluetoothService.getAddressFromObjectPath(path);
+            if (address == null) return;
+
+            boolean connected = false;
+            BluetoothDevice device = mAdapter.getRemoteDevice(address);
+            int state = mBluetoothService.getPanDeviceConnectionState(device);
+            if (state == BluetoothPan.STATE_CONNECTING) {
+                if (result == BluetoothPan.PAN_CONNECT_FAILED_ALREADY_CONNECTED) {
+                    connected = true;
+                } else {
+                    connected = false;
+                }
+            } else if (state == BluetoothPan.STATE_DISCONNECTING) {
+                if (result == BluetoothPan.PAN_DISCONNECT_FAILED_NOT_CONNECTED) {
+                    connected = false;
+                } else {
+                    // There is no better way to handle this, this shouldn't happen
+                    connected = true;
+                }
+            } else {
+                Log.e(TAG, "Error onPanDeviceConnectionResult. State is: "
+                        + state + " result: "+ result);
+            }
+            int newState = connected? BluetoothPan.STATE_CONNECTED :
+                BluetoothPan.STATE_DISCONNECTED;
+            mBluetoothService.handlePanDeviceStateChange(device, newState,
+                                                  BluetoothPan.LOCAL_PANU_ROLE);
+        }
+    }
+
+    /**
+     * Called by native code for the async response to a Connect
+     * method call to org.bluez.Health
+     *
+     * @param chanCode The internal id of the channel
+     * @param result Result code of the operation.
+     */
+    private void onHealthDeviceConnectionResult(int chanCode, int result) {
+        log ("onHealthDeviceConnectionResult " + chanCode + " " + result);
+        // Success case gets handled by Property Change signal
+        if (result != BluetoothHealth.HEALTH_OPERATION_SUCCESS) {
+            mBluetoothService.onHealthDeviceChannelConnectionError(chanCode,
+                                                 BluetoothHealth.STATE_CHANNEL_DISCONNECTED);
+        }
+    }
+
+    /**
+     * Called by native code on a DeviceDisconnected signal from
+     * org.bluez.NetworkServer.
+     *
+     * @param address the MAC address of the disconnected device
+     */
+    private void onNetworkDeviceDisconnected(String address) {
+        BluetoothDevice device = mAdapter.getRemoteDevice(address);
+        mBluetoothService.handlePanDeviceStateChange(device, BluetoothPan.STATE_DISCONNECTED,
+                                                      BluetoothPan.LOCAL_NAP_ROLE);
+    }
+
+    /**
+     * Called by native code on a DeviceConnected signal from
+     * org.bluez.NetworkServer.
+     *
+     * @param address the MAC address of the connected device
+     * @param iface interface of remote network
+     * @param destUuid unused UUID parameter
+     */
+    private void onNetworkDeviceConnected(String address, String iface, int destUuid) {
+        BluetoothDevice device = mAdapter.getRemoteDevice(address);
+        mBluetoothService.handlePanDeviceStateChange(device, iface, BluetoothPan.STATE_CONNECTED,
+                                                      BluetoothPan.LOCAL_NAP_ROLE);
+    }
+
+    /**
+     * Called by native code on a PropertyChanged signal from
+     * org.bluez.HealthDevice.
+     *
+     * @param devicePath the object path of the remote device
+     * @param propValues Properties (Name-Value) of the Health Device.
+     */
+    private void onHealthDevicePropertyChanged(String devicePath, String[] propValues) {
+        log("Health Device : Name of Property is: " + propValues[0] + " Value:" + propValues[1]);
+        mBluetoothService.onHealthDevicePropertyChanged(devicePath, propValues[1]);
+    }
+
+    /**
+     * Called by native code on a ChannelCreated/Deleted signal from
+     * org.bluez.HealthDevice.
+     *
+     * @param devicePath the object path of the remote device
+     * @param channelPath the path of the health channel.
+     * @param exists Boolean to indicate if the channel was created or deleted.
+     */
+    private void onHealthDeviceChannelChanged(String devicePath, String channelPath,
+            boolean exists) {
+        log("Health Device : devicePath: " + devicePath + ":channelPath:" + channelPath +
+                ":exists" + exists);
+        mBluetoothService.onHealthDeviceChannelChanged(devicePath, channelPath, exists);
+    }
+
+    private void onDiscoverCharacteristicsResult(String serviceObjectPath, boolean result) {
+
+        Log.d(TAG, "onDiscoverCharacteristicsResult: " + result  + "path " + serviceObjectPath);
+        String[] callbackData = serviceObjectPath.split("#");
+
+        if (result) {
+            Log.d(TAG, "updateGattServicePropertiesCache " + callbackData[0]);
+            mBluetoothService.updateGattServicePropertiesCache(callbackData[0]);
+        }
+        mBluetoothService.makeDiscoverCharacteristicsCallback(callbackData[0], callbackData[1], result);
+    }
+
+    private void onSetCharacteristicPropertyResult(String path, String property, boolean result) {
+
+        Log.d(TAG, "onSetCharPropResult path " + path + " property = " + property);
+        Log.d(TAG, "Path : " + path + "Result = " + result);
+        String[] callbackData = path.split("#");
+        mBluetoothService.makeSetCharacteristicPropertyCallback(callbackData[0], callbackData[1], property, result);
+    }
+
+    private void onIndicateResponse(String path, boolean result) {
+        Log.d(TAG, "onIndicateResponse path = " + path + " result : " + result);
+        BluetoothGattProfileHandler gattProfileHandler =
+            BluetoothGattProfileHandler.getInstance(mContext, mBluetoothService);
+        gattProfileHandler.onIndicateResponse(path, result);
+    }
+
+    private void onWatcherValueChanged(String characteristicPath, String value) {
+        // TODO: Send this to upper layer
+        mBluetoothService.makeWatcherValueChangedCallback(characteristicPath, value);
+
+    }
+
+    private void onUpdateCharacteristicValueResult(String charObjectPath, boolean result) {
+        Log.d(TAG, "onUpdateCharacteristicValueResult: " + result + "path " + charObjectPath);
+        String[] callbackData = charObjectPath.split("#");
+
+        mBluetoothService.makeUpdateCharacteristicValueCallback(callbackData[0], callbackData[1], result);
+    }
+
+    private void onGattDiscoverPrimaryRequest(String gattObjectPath, int start, int end, int reqHandle) {
+        Log.d(TAG, "Inside onGattDiscoverPrimaryRequest");
+
+        mGattRequestData.add(new Integer(reqHandle));
+
+        BluetoothGattProfileHandler gattProfileHandler =
+            BluetoothGattProfileHandler.getInstance(mContext, mBluetoothService);
+        gattProfileHandler.onGattDiscoverPrimaryRequest(gattObjectPath, start, end, reqHandle);
+    }
+
+    private void onGattDiscoverPrimaryByUuidRequest(String gattObjectPath, String uuid,
+                                                    int start, int end,
+                                                    int reqHandle) {
+        Log.d(TAG, "Inside onGattDiscoverPrimaryByUuidRequest");
+
+        mGattRequestData.add(new Integer(reqHandle));
+
+        BluetoothGattProfileHandler gattProfileHandler =
+            BluetoothGattProfileHandler.getInstance(mContext, mBluetoothService);
+        gattProfileHandler.onGattDiscoverPrimaryByUuidRequest(gattObjectPath, start, end, uuid,
+                                                              reqHandle);
+    }
+
+    private void onGattDiscoverIncludedRequest(String gattObjectPath, int start,
+                                                    int end, int reqHandle) {
+        Log.d(TAG, "Inside onGattDiscoverIncludedRequest");
+
+        mGattRequestData.add(new Integer(reqHandle));
+
+        BluetoothGattProfileHandler gattProfileHandler =
+            BluetoothGattProfileHandler.getInstance(mContext, mBluetoothService);
+        gattProfileHandler.onGattDiscoverIncludedRequest(gattObjectPath, start, end, reqHandle);
+    }
+
+    private void onGattDiscoverCharacteristicsRequest(String gattObjectPath, int start,
+                                                    int end, int reqHandle) {
+        Log.d(TAG, "Inside onGattDiscoverCharacteristicsRequest");
+
+        mGattRequestData.add(new Integer(reqHandle));
+
+        BluetoothGattProfileHandler gattProfileHandler =
+            BluetoothGattProfileHandler.getInstance(mContext, mBluetoothService);
+        gattProfileHandler.onGattDiscoverCharacteristicsRequest(gattObjectPath, start, end, reqHandle);
+    }
+
+    private void onGattFindInfoRequest(String gattObjectPath, int start,
+                                       int end, int reqHandle) {
+        Log.d(TAG, "Inside onGattFindInfoRequest");
+
+        mGattRequestData.add(new Integer(reqHandle));
+
+        BluetoothGattProfileHandler gattProfileHandler =
+            BluetoothGattProfileHandler.getInstance(mContext, mBluetoothService);
+        gattProfileHandler.onGattFindInfoRequest(gattObjectPath, start, end, reqHandle);
+    }
+
+    private void onGattReadByTypeRequest(String gattObjectPath, String uuid,
+                                         String auth, int start,
+                                         int end, int reqHandle) {
+        Log.d(TAG, "Inside onGattReadByTypeRequest");
+
+        mGattRequestData.add(new Integer(reqHandle));
+
+        BluetoothGattProfileHandler gattProfileHandler =
+            BluetoothGattProfileHandler.getInstance(mContext, mBluetoothService);
+        gattProfileHandler.onGattReadByTypeRequest(gattObjectPath, start, end,
+                                                   uuid, auth, reqHandle);
+    }
+
+    private void onGattReadRequest(String gattObjectPath, String auth, int handle, int reqHandle) {
+        Log.d(TAG, "Inside onGattReadRequest");
+
+        mGattRequestData.add(new Integer(reqHandle));
+
+        BluetoothGattProfileHandler gattProfileHandler =
+            BluetoothGattProfileHandler.getInstance(mContext, mBluetoothService);
+        gattProfileHandler.onGattReadRequest(gattObjectPath, auth, handle, reqHandle);
+    }
+
+    private void onGattWriteRequest(String gattObjectPath, String auth,
+                                      int attrHandle, byte[] value,
+                                      int sessionHandle, int reqHandle) {
+        Log.d(TAG, "onGattWriteRequest");
+
+        mGattRequestData.add(new Integer(reqHandle));
+
+        BluetoothGattProfileHandler gattProfileHandler =
+            BluetoothGattProfileHandler.getInstance(mContext, mBluetoothService);
+        gattProfileHandler.onGattWriteRequest(gattObjectPath, auth,
+                                              attrHandle, value, sessionHandle, reqHandle);
+    }
+
+    private void onGattWriteCommand(String gattObjectPath, String auth,
+                                    int attrHandle, byte[] value) {
+        Log.d(TAG, "onGattWriteCommand");
+
+        BluetoothGattProfileHandler gattProfileHandler =
+            BluetoothGattProfileHandler.getInstance(mContext, mBluetoothService);
+        gattProfileHandler.onGattWriteCommand(gattObjectPath, auth,
+                                              attrHandle, value);
+    }
+
+    private void onGattSetClientConfigDescriptor(String gattObjectPath, int sessionHandle,
+                                                 int attrHandle, byte[] value) {
+        Log.d(TAG, "onGattSetClientConfigDescriptor");
+
+        BluetoothGattProfileHandler gattProfileHandler =
+            BluetoothGattProfileHandler.getInstance(mContext, mBluetoothService);
+        gattProfileHandler.onGattSetClientConfigDescriptor(gattObjectPath, sessionHandle, attrHandle, value);
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+
+    private native void initializeNativeDataNative();
+    private native void startEventLoopNative();
+    private native void stopEventLoopNative();
+    private native boolean isEventLoopRunningNative();
+    private native void cleanupNativeDataNative();
+}
diff --git a/bluetoothmsm/java/android/server/BluetoothGattProfileHandler.java b/bluetoothmsm/java/android/server/BluetoothGattProfileHandler.java
new file mode 100644
index 0000000..01eaad2
--- /dev/null
+++ b/bluetoothmsm/java/android/server/BluetoothGattProfileHandler.java
@@ -0,0 +1,1082 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattAppConfiguration;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.IBluetoothGattCallback;
+import android.content.Context;
+import android.os.Handler;
+import android.os.Message;
+import android.os.Bundle;
+import android.os.ParcelFileDescriptor;
+import android.os.ParcelUuid;
+import android.os.RemoteException;
+import android.os.DeadObjectException;
+import android.util.Log;
+
+import java.io.IOException;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * This handles all the operations on the Bluetooth Gatt profile (server side).
+ *
+ * @hide
+ */
+final class BluetoothGattProfileHandler {
+    private static final String TAG = "BluetoothGattProfileHandler";
+    private static final boolean DBG = false;
+
+    private static BluetoothGattProfileHandler sInstance;
+    private BluetoothService mBluetoothService;
+    private HashMap <String, Boolean> mRegisteredServers;
+    private HashMap <String, BluetoothGattAppConfiguration> mAppConfigs;
+    private HashMap <BluetoothGattAppConfiguration, IBluetoothGattCallback> mCallbacks;
+
+    private static final int MESSAGE_REGISTER_APPLICATION = 1;
+    private static final int MESSAGE_UNREGISTER_APPLICATION = 2;
+    private static final int MESSAGE_SEND_INDICATION = 3;
+    private static final int MESSAGE_DISCOVER_PRIMARY_SERVICE_RESP = 4;
+    private static final int MESSAGE_DISCOVER_PRIMARY_SERVICE_BY_UUID_RESP = 5;
+    private static final int MESSAGE_FIND_INCLUDED_SERVICE_RESP = 6;
+    private static final int MESSAGE_DISCOVER_CHARACTERISTICS_RESP = 7;
+    private static final int MESSAGE_FIND_INFO_RESP = 8;
+    private static final int MESSAGE_READ_BY_TYPE_RESP = 9;
+    private static final int MESSAGE_READ_RESP = 10;
+    private static final int MESSAGE_WRITE_RESP = 11;
+    private static final int MESSAGE_DISCONNECT_LE = 12;
+    private static final int MESSAGE_ADD_TO_PREFERRED_DEVICE_LIST = 13;
+    private static final int MESSAGE_REMOVE_FROM_PREFERRED_DEVICE_LIST = 14;
+    private static final int MESSAGE_CLEAR_PREFERRED_DEVICE_LIST = 15;
+    private static final int MESSAGE_CREATE_CONN_REQ_PREFERRED_DEVICE_LIST = 16;
+    private static final int MESSAGE_CANCEL_CREATE_CONN_REQ_PREFERRED_DEVICE_LIST = 17;
+
+    private static final String UUID = "uuid";
+    private static final String HANDLE = "handle";
+    private static final String END = "end";
+    private static final String START = "start";
+    private static final String REQUEST_HANDLE = "request_handle";
+    private static final String ERROR = "error";
+    private static final String VALUE_HANDLE = "value_handle";
+    private static final String PROPERTY = "property";
+    private static final String PAYLOAD = "payload";
+    private static final String SESSION = "session";
+    private static final String NOTIFY = "notify";
+    private static final String PATH = "PATH";
+
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            BluetoothGattAppConfiguration config = (BluetoothGattAppConfiguration) msg.obj;
+            int status, handle, start, end, reqHandle, errorCode, valueHandle;
+            byte[] payload;
+            byte property;
+            String uuid;
+            boolean result = true;
+            String path = null;
+            if(config != null) {
+                path = config.getPath();
+            }
+            int payloadLen = 0;
+            String errorString;
+
+            switch (msg.what) {
+            case MESSAGE_REGISTER_APPLICATION:
+                int range = config.getRange();
+                boolean isNew;
+
+                /* Nothing to do, just return success for status */
+                if (mAppConfigs.containsKey(path))
+                    callGattApplicationStatusCallback(config,
+                           BluetoothGatt.GATT_CONFIG_REGISTRATION_SUCCESS);
+
+                if (mRegisteredServers.isEmpty()) {
+                    String[] servers = null;
+                    servers  = (String[]) mBluetoothService.getGattServersNative();
+                    if ((servers != null) && (servers.length > 0))
+                        loadRegisteredServers(servers);
+                }
+
+                isNew = mRegisteredServers.isEmpty() || !mRegisteredServers.containsKey(path);
+                result  = mBluetoothService.registerGattServerNative(path, range, isNew);
+
+                if (!result) {
+                    callGattApplicationStatusCallback(config,
+                           BluetoothGatt.GATT_CONFIG_REGISTRATION_FAILURE);
+                    mCallbacks.remove(config);
+                } else {
+                    mAppConfigs.put(path, config);
+                    serverEnable(path);
+                    callGattApplicationStatusCallback(config,
+                           BluetoothGatt.GATT_CONFIG_REGISTRATION_SUCCESS);
+                }
+
+                break;
+
+           case MESSAGE_UNREGISTER_APPLICATION:
+                Log.d(TAG, "GATT: MESSAGE_UNREGISTER_APPLICATION");
+
+                result = mBluetoothService.unregisterGattServerNative(path, true);
+
+                if (!result) {
+                    callGattApplicationStatusCallback(config,
+                           BluetoothGatt.GATT_CONFIG_UNREGISTRATION_FAILURE);
+                } else {
+                    callGattApplicationStatusCallback(config,
+                           BluetoothGatt.GATT_CONFIG_UNREGISTRATION_SUCCESS);
+                }
+
+                mCallbacks.remove(config);
+                mAppConfigs.remove(path);
+
+                break;
+
+            case MESSAGE_DISCONNECT_LE:
+                Log.d(TAG, "GATT: MESSAGE_DISCONNECT_LE");
+
+                String devPath = msg.getData().getString(PATH);
+
+                result = mBluetoothService.gattLeDisconnectRequestNative(devPath);
+
+                if (!result)
+                    Log.e(TAG, "Failed to handle GATT LE disconnect request for " + devPath);
+
+                break;
+
+             case MESSAGE_SEND_INDICATION:
+                boolean notify;
+                int sessionHandle;
+                Log.d(TAG, "GATT: MESSAGE_SEND_INDICATION");
+
+                sessionHandle = msg.getData().getInt(SESSION);
+                handle = msg.getData().getInt(HANDLE);
+                payload = msg.getData().getByteArray(PAYLOAD);
+                notify = msg.getData().getBoolean(NOTIFY);
+
+                if (notify)
+                    result = mBluetoothService.notifyNative(path, sessionHandle, handle, payload, payload.length);
+                else
+                    result = mBluetoothService.indicateNative(path, sessionHandle, handle, payload, payload.length);
+
+                if (!result)
+                    status = BluetoothGatt.GATT_FAILURE;
+                else
+                    status = BluetoothGatt.GATT_SUCCESS;
+
+                callGattActionCompleteCallback(config, "SEND_INDICATION", status);
+                break;
+
+            case MESSAGE_DISCOVER_PRIMARY_SERVICE_RESP:
+                uuid = msg.getData().getString(UUID);
+                handle = msg.getData().getInt(HANDLE);
+                end = msg.getData().getInt(END);
+                reqHandle = msg.getData().getInt(REQUEST_HANDLE);
+                errorCode = msg.getData().getInt(ERROR);
+                errorString = errorStatusToString(errorCode, handle);
+
+                result  = mBluetoothService.discoverPrimaryResponseNative(uuid, errorString, handle, end, reqHandle);
+
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+            case MESSAGE_DISCOVER_PRIMARY_SERVICE_BY_UUID_RESP:
+                handle = msg.getData().getInt(HANDLE);
+                end = msg.getData().getInt(END);
+                reqHandle = msg.getData().getInt(REQUEST_HANDLE);
+                errorCode = msg.getData().getInt(ERROR);
+                errorString = errorStatusToString(errorCode, handle);
+                result  = mBluetoothService.discoverPrimaryByUuidResponseNative(errorString, handle,
+                                                                                end, reqHandle);
+
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+
+            case MESSAGE_FIND_INCLUDED_SERVICE_RESP:
+                uuid = msg.getData().getString(UUID);
+                handle = msg.getData().getInt(HANDLE);
+                start = msg.getData().getInt(START);
+                end = msg.getData().getInt(END);
+                reqHandle = msg.getData().getInt(REQUEST_HANDLE);
+                errorCode = msg.getData().getInt(ERROR);
+                errorString = errorStatusToString(errorCode, handle);
+
+                result  = mBluetoothService.findIncludedResponseNative(uuid, errorString,
+                                                                       handle, start, end, reqHandle);
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+
+             case MESSAGE_DISCOVER_CHARACTERISTICS_RESP:
+                uuid = msg.getData().getString(UUID);
+                handle = msg.getData().getInt(HANDLE);
+                valueHandle = msg.getData().getInt(VALUE_HANDLE);
+                reqHandle = msg.getData().getInt(REQUEST_HANDLE);
+                errorCode = msg.getData().getInt(ERROR);
+                property = msg.getData().getByte(PROPERTY);
+                errorString = errorStatusToString(errorCode, handle);
+
+                result  = mBluetoothService.discoverCharacteristicsResponseNative(uuid, errorString,
+                                                                                  handle, (int) property,
+                                                                                  valueHandle, reqHandle);
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+
+            case MESSAGE_FIND_INFO_RESP:
+                uuid = msg.getData().getString(UUID);
+                handle = msg.getData().getInt(HANDLE);
+                reqHandle = msg.getData().getInt(REQUEST_HANDLE);
+                errorCode = msg.getData().getInt(ERROR);
+                errorString = errorStatusToString(errorCode, handle);
+
+                result  = mBluetoothService.findInfoResponseNative(uuid,
+                                                                   errorString, handle,
+                                                                   reqHandle);
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+
+            case MESSAGE_READ_BY_TYPE_RESP:
+                uuid = msg.getData().getString(UUID);
+                handle = msg.getData().getInt(HANDLE);
+                reqHandle = msg.getData().getInt(REQUEST_HANDLE);
+                errorCode = msg.getData().getInt(ERROR);
+                errorString = errorStatusToString(errorCode, handle);
+                payload = msg.getData().getByteArray(PAYLOAD);
+                if(payload != null)
+                    payloadLen = payload.length;
+                else
+                    payloadLen = 0;
+                result  = mBluetoothService.readByTypeResponseNative(uuid,  errorString,
+                                                                     handle, payload,
+                                                                     payloadLen, reqHandle);
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+
+            case MESSAGE_READ_RESP:
+                uuid = msg.getData().getString(UUID);
+                reqHandle = msg.getData().getInt(REQUEST_HANDLE);
+                errorCode = msg.getData().getInt(ERROR);
+                errorString = errorStatusToString(errorCode, -1);
+                payload = msg.getData().getByteArray(PAYLOAD);
+                if(payload != null)
+                    payloadLen = payload.length;
+                else
+                    payloadLen = 0;
+                result  = mBluetoothService.readResponseNative(uuid, errorString,
+                                                               payload, payloadLen,
+                                                               reqHandle);
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+
+            case MESSAGE_WRITE_RESP:
+                uuid = msg.getData().getString(UUID);
+                reqHandle = msg.getData().getInt(REQUEST_HANDLE);
+                errorCode = msg.getData().getInt(ERROR);
+                errorString = errorStatusToString(errorCode, -1);
+
+                result  = mBluetoothService.writeResponseNative(uuid, errorString, reqHandle);
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+
+            case MESSAGE_ADD_TO_PREFERRED_DEVICE_LIST:
+                path = msg.getData().getString(PATH);
+                result  = mBluetoothService.addToPreferredDeviceListNative(path);
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+
+            case MESSAGE_REMOVE_FROM_PREFERRED_DEVICE_LIST:
+                path = msg.getData().getString(PATH);
+
+                result  = mBluetoothService.removeFromPreferredDeviceListNative(path);
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+
+            case MESSAGE_CLEAR_PREFERRED_DEVICE_LIST:
+                result  = mBluetoothService.clearPreferredDeviceListNative();
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+
+            case MESSAGE_CREATE_CONN_REQ_PREFERRED_DEVICE_LIST:
+                result  = mBluetoothService.gattConnectToPreferredDeviceListNative();
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+
+            case MESSAGE_CANCEL_CREATE_CONN_REQ_PREFERRED_DEVICE_LIST:
+                result  = mBluetoothService.gattCancelConnectToPreferredDeviceListNative();
+                if (!result)
+                    status = BluetoothGatt.GATT_SUCCESS;
+                else
+                    status = BluetoothGatt.GATT_FAILURE;
+                break;
+
+            }
+        }
+    };
+
+    private BluetoothGattProfileHandler(Context context, BluetoothService service) {
+        mBluetoothService = service;
+        mAppConfigs = new HashMap<String, BluetoothGattAppConfiguration>();
+        mCallbacks = new HashMap<BluetoothGattAppConfiguration, IBluetoothGattCallback>();
+        mRegisteredServers = new HashMap<String, Boolean>();
+    }
+
+    static synchronized BluetoothGattProfileHandler getInstance(Context context,
+            BluetoothService service) {
+        if (sInstance == null) sInstance = new BluetoothGattProfileHandler(context, service);
+        return sInstance;
+    }
+
+    boolean registerAppConfiguration(BluetoothGattAppConfiguration config,
+                                     IBluetoothGattCallback callback) {
+
+        Message msg = mHandler.obtainMessage(MESSAGE_REGISTER_APPLICATION);
+        msg.obj = config;
+        mHandler.sendMessage(msg);
+        mCallbacks.put(config, callback);
+
+        return true;
+    }
+
+   boolean unregisterAppConfiguration(BluetoothGattAppConfiguration config) {
+       String path = config.getPath();
+       if (mAppConfigs.containsKey(path)) {
+               Message msg = mHandler.obtainMessage(MESSAGE_UNREGISTER_APPLICATION);
+               msg.obj = config;
+               mHandler.sendMessage(msg);
+               removeRegisteredServer(path);
+               return true;
+       } else {
+           Log.e(TAG, "unregisterAppConfiguration: GATT app not registered");
+           return false;
+       }
+    }
+
+    boolean closeGattLeConnection(BluetoothGattAppConfiguration config,
+                                  String devPath) {
+       String path = config.getPath();
+
+       Log.d(TAG, "closeGattLeConnection");
+       if (!mAppConfigs.containsKey(path)) {
+            Log.e(TAG, "sendIndication: GATT app not registered");
+            return false;
+        }
+
+        Bundle b = new Bundle();
+        b.putString(PATH, devPath);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_DISCONNECT_LE);
+        msg.obj = config;
+        msg.setData(b);
+        mHandler.sendMessage(msg);
+
+        return true;
+    }
+
+    boolean sendIndication(BluetoothGattAppConfiguration config,
+                           int handle, byte[] value, boolean notify, int sessionHandle) {
+
+       String path = config.getPath();
+       if (!mAppConfigs.containsKey(path)) {
+            Log.e(TAG, "sendIndication: GATT app not registered");
+            return false;
+        }
+
+        Bundle b = new Bundle();
+        b.putInt(SESSION, sessionHandle);
+        b.putInt(HANDLE, handle);
+        b.putByteArray(PAYLOAD, value);
+        b.putBoolean(NOTIFY, notify);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_SEND_INDICATION);
+        msg.obj = config;
+        msg.setData(b);
+        mHandler.sendMessage(msg);
+
+        return true;
+    }
+
+    boolean discoverPrimaryResponse(BluetoothGattAppConfiguration config,
+                                       String uuid, int handle, int end, int status, int reqHandle) {
+
+       Log.d(TAG, "discoverPrimaryResponse uuid : " + uuid +
+             " handle : " + handle + " end: " + end + " reqHandle : " + reqHandle);
+
+       String path = config.getPath();
+       if (!mAppConfigs.containsKey(path)) {
+            Log.e(TAG, "discoverPrimaryResponse: GATT app not registered");
+            return false;
+        }
+
+        Bundle b = new Bundle();
+
+        b.putString(UUID, uuid);
+        b.putInt(HANDLE, handle);
+        b.putInt(END, end);
+        b.putInt(ERROR, status);
+        b.putInt(REQUEST_HANDLE, reqHandle);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_DISCOVER_PRIMARY_SERVICE_RESP);
+        msg.obj = config;
+        msg.setData(b);
+        mHandler.sendMessage(msg);
+
+        return true;
+    }
+
+    boolean discoverPrimaryByUuidResponse(BluetoothGattAppConfiguration config,
+                                          int handle, int end, int status, int reqHandle) {
+       String path = config.getPath();
+       if (!mAppConfigs.containsKey(path)) {
+            Log.e(TAG, "discoverPrimaryByUuidResponse: GATT app not registered");
+            return false;
+        }
+
+       Log.d(TAG, "discoverPrimaryByUuidResponse " + " handle : " + handle
+             + " end: " + end + " reqHandle : " + reqHandle);
+
+        Bundle b = new Bundle();
+        b.putInt(HANDLE, handle);
+        b.putInt(END, end);
+        b.putInt(ERROR, status);
+        b.putInt(REQUEST_HANDLE, reqHandle);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_DISCOVER_PRIMARY_SERVICE_BY_UUID_RESP);
+        msg.obj = config;
+        msg.setData(b);
+        mHandler.sendMessage(msg);
+
+        return true;
+    }
+
+    boolean findIncludedResponse(BluetoothGattAppConfiguration config, String uuid,
+                                 int handle, int start, int end, int status, int reqHandle) {
+       String path = config.getPath();
+       if (!mAppConfigs.containsKey(path)) {
+            Log.e(TAG, "findIncludedResponse: GATT app not registered");
+            return false;
+        }
+
+       Log.d(TAG, "findIncludedResponse uuid : " + uuid +
+             " handle : " + handle + " end: " + end + " reqHandle : " + reqHandle);
+
+        Bundle b = new Bundle();
+        b.putString(UUID, uuid);
+        b.putInt(HANDLE, handle);
+        b.putInt(START, start);
+        b.putInt(END, end);
+        b.putInt(ERROR, status);
+        b.putInt(REQUEST_HANDLE, reqHandle);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_FIND_INCLUDED_SERVICE_RESP);
+        msg.obj = config;
+        msg.setData(b);
+        mHandler.sendMessage(msg);
+
+        return true;
+    }
+
+    boolean discoverCharacteristicsResponse(BluetoothGattAppConfiguration config, String uuid,
+                                            int handle, byte property, int valueHandle,
+                                            int status, int reqHandle) {
+       String path = config.getPath();
+       if (!mAppConfigs.containsKey(path)) {
+            Log.e(TAG, "discoverCharacteristicsResponse: GATT app not registered");
+            return false;
+        }
+       Log.d(TAG, " discoverCharacteristicsResponse uuid : " + uuid + " handle : " + handle
+             + " property : " + property +  " valHandle : " + valueHandle +
+             " reqHandle : " + reqHandle);
+
+        Bundle b = new Bundle();
+        b.putString(UUID, uuid);
+        b.putInt(HANDLE, handle);
+        b.putByte(PROPERTY, property);
+        b.putInt(VALUE_HANDLE, valueHandle);
+        b.putInt(ERROR, status);
+        b.putInt(REQUEST_HANDLE, reqHandle);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_DISCOVER_CHARACTERISTICS_RESP);
+        msg.obj = config;
+        msg.setData(b);
+        mHandler.sendMessage(msg);
+
+        return true;
+    }
+
+    boolean findInfoResponse(BluetoothGattAppConfiguration config, String uuid,
+                             int handle, int status, int reqHandle) {
+        String path = config.getPath();
+        if (!mAppConfigs.containsKey(path)) {
+            Log.e(TAG, "findInfoResponse: GATT app not registered");
+            return false;
+        }
+       Log.d(TAG, "findInfoResponse uuid : " + uuid + " handle : " + handle
+             + " reqHandle : " + reqHandle);
+
+        Bundle b = new Bundle();
+        b.putString(UUID, uuid);
+        b.putInt(HANDLE, handle);
+        b.putInt(ERROR, status);
+        b.putInt(REQUEST_HANDLE, reqHandle);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_FIND_INFO_RESP);
+        msg.obj = config;
+        msg.setData(b);
+        mHandler.sendMessage(msg);
+
+        return true;
+    }
+
+    boolean readByTypeResponse(BluetoothGattAppConfiguration config, String uuid, int handle,
+                               byte[] payload, int status, int reqHandle) {
+       String path = config.getPath();
+       if (!mAppConfigs.containsKey(path)) {
+            Log.e(TAG, "readByTypeResponse: GATT app not registered");
+            return false;
+        }
+       Log.d(TAG, " readByTypeResponse uuid : " + uuid + " handle : " + handle
+             + " reqHandle : " + reqHandle);
+
+        Bundle b = new Bundle();
+        b.putString(UUID, uuid);
+        b.putInt(HANDLE, handle);
+        b.putByteArray(PAYLOAD, payload);
+        b.putInt(ERROR, status);
+        b.putInt(REQUEST_HANDLE, reqHandle);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_READ_BY_TYPE_RESP);
+        msg.obj = config;
+        msg.setData(b);
+        mHandler.sendMessage(msg);
+
+        return true;
+    }
+
+    boolean readResponse(BluetoothGattAppConfiguration config, String uuid,
+                         byte[] payload, int status, int reqHandle) {
+       String path = config.getPath();
+       if (!mAppConfigs.containsKey(path)) {
+            Log.e(TAG, "readResponse: GATT app not registered");
+            return false;
+        }
+        Log.d(TAG, " readResponse uuid : " + uuid + " reqHandle : " + reqHandle);
+        Log.d(TAG, "payload " + payload);
+
+        Bundle b = new Bundle();
+        b.putString(UUID, uuid);
+        b.putByteArray(PAYLOAD, payload);
+        b.putInt(ERROR, status);
+        b.putInt(REQUEST_HANDLE, reqHandle);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_READ_RESP);
+        msg.obj = config;
+        msg.setData(b);
+        mHandler.sendMessage(msg);
+
+        return true;
+    }
+
+    boolean writeResponse(BluetoothGattAppConfiguration config, String uuid, int status,
+                          int reqHandle) {
+       String path = config.getPath();
+       if (!mAppConfigs.containsKey(path)) {
+            Log.e(TAG, "writeResponse: GATT app not registered");
+            return false;
+        }
+       Log.d(TAG, " writeResponse uuid : " + uuid + " reqHandle : " + reqHandle);
+
+        Bundle b = new Bundle();
+        b.putString(UUID, uuid);
+        b.putInt(ERROR, status);
+        b.putInt(REQUEST_HANDLE, reqHandle);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_WRITE_RESP);
+        msg.obj = config;
+        msg.setData(b);
+        mHandler.sendMessage(msg);
+
+        return true;
+    }
+
+    boolean addToPreferredDeviceList(String  path) {
+        Log.d(TAG, " addToPreferredDeviceList path : " + path);
+        Bundle b = new Bundle();
+        b.putString(PATH, path);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_ADD_TO_PREFERRED_DEVICE_LIST);
+        msg.setData(b);
+        mHandler.sendMessage(msg);
+        return true;
+    }
+
+    boolean removeFromPreferredDeviceList(String  path) {
+        Log.d(TAG, " removeFromPreferredDeviceList path : " + path);
+        Bundle b = new Bundle();
+        b.putString(PATH, path);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_REMOVE_FROM_PREFERRED_DEVICE_LIST);
+        msg.setData(b);
+        mHandler.sendMessage(msg);
+        return true;
+    }
+
+    boolean clearPreferredDeviceList() {
+        Log.d(TAG, " clearPreferredDeviceList  : ");
+        Message msg = mHandler.obtainMessage(MESSAGE_CLEAR_PREFERRED_DEVICE_LIST);
+        mHandler.sendMessage(msg);
+        return true;
+    }
+
+    boolean gattConnectToPreferredDeviceList() {
+        Log.d(TAG, " gattConnectToPreferredDeviceList  : ");
+        Message msg = mHandler.obtainMessage(MESSAGE_CREATE_CONN_REQ_PREFERRED_DEVICE_LIST);
+        mHandler.sendMessage(msg);
+        return true;
+    }
+
+    boolean gattCancelConnectToPreferredDeviceList() {
+        Log.d(TAG, " gattCancelConnectToPreferredDeviceList : ");
+        Message msg = mHandler.obtainMessage(MESSAGE_CANCEL_CREATE_CONN_REQ_PREFERRED_DEVICE_LIST);
+        mHandler.sendMessage(msg);
+        return true;
+    }
+
+
+    /*package*/ synchronized void onGattDiscoverPrimaryRequest(String path, int start, int end, int reqHandle) {
+         Log.d(TAG, "onGattDiscoverPrimaryRequest - path : "  + path + "start :  " + start + " end : " + end );
+         BluetoothGattAppConfiguration config = mAppConfigs.get(path);
+         if (config != null) {
+             IBluetoothGattCallback callback = mCallbacks.get(config);
+             if (callback != null && isServerEnabled(path)) {
+                try {
+                    callback.onGattDiscoverPrimaryServiceRequest(config, start, end, reqHandle);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Remote Exception:" + e);
+                    if (e instanceof DeadObjectException)
+                        serverDisable(path);
+                } catch (NullPointerException e) {
+                    Log.e(TAG, "Exception:" + e);
+                }
+             }
+         }
+     }
+
+    /*package*/ synchronized void onIndicateResponse(String path, boolean result) {
+        Log.d(TAG, "Indicate response object path : "  + path + "result :" + result );
+        BluetoothGattAppConfiguration config = mAppConfigs.get(path);
+        Log.d(TAG, "Config " + config);
+        if (config != null) {
+            IBluetoothGattCallback callback = mCallbacks.get(config);
+            if (callback != null) {
+                try {
+                    callback.onGattIndicateResponse(config, result);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Remote Exception:" + e);
+                }
+            }
+        }
+    }
+
+     /*package*/ synchronized void onGattDiscoverPrimaryByUuidRequest(String path,
+                                                                      int start, int end,
+                                                                      String uuidStr,
+                                                                      int reqHandle) {
+         Log.d(TAG, "onGattDiscoverPrimaryByUuidRequest - path : "  + path + "uuid : " + uuidStr +
+               "start :  " + start + " end : " + end );
+         BluetoothGattAppConfiguration config = mAppConfigs.get(path);
+         if (config != null) {
+             IBluetoothGattCallback callback = mCallbacks.get(config);
+             if (callback != null && isServerEnabled(path)) {
+                try {
+                    ParcelUuid uuid = ParcelUuid.fromString(uuidStr);
+                    Log.d(TAG, "Convert string to parceluuid : " + uuid);
+                    callback.onGattDiscoverPrimaryServiceByUuidRequest(config, start, end, uuid, reqHandle);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Remote Exception:" + e);
+                    if (e instanceof DeadObjectException)
+                        serverDisable(path);
+                } catch (NullPointerException e) {
+                    Log.e(TAG, "Exception:" + e);
+                }
+             }
+         }
+     }
+
+     /*package*/ synchronized void onGattDiscoverIncludedRequest(String path,
+                                                                 int start, int end,
+                                                                 int reqHandle) {
+         Log.d(TAG, "onGattDiscoverIncludedRequest - path : "  + path +
+               "start :  " + start + " end : " + end );
+         BluetoothGattAppConfiguration config = mAppConfigs.get(path);
+         if (config != null) {
+             IBluetoothGattCallback callback = mCallbacks.get(config);
+             if (callback != null && isServerEnabled(path)) {
+                try {
+                    callback.onGattFindIncludedServiceRequest(config, start, end, reqHandle);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Remote Exception:" + e);
+                    if (e instanceof DeadObjectException)
+                        serverDisable(path);
+                } catch (NullPointerException e) {
+                    Log.e(TAG, "Exception:" + e);
+                }
+             }
+         }
+     }
+
+     /*package*/ synchronized void onGattDiscoverCharacteristicsRequest(String path,
+                                                                 int start, int end,
+                                                                 int reqHandle) {
+         Log.d(TAG, "onGattDiscoverCharacteristicsRequest - path : "  + path +
+               "start :  " + start + " end : " + end );
+         BluetoothGattAppConfiguration config = mAppConfigs.get(path);
+         if (config != null) {
+             IBluetoothGattCallback callback = mCallbacks.get(config);
+             if (callback != null && isServerEnabled(path)) {
+                try {
+                    callback.onGattDiscoverCharacteristicRequest(config, start, end, reqHandle);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Remote Exception:" + e);
+                    if (e instanceof DeadObjectException)
+                        serverDisable(path);
+                } catch (NullPointerException e) {
+                    Log.e(TAG, "Exception:" + e);
+                }
+             }
+         }
+     }
+
+     /*package*/ synchronized void onGattFindInfoRequest(String path,
+                                                         int start, int end,
+                                                         int reqHandle) {
+         Log.d(TAG, "Gatt object path : "  + path +
+               "start :  " + start + " end : " + end );
+         BluetoothGattAppConfiguration config = mAppConfigs.get(path);
+         if (config != null) {
+             IBluetoothGattCallback callback = mCallbacks.get(config);
+             if (callback != null && isServerEnabled(path)) {
+                try {
+                    callback.onGattFindInfoRequest(config, start,
+                                                   end, reqHandle);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Remote Exception:" + e);
+                    if (e instanceof DeadObjectException)
+                        serverDisable(path);
+                } catch (NullPointerException e) {
+                    Log.e(TAG, "Exception:" + e);
+                }
+             }
+         }
+     }
+
+     /*package*/ synchronized void onGattReadByTypeRequest(String path, int start, int end,
+                                                           String uuidStr, String auth, int reqHandle) {
+         Log.d(TAG, "onGattReadByTypeRequest - path : "  + path + "uuid : " + uuidStr +
+               "start :  " + start + " end : " + end + " auth : " + auth);
+         BluetoothGattAppConfiguration config = mAppConfigs.get(path);
+         if (config != null) {
+             IBluetoothGattCallback callback = mCallbacks.get(config);
+             if (callback != null && isServerEnabled(path)) {
+                try {
+                    ParcelUuid uuid = ParcelUuid.fromString(uuidStr);
+                    Log.d(TAG, "Convert string to parceluuid : " + uuid);
+                    callback.onGattReadByTypeRequest(config, uuid, start, end, auth, reqHandle);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Remote Exception:" + e);
+                    if (e instanceof DeadObjectException)
+                        serverDisable(path);
+                } catch (NullPointerException e) {
+                    Log.e(TAG, "Exception:" + e);
+                }
+             }
+         }
+     }
+
+     /*package*/ synchronized void onGattReadRequest(String path, String auth,
+                                                     int handle, int reqHandle) {
+         Log.d(TAG, "onGattReadRequest - path : "  + "handle :  " + handle + " auth : " + auth);
+         BluetoothGattAppConfiguration config = mAppConfigs.get(path);
+         if (config != null) {
+             IBluetoothGattCallback callback = mCallbacks.get(config);
+             if (callback != null && isServerEnabled(path)) {
+                try {
+                    callback.onGattReadRequest(config, handle, auth, reqHandle);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Remote Exception:" + e);
+                    if (e instanceof DeadObjectException)
+                        serverDisable(path);
+                } catch (NullPointerException e) {
+                    Log.e(TAG, "Exception:" + e);
+                }
+             }
+         }
+     }
+
+     /*package*/ synchronized void onGattWriteCommand(String path, String auth,
+                                                      int attrHandle, byte[] value) {
+         BluetoothGattAppConfiguration config = mAppConfigs.get(path);
+         Log.d(TAG, "onGattWriteRequest - path : "  + path + ", config " + config + ", auth " + auth);
+
+         if (config != null) {
+             IBluetoothGattCallback callback = mCallbacks.get(config);
+             if (callback != null && isServerEnabled(path)) {
+                try {
+                    callback.onGattWriteCommand(config, attrHandle, value, auth);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Remote Exception:" + e);
+                    if (e instanceof DeadObjectException)
+                        serverDisable(path);
+                } catch (NullPointerException e) {
+                    Log.e(TAG, "Exception:" + e);
+                }
+             }
+         }
+     }
+
+     /*package*/ synchronized void onGattWriteRequest(String path, String auth,
+                                                      int attrHandle, byte[] value,
+                                                      int sessionHandle, int reqHandle) {
+         BluetoothGattAppConfiguration config = mAppConfigs.get(path);
+         Log.d(TAG, "onGattReliableWriteRequest - path : "  + path + ", config " + config);
+         if (config != null) {
+             IBluetoothGattCallback callback = mCallbacks.get(config);
+             if (callback != null && isServerEnabled(path)) {
+                try {
+                    callback.onGattWriteRequest(config, attrHandle, value, auth, sessionHandle, reqHandle);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Remote Exception:" + e);
+                    if (e instanceof DeadObjectException)
+                        serverDisable(path);
+                } catch (NullPointerException e) {
+                    Log.e(TAG, "Exception:" + e);
+                }
+             }
+         }
+     }
+
+    /*package*/ synchronized void onGattSetClientConfigDescriptor(String path,
+                                                                  int sessionHandle, int attrHandle, byte[] value) {
+         BluetoothGattAppConfiguration config = mAppConfigs.get(path);
+         Log.d(TAG, "onGattSetClientConfigDescriptor - path : "  + path + ", config " + config);
+         if (config != null) {
+             IBluetoothGattCallback callback = mCallbacks.get(config);
+             if (callback != null && isServerEnabled(path)) {
+                try {
+                    callback.onGattSetClientConfigDescriptor(config, attrHandle, value, sessionHandle);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Remote Exception:" + e);
+                    if (e instanceof DeadObjectException)
+                        serverDisable(path);
+                } catch (NullPointerException e) {
+                    Log.e(TAG, "Exception:" + e);
+                }
+             }
+         }
+     }
+
+    private void callGattApplicationStatusCallback(
+            BluetoothGattAppConfiguration config, int status) {
+        Log.d(TAG, "GATT Application: " + config + " State Change: status:"
+                + status);
+        IBluetoothGattCallback callback = mCallbacks.get(config);
+        if (callback != null) {
+            try {
+                callback.onGattAppConfigurationStatusChange(config, status);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Remote Exception:" + e);
+                if (e instanceof DeadObjectException)
+                    serverDisable(config.getPath());
+            } catch (NullPointerException e) {
+                Log.e(TAG, "Exception:" + e);
+            }
+        }
+    }
+
+   private void callGattActionCompleteCallback(
+                                               BluetoothGattAppConfiguration config, String action, int status) {
+        Log.d(TAG, "GATT Action: " + action + " status:" + status);
+        IBluetoothGattCallback callback = mCallbacks.get(config);
+        if (callback != null && isServerEnabled(config.getPath())) {
+            try {
+                callback.onGattActionComplete(config, action, status);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Remote Exception:" + e);
+                if (e instanceof DeadObjectException)
+                    serverDisable(config.getPath());
+            } catch (NullPointerException e) {
+                Log.e(TAG, "Exception:" + e);
+            }
+        }
+    }
+
+    private String errorStatusToString(int errorCode, int handle) {
+
+        /* This will be handled as "no error" by  JNI code */
+        if (errorCode ==  BluetoothGatt.GATT_SUCCESS)
+                return null;
+
+        String errorString = new String();
+
+        switch (errorCode) {
+            /* ATT spec error codes */
+            case BluetoothGatt.ATT_INVALID_HANDLE:
+                errorString = "ATT_INVALID_HANDLE";
+                break;
+            case BluetoothGatt.ATT_WRITE_NOT_PERM:
+                errorString = "ATT_WRITE_NOT_PERM";
+                break;
+            case BluetoothGatt.ATT_READ_NOT_PERM:
+                errorString = "ATT_READ_NOT_PERM";
+                break;
+            case BluetoothGatt.ATT_INVALID_PDU:
+                errorString = "ATT_INVALID_PDU";
+                break;
+            case BluetoothGatt.ATT_AUTHENTICATION:
+                errorString = "ATT_INSUFF_AUTHENTICATION";
+                 break;
+            case BluetoothGatt.ATT_REQ_NOT_SUPP:
+                errorString = "ATT_REQ_NOT_SUPP";
+                break;
+            case BluetoothGatt.ATT_INVALID_OFFSET:
+                errorString = "ATT_INVALID_OFFSET";
+                break;
+            case BluetoothGatt.ATT_AUTHORIZATION:
+                errorString = "ATT_INSUFF_AUTHORIZATION";
+                break;
+            case BluetoothGatt.ATT_PREP_QUEUE_FULL:
+                errorString = "ATT_PREP_QUEUE_FULL";
+                break;
+            case BluetoothGatt.ATT_ATTR_NOT_FOUND:
+                errorString = "ATT_ATTR_NOT_FOUND";
+                break;
+            case BluetoothGatt.ATT_ATTR_NOT_LONG:
+                errorString = "ATT_ATTR_NOT_LONG";
+                break;
+            case BluetoothGatt.ATT_INSUFF_ENCR_KEY_SIZE:
+                errorString = "ATT_INSUFF_ENCR_KEY_SIZE";
+                break;
+            case BluetoothGatt.ATT_INVAL_ATTR_VALUE_LEN:
+                errorString = "ATT_INVAL_ATTR_VALUE_LEN";
+                break;
+            case BluetoothGatt.ATT_UNLIKELY:
+                errorString = "ATT_UNLIKELY";
+                break;
+            case BluetoothGatt.ATT_INSUFF_ENC:
+                errorString = "ATT_INSUFF_ENCRYPTION";
+                break;
+            case BluetoothGatt.ATT_UNSUPP_GRP_TYPE:
+                errorString = "ATT_UNSUPP_GRP_TYPE";
+                break;
+            case BluetoothGatt.ATT_INSUFF_RESOURCES:
+                errorString = "ATT_INSUFF_RESOURCES";
+                break;
+            default:
+                /* Check if this is an application defined error */
+                if (errorCode >= 0x01 && errorCode <= 0xff)
+                    errorString = "ATT_0x" + Integer.toHexString(errorCode);
+                else
+                    errorString = "ATT_UNLIKELY";
+        }
+
+        if (handle != -1)
+            errorString = errorString + "." + Integer.toHexString(handle);
+
+        return errorString;
+    }
+
+    private void loadRegisteredServers(String[] servers) {
+        for (int i = 0; i < servers.length; i++)
+             mRegisteredServers.put(servers[i], true);
+    }
+
+    private void removeRegisteredServer(String path) {
+        if (mRegisteredServers.containsKey(path))
+            mRegisteredServers.remove(path);
+    }
+
+    private boolean isServerEnabled(String path) {
+        if (mRegisteredServers.containsKey(path))
+            return mRegisteredServers.get(path);
+        return false;
+    }
+
+    private void serverDisable(String path) {
+        if (mRegisteredServers.containsKey(path))
+            mRegisteredServers.remove(path);
+        mRegisteredServers.put(path, false);
+        mBluetoothService.unregisterGattServerNative(path, false);
+    }
+
+    private void serverEnable(String path) {
+        if (mRegisteredServers.containsKey(path))
+            mRegisteredServers.remove(path);
+        mRegisteredServers.put(path, true);
+    }
+}
diff --git a/bluetoothmsm/java/android/server/BluetoothHealthProfileHandler.java b/bluetoothmsm/java/android/server/BluetoothHealthProfileHandler.java
new file mode 100644
index 0000000..5e93b81
--- /dev/null
+++ b/bluetoothmsm/java/android/server/BluetoothHealthProfileHandler.java
@@ -0,0 +1,671 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHealth;
+import android.bluetooth.BluetoothHealthAppConfiguration;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.IBluetoothHealthCallback;
+import android.content.Context;
+import android.os.Handler;
+import android.os.Message;
+import android.os.ParcelFileDescriptor;
+import android.os.RemoteException;
+import android.util.Log;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * This handles all the operations on the Bluetooth Health profile.
+ * All functions are called by BluetoothService, as Bluetooth Service
+ * is the Service handler for the HDP profile.
+ *
+ * @hide
+ */
+final class BluetoothHealthProfileHandler {
+    private static final String TAG = "BluetoothHealthProfileHandler";
+    private static final boolean DBG = false;
+
+    private static BluetoothHealthProfileHandler sInstance;
+    private BluetoothService mBluetoothService;
+    private ArrayList<HealthChannel> mHealthChannels;
+    private HashMap <BluetoothHealthAppConfiguration, String> mHealthAppConfigs;
+    private HashMap <BluetoothDevice, Integer> mHealthDevices;
+    private HashMap <BluetoothHealthAppConfiguration, IBluetoothHealthCallback> mCallbacks;
+
+    private static final int MESSAGE_REGISTER_APPLICATION = 0;
+    private static final int MESSAGE_UNREGISTER_APPLICATION = 1;
+    private static final int MESSAGE_CONNECT_CHANNEL = 2;
+    private static final AtomicInteger sChannelId = new AtomicInteger();
+
+    class HealthChannel {
+        private ParcelFileDescriptor mChannelFd;
+        private boolean mMainChannel;
+        private String mChannelPath;
+        private BluetoothDevice mDevice;
+        private BluetoothHealthAppConfiguration mConfig;
+        private int mState;
+        private int mChannelType;
+        private int mId;
+
+        HealthChannel(BluetoothDevice device, BluetoothHealthAppConfiguration config,
+                ParcelFileDescriptor fd, boolean mainChannel, String channelPath) {
+             mChannelFd = fd;
+             mMainChannel = mainChannel;
+             mChannelPath = channelPath;
+             mDevice = device;
+             mConfig = config;
+             mState = BluetoothHealth.STATE_CHANNEL_DISCONNECTED;
+             mId = getChannelId();
+        }
+    }
+
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+            case MESSAGE_REGISTER_APPLICATION:
+                BluetoothHealthAppConfiguration registerApp =
+                    (BluetoothHealthAppConfiguration) msg.obj;
+                int role = registerApp.getRole();
+                String path = null;
+
+                if (role == BluetoothHealth.SINK_ROLE) {
+                    path = mBluetoothService.registerHealthApplicationNative(
+                            registerApp.getDataType(), getStringRole(role), registerApp.getName());
+                } else {
+                    path = mBluetoothService.registerHealthApplicationNative(
+                            registerApp.getDataType(), getStringRole(role), registerApp.getName(),
+                            getStringChannelType(registerApp.getChannelType()));
+                }
+
+                if (path == null) {
+                    callHealthApplicationStatusCallback(registerApp,
+                            BluetoothHealth.APP_CONFIG_REGISTRATION_FAILURE);
+                    mCallbacks.remove(registerApp);
+                } else {
+                    mHealthAppConfigs.put(registerApp, path);
+                    callHealthApplicationStatusCallback(registerApp,
+                            BluetoothHealth.APP_CONFIG_REGISTRATION_SUCCESS);
+                }
+
+                break;
+            case MESSAGE_UNREGISTER_APPLICATION:
+                BluetoothHealthAppConfiguration unregisterApp =
+                    (BluetoothHealthAppConfiguration) msg.obj;
+
+                // Disconnect all the channels
+                for (HealthChannel chan : mHealthChannels) {
+                    if (chan.mConfig.equals(unregisterApp) &&
+                            chan.mState != BluetoothHealth.STATE_CHANNEL_DISCONNECTED) {
+                        disconnectChannel(chan.mDevice, unregisterApp, chan.mId);
+                    }
+                }
+
+                boolean result = mBluetoothService.unregisterHealthApplicationNative(
+                        mHealthAppConfigs.get(unregisterApp));
+                if (result) {
+                    callHealthApplicationStatusCallback(unregisterApp,
+                            BluetoothHealth.APP_CONFIG_UNREGISTRATION_SUCCESS);
+                    mCallbacks.remove(unregisterApp);
+                    mHealthAppConfigs.remove(unregisterApp);
+                } else {
+                    callHealthApplicationStatusCallback(unregisterApp,
+                            BluetoothHealth.APP_CONFIG_UNREGISTRATION_FAILURE);
+                }
+                break;
+            case MESSAGE_CONNECT_CHANNEL:
+                HealthChannel chan = (HealthChannel)msg.obj;
+                String deviceObjectPath =
+                    mBluetoothService.getObjectPathFromAddress(chan.mDevice.getAddress());
+                String configPath = mHealthAppConfigs.get(chan.mConfig);
+                String channelType = getStringChannelType(chan.mChannelType);
+
+                if (!mBluetoothService.createChannelNative(deviceObjectPath, configPath,
+                          channelType, chan.mId)) {
+                    int prevState = chan.mState;
+                    int state = BluetoothHealth.STATE_CHANNEL_DISCONNECTED;
+                    callHealthChannelCallback(chan.mConfig, chan.mDevice, prevState, state, null,
+                            chan.mId);
+                    mHealthChannels.remove(chan);
+                }
+            }
+        }
+    };
+
+    private BluetoothHealthProfileHandler(Context context, BluetoothService service) {
+        mBluetoothService = service;
+        mHealthAppConfigs = new HashMap<BluetoothHealthAppConfiguration, String>();
+        mHealthChannels = new ArrayList<HealthChannel>();
+        mHealthDevices = new HashMap<BluetoothDevice, Integer>();
+        mCallbacks = new HashMap<BluetoothHealthAppConfiguration, IBluetoothHealthCallback>();
+    }
+
+    static synchronized BluetoothHealthProfileHandler getInstance(Context context,
+            BluetoothService service) {
+        if (sInstance == null) sInstance = new BluetoothHealthProfileHandler(context, service);
+        return sInstance;
+    }
+
+    boolean registerAppConfiguration(BluetoothHealthAppConfiguration config,
+                                     IBluetoothHealthCallback callback) {
+        Message msg = mHandler.obtainMessage(MESSAGE_REGISTER_APPLICATION);
+        msg.obj = config;
+        mHandler.sendMessage(msg);
+        mCallbacks.put(config, callback);
+        return true;
+    }
+
+    boolean unregisterAppConfiguration(BluetoothHealthAppConfiguration config) {
+        String path = mHealthAppConfigs.get(config);
+        if (path == null) return false;
+
+        Message msg = mHandler.obtainMessage(MESSAGE_UNREGISTER_APPLICATION);
+        msg.obj = config;
+        mHandler.sendMessage(msg);
+        return true;
+    }
+
+    boolean connectChannelToSource(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        return connectChannel(device, config, BluetoothHealth.CHANNEL_TYPE_ANY);
+    }
+
+    private HealthChannel getMainChannel(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        for (HealthChannel chan: mHealthChannels) {
+            if (chan.mDevice.equals(device) && chan.mConfig.equals(config)) {
+                if (chan.mMainChannel) return chan;
+            }
+        }
+        return null;
+    }
+
+    boolean connectChannel(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config, int channelType) {
+        String deviceObjectPath =
+            mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (deviceObjectPath == null) return false;
+
+        String configPath = mHealthAppConfigs.get(config);
+        if (configPath == null) return false;
+
+        HealthChannel chan = new HealthChannel(device, config, null, false, null);
+        chan.mState = BluetoothHealth.STATE_CHANNEL_CONNECTING;
+        chan.mChannelType = channelType;
+        mHealthChannels.add(chan);
+
+        int prevState = BluetoothHealth.STATE_CHANNEL_DISCONNECTED;
+        int state = BluetoothHealth.STATE_CHANNEL_CONNECTING;
+        callHealthChannelCallback(config, device, prevState, state, null, chan.mId);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_CONNECT_CHANNEL);
+        msg.obj = chan;
+        mHandler.sendMessage(msg);
+
+        return true;
+    }
+
+    private String getStringChannelType(int type) {
+        if (type == BluetoothHealth.CHANNEL_TYPE_RELIABLE) {
+            return "Reliable";
+        } else if (type == BluetoothHealth.CHANNEL_TYPE_STREAMING) {
+            return "Streaming";
+        } else {
+            return "Any";
+        }
+    }
+
+    private String getStringRole(int role) {
+        if (role == BluetoothHealth.SINK_ROLE) {
+            return "Sink";
+        } else if (role == BluetoothHealth.SOURCE_ROLE) {
+            return "Streaming";
+        } else {
+            return null;
+        }
+    }
+
+    private int getChannelId() {
+        // The function doesn't need to be synchronized, as the health profile handler
+        // will only allow one health channel object creation at a time.
+        // In the worst case the while loop will have to break out at some point of
+        // time, because only a limited number of L2CAP channels are possible.
+        int id;
+        boolean found;
+        do {
+            id = sChannelId.incrementAndGet();
+            found = false;
+            for (HealthChannel chan: mHealthChannels) {
+                if (chan.mId == id) found = true;
+            }
+        } while (found);
+        return id;
+    }
+
+    boolean disconnectChannel(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config, int id) {
+        HealthChannel chan = findChannelById(id);
+        if (chan == null) {
+          return false;
+        }
+
+        String deviceObjectPath =
+                mBluetoothService.getObjectPathFromAddress(device.getAddress());
+
+        mBluetoothService.releaseChannelFdNative(chan.mChannelPath);
+
+        int prevState = chan.mState;
+        chan.mState = BluetoothHealth.STATE_CHANNEL_DISCONNECTING;
+        callHealthChannelCallback(config, device, prevState, chan.mState,
+                null, chan.mId);
+
+        if (!mBluetoothService.destroyChannelNative(deviceObjectPath, chan.mChannelPath,
+                                                    chan.mId)) {
+            prevState = chan.mState;
+            chan.mState = BluetoothHealth.STATE_CHANNEL_CONNECTED;
+            callHealthChannelCallback(config, device, prevState, chan.mState,
+                    chan.mChannelFd, chan.mId);
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    private HealthChannel findChannelById(int id) {
+        for (HealthChannel chan : mHealthChannels) {
+            if (chan.mId == id) return chan;
+        }
+        return null;
+    }
+
+    private HealthChannel findChannelByPath(BluetoothDevice device, String path) {
+        for (HealthChannel chan : mHealthChannels) {
+            if (path.equals(chan.mChannelPath) && device.equals(chan.mDevice)) return chan;
+        }
+        return null;
+    }
+
+    private List<HealthChannel> findChannelByStates(BluetoothDevice device, int[] states) {
+        List<HealthChannel> channels = new ArrayList<HealthChannel>();
+        for (HealthChannel chan: mHealthChannels) {
+            if (chan.mDevice.equals(device)) {
+                for (int state : states) {
+                    if (chan.mState == state) {
+                        channels.add(chan);
+                    }
+                }
+            }
+        }
+        return channels;
+    }
+
+    private HealthChannel findConnectingChannel(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        for (HealthChannel chan : mHealthChannels) {
+            if (chan.mDevice.equals(device) && chan.mConfig.equals(config) &&
+                chan.mState == BluetoothHealth.STATE_CHANNEL_CONNECTING) return chan;
+        }
+        return null;
+    }
+
+    ParcelFileDescriptor getMainChannelFd(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        HealthChannel chan = getMainChannel(device, config);
+        if (chan != null) {
+            ParcelFileDescriptor pfd =  null;
+            try {
+                pfd = chan.mChannelFd.dup();
+                return pfd;
+            } catch (IOException e) {
+                return null;
+            }
+        }
+
+        String objectPath =
+                mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (objectPath == null) return null;
+
+        String mainChannelPath = mBluetoothService.getMainChannelNative(objectPath);
+        if (mainChannelPath == null) return null;
+
+        // We had no record of the main channel but querying Bluez we got a
+        // main channel. We might not have received the PropertyChanged yet for
+        // the main channel creation so update our data structure here.
+        chan = findChannelByPath(device, mainChannelPath);
+        if (chan == null) {
+            errorLog("Main Channel present but we don't have any account of it:" +
+                    device +":" + config);
+            return null;
+        }
+        chan.mMainChannel = true;
+        try {
+            return chan.mChannelFd.dup();
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    /*package*/ void onHealthDevicePropertyChanged(String devicePath,
+            String channelPath) {
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        String address = mBluetoothService.getAddressFromObjectPath(devicePath);
+        if (address == null) return;
+
+        //TODO: Fix this in Bluez
+        if (channelPath.equals("/")) {
+            // This means that the main channel is being destroyed.
+            return;
+        }
+
+        BluetoothDevice device = adapter.getRemoteDevice(address);
+        BluetoothHealthAppConfiguration config = findHealthApplication(device,
+                channelPath);
+        if (config != null) {
+            HealthChannel chan = findChannelByPath(device, channelPath);
+            if (chan == null) {
+                errorLog("Health Channel is not present:" + channelPath);
+            } else {
+                chan.mMainChannel = true;
+            }
+        }
+    }
+
+    /*package*/ void onHealthDeviceChannelConnectionError(int chanCode,
+                                                          int state) {
+        HealthChannel channel = findChannelById(chanCode);
+        if (channel == null) errorLog("No record of this channel:" + chanCode);
+
+        callHealthChannelCallback(channel.mConfig, channel.mDevice, channel.mState, state, null,
+                chanCode);
+    }
+
+    private BluetoothHealthAppConfiguration findHealthApplication(
+            BluetoothDevice device, String channelPath) {
+        BluetoothHealthAppConfiguration config = null;
+        HealthChannel chan = findChannelByPath(device, channelPath);
+
+        if (chan != null) {
+            config = chan.mConfig;
+        } else {
+            String configPath = mBluetoothService.getChannelApplicationNative(channelPath);
+            if (configPath == null) {
+                errorLog("Config path is null for application");
+            } else {
+                for (Entry<BluetoothHealthAppConfiguration, String> e :
+                        mHealthAppConfigs.entrySet()) {
+                    if (e.getValue().equals(configPath)) {
+                        config = e.getKey();
+                    }
+                }
+                if (config == null) errorLog("No associated application for path:" + configPath);
+            }
+        }
+        return config;
+    }
+
+    /*package*/ void onHealthDeviceChannelChanged(String devicePath,
+            String channelPath, boolean exists) {
+        debugLog("onHealthDeviceChannelChanged: devicePath: " + devicePath +
+                "ChannelPath: " + channelPath + "Exists: " + exists);
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        String address = mBluetoothService.getAddressFromObjectPath(devicePath);
+        if (address == null) return;
+
+        BluetoothDevice device = adapter.getRemoteDevice(address);
+        BluetoothHealthAppConfiguration config;
+        int state, prevState = BluetoothHealth.STATE_CHANNEL_DISCONNECTED;
+        ParcelFileDescriptor fd;
+        HealthChannel channel;
+        config = findHealthApplication(device, channelPath);
+
+        if (exists) {
+            channel = findConnectingChannel(device, config);
+            if (channel == null) {
+               channel = new HealthChannel(device, config, null, false,
+                       channelPath);
+               channel.mState = BluetoothHealth.STATE_CHANNEL_DISCONNECTED;
+               mHealthChannels.add(channel);
+            }
+            channel.mChannelPath = channelPath;
+
+            fd = mBluetoothService.getChannelFdNative(channelPath);
+            if (fd == null) {
+                errorLog("Error obtaining fd for channel:" + channelPath);
+                disconnectChannel(device, config, channel.mId);
+                return;
+            }
+            boolean mainChannel =
+                    getMainChannel(device, config) == null ? false : true;
+            if (!mainChannel) {
+                String mainChannelPath =
+                        mBluetoothService.getMainChannelNative(devicePath);
+                if (mainChannelPath == null) {
+                    errorLog("Main Channel Path is null for devicePath:" + devicePath);
+                    return;
+                }
+                if (mainChannelPath.equals(channelPath)) mainChannel = true;
+            }
+
+            channel.mChannelFd = fd;
+            channel.mMainChannel = mainChannel;
+            prevState = channel.mState;
+            state = BluetoothHealth.STATE_CHANNEL_CONNECTED;
+        } else {
+            channel = findChannelByPath(device, channelPath);
+            if (channel == null) {
+                errorLog("Channel not found:" + config + ":" + channelPath);
+                return;
+            }
+            mHealthChannels.remove(channel);
+
+            channel.mChannelFd = null;
+            prevState = channel.mState;
+            state = BluetoothHealth.STATE_CHANNEL_DISCONNECTED;
+        }
+        channel.mState = state;
+        callHealthChannelCallback(config, device, prevState, state, channel.mChannelFd,
+                channel.mId);
+    }
+
+    private void callHealthChannelCallback(BluetoothHealthAppConfiguration config,
+            BluetoothDevice device, int prevState, int state, ParcelFileDescriptor fd, int id) {
+        broadcastHealthDeviceStateChange(device, prevState, state);
+
+        debugLog("Health Device Callback: " + device + " State Change: "
+                + prevState + "->" + state);
+
+        ParcelFileDescriptor dupedFd = null;
+        if (fd != null) {
+            try {
+                dupedFd = fd.dup();
+            } catch (IOException e) {
+                dupedFd = null;
+                errorLog("Exception while duping: " + e);
+            }
+        }
+
+        IBluetoothHealthCallback callback = mCallbacks.get(config);
+        if (callback != null) {
+            try {
+                callback.onHealthChannelStateChange(config, device, prevState, state, dupedFd, id);
+            } catch (RemoteException e) {
+                errorLog("Remote Exception:" + e);
+            }
+        }
+    }
+
+    private void callHealthApplicationStatusCallback(
+            BluetoothHealthAppConfiguration config, int status) {
+        debugLog("Health Device Application: " + config + " State Change: status:"
+                + status);
+        IBluetoothHealthCallback callback = mCallbacks.get(config);
+        if (callback != null) {
+            try {
+                callback.onHealthAppConfigurationStatusChange(config, status);
+            } catch (RemoteException e) {
+                errorLog("Remote Exception:" + e);
+            }
+        }
+    }
+
+    int getHealthDeviceConnectionState(BluetoothDevice device) {
+        if (mHealthDevices.get(device) == null) {
+            return BluetoothHealth.STATE_DISCONNECTED;
+        }
+        return mHealthDevices.get(device);
+    }
+
+    List<BluetoothDevice> getConnectedHealthDevices() {
+        List<BluetoothDevice> devices = lookupHealthDevicesMatchingStates(
+                    new int[] {BluetoothHealth.STATE_CONNECTED});
+        return devices;
+    }
+
+    List<BluetoothDevice> getHealthDevicesMatchingConnectionStates(int[] states) {
+        List<BluetoothDevice> devices = lookupHealthDevicesMatchingStates(states);
+        return devices;
+    }
+
+    List<BluetoothDevice> lookupHealthDevicesMatchingStates(int[] states) {
+        List<BluetoothDevice> healthDevices = new ArrayList<BluetoothDevice>();
+
+        for (BluetoothDevice device: mHealthDevices.keySet()) {
+            int healthDeviceState = getHealthDeviceConnectionState(device);
+            for (int state : states) {
+                if (state == healthDeviceState) {
+                    healthDevices.add(device);
+                    break;
+                }
+            }
+        }
+        return healthDevices;
+    }
+
+    /**
+     * This function sends the intent for the updates on the connection status to the remote device.
+     * Note that multiple channels can be connected to the remote device by multiple applications.
+     * This sends an intent for the update to the device connection status and not the channel
+     * connection status. Only the following state transitions are possible:
+     *
+     * {@link BluetoothHealth#STATE_DISCONNECTED} to {@link BluetoothHealth#STATE_CONNECTING}
+     * {@link BluetoothHealth#STATE_CONNECTING} to {@link BluetoothHealth#STATE_CONNECTED}
+     * {@link BluetoothHealth#STATE_CONNECTED} to {@link BluetoothHealth#STATE_DISCONNECTING}
+     * {@link BluetoothHealth#STATE_DISCONNECTING} to {@link BluetoothHealth#STATE_DISCONNECTED}
+     * {@link BluetoothHealth#STATE_DISCONNECTED} to {@link BluetoothHealth#STATE_CONNECTED}
+     * {@link BluetoothHealth#STATE_CONNECTED} to {@link BluetoothHealth#STATE_DISCONNECTED}
+     * {@link BluetoothHealth#STATE_CONNECTING} to {{@link BluetoothHealth#STATE_DISCONNECTED}
+     *
+     * @param device
+     * @param prevChannelState
+     * @param newChannelState
+     * @hide
+     */
+    private void broadcastHealthDeviceStateChange(BluetoothDevice device, int prevChannelState,
+            int newChannelState) {
+        if (mHealthDevices.get(device) == null) {
+            mHealthDevices.put(device, BluetoothHealth.STATE_DISCONNECTED);
+        }
+
+        int currDeviceState = mHealthDevices.get(device);
+        int newDeviceState = convertState(newChannelState);
+
+        if (currDeviceState != newDeviceState) {
+            List<HealthChannel> chan;
+            switch (currDeviceState) {
+                case BluetoothHealth.STATE_DISCONNECTED:
+                    updateAndSendIntent(device, currDeviceState, newDeviceState);
+                    break;
+                case BluetoothHealth.STATE_CONNECTING:
+                    // Channel got connected.
+                    if (newDeviceState == BluetoothHealth.STATE_CONNECTED) {
+                        updateAndSendIntent(device, currDeviceState, newDeviceState);
+                    } else {
+                        // Channel got disconnected
+                        chan = findChannelByStates(device, new int [] {
+                                    BluetoothHealth.STATE_CHANNEL_CONNECTING,
+                                    BluetoothHealth.STATE_CHANNEL_DISCONNECTING});
+                        if (chan.isEmpty()) {
+                            updateAndSendIntent(device, currDeviceState, newDeviceState);
+                        }
+                    }
+                    break;
+                case BluetoothHealth.STATE_CONNECTED:
+                    // Channel got disconnected or is in disconnecting state.
+                    chan = findChannelByStates(device, new int [] {
+                                BluetoothHealth.STATE_CHANNEL_CONNECTING,
+                                BluetoothHealth.STATE_CHANNEL_CONNECTED});
+                    if (chan.isEmpty()) {
+                        updateAndSendIntent(device, currDeviceState, newDeviceState);
+                    }
+                    break;
+                case BluetoothHealth.STATE_DISCONNECTING:
+                    // Channel got disconnected.
+                    chan = findChannelByStates(device, new int [] {
+                                BluetoothHealth.STATE_CHANNEL_CONNECTING,
+                                BluetoothHealth.STATE_CHANNEL_DISCONNECTING});
+                    if (chan.isEmpty()) {
+                        updateAndSendIntent(device, currDeviceState, newDeviceState);
+                    }
+                    break;
+            }
+        }
+    }
+
+    private void updateAndSendIntent(BluetoothDevice device, int prevDeviceState,
+            int newDeviceState) {
+        mHealthDevices.put(device, newDeviceState);
+        mBluetoothService.sendConnectionStateChange(device, BluetoothProfile.HEALTH,
+                                                    newDeviceState, prevDeviceState);
+    }
+
+    /**
+     * This function converts the channel connection state to device connection state.
+     *
+     * @param state
+     * @return
+     */
+    private int convertState(int state) {
+        switch (state) {
+            case BluetoothHealth.STATE_CHANNEL_CONNECTED:
+                return BluetoothHealth.STATE_CONNECTED;
+            case BluetoothHealth.STATE_CHANNEL_CONNECTING:
+                return BluetoothHealth.STATE_CONNECTING;
+            case BluetoothHealth.STATE_CHANNEL_DISCONNECTING:
+                return BluetoothHealth.STATE_DISCONNECTING;
+            case BluetoothHealth.STATE_CHANNEL_DISCONNECTED:
+                return BluetoothHealth.STATE_DISCONNECTED;
+        }
+        errorLog("Mismatch in Channel and Health Device State");
+        return -1;
+    }
+
+    private static void debugLog(String msg) {
+        if (DBG) Log.d(TAG, msg);
+    }
+
+    private static void errorLog(String msg) {
+        Log.e(TAG, msg);
+    }
+}
diff --git a/bluetoothmsm/java/android/server/BluetoothInputProfileHandler.java b/bluetoothmsm/java/android/server/BluetoothInputProfileHandler.java
new file mode 100644
index 0000000..8bc4e13
--- /dev/null
+++ b/bluetoothmsm/java/android/server/BluetoothInputProfileHandler.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (c) 2013 The Linux Foundation. All rights reserved
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothDeviceProfileState;
+import android.bluetooth.BluetoothInputDevice;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothProfileState;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Message;
+import android.provider.Settings;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * This handles all the operations on the HID profile.
+ * All functions are called by BluetoothService, as Bluetooth Service
+ * is the Service handler for the HID profile.
+ */
+final class BluetoothInputProfileHandler {
+    private static final String TAG = "BluetoothInputProfileHandler";
+    private static final boolean DBG = true;
+
+    public static BluetoothInputProfileHandler sInstance;
+    private Context mContext;
+    private BluetoothService mBluetoothService;
+    private final HashMap<BluetoothDevice, Integer> mInputDevices;
+    private final BluetoothProfileState mHidProfileState;
+
+    private BluetoothInputProfileHandler(Context context, BluetoothService service) {
+        mContext = context;
+        mBluetoothService = service;
+        mInputDevices = new HashMap<BluetoothDevice, Integer>();
+        mHidProfileState = new BluetoothProfileState(mContext, BluetoothProfileState.HID);
+        mHidProfileState.start();
+    }
+
+    static synchronized BluetoothInputProfileHandler getInstance(Context context,
+            BluetoothService service) {
+        if (sInstance == null) sInstance = new BluetoothInputProfileHandler(context, service);
+        return sInstance;
+    }
+
+    boolean connectInputDevice(BluetoothDevice device,
+                                            BluetoothDeviceProfileState state) {
+        String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (objectPath == null ||
+            getInputDeviceConnectionState(device) != BluetoothInputDevice.STATE_DISCONNECTED ||
+            getInputDevicePriority(device) == BluetoothInputDevice.PRIORITY_OFF) {
+            return false;
+        }
+        if (state != null) {
+            Message msg = new Message();
+            msg.arg1 = BluetoothDeviceProfileState.CONNECT_HID_OUTGOING;
+            msg.obj = state;
+            mHidProfileState.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    boolean connectInputDeviceInternal(BluetoothDevice device) {
+        String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        handleInputDeviceStateChange(device, BluetoothInputDevice.STATE_CONNECTING);
+        if (!mBluetoothService.connectInputDeviceNative(objectPath)) {
+            handleInputDeviceStateChange(device, BluetoothInputDevice.STATE_DISCONNECTED);
+            return false;
+        }
+        return true;
+    }
+
+    boolean disconnectInputDevice(BluetoothDevice device,
+                                               BluetoothDeviceProfileState state) {
+        String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (objectPath == null ||
+                getInputDeviceConnectionState(device) == BluetoothInputDevice.STATE_DISCONNECTED) {
+            return false;
+        }
+        if (state != null) {
+            Message msg = new Message();
+            msg.arg1 = BluetoothDeviceProfileState.DISCONNECT_HID_OUTGOING;
+            msg.obj = state;
+            mHidProfileState.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    boolean disconnectInputDeviceInternal(BluetoothDevice device) {
+        String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        handleInputDeviceStateChange(device, BluetoothInputDevice.STATE_DISCONNECTING);
+        if (!mBluetoothService.disconnectInputDeviceNative(objectPath)) {
+            handleInputDeviceStateChange(device, BluetoothInputDevice.STATE_CONNECTED);
+            return false;
+        }
+        return true;
+    }
+
+    int getInputDeviceConnectionState(BluetoothDevice device) {
+        if (mInputDevices.get(device) == null) {
+            return BluetoothInputDevice.STATE_DISCONNECTED;
+        }
+        return mInputDevices.get(device);
+    }
+
+    List<BluetoothDevice> getConnectedInputDevices() {
+        List<BluetoothDevice> devices = lookupInputDevicesMatchingStates(
+            new int[] {BluetoothInputDevice.STATE_CONNECTED});
+        return devices;
+    }
+
+    List<BluetoothDevice> getInputDevicesMatchingConnectionStates(int[] states) {
+        List<BluetoothDevice> devices = lookupInputDevicesMatchingStates(states);
+        return devices;
+    }
+    //MR1 Change
+    int getInputDevicePriority(BluetoothDevice device) {
+        return Settings.Secure.getInt(mContext.getContentResolver(),
+                Settings.Global.getBluetoothInputDevicePriorityKey(device.getAddress()),
+                BluetoothInputDevice.PRIORITY_UNDEFINED);
+    }
+    //MR1 change
+    boolean setInputDevicePriority(BluetoothDevice device, int priority) {
+        if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {
+            return false;
+        }
+        return Settings.Secure.putInt(mContext.getContentResolver(),
+                Settings.Global.getBluetoothInputDevicePriorityKey(device.getAddress()),
+                priority);
+    }
+
+    List<BluetoothDevice> lookupInputDevicesMatchingStates(int[] states) {
+        List<BluetoothDevice> inputDevices = new ArrayList<BluetoothDevice>();
+
+        for (BluetoothDevice device: mInputDevices.keySet()) {
+            int inputDeviceState = getInputDeviceConnectionState(device);
+            for (int state : states) {
+                if (state == inputDeviceState) {
+                    inputDevices.add(device);
+                    break;
+                }
+            }
+        }
+        return inputDevices;
+    }
+
+    private void handleInputDeviceStateChange(BluetoothDevice device, int state) {
+        int prevState;
+        if (mInputDevices.get(device) == null) {
+            prevState = BluetoothInputDevice.STATE_DISCONNECTED;
+        } else {
+            prevState = mInputDevices.get(device);
+        }
+        if (prevState == state) return;
+
+        mInputDevices.put(device, state);
+
+        if (getInputDevicePriority(device) >
+              BluetoothInputDevice.PRIORITY_OFF &&
+            state == BluetoothInputDevice.STATE_CONNECTING ||
+            state == BluetoothInputDevice.STATE_CONNECTED) {
+            // We have connected or attempting to connect.
+            // Bump priority
+            setInputDevicePriority(device, BluetoothInputDevice.PRIORITY_AUTO_CONNECT);
+        }
+
+        Intent intent = new Intent(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+        intent.putExtra(BluetoothInputDevice.EXTRA_PREVIOUS_STATE, prevState);
+        intent.putExtra(BluetoothInputDevice.EXTRA_STATE, state);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mContext.sendBroadcast(intent, BluetoothService.BLUETOOTH_PERM);
+
+        debugLog("InputDevice state : device: " + device + " State:" + prevState + "->" + state);
+    }
+
+    void handleInputDevicePropertyChange(String address, boolean connected) {
+        int state = connected ? BluetoothInputDevice.STATE_CONNECTED :
+            BluetoothInputDevice.STATE_DISCONNECTED;
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        BluetoothDevice device = adapter.getRemoteDevice(address);
+        handleInputDeviceStateChange(device, state);
+    }
+
+    void setInitialInputDevicePriority(BluetoothDevice device, int state) {
+        switch (state) {
+            case BluetoothDevice.BOND_BONDED:
+                if (getInputDevicePriority(device) == BluetoothInputDevice.PRIORITY_UNDEFINED) {
+                    setInputDevicePriority(device, BluetoothInputDevice.PRIORITY_ON);
+                }
+                break;
+            case BluetoothDevice.BOND_NONE:
+                setInputDevicePriority(device, BluetoothInputDevice.PRIORITY_UNDEFINED);
+                break;
+        }
+    }
+
+    private static void debugLog(String msg) {
+        if (DBG) Log.d(TAG, msg);
+    }
+
+    private static void errorLog(String msg) {
+        Log.e(TAG, msg);
+    }
+}
diff --git a/bluetoothmsm/java/android/server/BluetoothManagerService.java b/bluetoothmsm/java/android/server/BluetoothManagerService.java
new file mode 100644
index 0000000..b4cd3aa
--- /dev/null
+++ b/bluetoothmsm/java/android/server/BluetoothManagerService.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (c) 2013 The Linux Foundation. All rights reserved
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import android.content.Context;
+import android.content.ContentResolver;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.util.Log;
+import android.util.Slog;
+
+
+import android.bluetooth.IBluetoothManager;
+import android.server.BluetoothA2dpService;
+import android.server.BluetoothService;
+import android.bluetooth.BluetoothAdapter;
+
+
+class BluetoothManagerService extends IBluetoothManager.Stub {
+    private static final String TAG = "BluetoothManagerService";
+    private static final boolean DBG = true;
+    BluetoothService bluetooth = null;
+    BluetoothA2dpService bluetoothA2dp = null;
+
+    //private final Context mContext;
+	private final ContentResolver mContentResolver;
+
+
+   /* private final IBluetoothCallback mBluetoothCallback =  new IBluetoothCallback.Stub() {
+        @Override
+        public void onBluetoothStateChange(int prevState, int newState) throws RemoteException  {
+            Message msg = mHandler.obtainMessage(MESSAGE_BLUETOOTH_STATE_CHANGE,prevState,newState);
+            mHandler.sendMessage(msg);
+        }
+    };*/
+
+    BluetoothManagerService(Context context) {
+        Slog.i(TAG, "BluetoothManagerService started.Start Bluetooth Service");
+        mContentResolver = context.getContentResolver();
+        bluetooth = new BluetoothService(context);
+        ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, bluetooth);
+        bluetooth.initAfterRegistration();
+        bluetoothA2dp = new BluetoothA2dpService(context, bluetooth);
+        ServiceManager.addService(BluetoothA2dpService.BLUETOOTH_A2DP_SERVICE, bluetoothA2dp);
+        bluetooth.initAfterA2dpRegistration();
+        int airplaneModeOn = Settings.System.getInt(mContentResolver,
+               Settings.System.AIRPLANE_MODE_ON, 0);
+        int bluetoothOn = Settings.Secure.getInt(mContentResolver,
+            Settings.Secure.BLUETOOTH_ON, 0);
+        if (airplaneModeOn == 0 && bluetoothOn != 0) {
+            bluetooth.enable();
+        }
+    }
+
+    public boolean isEnabled() {
+        return false;
+    }
+
+    public boolean disable(boolean saveSetting) {
+        return bluetooth.disable(saveSetting);
+    }
+
+    public boolean enableNoAutoConnect() {
+        return false;
+    }
+
+    public String getAddress() {
+        return null;
+    }
+
+    public String getName() {
+        return null;
+    }
+}
+
diff --git a/bluetoothmsm/java/android/server/BluetoothPanProfileHandler.java b/bluetoothmsm/java/android/server/BluetoothPanProfileHandler.java
new file mode 100644
index 0000000..6c4252c
--- /dev/null
+++ b/bluetoothmsm/java/android/server/BluetoothPanProfileHandler.java
@@ -0,0 +1,417 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (c) 2013 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothPan;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothTetheringDataTracker;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources.NotFoundException;
+import android.net.ConnectivityManager;
+import android.net.InterfaceConfiguration;
+import android.net.LinkAddress;
+import android.net.NetworkUtils;
+import android.os.IBinder;
+import android.os.INetworkManagementService;
+import android.os.ServiceManager;
+import android.util.Log;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * This handles the PAN profile. All calls into this are made
+ * from Bluetooth Service.
+ */
+final class BluetoothPanProfileHandler {
+    private static final String TAG = "BluetoothPanProfileHandler";
+    private static final boolean DBG = true;
+
+    private ArrayList<String> mBluetoothIfaceAddresses;
+    private int mMaxPanDevices;
+
+    private static final String BLUETOOTH_IFACE_ADDR_START= "192.168.44.1";
+    private static final int BLUETOOTH_MAX_PAN_CONNECTIONS = 5;
+    private static final int BLUETOOTH_PREFIX_LENGTH        = 24;
+    public static BluetoothPanProfileHandler sInstance;
+    private final HashMap<BluetoothDevice, BluetoothPanDevice> mPanDevices;
+    private boolean mTetheringOn;
+    private Context mContext;
+    private BluetoothService mBluetoothService;
+
+    static final String NAP_ROLE = "nap";
+    static final String NAP_BRIDGE = "pan1";
+
+    private BluetoothPanProfileHandler(Context context, BluetoothService service) {
+        mContext = context;
+        mPanDevices = new HashMap<BluetoothDevice, BluetoothPanDevice>();
+        mBluetoothService = service;
+        mTetheringOn = false;
+        mBluetoothIfaceAddresses = new ArrayList<String>();
+        try {
+            mMaxPanDevices = context.getResources().getInteger(
+                            com.android.internal.R.integer.config_max_pan_devices);
+        } catch (NotFoundException e) {
+            mMaxPanDevices = BLUETOOTH_MAX_PAN_CONNECTIONS;
+        }
+    }
+
+    static BluetoothPanProfileHandler getInstance(Context context,
+            BluetoothService service) {
+        if (sInstance == null) sInstance = new BluetoothPanProfileHandler(context, service);
+        return sInstance;
+    }
+
+    boolean isTetheringOn() {
+        return mTetheringOn;
+    }
+
+    boolean allowIncomingTethering() {
+        if (isTetheringOn() && getConnectedPanDevices().size() < mMaxPanDevices)
+            return true;
+        return false;
+    }
+
+    private BroadcastReceiver mTetheringReceiver = null;
+
+    void setBluetoothTethering(boolean value) {
+        if (!value) {
+            disconnectPanServerDevices();
+        }
+
+        if (mBluetoothService.getBluetoothState() != BluetoothAdapter.STATE_ON && value) {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
+            mTetheringReceiver = new BroadcastReceiver() {
+                @Override
+                public void onReceive(Context context, Intent intent) {
+                    if (intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.STATE_OFF)
+                            == BluetoothAdapter.STATE_ON) {
+                        mTetheringOn = true;
+                        mContext.unregisterReceiver(mTetheringReceiver);
+                    }
+                }
+            };
+            mContext.registerReceiver(mTetheringReceiver, filter);
+        } else {
+            mTetheringOn = value;
+        }
+    }
+
+    int getPanDeviceConnectionState(BluetoothDevice device) {
+        BluetoothPanDevice panDevice = mPanDevices.get(device);
+        if (panDevice == null) {
+            return BluetoothPan.STATE_DISCONNECTED;
+        }
+        return panDevice.mState;
+    }
+
+    public int getPanDeviceRole(BluetoothDevice device) {
+        BluetoothPanDevice panDevice = mPanDevices.get(device);
+        if (panDevice == null) {
+            return 0;
+        }
+        return panDevice.mLocalRole;
+    }
+
+    boolean connectPanDevice(BluetoothDevice device) {
+        String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (DBG) Log.d(TAG, "connect PAN(" + objectPath + ")");
+        if (getPanDeviceConnectionState(device) != BluetoothPan.STATE_DISCONNECTED) {
+            errorLog(device + " already connected to PAN");
+        }
+
+        int connectedCount = 0;
+        for (BluetoothDevice panDevice: mPanDevices.keySet()) {
+            if (getPanDeviceConnectionState(panDevice) == BluetoothPan.STATE_CONNECTED) {
+                connectedCount ++;
+            }
+        }
+        if (connectedCount > 8) {
+            debugLog(device + " could not connect to PAN because 8 other devices are"
+                    + "already connected");
+            return false;
+        }
+
+        // Send interface as null as it is not known
+        handlePanDeviceStateChange(device, null, BluetoothPan.STATE_CONNECTING,
+                                           BluetoothPan.LOCAL_PANU_ROLE);
+        if (mBluetoothService.connectPanDeviceNative(objectPath, "nap")) {
+            debugLog("connecting to PAN");
+            return true;
+        } else {
+            handlePanDeviceStateChange(device, null, BluetoothPan.STATE_DISCONNECTED,
+                                                BluetoothPan.LOCAL_PANU_ROLE);
+            errorLog("could not connect to PAN");
+            return false;
+        }
+    }
+
+    private boolean disconnectPanServerDevices() {
+        debugLog("disconnect all PAN devices");
+
+        for (BluetoothDevice device: mPanDevices.keySet()) {
+            BluetoothPanDevice panDevice = mPanDevices.get(device);
+            int state = panDevice.mState;
+            if (state == BluetoothPan.STATE_CONNECTED &&
+                    panDevice.mLocalRole == BluetoothPan.LOCAL_NAP_ROLE) {
+                String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+
+                handlePanDeviceStateChange(device, panDevice.mIface,
+                        BluetoothPan.STATE_DISCONNECTING, panDevice.mLocalRole);
+
+                if (!mBluetoothService.disconnectPanServerDeviceNative(objectPath,
+                        device.getAddress(),
+                        panDevice.mIface)) {
+                    errorLog("could not disconnect Pan Server Device "+device.getAddress());
+
+                    // Restore prev state
+                    handlePanDeviceStateChange(device, panDevice.mIface, state,
+                            panDevice.mLocalRole);
+
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    List<BluetoothDevice> getConnectedPanDevices() {
+        List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();
+
+        for (BluetoothDevice device: mPanDevices.keySet()) {
+            if (getPanDeviceConnectionState(device) == BluetoothPan.STATE_CONNECTED) {
+                devices.add(device);
+            }
+        }
+        return devices;
+    }
+
+    List<BluetoothDevice> getPanDevicesMatchingConnectionStates(int[] states) {
+        List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();
+
+        for (BluetoothDevice device: mPanDevices.keySet()) {
+            int panDeviceState = getPanDeviceConnectionState(device);
+            for (int state : states) {
+                if (state == panDeviceState) {
+                    devices.add(device);
+                    break;
+                }
+            }
+        }
+        return devices;
+    }
+
+    boolean disconnectPanDevice(BluetoothDevice device) {
+        String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        debugLog("disconnect PAN(" + objectPath + ")");
+
+        int state = getPanDeviceConnectionState(device);
+        if (state != BluetoothPan.STATE_CONNECTED) {
+            debugLog(device + " already disconnected from PAN");
+            return false;
+        }
+
+        BluetoothPanDevice panDevice = mPanDevices.get(device);
+
+        if (panDevice == null) {
+            errorLog("No record for this Pan device:" + device);
+            return false;
+        }
+
+        handlePanDeviceStateChange(device, panDevice.mIface, BluetoothPan.STATE_DISCONNECTING,
+                                    panDevice.mLocalRole);
+        if (panDevice.mLocalRole == BluetoothPan.LOCAL_NAP_ROLE) {
+            if (!mBluetoothService.disconnectPanServerDeviceNative(objectPath, device.getAddress(),
+                    panDevice.mIface)) {
+                // Restore prev state, this shouldn't happen
+                handlePanDeviceStateChange(device, panDevice.mIface, state, panDevice.mLocalRole);
+                return false;
+            }
+        } else {
+            if (!mBluetoothService.disconnectPanDeviceNative(objectPath)) {
+                // Restore prev state, this shouldn't happen
+                handlePanDeviceStateChange(device, panDevice.mIface, state, panDevice.mLocalRole);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    void handlePanDeviceStateChange(BluetoothDevice device,
+                                                 String iface, int state, int role) {
+        int prevState;
+        String ifaceAddr = null;
+        BluetoothPanDevice panDevice = mPanDevices.get(device);
+
+        if (panDevice == null) {
+            prevState = BluetoothPan.STATE_DISCONNECTED;
+        } else {
+            prevState = panDevice.mState;
+            ifaceAddr = panDevice.mIfaceAddr;
+        }
+        if (prevState == state) return;
+
+        if (role == BluetoothPan.LOCAL_NAP_ROLE) {
+            if (state == BluetoothPan.STATE_CONNECTED) {
+                ifaceAddr = enableTethering(iface);
+                if (ifaceAddr == null) Log.e(TAG, "Error seting up tether interface");
+            } else if (state == BluetoothPan.STATE_DISCONNECTED) {
+                if (ifaceAddr != null) {
+                    mBluetoothIfaceAddresses.remove(ifaceAddr);
+                    ifaceAddr = null;
+                }
+            }
+        } else {
+            // PANU Role = reverse Tether
+            if (state == BluetoothPan.STATE_CONNECTED) {
+                BluetoothTetheringDataTracker.getInstance().startReverseTether(iface, device);
+            } else if (state == BluetoothPan.STATE_DISCONNECTED &&
+                  (prevState == BluetoothPan.STATE_CONNECTED ||
+                  prevState == BluetoothPan.STATE_DISCONNECTING)) {
+                BluetoothTetheringDataTracker.getInstance().stopReverseTether(panDevice.mIface);
+            }
+        }
+
+        if (panDevice == null) {
+            panDevice = new BluetoothPanDevice(state, ifaceAddr, iface, role);
+            mPanDevices.put(device, panDevice);
+        } else {
+            panDevice.mState = state;
+            panDevice.mIfaceAddr = ifaceAddr;
+            panDevice.mLocalRole = role;
+            panDevice.mIface = iface;
+        }
+
+        Intent intent = new Intent(BluetoothPan.ACTION_CONNECTION_STATE_CHANGED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+        intent.putExtra(BluetoothPan.EXTRA_PREVIOUS_STATE, prevState);
+        intent.putExtra(BluetoothPan.EXTRA_STATE, state);
+        intent.putExtra(BluetoothPan.EXTRA_LOCAL_ROLE, role);
+        mContext.sendBroadcast(intent, BluetoothService.BLUETOOTH_PERM);
+
+        debugLog("Pan Device state : device: " + device + " State:" + prevState + "->" + state);
+    }
+
+    private class BluetoothPanDevice {
+        private int mState;
+        private String mIfaceAddr;
+        private String mIface;
+        private int mLocalRole; // Which local role is this PAN device bound to
+
+        BluetoothPanDevice(int state, String ifaceAddr, String iface, int localRole) {
+            mState = state;
+            mIfaceAddr = ifaceAddr;
+            mIface = iface;
+            mLocalRole = localRole;
+        }
+    }
+
+    private String createNewTetheringAddressLocked() {
+        if (getConnectedPanDevices().size() == mMaxPanDevices) {
+            debugLog ("Max PAN device connections reached");
+            return null;
+        }
+        String address = BLUETOOTH_IFACE_ADDR_START;
+        while (true) {
+            if (mBluetoothIfaceAddresses.contains(address)) {
+                String[] addr = address.split("\\.");
+                Integer newIp = Integer.parseInt(addr[2]) + 1;
+                address = address.replace(addr[2], newIp.toString());
+            } else {
+                break;
+            }
+        }
+        mBluetoothIfaceAddresses.add(address);
+        return address;
+    }
+
+    // configured when we start tethering
+    private String enableTethering(String iface) {
+        debugLog("updateTetherState:" + iface);
+
+        IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
+        INetworkManagementService service = INetworkManagementService.Stub.asInterface(b);
+        ConnectivityManager cm =
+            (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+        String[] bluetoothRegexs = cm.getTetherableBluetoothRegexs();
+
+        // bring toggle the interfaces
+        String[] currentIfaces = new String[0];
+        try {
+            currentIfaces = service.listInterfaces();
+        } catch (Exception e) {
+            Log.e(TAG, "Error listing Interfaces :" + e);
+            return null;
+        }
+
+        boolean found = false;
+        for (String currIface: currentIfaces) {
+            if (currIface.equals(iface)) {
+                found = true;
+                break;
+            }
+        }
+
+        if (!found) return null;
+
+        String address = createNewTetheringAddressLocked();
+        if (address == null) return null;
+
+        InterfaceConfiguration ifcg = null;
+        try {
+            ifcg = service.getInterfaceConfig(iface);
+            if (ifcg != null) {
+                final LinkAddress linkAddr = ifcg.getLinkAddress();
+                InetAddress addr = null;
+                if (linkAddr == null || (addr = linkAddr.getAddress()) == null ||
+                        addr.equals(NetworkUtils.numericToInetAddress("0.0.0.0")) ||
+                        addr.equals(NetworkUtils.numericToInetAddress("::0"))) {
+                    addr = NetworkUtils.numericToInetAddress(address);
+                }
+                ifcg.setInterfaceUp();
+                ifcg.clearFlag("running");
+                ifcg.setLinkAddress(new LinkAddress(addr, BLUETOOTH_PREFIX_LENGTH));
+                service.setInterfaceConfig(iface, ifcg);
+                if (cm.tether(iface) != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
+                    Log.e(TAG, "Error tethering "+iface);
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Error configuring interface " + iface + ", :" + e);
+            mBluetoothIfaceAddresses.remove(address);
+            return null;
+        }
+        return address;
+    }
+
+    private static void debugLog(String msg) {
+        if (DBG) Log.d(TAG, msg);
+    }
+
+    private static void errorLog(String msg) {
+        Log.e(TAG, msg);
+    }
+}
diff --git a/bluetoothmsm/java/android/server/BluetoothService.java b/bluetoothmsm/java/android/server/BluetoothService.java
new file mode 100644
index 0000000..09f125f
--- /dev/null
+++ b/bluetoothmsm/java/android/server/BluetoothService.java
@@ -0,0 +1,5715 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * TODO: Move this to
+ * java/services/com/android/server/BluetoothService.java
+ * and make the contructor package private again.
+ *
+ * @hide
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothDeviceProfileState;
+import android.bluetooth.BluetoothHeadset;
+import android.bluetooth.BluetoothHealthAppConfiguration;
+import android.bluetooth.BluetoothInputDevice;
+import android.bluetooth.BluetoothPan;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothProfileState;
+import android.bluetooth.BluetoothSocket;
+import android.bluetooth.BluetoothUuid;
+import android.bluetooth.BluetoothGattService;
+import android.bluetooth.IBluetooth;
+import android.bluetooth.IBluetoothCallback;
+import android.bluetooth.IBluetoothHealthCallback;
+import android.bluetooth.IBluetoothStateChangeCallback;
+import android.bluetooth.IBluetoothGattService;
+import android.bluetooth.IBluetoothGattCallback;
+import android.bluetooth.BluetoothGattAppConfiguration;
+import android.bluetooth.IBluetoothPreferredDeviceListCallback;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.content.res.Resources;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.ParcelFileDescriptor;
+import android.os.ParcelUuid;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemService;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.util.Log;
+import android.util.Pair;
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.os.SystemClock;
+
+import com.android.internal.app.IBatteryStats;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.DataInputStream;
+import java.io.File;
+import java.io.FileDescriptor;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.io.RandomAccessFile;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.SortedMap;
+import java.util.TreeMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.LinkedList;
+import java.util.ListIterator;
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+public class BluetoothService extends IBluetooth.Stub {
+    private static final String TAG = "BluetoothService";
+    private static final boolean DBG = true;
+
+    private int mNativeData;
+    private BluetoothEventLoop mEventLoop;
+    private BluetoothHeadset mHeadsetProxy;
+    private BluetoothInputDevice mInputDevice;
+    private BluetoothPan mPan;
+    private boolean mIsAirplaneSensitive;
+    private boolean mIsAirplaneToggleable;
+    private BluetoothAdapterStateMachine mBluetoothState;
+    private int[] mAdapterSdpHandles;
+    private ParcelUuid[] mAdapterUuids;
+
+    private BluetoothAdapter mAdapter;  // constant after init()
+    private final BluetoothBondState mBondState;  // local cache of bondings
+    private final IBatteryStats mBatteryStats;
+    private final Context mContext;
+    private Map<Integer, IBluetoothStateChangeCallback> mStateChangeTracker =
+        Collections.synchronizedMap(new HashMap<Integer, IBluetoothStateChangeCallback>());
+
+    private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
+    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
+
+    private static final String DOCK_ADDRESS_PATH = "/sys/class/switch/dock/bt_addr";
+    private static final String DOCK_PIN_PATH = "/sys/class/switch/dock/bt_pin";
+
+    private static final String SHARED_PREFERENCE_DOCK_ADDRESS = "dock_bluetooth_address";
+    private static final String SHARED_PREFERENCES_NAME = "bluetooth_service_settings";
+
+    private static final int MESSAGE_UUID_INTENT = 1;
+    private static final int MESSAGE_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY = 2;
+    private static final int MESSAGE_REMOVE_SERVICE_RECORD = 3;
+
+    private static final int MESSAGE_GATT_INTENT = 7;
+    private static final int RFCOMM_RECORD_REAPER = 10;
+    private static final int STATE_CHANGE_REAPER = 11;
+
+    // The time (in millisecs) to delay the pairing attempt after the first
+    // auto pairing attempt fails. We use an exponential delay with
+    // INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY as the initial value and
+    // MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY as the max value.
+    private static final long INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY = 3000;
+    private static final long MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY = 12000;
+
+    private static final int SDP_ATTR_PROTO_DESC_LIST = 0x0004;
+    private static final int SDP_ATTR_ADD_PROTO_DESC_LIST = 0x000d;
+    private static final int SDP_ATTR_GOEP_L2CAP_PSM = 0x0200;
+    private static final int SDP_ATTR_BPP_SUPPORTED_DOC_FORMAT = 0x0350;
+
+    // The timeout used to sent the UUIDs Intent
+    // This timeout should be greater than the page timeout
+    // Some of devices takes more than 15 secons for SDP response,
+    // Therefore, it is better set 30 seconds timeout instead of 6 seconds.
+    private static final int UUID_INTENT_DELAY = 30000;
+
+    // The timeout used to sent the GATT services Intent
+    // This timeout should be greater than the page timeout
+    private static final int GATT_INTENT_DELAY = 30000;
+
+    public static final String SAP_STATECHANGE_INTENT =
+            "com.android.bluetooth.sap.statechanged";
+
+    public static final String DUN_STATECHANGE_INTENT =
+            "com.android.bluetooth.dun.statechanged";
+
+    private static final String SAP_UUID = "0000112D-0000-1000-8000-00805F9B34FB";
+    private static final String DUN_UUID = "00001103-0000-1000-8000-00805F9B34FB";
+
+    /** Always retrieve RFCOMM channel for these SDP UUIDs */
+    private static final ParcelUuid[] RFCOMM_UUIDS = {
+            BluetoothUuid.Handsfree,
+            BluetoothUuid.HSP,
+            BluetoothUuid.ObexObjectPush,
+            BluetoothUuid.MessageNotificationServer,
+            BluetoothUuid.DirectPrinting,
+            BluetoothUuid.ReferencePrinting,
+            BluetoothUuid.PrintingStatus };
+
+    private final BluetoothAdapterProperties mAdapterProperties;
+    private final BluetoothDeviceProperties mDeviceProperties;
+
+    private final HashMap<String, Map<String, String>> mGattProperties;
+
+    private final HashMap<String, Map<ParcelUuid, Integer>> mDeviceServiceChannelCache;
+    private final HashMap<String, Map<ParcelUuid, Integer>> mDeviceL2capPsmCache;
+    private final HashMap<String, Map<String, String>> mDeviceFeatureCache;
+
+    private final ArrayList<String> mUuidIntentTracker;
+    private final ConcurrentHashMap<RemoteService, IBluetoothCallback> mUuidCallbackTracker;
+
+    private static class ServiceRecordClient {
+        int pid;
+        IBinder binder;
+        IBinder.DeathRecipient death;
+    }
+    private final ConcurrentHashMap<Integer, ServiceRecordClient> mServiceRecordToPid;
+    private final HashMap<String, ArrayList<ParcelUuid>> mGattIntentTracker;
+    private final HashMap<String, IBluetoothGattService> mGattServiceTracker;
+    private final HashMap<String, HashMap<Integer, IBluetoothGattService>> mGattWatcherTracker;
+    private final HashMap<String, ArrayList<String>> mGattOperationTracker;
+
+    private final SortedMap<String, Integer> mGattServices;
+
+    private final HashMap<String, BluetoothDeviceProfileState> mDeviceProfileState;
+    private final BluetoothProfileState mA2dpProfileState;
+    private final BluetoothProfileState mHfpProfileState;
+
+    private BluetoothA2dpService mA2dpService;
+    private final HashMap<String, Pair<byte[], byte[]>> mDeviceOobData;
+    private HostPatchForIOP mHostPatchForIOP;
+
+    private int mProfilesConnected = 0, mProfilesConnecting = 0, mProfilesDisconnecting = 0;
+
+    private int mDeviceConnected = 0;
+
+    private static String mDockAddress;
+    private String mDockPin;
+
+    private Object mAllowConnectLock = new Object();
+    private boolean mAllowConnect = true;
+
+    private int mAdapterConnectionState = BluetoothAdapter.STATE_DISCONNECTED;
+    private BluetoothPanProfileHandler mBluetoothPanProfileHandler;
+    private BluetoothInputProfileHandler mBluetoothInputProfileHandler;
+    private BluetoothHealthProfileHandler mBluetoothHealthProfileHandler;
+    private BluetoothGattProfileHandler mBluetoothGattProfileHandler;
+    private static final String INCOMING_CONNECTION_FILE =
+      "/data/misc/bluetooth/incoming_connection.conf";
+    private HashMap<String, Pair<Integer, String>> mIncomingConnections;
+    private HashMap<Integer, Pair<Integer, Integer>> mProfileConnectionState;
+
+    private int[] mDUNRecordHandle;
+    private boolean mDUNEnabled = false;
+
+    private int[] mFTPRecordHandle;
+    private boolean mFTPEnabled = false;
+    private int[] mSAPRecordHandle;
+    private boolean mSAPEnabled = false;
+    private int[] mMAPRecordHandle;
+    private boolean mMAPEnabled = false;
+
+    private AlarmManager mAlarmManager;
+    private Intent mDiscoverableTimeoutIntent;
+    private PendingIntent mPendingDiscoverableTimeout;
+    private static final String ACTION_BT_DISCOVERABLE_TIMEOUT =
+             "android.bluetooth.service.action.DISCOVERABLE_TIMEOUT";
+
+    public IBluetoothPreferredDeviceListCallback sPListCallBack = null;
+    public ArrayList<Integer> usedSrvIds = new ArrayList<Integer>();
+    public String callerPreferredDevApi = null;
+    public String callerIntent = null;
+    public HashMap<BluetoothDevice, Integer> preferredDevicesList;
+    public BluetoothDevice btDeviceInPreferredDevList;
+    public boolean isScanInProgress = false;
+    public final int DEVICE_IS_CONNECTED = 1;
+    public final int DEVICE_IN_PREFERRED_DEVICES_LIST = 2;
+
+    private static class RemoteService {
+        public String address;
+        public ParcelUuid uuid;
+        public RemoteService(String address, ParcelUuid uuid) {
+            this.address = address;
+            this.uuid = uuid;
+        }
+        @Override
+        public boolean equals(Object o) {
+            if (o instanceof RemoteService) {
+                RemoteService service = (RemoteService)o;
+                return address.equals(service.address) && uuid.equals(service.uuid);
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            int hash = 1;
+            hash = hash * 31 + (address == null ? 0 : address.hashCode());
+            hash = hash * 31 + (uuid == null ? 0 : uuid.hashCode());
+            return hash;
+        }
+    }
+
+    private static class HostPatchForIOP {
+        private static final String HOST_PATCH_IOP_BLACKLIST =
+                 "/etc/bluetooth/iop_device_list.conf";
+        private ArrayList <String> mDontRemoveServiceBlackList;
+        private ArrayList <String> mAvoidConnectOnPairBlackList;
+        private ArrayList <String> mAvoidAutoConnectBlackList;
+        private ArrayList <String> mEnablePhotoOnPbap;
+
+        public HostPatchForIOP() {
+             // Read the IOP device list into patch table
+            if(DBG) Log.d(TAG, " HostPatchForIOT: Loading from conf");
+            FileInputStream fstream = null;
+            try {
+                fstream = new FileInputStream(HOST_PATCH_IOP_BLACKLIST);
+                DataInputStream in = new DataInputStream(fstream);
+                BufferedReader file = new BufferedReader(new InputStreamReader(in));
+                String line;
+                while((line = file.readLine()) != null) {
+                    line = line.trim();
+                    if (line.length() == 0 || line.startsWith("//")) continue;
+                    String[] value = line.split(" ");
+                    if (value != null && value.length == 2) {
+                        String[] val = value[1].split(";");
+                        if (value[0].equalsIgnoreCase("sdp_missing_uuids")) {
+                            mDontRemoveServiceBlackList =
+                                new ArrayList<String>(Arrays.asList(val));
+                            if(DBG) Log.d(TAG, " HostPatchForIOT: Loaded DontRemoveService");
+                        } else if (value[0].equalsIgnoreCase("avoid_connect_after_pair")) {
+                            mAvoidConnectOnPairBlackList =
+                                new ArrayList<String>(Arrays.asList(val));
+                            if(DBG) Log.d(TAG, " HostPatchForIOT: Loaded NoConnectionOnPair");
+                        } else if (value[0].equalsIgnoreCase("avoid_autoconnect")) {
+                            mAvoidAutoConnectBlackList =
+                                new ArrayList<String>(Arrays.asList(val));
+                            if(DBG) Log.d(TAG, " HostPatchForIOT: Loaded NoAutoConnectList");
+                        } else if (value[0].equalsIgnoreCase("enable_photosharing")) {
+                            if(DBG) Log.d(TAG, " HostPatchForIOT: Loaded  Photo Sharing");
+                            mEnablePhotoOnPbap =
+                                    new ArrayList<String>(Arrays.asList(val));
+                        }
+                    }
+                }
+            } catch (FileNotFoundException e) {
+                Log.e(TAG, "HOST Patch conf File Not found : " + HOST_PATCH_IOP_BLACKLIST);
+            } catch (IOException e) {
+                Log.e(TAG, "IOException: read HOST Patch conf File " + e);
+            } finally {
+                if (fstream != null) {
+                    try {
+                        fstream.close();
+                    } catch (IOException e) {
+                        // Ignore
+                    }
+                }
+            }
+        }
+
+        public boolean isHostPatchRequired(String address, int patch_id) {
+            // Check the device address in patch table
+            // If the device is found in the list for the patch, return true
+            if(DBG) Log.d(TAG, " HostPatchForIOT: Checking");
+            switch (patch_id) {
+            case BluetoothAdapter.HOST_PATCH_DONT_REMOVE_SERVICE:
+                if (mDontRemoveServiceBlackList != null) {
+                    for (String blacklistAddress : mDontRemoveServiceBlackList) {
+                        if (address.regionMatches(true, 0,
+                             blacklistAddress, 0, blacklistAddress.length())) {
+                            if(DBG) Log.d(TAG, " HostPatchForIOT: Apply DontRemoveService");
+                            return true;
+                        }
+                    }
+                }
+                break;
+            case BluetoothAdapter.HOST_PATCH_AVOID_CONNECT_ON_PAIR:
+                if (mAvoidConnectOnPairBlackList != null) {
+                    for (String blacklistAddress : mAvoidConnectOnPairBlackList) {
+                        if (address.regionMatches(true, 0,
+                             blacklistAddress, 0, blacklistAddress.length())) {
+                            if(DBG) Log.d(TAG, " HostPatchForIOT: Apply DontGoforConnect");
+                            return true;
+                        }
+                    }
+                }
+                break;
+            case BluetoothAdapter.HOST_PATCH_AVOID_AUTO_CONNECT:
+                if (mAvoidAutoConnectBlackList != null) {
+                    for (String blacklistAddress : mAvoidAutoConnectBlackList) {
+                        if (address.regionMatches(true, 0,
+                            blacklistAddress, 0, blacklistAddress.length())) {
+                            if(DBG) Log.d(TAG, " HostPatchForIOT: Apply DontAutoConnect");
+                            return true;
+                        }
+                    }
+                }
+                break;
+            case BluetoothAdapter.HOST_PATCH_ENABLE_PHOTO_ON_PBAP:
+                if (mEnablePhotoOnPbap != null) {
+                    for (String PhotoVcardFeature : mEnablePhotoOnPbap) {
+                        if( PhotoVcardFeature.equals("true")) {
+                           if(DBG) Log.d(TAG, " HostPatchForIOT: Apply Avoid photo on pbap");
+                           return true;
+                        }
+                    }
+                }
+                break;
+            }
+            return false;
+        }
+    }
+
+    static {
+        classInitNative();
+    }
+
+    public BluetoothService(Context context) {
+        mContext = context;
+
+        // Need to do this in place of:
+        // mBatteryStats = BatteryStatsService.getService();
+        // Since we can not import BatteryStatsService from here. This class really needs to be
+        // moved to java/services/com/android/server/
+        mBatteryStats = IBatteryStats.Stub.asInterface(ServiceManager.getService("batteryinfo"));
+
+        initializeNativeDataNative();
+
+        if (isEnabledNative() == 1) {
+            Log.w(TAG, "Bluetooth daemons already running - runtime restart? ");
+            disableNative();
+        }
+
+        mBondState = new BluetoothBondState(context, this);
+        mAdapterProperties = new BluetoothAdapterProperties(context, this);
+        mDeviceProperties = new BluetoothDeviceProperties(this);
+
+        mGattProperties = new HashMap<String, Map<String,String>>();
+
+        mDeviceServiceChannelCache = new HashMap<String, Map<ParcelUuid, Integer>>();
+        mDeviceFeatureCache = new HashMap<String, Map<String, String>>();
+        mDeviceOobData = new HashMap<String, Pair<byte[], byte[]>>();
+        mDeviceL2capPsmCache = new HashMap<String, Map<ParcelUuid, Integer>>();
+        mUuidIntentTracker = new ArrayList<String>();
+        mServiceRecordToPid = new ConcurrentHashMap<Integer, ServiceRecordClient>();
+        mUuidCallbackTracker = new ConcurrentHashMap<RemoteService, IBluetoothCallback>();
+        mGattIntentTracker = new HashMap<String, ArrayList<ParcelUuid>>();
+        mGattServiceTracker = new HashMap<String, IBluetoothGattService>();
+        mGattWatcherTracker = new HashMap<String, HashMap<Integer, IBluetoothGattService>>();
+        mGattOperationTracker = new HashMap<String, ArrayList<String>>();
+        mGattServices = new TreeMap<String, Integer>();
+        mDeviceProfileState = new HashMap<String, BluetoothDeviceProfileState>();
+        mA2dpProfileState = new BluetoothProfileState(mContext, BluetoothProfileState.A2DP);
+        mHfpProfileState = new BluetoothProfileState(mContext, BluetoothProfileState.HFP);
+        mHfpProfileState.start();
+        mA2dpProfileState.start();
+
+        mConnectionManager = new ConnectionManager();
+
+        mHostPatchForIOP = new HostPatchForIOP();
+
+        IntentFilter filter = new IntentFilter();
+        registerForAirplaneMode(filter);
+
+        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
+        mDiscoverableTimeoutIntent = new Intent(ACTION_BT_DISCOVERABLE_TIMEOUT, null);
+        mPendingDiscoverableTimeout =
+                PendingIntent.getBroadcast(mContext, 0, mDiscoverableTimeoutIntent, 0);
+        filter.addAction(ACTION_BT_DISCOVERABLE_TIMEOUT);
+
+        // Register for connection-oriented notifications
+        filter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
+        filter.addAction(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothA2dp.ACTION_PLAYING_STATE_CHANGED);
+        filter.addAction(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothPan.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(Intent.ACTION_DOCK_EVENT);
+        filter.addAction(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
+        filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
+        filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
+        filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
+        mContext.registerReceiver(mReceiver, filter);
+        mBluetoothInputProfileHandler = BluetoothInputProfileHandler.getInstance(mContext, this);
+        mBluetoothPanProfileHandler = BluetoothPanProfileHandler.getInstance(mContext, this);
+        mBluetoothHealthProfileHandler = BluetoothHealthProfileHandler.getInstance(mContext, this);
+        mBluetoothGattProfileHandler = BluetoothGattProfileHandler.getInstance(mContext, this);
+        mIncomingConnections = new HashMap<String, Pair<Integer, String>>();
+        mProfileConnectionState = new HashMap<Integer, Pair<Integer, Integer>>();
+    }
+
+    public static synchronized String readDockBluetoothAddress() {
+        if (mDockAddress != null) return mDockAddress;
+
+        BufferedInputStream file = null;
+        String dockAddress;
+        try {
+            file = new BufferedInputStream(new FileInputStream(DOCK_ADDRESS_PATH));
+            byte[] address = new byte[17];
+            file.read(address);
+            dockAddress = new String(address);
+            dockAddress = dockAddress.toUpperCase();
+            if (BluetoothAdapter.checkBluetoothAddress(dockAddress)) {
+                mDockAddress = dockAddress;
+                return mDockAddress;
+            } else {
+                Log.e(TAG, "CheckBluetoothAddress failed for car dock address: "
+                        + dockAddress);
+            }
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "FileNotFoundException while trying to read dock address");
+        } catch (IOException e) {
+            Log.e(TAG, "IOException while trying to read dock address");
+        } finally {
+            if (file != null) {
+                try {
+                    file.close();
+                } catch (IOException e) {
+                    // Ignore
+                }
+            }
+        }
+        mDockAddress = null;
+        return null;
+    }
+
+    public boolean isHostPatchRequired (BluetoothDevice btDevice, int patch_id) {
+        if (mHostPatchForIOP != null) {
+            String address = btDevice.getAddress();
+            return mHostPatchForIOP.isHostPatchRequired(address, patch_id);
+        }
+        return false;
+    }
+
+    private synchronized boolean writeDockPin() {
+        BufferedWriter out = null;
+        try {
+            out = new BufferedWriter(new FileWriter(DOCK_PIN_PATH));
+
+            // Generate a random 4 digit pin between 0000 and 9999
+            // This is not truly random but good enough for our purposes.
+            int pin = (int) Math.floor(Math.random() * 10000);
+
+            mDockPin = String.format("%04d", pin);
+            out.write(mDockPin);
+            return true;
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "FileNotFoundException while trying to write dock pairing pin");
+        } catch (IOException e) {
+            Log.e(TAG, "IOException while while trying to write dock pairing pin");
+        } finally {
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException e) {
+                    // Ignore
+                }
+            }
+        }
+        mDockPin = null;
+        return false;
+    }
+
+    /*package*/ synchronized String getDockPin() {
+        return mDockPin;
+    }
+
+    public synchronized void initAfterRegistration() {
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+        mBluetoothState = new BluetoothAdapterStateMachine(mContext, this, mAdapter);
+        mBluetoothState.start();
+        if (mContext.getResources().getBoolean
+            (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch) &&
+            mBluetoothState.is_hot_off_enabled()) {
+            mBluetoothState.sendMessage(BluetoothAdapterStateMachine.TURN_HOT);
+        }
+        mEventLoop = mBluetoothState.getBluetoothEventLoop();
+    }
+
+    public synchronized void initAfterA2dpRegistration() {
+        mEventLoop.getProfileProxy();
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        mContext.unregisterReceiver(mReceiver);
+        try {
+            cleanupNativeDataNative();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    public boolean isEnabled() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        return isEnabledInternal();
+    }
+
+    public boolean isServiceRegistered(ParcelUuid uuid) {
+       if (DBG) Log.d(TAG, "isServiceRegistered UUID: " + uuid);
+       if (uuid == null) return false;
+
+       if (BluetoothUuid.isFileTransfer(uuid)) {
+         return mFTPEnabled;
+       } else if (BluetoothUuid.isMessageAccessServer(uuid)) {
+         return mMAPEnabled;
+       } else if (BluetoothUuid.isDun(uuid)) {
+         return mDUNEnabled;
+       } else if (BluetoothUuid.isSap(uuid)) {
+         return mSAPEnabled;
+       } else {
+         if (DBG) Log.d(TAG, "Unsupported service UUID: " + uuid);
+         return false;
+       }
+    }
+
+    public  boolean registerService(ParcelUuid uuid, boolean enable) {
+       if (DBG) Log.d(TAG, "registerService UUID: " + uuid + " " + "register = " + enable);
+       if (uuid == null) return false;
+
+       if (BluetoothUuid.isFileTransfer(uuid)) {
+         if (enable) return enableFTP();
+         return  disableFTP();
+       } else if (BluetoothUuid.isMessageAccessServer(uuid)) {
+         if (enable) return enableMAP();
+         return disableMAP();
+       } else if (BluetoothUuid.isDun(uuid)) {
+         if (enable) return enableDUN();
+         return disableDUN();
+       } else if (BluetoothUuid.isSap(uuid)) {
+         if (enable) return enableSAP();
+         return disableSAP();
+       } else {
+         if (DBG) Log.d(TAG, "Unsupported service UUID: " + uuid + " " + "register = " + enable);
+         return false;
+       }
+    }
+
+    private boolean isEnabledInternal() {
+        return (getBluetoothStateInternal() == BluetoothAdapter.STATE_ON);
+    }
+
+    public int getBluetoothState() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        return getBluetoothStateInternal();
+    }
+
+    int getBluetoothStateInternal() {
+        return mBluetoothState.getBluetoothAdapterState();
+    }
+
+    /**
+     * Bring down bluetooth and disable BT in settings. Returns true on success.
+     */
+    public boolean disable() {
+        return disable(true);
+    }
+
+    /**
+     * Bring down bluetooth. Returns true on success.
+     *
+     * @param saveSetting If true, persist the new setting
+     */
+    public synchronized boolean disable(boolean saveSetting) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
+
+        int adapterState = getBluetoothStateInternal();
+
+        switch (adapterState) {
+        case BluetoothAdapter.STATE_OFF:
+            return true;
+        case BluetoothAdapter.STATE_ON:
+            break;
+        default:
+            return false;
+        }
+
+        mBluetoothState.sendMessage(BluetoothAdapterStateMachine.USER_TURN_OFF, saveSetting);
+        SystemProperties.set("bluetooth.isEnabled","false");
+        return true;
+    }
+
+    synchronized void disconnectDevices() {
+        // Disconnect devices handled by BluetoothService.
+        for (BluetoothDevice device: getConnectedInputDevices()) {
+            disconnectInputDevice(device);
+        }
+
+        for (BluetoothDevice device: getConnectedPanDevices()) {
+            disconnectPanDevice(device);
+        }
+
+        // for no profile connection usecase this will be true
+        if (getAdapterConnectionState() ==
+                 BluetoothAdapter.STATE_DISCONNECTED) {
+            disconnectAllConnectionsNative();
+        }
+    }
+
+    /**
+     * The Bluetooth has been turned off, but hot. Do bonding, profile cleanup
+     */
+    synchronized void finishDisable() {
+
+        // mark in progress bondings as cancelled
+        for (String address : mBondState.listInState(BluetoothDevice.BOND_BONDING)) {
+            mBondState.setBondState(address, BluetoothDevice.BOND_NONE,
+                                    BluetoothDevice.UNBOND_REASON_AUTH_CANCELED);
+        }
+
+        // Regardless of bonded state, BluetoothDeviceProfileState must be removed
+        // after Bluetooth has been turned off
+        // They will be added back in after Bluetooth has been turned on.
+        removeAllProfileState();
+
+        // update mode
+        Intent intent = new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
+        intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE, BluetoothAdapter.SCAN_MODE_NONE);
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+    }
+
+    /**
+     * Local clean up after broadcasting STATE_OFF intent
+     */
+    synchronized void cleanupAfterFinishDisable() {
+        mAdapterProperties.clear();
+
+        for (Integer srHandle : mServiceRecordToPid.keySet()) {
+            Integer pid = mServiceRecordToPid.get(srHandle).pid;
+            checkAndRemoveRecord(srHandle, pid);
+        }
+        mServiceRecordToPid.clear();
+
+        mProfilesConnected = 0;
+        mProfilesConnecting = 0;
+        mProfilesDisconnecting = 0;
+        mDeviceConnected = 0; //reset the connection counter
+        mAdapterConnectionState = BluetoothAdapter.STATE_DISCONNECTED;
+        mAdapterUuids = null;
+        mAdapterSdpHandles = null;
+        usedSrvIds.clear();
+
+        // Log bluetooth off to battery stats.
+        long ident = Binder.clearCallingIdentity();
+        mBondState.deinitBondState();
+        try {
+            mBatteryStats.noteBluetoothOff();
+            //Balancing calls to unbind Headset service which is bound
+            //earlier via local getProfileProxy()
+            //ToDo: Need to find a way to balance the calls to bind/unbind
+            //      Headset service. There are still some clients not
+            //      ensuring this but these are outside Bluetooth on/off
+            //      path.
+            mAdapter.closeProfileProxy(BluetoothProfile.HEADSET, mHeadsetProxy);
+        } catch (RemoteException e) {
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    /**
+     * power off Bluetooth
+     */
+    synchronized void shutoffBluetooth() {
+        if (mAdapterSdpHandles != null) removeReservedServiceRecordsNative(mAdapterSdpHandles);
+        if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.nap", true)) {
+            setBluetoothTetheringNative(false, BluetoothPanProfileHandler.NAP_ROLE,
+                BluetoothPanProfileHandler.NAP_BRIDGE);
+        }
+
+        /*
+         * disable QC based profiles
+         */
+        disableFTP();
+        disableDUN();
+        disableSAP();
+        disableMAP();
+        tearDownNativeDataNative();
+        usedSrvIds.clear();
+    }
+
+    /**
+     * Data clean up after Bluetooth shutoff
+     */
+    synchronized void cleanNativeAfterShutoffBluetooth() {
+        // Ths method is called after shutdown of event loop in the Bluetooth shut down
+        // procedure
+
+        // the adapter property could be changed before event loop is stoped, clear it again
+        mAdapterProperties.clear();
+        disableNative();
+    }
+
+    /** Bring up BT and persist BT on in settings */
+    public boolean enable() {
+        return enable(true, true);
+    }
+
+    /**
+     * Enable this Bluetooth device, asynchronously.
+     * This turns on/off the underlying hardware.
+     *
+     * @param saveSetting If true, persist the new state of BT in settings
+     * @param allowConnect If true, auto-connects device when BT is turned on
+     *                     and allows incoming A2DP/HSP connections
+     * @return True on success (so far)
+     */
+    public synchronized boolean enable(boolean saveSetting, boolean allowConnect) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+
+        // Airplane mode can prevent Bluetooth radio from being turned on.
+        if (mIsAirplaneSensitive && isAirplaneModeOn() && !mIsAirplaneToggleable) {
+            return false;
+        }
+        mAllowConnect = allowConnect;
+        mBluetoothState.sendMessage(BluetoothAdapterStateMachine.USER_TURN_ON,
+                                           saveSetting);
+        return true;
+    }
+
+    /**
+     * Enable this Bluetooth device, asynchronously, but does not
+     * auto-connect devices. In this state the Bluetooth adapter
+     * also does not allow incoming A2DP/HSP connections (that
+     * must go through this service), but does allow communication
+     * on RFCOMM sockets implemented outside of this service (ie BTOPP).
+     * This method is used to temporarily enable Bluetooth
+     * for data transfer, without changing
+     *
+     * This turns on/off the underlying hardware.
+     *
+     * @return True on success (so far)
+     */
+    public boolean enableNoAutoConnect() {
+        return enable(false, false);
+    }
+
+    /**
+     * Turn on Bluetooth Module, Load firmware, and do all the preparation
+     * needed to get the Bluetooth Module ready but keep it not discoverable
+     * and not connectable.
+     */
+    /* package */ synchronized boolean prepareBluetooth() {
+        if (!setupNativeDataNative()) {
+            return false;
+        }
+        switchConnectable(false);
+        updateSdpRecords();
+        return true;
+    }
+
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+            case MESSAGE_UUID_INTENT:
+                String address = (String)msg.obj;
+                if (address != null) {
+                    sendUuidIntent(address);
+                    makeServiceChannelCallbacks(address);
+                }
+                break;
+            case MESSAGE_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY:
+                address = (String)msg.obj;
+                if (address == null) return;
+                int attempt = mBondState.getAttempt(address);
+
+                // Try only if attemps are in progress and cap it 2 attempts
+                // The 2 attempts cap is a fail safe if the stack returns
+                // an incorrect error code for bonding failures and if the pin
+                // is entered wrongly twice we should abort.
+                if (attempt > 0 && attempt <= 2) {
+                    mBondState.attempt(address);
+                    if (true == createBond(address)) {
+                       setBondState(address,
+                            BluetoothDevice.BOND_RETRY,
+                            BluetoothDevice.UNBOND_REASON_AUTH_FAILED);
+                    }
+                    return;
+                }
+                if (attempt > 0) mBondState.clearPinAttempts(address);
+                break;
+            case MESSAGE_REMOVE_SERVICE_RECORD:
+                Pair<Integer, Integer> pair = (Pair<Integer, Integer>) msg.obj;
+                checkAndRemoveRecord(pair.first, pair.second);
+                break;
+            case MESSAGE_GATT_INTENT:
+                address = (String)msg.obj;
+                if (address != null && mGattIntentTracker.containsKey(address)){
+                    sendGattIntent(address, BluetoothDevice.GATT_RESULT_TIMEOUT);
+                }
+                break;
+            }
+        }
+    };
+
+    private synchronized void addReservedSdpRecords(final ArrayList<ParcelUuid> uuids) {
+        //Register SDP records.
+        int[] svcIdentifiers = new int[uuids.size()];
+        for (int i = 0; i < uuids.size(); i++) {
+            svcIdentifiers[i] = BluetoothUuid.getServiceIdentifierFromParcelUuid(uuids.get(i));
+        }
+        mAdapterSdpHandles = addReservedServiceRecordsNative(svcIdentifiers);
+    }
+
+    private synchronized boolean enableFTP(){
+        if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.ftp", false) == false) {
+            Log.e(TAG, "FTP is not supported");
+            return false;
+        }
+
+        if (mFTPEnabled != true){
+            int[] svcIdentifiers = new int[1];
+            svcIdentifiers[0] =  BluetoothUuid.getServiceIdentifierFromParcelUuid(BluetoothUuid.FileTransfer);
+
+            mFTPRecordHandle = addReservedServiceRecordsNative(svcIdentifiers);
+            if (null != mFTPRecordHandle){
+                mFTPEnabled = true;
+                return true;
+            } else {
+                Log.e(TAG, "Failed to add FTP service record");
+                return false;
+            }
+        } else {
+            Log.e(TAG, "FTP already enabled");
+            return false;
+        }
+    }
+
+    private synchronized boolean disableFTP(){
+        if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.ftp", false) == false) {
+            Log.e(TAG, "FTP is not supported");
+            return false;
+        }
+
+        if((mFTPEnabled == true) && (null !=  mFTPRecordHandle)){
+            removeReservedServiceRecordsNative(mFTPRecordHandle);
+            mFTPEnabled = false;
+            return true;
+        } else {
+            Log.e(TAG, "FTP already disabled");
+            return false;
+        }
+    }
+
+    public synchronized boolean enableDUN() {
+        if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.dun", false) == false) {
+            Log.e(TAG, "DUN is not supported");
+            return false;
+        }
+
+        if (mDUNEnabled != true) {
+            int[] svcIdentifiers = new int[1];
+            svcIdentifiers[0] =  BluetoothUuid.getServiceIdentifierFromParcelUuid(BluetoothUuid.DUN);
+
+            mDUNRecordHandle = addReservedServiceRecordsNative(svcIdentifiers);
+            if (null != mDUNRecordHandle){
+                Log.e(TAG, "Starting BT-DUN server");
+                SystemService.start("bt-dun");
+                mDUNEnabled = true;
+                return true;
+            } else {
+                Log.e(TAG, "Failed to add DUN service record");
+                return false;
+            }
+        } else {
+            Log.e(TAG, "DUN already enabled");
+            return false;
+        }
+    }
+
+    public synchronized boolean disableDUN() {
+        if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.dun", false) == false) {
+            Log.e(TAG, "DUN is not supported");
+            return false;
+        }
+
+        if ((mDUNEnabled == true) && (null != mDUNRecordHandle)) {
+            removeReservedServiceRecordsNative(mDUNRecordHandle);
+            Log.e(TAG, "Stop BT-DUN server");
+            SystemService.stop("bt-dun");
+            mDUNEnabled = false;
+            return true;
+        } else {
+            Log.e(TAG, "DUN already disabled");
+            return false;
+        }
+    }
+
+    private synchronized boolean enableSAP() {
+        if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.sap", false) == false) {
+            Log.e(TAG, "SAP is not supported");
+            return false;
+        }
+
+        if (mSAPEnabled != true) {
+            int[] svcIdentifiers = new int[1];
+            svcIdentifiers[0] =  BluetoothUuid.getServiceIdentifierFromParcelUuid(BluetoothUuid.SAP);
+
+            mSAPRecordHandle = addReservedServiceRecordsNative(svcIdentifiers);
+            if (null != mSAPRecordHandle) {
+                Log.i(TAG, "Starting SAP server");
+                SystemService.start("bt-sap");
+                mSAPEnabled = true;
+                return true;
+            } else {
+                Log.e(TAG, "Failed to add SAP service record");
+                return false;
+            }
+        } else {
+            Log.e(TAG, "SAP already enabled");
+            return false;
+        }
+    }
+
+    private synchronized boolean disableSAP() {
+        if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.sap", false) == false) {
+            Log.e(TAG, "SAP is not supported");
+            return false;
+        }
+
+        if ((mSAPEnabled == true) && (null != mSAPRecordHandle)) {
+            removeReservedServiceRecordsNative(mSAPRecordHandle);
+            Log.i(TAG, "Stop SAP server");
+            SystemService.stop("bt-sap");
+            mSAPEnabled = false;
+            return true;
+        } else {
+            Log.e(TAG, "SAP already disabled");
+            return false;
+        }
+    }
+
+    private synchronized boolean enableMAP() {
+        /* TODO:
+         * 1> if map property is not present it return true, Need to address
+         *    once feature property is added
+         * 2> Adds records for both MAS0 and MAS1. Need to address with
+         *    different interfaces if needed
+         */
+        if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.map", true) == false) {
+            Log.e(TAG, "MAP is not supported");
+            return false;
+        }
+
+        if (mMAPEnabled != true) {
+            int[] svcIdentifiers = new int[1];
+            svcIdentifiers[0] =  BluetoothUuid.getServiceIdentifierFromParcelUuid(BluetoothUuid.MessageAccessServer);
+            Log.e(TAG, "calling addReservedServiceRecordsNative");
+            mMAPRecordHandle = addReservedServiceRecordsNative(svcIdentifiers);
+            if (null != mMAPRecordHandle) {
+                mMAPEnabled = true;
+                return true;
+            } else {
+                Log.e(TAG, "Failed to add MAP service record");
+                return false;
+            }
+        } else {
+            Log.e(TAG, "MAP already enabled");
+            return false;
+        }
+    }
+
+    private synchronized boolean disableMAP() {
+        /* TODO:
+         * 1> if map property is not present it return true, Need to address
+         *    once feature property is added
+         * 2> Removes records for both MAS0 and MAS1. Need to address with
+         *    different interfaces if needed
+         */
+        if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.map", true) == false) {
+            Log.e(TAG, "MAP is not supported");
+            return false;
+        }
+
+        if ((mMAPEnabled == true) && (null != mMAPRecordHandle)) {
+            removeReservedServiceRecordsNative(mMAPRecordHandle);
+            mMAPEnabled = false;
+            return true;
+        } else {
+            Log.e(TAG, "MAP already disabled");
+            return false;
+        }
+    }
+
+    private synchronized void updateSdpRecords() {
+        ArrayList<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
+
+        Resources R = mContext.getResources();
+
+        // Add the default records
+        if (R.getBoolean(com.android.internal.R.bool.config_bluetooth_default_profiles)) {
+            uuids.add(BluetoothUuid.HSP_AG);
+            uuids.add(BluetoothUuid.ObexObjectPush);
+        }
+
+        if (R.getBoolean(com.android.internal.R.bool.config_voice_capable)) {
+            uuids.add(BluetoothUuid.Handsfree_AG);
+            if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.pbap", true)) {
+                Log.i(TAG, "enabling PBAP services");
+                uuids.add(BluetoothUuid.PBAP_PSE);
+            }
+        }
+
+        // Add SDP records for profiles maintained by Android userspace
+        addReservedSdpRecords(uuids);
+
+        if (R.getBoolean(com.android.internal.R.bool.config_bluetooth_default_profiles)) {
+            if (SystemProperties.getBoolean("ro.qualcomm.bluetooth.nap", true)) {
+                setBluetoothTetheringNative(true, BluetoothPanProfileHandler.NAP_ROLE,
+                   BluetoothPanProfileHandler.NAP_BRIDGE);
+                Log.i(TAG, "enabling NAP services");
+                uuids.add(BluetoothUuid.NAP);
+            }
+            // Add SDP records for profiles maintained by Bluez userspace
+            uuids.add(BluetoothUuid.AudioSource);
+            uuids.add(BluetoothUuid.AvrcpTarget);
+        }
+
+        // Cannot cast uuids.toArray directly since ParcelUuid is parcelable
+        mAdapterUuids = new ParcelUuid[uuids.size()];
+        for (int i = 0; i < uuids.size(); i++) {
+            mAdapterUuids[i] = uuids.get(i);
+        }
+
+        /* Enable all QC prop profiles
+           remove once dynamic enable/disable is up*/
+        enableFTP();
+        enableDUN();
+        enableSAP();
+        enableMAP();
+    }
+
+    /**
+     * This function is called from Bluetooth Event Loop when onPropertyChanged
+     * for adapter comes in with UUID property.
+     * @param uuidsThe uuids of adapter as reported by Bluez.
+     */
+    /*package*/ synchronized void updateBluetoothState(String uuids) {
+        ParcelUuid[] adapterUuids = convertStringToParcelUuid(uuids);
+
+        if (mAdapterUuids != null &&
+            BluetoothUuid.containsAllUuids(adapterUuids, mAdapterUuids)) {
+            mBluetoothState.sendMessage(BluetoothAdapterStateMachine.SERVICE_RECORD_LOADED);
+        }
+    }
+
+    /**
+     * This method is called immediately before Bluetooth module is turned on after
+     * the adapter became pariable.
+     * It inits bond state and profile state before STATE_ON intent is broadcasted.
+     */
+    /*package*/ void initBluetoothAfterTurningOn() {
+        String discoverable = getProperty("Discoverable", false);
+        String timeout = getProperty("DiscoverableTimeout", false);
+        if (timeout == null) {
+            Log.w(TAG, "Null DiscoverableTimeout property");
+            // assign a number, anything not 0
+            timeout = "1";
+        }
+        if (discoverable.equals("true") && Integer.valueOf(timeout) != 0) {
+            setAdapterPropertyBooleanNative("Discoverable", 0);
+        }
+        mBondState.initBondState();
+        initProfileState();
+        getProfileProxy();
+    }
+
+    /**
+     * This method is called immediately after Bluetooth module is turned on.
+     * It starts auto-connection and places bluetooth on sign onto the battery
+     * stats
+     */
+    /*package*/ void runBluetooth() {
+        autoConnect();
+
+        // Log bluetooth on to battery stats.
+        long ident = Binder.clearCallingIdentity();
+        try {
+            mBatteryStats.noteBluetoothOn();
+        } catch (RemoteException e) {
+            Log.e(TAG, "", e);
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    private ConnectionManager mConnectionManager;
+
+    // Track system Bluetooth profile connection state.  A centralized location to
+    // control and enforce profile concurrency policies (e.g., do X when audio activity
+    // is present)
+    private class ConnectionManager {
+        private LinkedList<BtPolicyCallback> mConnectionList = new LinkedList<BtPolicyCallback>();
+        private boolean mScoAudioActive = false;
+        private boolean mA2dpAudioActive = false;
+        private boolean mUseWifiForBtTransfers = true;
+
+        private int mBtPolicyHandle = 1;
+        private LinkedList<Integer> mBtPolicyHandlesAvailable = new LinkedList<Integer>();
+
+        private class BtPolicyCallback {
+            IBluetoothCallback mCallback;
+            int mDesiredAmpPolicy = BluetoothSocket.BT_AMP_POLICY_REQUIRE_BR_EDR;
+            int mCurrentAmpPolicy = BluetoothSocket.BT_AMP_POLICY_REQUIRE_BR_EDR;
+            int mHandle = 0;
+
+            boolean removeHandle(int handle) {
+                Log.i(TAG, "Deallocating handle " + Integer.toString(mHandle) + " to track BT policy.");
+                mHandle = 0;
+                return mBtPolicyHandlesAvailable.add(handle);
+            }
+
+            int getHandle() {
+                return mHandle;
+            }
+
+            BtPolicyCallback(IBluetoothCallback newCallback, int newDesiredAmpPolicy) {
+                this.mCallback = newCallback;
+                this.mDesiredAmpPolicy = validateAmpPolicy(newDesiredAmpPolicy);
+                this.mCurrentAmpPolicy = getEffectiveAmpPolicy(newDesiredAmpPolicy);
+
+                /* Allocate a handle */
+                try {
+                    mHandle = mBtPolicyHandlesAvailable.removeFirst();
+                    Log.i(TAG, "Re-using handle " + Integer.toString(mHandle) + " to track BT policy.");
+                } catch (NoSuchElementException e) {
+                    if (mBtPolicyHandle < Integer.MAX_VALUE) {
+                        mHandle = ++mBtPolicyHandle;
+                        Log.i(TAG, "Allocating new handle " + Integer.toString(mHandle) + " to track BT policy.");
+                    } else {
+                        Log.e(TAG, "Trouble finding open handle to track BT policy!");
+                    }
+                }
+            }
+        }
+
+        private int validateAmpPolicy(int policy) {
+            if (policy == BluetoothSocket.BT_AMP_POLICY_PREFER_BR_EDR ||
+                    policy == BluetoothSocket.BT_AMP_POLICY_PREFER_AMP) {
+                return policy;
+            }
+            return BluetoothSocket.BT_AMP_POLICY_REQUIRE_BR_EDR;
+        }
+
+        public synchronized int getEffectiveAmpPolicy(int policy) {
+            if (mScoAudioActive || mA2dpAudioActive || !mUseWifiForBtTransfers) {
+                return BluetoothSocket.BT_AMP_POLICY_REQUIRE_BR_EDR;
+            }
+            return validateAmpPolicy(policy);
+        }
+
+        public synchronized int registerEl2capConnection(IBluetoothCallback callback, int initialPolicy) {
+            BtPolicyCallback bpc = new BtPolicyCallback(callback, initialPolicy);
+            mConnectionList.add(bpc);
+            return bpc.getHandle();
+        }
+
+        public synchronized void deregisterEl2capConnection(int handle) {
+            ListIterator<BtPolicyCallback> it = mConnectionList.listIterator();
+            while (it.hasNext()) {
+                BtPolicyCallback thisBtPolicyCallback = it.next();
+                if (thisBtPolicyCallback.mHandle == handle) {
+                    thisBtPolicyCallback.removeHandle(handle);
+                    mConnectionList.remove(thisBtPolicyCallback);
+                    break;
+                }
+            }
+        }
+
+        public synchronized boolean setDesiredAmpPolicy(int handle, int policy) {
+            boolean result = true;
+            ListIterator<BtPolicyCallback> it = mConnectionList.listIterator();
+            policy = validateAmpPolicy(policy);
+            int allowedPolicy = getEffectiveAmpPolicy(policy);
+            while (it.hasNext()) {
+                BtPolicyCallback thisBtPolicyCallback = it.next();
+                if (thisBtPolicyCallback.mHandle == handle) {
+                    if (thisBtPolicyCallback.mCurrentAmpPolicy != allowedPolicy) {
+                        try {
+                            thisBtPolicyCallback.mCallback.onAmpPolicyChange(allowedPolicy);
+                            thisBtPolicyCallback.mCurrentAmpPolicy = allowedPolicy;
+                            thisBtPolicyCallback.mDesiredAmpPolicy = policy;
+                        } catch (RemoteException e) {
+                            Log.e(TAG, "", e);
+                            result = false;
+                        }
+                    }
+                    break;
+                }
+            }
+            return result;
+        }
+
+        public synchronized void setScoAudioActive(boolean active) {
+            Log.d(TAG, "setScoAudioActive(): " + active);
+
+            if (mScoAudioActive != active) {
+                mScoAudioActive = active;
+                updateConnectionAmpPolicies();
+            }
+        }
+
+        public synchronized void setA2dpAudioActive(boolean active) {
+            Log.d(TAG, "setA2dpAudioActive(): " + active);
+
+            if (mA2dpAudioActive != active) {
+                mA2dpAudioActive = active;
+                updateConnectionAmpPolicies();
+            }
+        }
+
+        public synchronized void setUseWifiForBtTransfers(boolean useWifi) {
+            Log.d(TAG, "setUseWifiForBtTransfers(): " + useWifi);
+
+            if (mUseWifiForBtTransfers != useWifi) {
+                mUseWifiForBtTransfers = useWifi;
+                updateConnectionAmpPolicies();
+            }
+        }
+
+        // call when anything happens that can change an AMP policy
+        private boolean updateConnectionAmpPolicies() {
+            boolean result = true;
+            ListIterator<BtPolicyCallback> it = mConnectionList.listIterator();
+            while (it.hasNext()) {
+                BtPolicyCallback thisBtPolicyCallback = it.next();
+                int allowedPolicy = getEffectiveAmpPolicy(thisBtPolicyCallback.mDesiredAmpPolicy);
+                if (allowedPolicy != thisBtPolicyCallback.mCurrentAmpPolicy) {
+                    try {
+                        thisBtPolicyCallback.mCallback.onAmpPolicyChange(allowedPolicy);
+                        thisBtPolicyCallback.mCurrentAmpPolicy = allowedPolicy;
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "", e);
+                        result = false; /* This one didn't update, but keep looping */
+                    }
+                }
+            }
+            return result;
+        }
+    }
+
+    /*package*/ synchronized boolean attemptAutoPair(String address) {
+        if (!mBondState.hasAutoPairingFailed(address) &&
+                !mBondState.isAutoPairingBlacklisted(address)) {
+            mBondState.attempt(address);
+            setPin(address, BluetoothDevice.convertPinToBytes("0000"));
+            return true;
+        }
+        return false;
+    }
+
+    /*package*/ synchronized boolean isFixedPinZerosAutoPairKeyboard(String address) {
+        // Check for keyboards which have fixed PIN 0000 as the pairing pin
+        return mBondState.isFixedPinZerosAutoPairKeyboard(address);
+    }
+
+    /*package*/ synchronized void onCreatePairedDeviceResult(String address, int result) {
+        if (result == BluetoothDevice.BOND_SUCCESS) {
+            setBondState(address, BluetoothDevice.BOND_BONDED);
+            if (mBondState.isAutoPairingAttemptsInProgress(address)) {
+                mBondState.clearPinAttempts(address);
+            }
+        } else {
+            if (result == BluetoothDevice.UNBOND_REASON_AUTH_FAILED &&
+                mBondState.getAttempt(address) == 1) {
+                //Dont update UI as we reattempt poping up for key
+                result = BluetoothDevice.UNBOND_REASON_REMOVED;
+                mBondState.addAutoPairingFailure(address);
+                pairingAttempt(address, result);
+            } else if (result == BluetoothDevice.UNBOND_REASON_REMOTE_DEVICE_DOWN &&
+                  mBondState.isAutoPairingAttemptsInProgress(address)) {
+                pairingAttempt(address, result);
+            } else {
+                if (mBondState.isAutoPairingAttemptsInProgress(address)) {
+                   mBondState.clearPinAttempts(address);
+                }
+            }
+            setBondState(address, BluetoothDevice.BOND_NONE, result);
+        }
+    }
+
+    synchronized void onAddToPreferredDeviceListResult(int result) {
+        try {
+            if(callerPreferredDevApi != null && callerPreferredDevApi.equalsIgnoreCase("AutoConnect")
+                    || (callerIntent != null && callerIntent.equalsIgnoreCase("ACTION_ACL_DISCONNECTED"))) {
+                try {
+                    Log.d(TAG, "onAddDeviceAutoConnect in BT service");
+                    if(sPListCallBack != null) {
+                        if(result == 0) { //result 0 is success
+                            //add device to devices in preferred devices list
+                            if(preferredDevicesList == null) {
+                                preferredDevicesList = new HashMap<BluetoothDevice, Integer>();
+                                preferredDevicesList.put(btDeviceInPreferredDevList, DEVICE_IN_PREFERRED_DEVICES_LIST);
+                            }
+                            else {
+                                boolean isDevPresent = false;
+                                if(preferredDevicesList != null) {
+                                    for(Map.Entry<BluetoothDevice, Integer> entry : preferredDevicesList.entrySet()) {
+                                        if(btDeviceInPreferredDevList.getAddress().equalsIgnoreCase(
+                                                entry.getKey().getAddress())) {
+                                            preferredDevicesList.put(entry.getKey(), DEVICE_IN_PREFERRED_DEVICES_LIST);
+                                            isDevPresent = true;
+                                        }
+                                    }
+                                    if(isDevPresent == false) {
+                                        preferredDevicesList.put(btDeviceInPreferredDevList, DEVICE_IN_PREFERRED_DEVICES_LIST);
+                                    }
+                                }
+                            }
+                        }
+                        //call create connection to preferred devices list
+                        callerIntent = null;
+                        callerPreferredDevApi = "AutoConnect";
+                        gattConnectToPreferredDeviceList(sPListCallBack);
+                    }
+                } catch (Exception e) {
+                    Log.e(TAG, "onAddDeviceAutoConnect", e);
+                }
+            }
+            else {//for older white list API
+                sPListCallBack.onAddDeviceToPreferredList(result);
+            }
+        }
+        catch(Exception e) {
+            {Log.e(TAG, "onAddToPreferredDeviceListResult", e);}
+        }
+    }
+    synchronized void onRemoveFromPreferredDeviceListResult(int result) {
+        try {
+            Log.d(TAG, "onRemoveFromPreferredDeviceListResult");
+            if((callerPreferredDevApi != null && callerPreferredDevApi.equalsIgnoreCase("AutoConnectCancel")) ||
+                    (callerIntent != null && callerIntent.equalsIgnoreCase("ACTION_ACL_CONNECTED"))) {
+                try {
+                    if(sPListCallBack != null) {
+                        if(callerPreferredDevApi != null &&
+                                callerPreferredDevApi.equalsIgnoreCase("AutoConnectCancel")){
+                            sPListCallBack.onGattAutoConnectCancel(result); //callback to app
+                            if(result == 0) {
+                                //remove device from device in preferred devices list
+                                if(preferredDevicesList != null) {
+                                    for(Map.Entry<BluetoothDevice, Integer> entry : preferredDevicesList.entrySet()) {
+                                        if(btDeviceInPreferredDevList.getAddress().equalsIgnoreCase(entry.getKey().getAddress())) {
+                                            preferredDevicesList.remove(entry.getKey());
+                                        }
+                                    }
+                                }
+                                //call create connection to preferred devices list if there are
+                                //any devices in preferred devices list
+                                if(preferredDevicesList != null &&
+                                        preferredDevicesList.containsValue(DEVICE_IN_PREFERRED_DEVICES_LIST)){
+                                    callerPreferredDevApi = "AutoConnect";
+                                    gattConnectToPreferredDeviceList(sPListCallBack);
+                                }
+                                else {
+                                    callerPreferredDevApi = null;
+                                }
+                            }
+                        }
+                        else if(callerIntent != null &&
+                                callerIntent.equalsIgnoreCase("ACTION_ACL_CONNECTED")) {
+                            if(result == 0) {
+                                //change the status to connected for the device in the list
+                                if(preferredDevicesList != null) {
+                                    //find the device in the list
+                                    if(preferredDevicesList != null) {
+                                        for(Map.Entry<BluetoothDevice, Integer> entry : preferredDevicesList.entrySet()) {
+                                            if(btDeviceInPreferredDevList.getAddress().equalsIgnoreCase(
+                                                    entry.getKey().getAddress())) {
+                                                preferredDevicesList.put(entry.getKey(), DEVICE_IS_CONNECTED);
+                                                callerPreferredDevApi = null;
+                                                callerIntent = null;
+                                            }
+                                        }
+                                    }
+                                }
+                                Log.d(TAG, "onRemoveDeviceAutoConnect isScanInProgress ::"+isScanInProgress);
+                                //Start the scan again
+                                if(preferredDevicesList != null &&
+                                        preferredDevicesList.containsValue(DEVICE_IN_PREFERRED_DEVICES_LIST)){
+                                    callerPreferredDevApi = "AutoConnect";
+                                    callerIntent = null;
+                                    gattConnectToPreferredDeviceList(sPListCallBack);
+                                }
+                            }
+                        }
+                    }
+                } catch (RemoteException e) {
+                    Log.e(TAG, "onRemoveDeviceAutoConnect", e);
+                }
+            }
+            else {
+                sPListCallBack.onRemoveDeviceFromPreferredList(result);
+            }
+        }
+        catch(Exception e) {
+            {Log.e(TAG, "onRemoveFromPreferredDeviceListResult", e);}
+        }
+    }
+    synchronized void onClearPreferredDeviceListResult(int result) {
+        try {
+            if(sPListCallBack != null) {
+                sPListCallBack.onClearPreferredDeviceList(result);
+            }
+        }
+        catch(Exception e) {
+            {Log.e(TAG, "onClearPreferredDeviceListResult", e);}
+        }
+    }
+    synchronized void onGattConnectToPreferredDeviceListResult(int result) {
+        try {
+            if(callerPreferredDevApi != null && callerPreferredDevApi.equalsIgnoreCase("AutoConnect")
+                    || (callerIntent != null && callerIntent.equalsIgnoreCase("ACTION_ACL_DISCONNECTED"))) {
+                sPListCallBack.onGattAutoConnect(result); //callback to app
+                callerPreferredDevApi = null;
+                callerIntent = null;
+                isScanInProgress = true;
+                Log.d(TAG, "onGattConnectToPreferredDeviceListResult isScanInProgress ::"+isScanInProgress);
+            }
+            else {
+                sPListCallBack.onGattConnectToPreferredDeviceList(result);
+            }
+        }
+        catch(Exception e) {
+            {Log.e(TAG, "onGattConnectToPreferredDeviceListResult", e);}
+        }
+    }
+    synchronized void onGattCancelConnectToPreferredDeviceListResult(int result) {
+        try {
+            Log.d(TAG, "onGattCancelConnectToPreferredDeviceListResult");
+            if((callerPreferredDevApi != null && callerPreferredDevApi.equalsIgnoreCase("AutoConnectCancel")) ||
+                    (callerIntent != null && callerIntent.equalsIgnoreCase("ACTION_ACL_DISCONNECTED"))) {
+                try {
+                    if(sPListCallBack != null) {
+                        if(result == 0) { //result 0 is success
+                            if(callerPreferredDevApi != null &&
+                                    callerPreferredDevApi.equalsIgnoreCase("AutoConnectCancel")){
+                                Log.d(TAG,"AutoConnectCancel....");
+                                //call remove device from preffered devices list
+                                removeFromPreferredDeviceList(btDeviceInPreferredDevList.getAddress(),
+                                        sPListCallBack);
+                            }
+                            else if(callerIntent != null &&
+                                    callerIntent.equalsIgnoreCase("ACTION_ACL_DISCONNECTED")) {
+                                //change the status for the device in preferred devices list
+                                //ie remove device from connect list and add the device to preferred devices list
+                                //call add device to preferred devices list API
+                                addToPreferredDeviceList(btDeviceInPreferredDevList.getAddress(), sPListCallBack);
+                            }
+                        }
+                    }
+                } catch (Exception e) {
+                    Log.e(TAG, "onGattAutoConnectCancel", e);
+                }
+            }
+            else if(callerPreferredDevApi != null && callerPreferredDevApi.equalsIgnoreCase("AutoConnect")) {
+                addToPreferredDeviceList(btDeviceInPreferredDevList.getAddress(), sPListCallBack);
+            }
+            else {//callback for old white list API
+                sPListCallBack.onGattCancelConnectToPreferredDeviceList(result);
+            }
+        }
+        catch(Exception e) {
+            {Log.e(TAG, "onGattCancelConnectToPreferredDeviceListResult", e);}
+        }
+    }
+
+
+    /*package*/ synchronized String getPendingOutgoingBonding() {
+        return mBondState.getPendingOutgoingBonding();
+    }
+
+    private void pairingAttempt(String address, int result) {
+        // This happens when our initial guess of "0000" as the pass key
+        // fails. Try to create the bond again and display the pin dialog
+        // to the user. Use back-off while posting the delayed
+        // message. The initial value is
+        // INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY and the max value is
+        // MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY. If the max value is
+        // reached, display an error to the user.
+        int attempt = mBondState.getAttempt(address);
+        if (attempt * INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY >
+                    MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY) {
+            mBondState.clearPinAttempts(address);
+            setBondState(address, BluetoothDevice.BOND_NONE, result);
+            return;
+        }
+
+        Message message = mHandler.obtainMessage(MESSAGE_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY);
+        message.obj = address;
+        boolean postResult =  mHandler.sendMessageDelayed(message,
+                                        attempt * INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY);
+        if (!postResult) {
+            mBondState.clearPinAttempts(address);
+            setBondState(address,
+                    BluetoothDevice.BOND_NONE, result);
+            return;
+        }
+    }
+
+    /*package*/ BluetoothDevice getRemoteDevice(String address) {
+        return mAdapter.getRemoteDevice(address);
+    }
+
+    private static String toBondStateString(int bondState) {
+        switch (bondState) {
+        case BluetoothDevice.BOND_NONE:
+            return "not bonded";
+        case BluetoothDevice.BOND_BONDING:
+            return "bonding";
+        case BluetoothDevice.BOND_BONDED:
+            return "bonded";
+        default:
+            return "??????";
+        }
+    }
+
+    public synchronized boolean setName(String name) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (name == null) {
+            return false;
+        }
+        return setPropertyString("Name", name);
+    }
+
+    //TODO(): setPropertyString, setPropertyInteger, setPropertyBoolean
+    // Either have a single property function with Object as the parameter
+    // or have a function for each property and then obfuscate in the JNI layer.
+    // The following looks dirty.
+    private boolean setPropertyString(String key, String value) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+        return setAdapterPropertyStringNative(key, value);
+    }
+
+    private boolean setPropertyInteger(String key, int value) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+        return setAdapterPropertyIntegerNative(key, value);
+    }
+
+    private boolean setPropertyBoolean(String key, boolean value) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+        return setAdapterPropertyBooleanNative(key, value ? 1 : 0);
+    }
+
+    /**
+     * Set the discoverability window for the device.  A timeout of zero
+     * makes the device permanently discoverable (if the device is
+     * discoverable).  Setting the timeout to a nonzero value does not make
+     * a device discoverable; you need to call setMode() to make the device
+     * explicitly discoverable.
+     *
+     * @param timeout The discoverable timeout in seconds.
+     */
+    public synchronized boolean setDiscoverableTimeout(int timeout) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        return setPropertyInteger("DiscoverableTimeout", timeout);
+    }
+
+    public synchronized boolean setScanMode(int mode, int duration) {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WRITE_SECURE_SETTINGS,
+                                                "Need WRITE_SECURE_SETTINGS permission");
+        boolean pairable;
+        boolean discoverable;
+
+        //Cancel pending alarm before setting the scan mode.
+        if (mAlarmManager != null) {
+            try {
+                mAlarmManager.cancel(mPendingDiscoverableTimeout);
+            } catch (NullPointerException e) {
+                Log.e(TAG, "mAlarmManager Exception with " + e);
+            }
+        }
+
+        switch (mode) {
+        case BluetoothAdapter.SCAN_MODE_NONE:
+            pairable = false;
+            discoverable = false;
+            break;
+        case BluetoothAdapter.SCAN_MODE_CONNECTABLE:
+            pairable = true;
+            discoverable = false;
+            break;
+        case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:
+            pairable = true;
+            discoverable = true;
+            if (DBG) Log.d(TAG, "BT Discoverable for " + duration + " seconds");
+
+            // AlarmManager needs to be set only when timeout is required.
+            // For Never Time Out case duration will be 0.
+            if (duration != 0) {
+                long mWakeupTime = SystemClock.elapsedRealtime() + (duration * 1000);
+                if (DBG) Log.d(TAG, "System Wakes up at " + mWakeupTime + " milliseconds");
+
+                try {
+                    mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, mWakeupTime,
+                                      mPendingDiscoverableTimeout);
+                } catch (NullPointerException e) {
+                    Log.e(TAG, "mAlarmManager Exception with " + e);
+                    Log.e(TAG, "BT Discoverable timeout may or maynot occur");
+                }
+            }
+            break;
+        default:
+            Log.w(TAG, "Requested invalid scan mode " + mode);
+            return false;
+        }
+
+        setPropertyBoolean("Discoverable", discoverable);
+        setPropertyBoolean("Pairable", pairable);
+        return true;
+    }
+
+    /**
+     * @param on true set the local Bluetooth module to be connectable
+     *                The dicoverability is recovered to what it was before
+     *                switchConnectable(false) call
+     *           false set the local Bluetooth module to be not connectable
+     *                 and not dicoverable
+     */
+    /*package*/ synchronized void switchConnectable(boolean on) {
+        setAdapterPropertyBooleanNative("Powered", on ? 1 : 0);
+    }
+
+    /*package*/ synchronized void setPairable() {
+        String pairableString = getProperty("Pairable", false);
+        if (pairableString == null) {
+            Log.e(TAG, "null pairableString");
+            return;
+        }
+        if (pairableString.equals("false")) {
+            setAdapterPropertyBooleanNative("Pairable", 1);
+        }
+    }
+
+    /*package*/ String getProperty(String name, boolean checkState) {
+        // If checkState is false, check if the event loop is running.
+        // before making the call to Bluez
+        if (checkState) {
+            if (!isEnabledInternal()) return null;
+        } else if (!mEventLoop.isEventLoopRunning()) {
+            return null;
+        }
+
+        return mAdapterProperties.getProperty(name);
+    }
+
+    BluetoothAdapterProperties getAdapterProperties() {
+        return mAdapterProperties;
+    }
+
+    BluetoothDeviceProperties getDeviceProperties() {
+        return mDeviceProperties;
+    }
+
+    boolean isRemoteDeviceInCache(String address) {
+        return mDeviceProperties.isInCache(address);
+    }
+
+    void setRemoteDeviceProperty(String address, String name, String value) {
+        mDeviceProperties.setProperty(address, name, value);
+    }
+
+    void updateRemoteDevicePropertiesCache(String address) {
+        mDeviceProperties.updateCache(address);
+    }
+
+    public synchronized String getAddress() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        // Don't check state since we want to provide address, even if BT is off
+        return getProperty("Address", false);
+    }
+
+    public synchronized String getName() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        // Don't check state since we want to provide name, even if BT is off
+        return getProperty("Name", false);
+    }
+
+    public ParcelUuid[] getUuids() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        String value =  getProperty("UUIDs", true);
+        if (value == null) return null;
+        return convertStringToParcelUuid(value);
+    }
+
+    private ParcelUuid[] convertStringToParcelUuid(String value) {
+        String[] uuidStrings = null;
+        // The UUIDs are stored as a "," separated string.
+        uuidStrings = value.split(",");
+        ParcelUuid[] uuids = new ParcelUuid[uuidStrings.length];
+
+        for (int i = 0; i < uuidStrings.length; i++) {
+            uuids[i] = ParcelUuid.fromString(uuidStrings[i]);
+        }
+        return uuids;
+    }
+
+    public synchronized String getCOD() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        return getProperty("Class", false);
+    }
+
+    public boolean setBluetoothClass(String address, int classOfDevice) {
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                    "Need BLUETOOTH_ADMIN permission");
+            return false;
+        }
+
+        if (!isEnabledInternal()) return false;
+
+        return setDevicePropertyIntegerNative(getObjectPathFromAddress(address), "Class",
+                classOfDevice);
+    }
+
+    public boolean setLEConnectionParams(String address, byte prohibitRemoteChg,
+                                         byte filterPolicy, int scanInterval,
+                                         int scanWindow, int intervalMin,
+                                         int intervalMax, int latency,
+                                         int superVisionTimeout, int minCeLen,
+                                         int maxCeLen, int connTimeout) {
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                    "Need BLUETOOTH_ADMIN permission");
+            return false;
+        }
+
+        if (!isEnabledInternal()) return false;
+
+        String devPath = null;
+        if (isRemoteDeviceInCache(address) && findDeviceNative(address) != null) {
+            Log.d(TAG, "Find LE device");
+            devPath = getObjectPathFromAddress(address);
+        } else {
+            Log.d(TAG, "Create LE device");
+            devPath = createLeDeviceNative(address);
+        }
+
+        if (devPath == null) {
+            Log.d(TAG, "Device path is null");
+            return false;
+        }
+
+        return setLEConnectionParamNative(devPath,
+                                          (int) prohibitRemoteChg, (int) filterPolicy,
+                                          scanInterval, scanWindow,
+                                          intervalMin, intervalMax,
+                                          latency, superVisionTimeout,
+                                          minCeLen, maxCeLen, connTimeout);
+    }
+
+    public boolean updateLEConnectionParams(String address,
+                                       byte prohibitRemoteChg,
+                                       int intervalMin,
+                                       int intervalMax,
+                                       int slaveLatency,
+                                       int supervisionTimeout) {
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                    "Need BLUETOOTH_ADMIN permission");
+            return false;
+        }
+
+        if (!isEnabledInternal()) return false;
+
+        return updateLEConnectionParametersNative(getObjectPathFromAddress(address),
+                                             (int) prohibitRemoteChg,
+                                             intervalMin,
+                                             intervalMax,
+                                             slaveLatency,
+                                             supervisionTimeout);
+    }
+
+    public synchronized boolean registerRssiUpdateWatcher(String address,
+                                              int rssiThreshold,
+                                              int interval,
+                                              boolean updateOnThreshExceed) {
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                    "Need BLUETOOTH_ADMIN permission");
+            return false;
+        }
+
+        if (!isEnabledInternal()) return false;
+
+        return registerRssiUpdateWatcherNative(getObjectPathFromAddress(address),
+                                               rssiThreshold,
+                                               interval,
+                                               updateOnThreshExceed);
+    }
+
+    public synchronized boolean unregisterRssiUpdateWatcher(String address) {
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                    "Need BLUETOOTH_ADMIN permission");
+            return false;
+        }
+
+        if (!isEnabledInternal()) return false;
+
+        return unregisterRssiUpdateWatcherNative(getObjectPathFromAddress(address));
+    }
+
+    /**
+     * Returns the user-friendly name of a remote device.  This value is
+     * returned from our local cache, which is updated when onPropertyChange
+     * event is received.
+     * Do not expect to retrieve the updated remote name immediately after
+     * changing the name on the remote device.
+     *
+     * @param address Bluetooth address of remote device.
+     *
+     * @return The user-friendly name of the specified remote device.
+     */
+    public synchronized String getRemoteName(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return null;
+        }
+        return mDeviceProperties.getProperty(address, "Name");
+    }
+
+    /**
+     * Returns alias of a remote device.  This value is returned from our
+     * local cache, which is updated when onPropertyChange event is received.
+     *
+     * @param address Bluetooth address of remote device.
+     *
+     * @return The alias of the specified remote device.
+     */
+    public synchronized String getRemoteAlias(String address) {
+
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return null;
+        }
+        return mDeviceProperties.getProperty(address, "Alias");
+    }
+
+    /**
+     * Set the alias of a remote device.
+     *
+     * @param address Bluetooth address of remote device.
+     * @param alias new alias to change to
+     * @return true on success, false on error
+     */
+    public synchronized boolean setRemoteAlias(String address, String alias) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+
+        return setDevicePropertyStringNative(getObjectPathFromAddress(address),
+                                             "Alias", alias);
+    }
+
+    /**
+     * Get the discoverability window for the device.  A timeout of zero
+     * means that the device is permanently discoverable (if the device is
+     * in the discoverable mode).
+     *
+     * @return The discoverability window of the device, in seconds.  A negative
+     *         value indicates an error.
+     */
+    public int getDiscoverableTimeout() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        String timeout = getProperty("DiscoverableTimeout", true);
+        if (timeout != null)
+           return Integer.valueOf(timeout);
+        else
+            return -1;
+    }
+
+    public int getScanMode() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal())
+            return BluetoothAdapter.SCAN_MODE_NONE;
+
+        boolean pairable = getProperty("Pairable", true).equals("true");
+        boolean discoverable = getProperty("Discoverable", true).equals("true");
+        return bluezStringToScanMode (pairable, discoverable);
+    }
+
+    public synchronized boolean startDiscovery() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+
+        log("**** startDiscovery");
+
+        return startDiscoveryNative();
+    }
+
+    public synchronized boolean cancelDiscovery() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        return stopDiscoveryNative();
+    }
+
+    public boolean isDiscovering() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+        String discoveringProperty = getProperty("Discovering", false);
+        if (discoveringProperty == null) {
+            return false;
+        }
+
+        return discoveringProperty.equals("true");
+    }
+
+    private boolean isBondingFeasible(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        address = address.toUpperCase();
+
+        if (mBondState.getPendingOutgoingBonding() != null) {
+            Log.d(TAG, "Ignoring createBond(): another device is bonding");
+            // a different device is currently bonding, fail
+            return false;
+        }
+
+        // Check for bond state only if we are not performing auto
+        // pairing exponential back-off attempts.
+        if (!mBondState.isAutoPairingAttemptsInProgress(address) &&
+                mBondState.getBondState(address) != BluetoothDevice.BOND_NONE) {
+            Log.d(TAG, "Ignoring createBond(): this device is already bonding or bonded");
+            return false;
+        }
+
+        if (address.equals(mDockAddress)) {
+            if (!writeDockPin()) {
+                Log.e(TAG, "Error while writing Pin for the dock");
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public synchronized boolean createBond(String address) {
+        if (!isBondingFeasible(address)) return false;
+        BluetoothClass btClass = new BluetoothClass(getRemoteClass(address));
+        int btDeviceClass = btClass.getDeviceClass();
+
+        if (!createPairedDeviceNative(address, 60000  /*1 minute*/ )) {
+            return false;
+        }
+
+        mBondState.setPendingOutgoingBonding(address);
+        mBondState.setBondState(address, BluetoothDevice.BOND_BONDING);
+
+        return true;
+    }
+
+    public synchronized boolean createBondOutOfBand(String address, byte[] hash,
+                                                    byte[] randomizer) {
+        if (!isBondingFeasible(address)) return false;
+
+        if (!createPairedDeviceOutOfBandNative(address, 60000 /* 1 minute */)) {
+            return false;
+        }
+
+        setDeviceOutOfBandData(address, hash, randomizer);
+        mBondState.setPendingOutgoingBonding(address);
+        mBondState.setBondState(address, BluetoothDevice.BOND_BONDING);
+
+        return true;
+    }
+
+    public synchronized boolean setDeviceOutOfBandData(String address, byte[] hash,
+            byte[] randomizer) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        Pair <byte[], byte[]> value = new Pair<byte[], byte[]>(hash, randomizer);
+
+        if (DBG) {
+            Log.d(TAG, "Setting out of band data for: " + address + ":" +
+                  Arrays.toString(hash) + ":" + Arrays.toString(randomizer));
+        }
+
+        mDeviceOobData.put(address, value);
+        return true;
+    }
+
+    Pair<byte[], byte[]> getDeviceOutOfBandData(BluetoothDevice device) {
+        return mDeviceOobData.get(device.getAddress());
+    }
+
+
+    public synchronized byte[] readOutOfBandData() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                                "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return null;
+
+        return readAdapterOutOfBandDataNative();
+    }
+
+    public synchronized boolean cancelBondProcess(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+
+        BluetoothClass btClass = new BluetoothClass(getRemoteClass(address));
+        int btDeviceClass = btClass.getDeviceClass();
+        String pairState = getUpdatedRemoteDeviceProperty(address, "Paired");
+
+        if (!isEnabledInternal()) return false;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address))
+            return false;
+
+        address = address.toUpperCase();
+
+        // HID PERIPHERAL_POINTING devices have BONDED state even if
+        // the pairing wasnt completed, So need to check pairState.
+        if ((btDeviceClass == BluetoothClass.Device.PERIPHERAL_POINTING) &&
+                       (mBondState.getBondState(address) == BluetoothDevice.BOND_BONDED)) {
+            if (pairState.equals("true"))
+                return false;
+        } else {
+            if (mBondState.getBondState(address) != BluetoothDevice.BOND_BONDING)
+                return false;
+        }
+
+        cancelDeviceCreationNative(address);
+
+        mBondState.setBondState(address, BluetoothDevice.BOND_NONE,
+                               BluetoothDevice.UNBOND_REASON_AUTH_CANCELED);
+        return true;
+    }
+
+    public synchronized boolean removeBond(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state != null) {
+            state.sendMessage(BluetoothDeviceProfileState.UNPAIR);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public synchronized boolean removeBondInternal(String address) {
+        // Unset the trusted device state and then unpair
+        setTrust(address, false);
+        return removeDeviceNative(getObjectPathFromAddress(address));
+    }
+
+    public synchronized String[] listBonds() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        return mBondState.listInState(BluetoothDevice.BOND_BONDED);
+    }
+
+    /*package*/ synchronized String[] listInState(int state) {
+      return mBondState.listInState(state);
+    }
+
+    public synchronized int getBondState(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return BluetoothDevice.ERROR;
+        }
+        return mBondState.getBondState(address.toUpperCase());
+    }
+
+    /*package*/ synchronized boolean setBondState(String address, int state) {
+        return setBondState(address, state, 0);
+    }
+
+    /*package*/ synchronized boolean setBondState(String address, int state, int reason) {
+        mBondState.setBondState(address.toUpperCase(), state, reason);
+        return true;
+    }
+
+    public synchronized boolean isBluetoothDock(String address) {
+        SharedPreferences sp = mContext.getSharedPreferences(SHARED_PREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+
+        return sp.contains(SHARED_PREFERENCE_DOCK_ADDRESS + address);
+    }
+
+    /*package*/ String[] getRemoteDeviceProperties(String address) {
+        Log.d(TAG, "getRemoteDeviceProperties: " + address);
+        if (!isEnabledInternal()) return null;
+
+        String objectPath = getObjectPathFromAddress(address);
+        return (String [])getDevicePropertiesNative(objectPath);
+    }
+
+    /*package*/ String getUpdatedRemoteDeviceProperty(String address, String property) {
+        String objectPath = getObjectPathFromAddress(address);
+        String[] propValues =  (String [])getDevicePropertiesNative(objectPath);
+        if (propValues != null) {
+            mDeviceProperties.addProperties(address, propValues, false);
+            return mDeviceProperties.getProperty(address, property);
+        }
+        Log.e(TAG, "getProperty: " + property + "not present:" + address);
+        return null;
+    }
+
+    /**
+     * Sets the remote device trust state.
+     *
+     * @return boolean to indicate operation success or fail
+     */
+    public synchronized boolean setTrust(String address, boolean value) {
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                    "Need BLUETOOTH_ADMIN permission");
+            return false;
+        }
+
+        if (!isEnabledInternal()) return false;
+
+        return setDevicePropertyBooleanNative(
+                getObjectPathFromAddress(address), "Trusted", value ? 1 : 0);
+    }
+
+    /**
+     * Gets the remote device trust state as boolean.
+     * Note: this value may be
+     * retrieved from cache if we retrieved the data before *
+     *
+     * @return boolean to indicate trusted or untrusted state
+     */
+    public synchronized boolean getTrustState(String address) {
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            return false;
+        }
+
+        String val = mDeviceProperties.getProperty(address, "Trusted");
+        if (val == null) {
+            return false;
+        } else {
+            return val.equals("true");
+        }
+    }
+
+    /**
+     * Gets the remote major, minor classes encoded as a 32-bit
+     * integer.
+     *
+     * Note: this value is retrieved from cache, because we get it during
+     *       remote-device discovery.
+     *
+     * @return 32-bit integer encoding the remote major, minor, and service
+     *         classes.
+     */
+    public synchronized int getRemoteClass(String address) {
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            return BluetoothClass.ERROR;
+        }
+        String val = mDeviceProperties.getProperty(address, "Class");
+        if (val == null)
+            return BluetoothClass.ERROR;
+        else {
+            return Integer.valueOf(val);
+        }
+    }
+
+    /**
+     * Gets the UUIDs supported by the remote device
+     *
+     * @return array of 128bit ParcelUuids
+     */
+    public synchronized ParcelUuid[] getRemoteUuids(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return null;
+        }
+        return getUuidFromCache(address);
+    }
+
+    ParcelUuid[] getUuidFromCache(String address) {
+        String value = mDeviceProperties.getProperty(address, "UUIDs");
+        if (value == null) return null;
+
+        String[] uuidStrings = null;
+        // The UUIDs are stored as a "," separated string.
+        uuidStrings = value.split(",");
+        ParcelUuid[] uuids = new ParcelUuid[uuidStrings.length];
+
+        for (int i = 0; i < uuidStrings.length; i++) {
+            uuids[i] = ParcelUuid.fromString(uuidStrings[i]);
+        }
+        return uuids;
+    }
+
+    /**
+     * Connect and fetch new UUID's using SDP.
+     * The UUID's found are broadcast as intents.
+     * Optionally takes a uuid and callback to fetch the RFCOMM channel for the
+     * a given uuid.
+     * TODO: Don't wait UUID_INTENT_DELAY to broadcast UUID intents on success
+     * TODO: Don't wait UUID_INTENT_DELAY to handle the failure case for
+     * callback and broadcast intents.
+     */
+    public synchronized boolean fetchRemoteUuids(String address, ParcelUuid uuid,
+            IBluetoothCallback callback) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+
+        RemoteService service = new RemoteService(address, uuid);
+        if (uuid != null && mUuidCallbackTracker.get(service) != null) {
+            // An SDP query for this address & uuid is already in progress
+            // Do not add this callback for the uuid
+            return false;
+        }
+
+        if (uuid != null) {
+            mUuidCallbackTracker.put(service, callback);
+        }
+
+        if (mUuidIntentTracker.contains(address)) {
+            // An SDP query for this address is already in progress
+            // Add this uuid onto the in-progress SDP query
+            return true;
+        }
+        mUuidIntentTracker.add(address);
+
+        boolean ret;
+        // Just do the SDP if the device is already  created and UUIDs are not
+        // NULL, else create the device and then do SDP.
+        if (isRemoteDeviceInCache(address) && getRemoteUuids(address) != null &&
+                findDeviceNative(address) != null) {
+            String path = getObjectPathFromAddress(address);
+            if (path == null) {
+                mUuidIntentTracker.remove(address);
+                return false;
+            }
+
+            // Use an empty string for the UUID pattern
+            ret = discoverServicesNative(path, "");
+        } else {
+            ret = createDeviceNative(address);
+        }
+
+        Message message = mHandler.obtainMessage(MESSAGE_UUID_INTENT);
+        message.obj = address;
+        mHandler.sendMessageDelayed(message, UUID_INTENT_DELAY);
+        return ret;
+    }
+
+    /**
+     * Gets the rfcomm channel associated with the UUID.
+     * Pulls records from the cache only.
+     *
+     * @param address Address of the remote device
+     * @param uuid ParcelUuid of the service attribute
+     *
+     * @return rfcomm channel associated with the service attribute
+     *         -1 on error
+     */
+    public int getRemoteServiceChannel(String address, ParcelUuid uuid) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return -1;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return BluetoothDevice.ERROR;
+        }
+        // Check if we are recovering from a crash.
+        if (mDeviceProperties.isEmpty()) {
+            if (mDeviceProperties.updateCache(address) == null)
+                return -1;
+        }
+
+        Map<ParcelUuid, Integer> value = mDeviceServiceChannelCache.get(address);
+        if (value != null && value.containsKey(uuid))
+            return value.get(uuid);
+
+        Log.w(TAG, "Server Channel is -1, updating the cache");
+        int channel = getDeviceServiceChannelForUuid(address, uuid);
+        Map <ParcelUuid, Integer> rfcommValue = new HashMap<ParcelUuid, Integer>();
+        if (channel > 0) {
+            rfcommValue.put(uuid, channel);
+            mDeviceServiceChannelCache.put(address, rfcommValue);
+        }
+        return channel;
+    }
+
+    /**
+     * Gets the remote features list associated with the feature name.
+     * Pulls records from the cache only.
+     *
+     * @param address Address of the remote device
+     * @param feature the name of feature to get
+     *
+     * @return feature list string value
+     *         null on error
+     */
+    public String getRemoteFeature(String address, String feature) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return null;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return null;
+        }
+
+        Map<String, String> value = mDeviceFeatureCache.get(address);
+        if (value != null && value.containsKey(feature))
+            return value.get(feature);
+        return null;
+    }
+
+    /**
+     * Gets the L2CAP PSM associated with the UUID.
+     * Pulls records from the cache only.
+     *
+     * @param address Address of the remote device
+     * @param uuid ParcelUuid of the service attribute
+     *
+     * @return L2CAP PSM associated with the service attribute
+     *         -1 on error
+     */
+    public int getRemoteL2capPsm(String address, ParcelUuid uuid) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return -1;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return BluetoothDevice.ERROR;
+        }
+        // Check if we are recovering from a crash.
+        if (mDeviceProperties.isEmpty()) {
+            updateRemoteDevicePropertiesCache(address);
+        }
+
+        Map<ParcelUuid, Integer> value = mDeviceL2capPsmCache.get(address);
+        if (value != null && value.containsKey(uuid)) {
+            return value.get(uuid);
+        }
+
+        return -1;
+    }
+
+    public synchronized boolean setPin(String address, byte[] pin) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        if (pin == null || pin.length <= 0 || pin.length > 16 ||
+            !BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        address = address.toUpperCase();
+        Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
+        if (data == null) {
+            Log.w(TAG, "setPin(" + address + ") called but no native data available, " +
+                  "ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device" +
+                  " or by bluez.\n");
+            return false;
+        }
+        // bluez API wants pin as a string
+        String pinString;
+        try {
+            pinString = new String(pin, "UTF8");
+        } catch (UnsupportedEncodingException uee) {
+            Log.e(TAG, "UTF8 not supported?!?");
+            return false;
+        }
+        return setPinNative(address, pinString, data.intValue());
+    }
+
+    public synchronized boolean sapAuthorize(String address, boolean access) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+
+        address = address.toUpperCase();
+        Integer data = mEventLoop.getAuthorizationRequestData().remove(address);
+        if (data == null) {
+            Log.w(TAG, "sapAuthorize(" + address + ") called but no native data available, " +
+                  "ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device" +
+                  " or by bluez.\n");
+            return false;
+        }
+
+        return sapAuthorizeNative(address, access, data.intValue());
+    }
+
+    public synchronized boolean DUNAuthorize(String address, boolean access) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+
+        address = address.toUpperCase();
+        Integer data = mEventLoop.getAuthorizationRequestData().remove(address);
+        if (data == null) {
+            Log.w(TAG, "DUNAuthorize(" + address + ") called but no native data available, " +
+                  "ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device" +
+                  " or by bluez.\n");
+            return false;
+        }
+
+        return DUNAuthorizeNative(address, access, data.intValue());
+    }
+
+    public synchronized boolean setPasskey(String address, int passkey) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        if (passkey < 0 || passkey > 999999 || !BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        address = address.toUpperCase();
+        Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
+        if (data == null) {
+            Log.w(TAG, "setPasskey(" + address + ") called but no native data available, " +
+                  "ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device" +
+                  " or by bluez.\n");
+            return false;
+        }
+        return setPasskeyNative(address, passkey, data.intValue());
+    }
+
+    public synchronized boolean setPairingConfirmation(String address, boolean confirm) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        address = address.toUpperCase();
+        Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
+        if (data == null) {
+            Log.w(TAG, "setPasskey(" + address + ") called but no native data available, " +
+                  "ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device" +
+                  " or by bluez.\n");
+            return false;
+        }
+        return setPairingConfirmationNative(address, confirm, data.intValue());
+    }
+
+    public synchronized boolean setRemoteOutOfBandData(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+        address = address.toUpperCase();
+        Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
+        if (data == null) {
+            Log.w(TAG, "setRemoteOobData(" + address + ") called but no native data available, " +
+                  "ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device" +
+                  " or by bluez.\n");
+            return false;
+        }
+
+        Pair<byte[], byte[]> val = mDeviceOobData.get(address);
+        byte[] hash, randomizer;
+        if (val == null) {
+            // TODO: check what should be passed in this case.
+            hash = new byte[16];
+            randomizer = new byte[16];
+        } else {
+            hash = val.first;
+            randomizer = val.second;
+        }
+        return setRemoteOutOfBandDataNative(address, hash, randomizer, data.intValue());
+    }
+
+    public synchronized boolean cancelPairingUserInput(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        mBondState.setBondState(address, BluetoothDevice.BOND_NONE,
+                BluetoothDevice.UNBOND_REASON_AUTH_CANCELED);
+        address = address.toUpperCase();
+        Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
+        if (data == null) {
+            Log.w(TAG, "cancelUserInputNative(" + address + ") called but no native data " +
+                "available, ignoring. Maybe the PasskeyAgent Request was already cancelled " +
+                "by the remote or by bluez.\n");
+            return false;
+        }
+        return cancelPairingUserInputNative(address, data.intValue());
+    }
+
+    /*package*/ void updateDeviceServiceChannelCache(String address) {
+        int state = getBluetoothStateInternal();
+        if ( state != BluetoothAdapter.STATE_ON &&
+             state != BluetoothAdapter.STATE_TURNING_ON) {
+            log("Bluetooth is not on");
+            return;
+        }
+
+        ParcelUuid[] deviceUuids = getRemoteUuids(address);
+        // We are storing the RFCOMM channel numbers and L2CAP PSMs
+        // only for the uuids we are interested in.
+        int channel;
+        int psm;
+
+        // Remove service channel timeout handler
+        mHandler.removeMessages(MESSAGE_UUID_INTENT);
+
+        ArrayList<ParcelUuid> applicationUuids = new ArrayList<ParcelUuid>();
+
+        synchronized (this) {
+            for (RemoteService service : mUuidCallbackTracker.keySet()) {
+                if (service.address.equals(address)) {
+                    applicationUuids.add(service.uuid);
+                }
+            }
+        }
+
+        Map <ParcelUuid, Integer> rfcommValue = new HashMap<ParcelUuid, Integer>();
+        Map <ParcelUuid, Integer> l2capPsmValue = new HashMap<ParcelUuid, Integer>();
+        Map <String, String> feature = new HashMap<String, String>();
+
+        // Retrieve RFCOMM channel and L2CAP PSM (if available) for default uuids
+        for (ParcelUuid uuid : RFCOMM_UUIDS) {
+            if (BluetoothUuid.isUuidPresent(deviceUuids, uuid)) {
+                psm = getDeviceServiceChannelNative(getObjectPathFromAddress(address),
+                        uuid.toString(), SDP_ATTR_GOEP_L2CAP_PSM);
+                l2capPsmValue.put(uuid, psm);
+                if (DBG) log("\tuuid(system): " + uuid + " PSM: "+ psm );
+                int attributeId = SDP_ATTR_PROTO_DESC_LIST;
+                // Retrieve Additional RFCOMM Channel for BPP
+                if(BluetoothUuid.isPrintingStatus(uuid)){
+                    attributeId = SDP_ATTR_ADD_PROTO_DESC_LIST; // find additional Channel Number
+                }
+                channel = getDeviceServiceChannelNative(getObjectPathFromAddress(address),
+                        uuid.toString(), attributeId);
+                rfcommValue.put(uuid, channel);
+                if (DBG) log("\tuuid(system): " + uuid + " SCN: "+ channel );
+
+                if (BluetoothUuid.isDirectPrinting(uuid)) {
+                    String supportedFormats;
+                    supportedFormats = getDeviceStringAttrValue(getObjectPathFromAddress(address),
+                            uuid.toString(), SDP_ATTR_BPP_SUPPORTED_DOC_FORMAT);
+                    if (DBG) log("\tSupportedFormats: " + uuid + " " + supportedFormats);
+                    feature.put("SupportedFormats", supportedFormats);
+                    mDeviceFeatureCache.put(address, feature);
+                }
+            }
+        }
+        // Retrieve RFCOMM channel and L2CAP PSM (if available) for
+        // application requested uuids
+        for (ParcelUuid uuid : applicationUuids) {
+            if (BluetoothUuid.isUuidPresent(deviceUuids, uuid)) {
+                psm = getDeviceServiceChannelNative(getObjectPathFromAddress(address),
+                        uuid.toString(), SDP_ATTR_GOEP_L2CAP_PSM);
+                channel = getDeviceServiceChannelNative(getObjectPathFromAddress(address),
+                        uuid.toString(), SDP_ATTR_PROTO_DESC_LIST);
+                if (DBG) Log.d(TAG,"\tuuid(application): " + uuid + " SCN: " + channel +
+                        " PSM: " + psm);
+                rfcommValue.put(uuid, channel);
+                l2capPsmValue.put(uuid, psm);
+            }
+        }
+
+        synchronized (this) {
+            // Make application callbacks (RFCOMM channels only)
+            for (Iterator<RemoteService> iter = mUuidCallbackTracker.keySet().iterator();
+                    iter.hasNext();) {
+                RemoteService service = iter.next();
+                if (service.address.equals(address)) {
+                    channel = -1;
+                    if (rfcommValue.get(service.uuid) != null) {
+                        channel = rfcommValue.get(service.uuid);
+                    }
+                    if (channel != -1) {
+                        if (DBG) Log.d(TAG,"Making callback for " + service.uuid + " with result " +
+                                channel);
+                        IBluetoothCallback callback = mUuidCallbackTracker.get(service);
+                        if (callback != null) {
+                            try {
+                                callback.onRfcommChannelFound(channel);
+                            } catch (RemoteException e) {Log.e(TAG, "", e);}
+                        }
+
+                        iter.remove();
+                    }
+                }
+            }
+
+            // Update cache
+            mDeviceServiceChannelCache.put(address, rfcommValue);
+            mDeviceL2capPsmCache.put(address, l2capPsmValue);
+        }
+    }
+
+    private int getDeviceServiceChannelForUuid(String address,
+            ParcelUuid uuid) {
+        return getDeviceServiceChannelNative(getObjectPathFromAddress(address),
+                uuid.toString(), 0x0004);
+    }
+
+    /**
+     * b is a handle to a Binder instance, so that this service can be notified
+     * for Applications that terminate unexpectedly, to clean there service
+     * records
+     */
+    public synchronized int addRfcommServiceRecord(String serviceName, ParcelUuid uuid,
+            int channel, IBinder b) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return -1;
+
+        if (serviceName == null || uuid == null || channel < 1 ||
+                channel > BluetoothSocket.MAX_RFCOMM_CHANNEL) {
+            return -1;
+        }
+        if (BluetoothUuid.isUuidPresent(BluetoothUuid.RESERVED_UUIDS, uuid)) {
+            Log.w(TAG, "Attempted to register a reserved UUID: " + uuid);
+            return -1;
+        }
+        int handle = addRfcommServiceRecordNative(serviceName,
+                uuid.getUuid().getMostSignificantBits(), uuid.getUuid().getLeastSignificantBits(),
+                (short)channel);
+        if (DBG) Log.d(TAG, "new handle " + Integer.toHexString(handle));
+        if (handle == -1) {
+            return -1;
+        }
+
+        ServiceRecordClient client = new ServiceRecordClient();
+        client.pid = Binder.getCallingPid();
+        client.binder = b;
+        client.death = new Reaper(handle, client.pid, RFCOMM_RECORD_REAPER);
+        mServiceRecordToPid.put(new Integer(handle), client);
+        try {
+            b.linkToDeath(client.death, 0);
+        } catch (RemoteException e) {
+            Log.e(TAG, "", e);
+            client.death = null;
+        }
+        return handle;
+    }
+
+    public void removeServiceRecord(int handle) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                                "Need BLUETOOTH permission");
+        // Since this is a binder call check if Bluetooth is off
+        if (getBluetoothStateInternal() == BluetoothAdapter.STATE_OFF) return;
+        Message message = mHandler.obtainMessage(MESSAGE_REMOVE_SERVICE_RECORD);
+        message.obj = new Pair<Integer, Integer>(handle, Binder.getCallingPid());
+        mHandler.sendMessage(message);
+    }
+
+    public int registerEl2capConnection(IBluetoothCallback callback, int desiredAmpPolicy) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                                "Need BLUETOOTH permission");
+        return mConnectionManager.registerEl2capConnection(callback, desiredAmpPolicy);
+    }
+
+    public void deregisterEl2capConnection(int handle) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                                "Need BLUETOOTH permission");
+        mConnectionManager.deregisterEl2capConnection(handle);
+    }
+
+    public int getEffectiveAmpPolicy(int desiredPolicy) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                                "Need BLUETOOTH permission");
+        return mConnectionManager.getEffectiveAmpPolicy(desiredPolicy);
+    }
+
+    public boolean setDesiredAmpPolicy(int handle, int policy) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                                "Need BLUETOOTH permission");
+        return mConnectionManager.setDesiredAmpPolicy(handle, policy);
+    }
+
+    public void setUseWifiForBtTransfers(boolean useWifi) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                                "Need BLUETOOTH permission");
+        mConnectionManager.setUseWifiForBtTransfers(useWifi);
+    }
+
+    private synchronized void checkAndRemoveRecord(int handle, int pid) {
+        ServiceRecordClient client = mServiceRecordToPid.get(handle);
+        if (client != null && pid == client.pid) {
+            if (DBG) Log.d(TAG, "Removing service record " +
+                Integer.toHexString(handle) + " for pid " + pid);
+
+            if (client.death != null) {
+                client.binder.unlinkToDeath(client.death, 0);
+            }
+
+            mServiceRecordToPid.remove(handle);
+            removeServiceRecordNative(handle);
+        }
+    }
+
+    private class Reaper implements IBinder.DeathRecipient {
+        int mPid;
+        int mHandle;
+        int mType;
+
+        Reaper(int handle, int pid, int type) {
+            mPid = pid;
+            mHandle = handle;
+            mType = type;
+        }
+
+        Reaper(int pid, int type) {
+            mPid = pid;
+            mType = type;
+        }
+
+        @Override
+        public void binderDied() {
+            synchronized (BluetoothService.this) {
+                if (DBG) Log.d(TAG, "Tracked app " + mPid + " died" + "Type:" + mType);
+                if (mType == RFCOMM_RECORD_REAPER) {
+                    checkAndRemoveRecord(mHandle, mPid);
+                } else if (mType == STATE_CHANGE_REAPER) {
+                    mStateChangeTracker.remove(mPid);
+                }
+            }
+        }
+    }
+
+
+    @Override
+    public boolean changeApplicationBluetoothState(boolean on,
+            IBluetoothStateChangeCallback callback, IBinder binder) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+        int pid = Binder.getCallingPid();
+        //mStateChangeTracker is a synchronized map
+        if (!mStateChangeTracker.containsKey(pid)) {
+            if (on) {
+                mStateChangeTracker.put(pid, callback);
+            } else {
+                return false;
+            }
+        } else if (!on) {
+            mStateChangeTracker.remove(pid);
+        }
+
+        if (binder != null) {
+            try {
+                binder.linkToDeath(new Reaper(pid, STATE_CHANGE_REAPER), 0);
+            } catch (RemoteException e) {
+                Log.e(TAG, "", e);
+                return false;
+            }
+        }
+
+        int type;
+        if (on) {
+            type = BluetoothAdapterStateMachine.PER_PROCESS_TURN_ON;
+        } else {
+            type = BluetoothAdapterStateMachine.PER_PROCESS_TURN_OFF;
+        }
+
+        /* Currently BTC module is not started/stopped for per process (application)
+         usecases. But only for user action of on/off via Settings application. */
+
+        mBluetoothState.sendMessage(type, callback);
+        return true;
+    }
+
+    boolean isApplicationStateChangeTrackerEmpty() {
+        return mStateChangeTracker.isEmpty();
+    }
+
+    void clearApplicationStateChangeTracker() {
+        mStateChangeTracker.clear();
+    }
+
+    Collection<IBluetoothStateChangeCallback> getApplicationStateChangeCallbacks() {
+        return mStateChangeTracker.values();
+    }
+
+    int getNumberOfApplicationStateChangeTrackers() {
+        return mStateChangeTracker.size();
+    }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent == null) return;
+
+            String action = intent.getAction();
+            if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
+                ContentResolver resolver = context.getContentResolver();
+                // Query the airplane mode from Settings.System just to make sure that
+                // some random app is not sending this intent and disabling bluetooth
+                if (isAirplaneModeOn()) {
+                    mBluetoothState.sendMessage(BluetoothAdapterStateMachine.AIRPLANE_MODE_ON);
+                } else {
+                    mBluetoothState.sendMessage(BluetoothAdapterStateMachine.AIRPLANE_MODE_OFF);
+                }
+            } else if (Intent.ACTION_DOCK_EVENT.equals(action)) {
+                int state = intent.getIntExtra(Intent.EXTRA_DOCK_STATE,
+                        Intent.EXTRA_DOCK_STATE_UNDOCKED);
+                if (DBG) Log.v(TAG, "Received ACTION_DOCK_EVENT with State:" + state);
+                if (state == Intent.EXTRA_DOCK_STATE_UNDOCKED) {
+                    mDockAddress = null;
+                    mDockPin = null;
+                } else {
+                    SharedPreferences.Editor editor =
+                        mContext.getSharedPreferences(SHARED_PREFERENCES_NAME,
+                                mContext.MODE_PRIVATE).edit();
+                    editor.putBoolean(SHARED_PREFERENCE_DOCK_ADDRESS + mDockAddress, true);
+                    editor.apply();
+                }
+            } else if (BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED.equals(action)) {
+                int audioState = intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,
+                        BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
+                mConnectionManager.setScoAudioActive(audioState == BluetoothHeadset.STATE_AUDIO_CONNECTED);
+            } else if (BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
+                Log.i(TAG, "Received ACTION_CONNECTION_STATE_CHANGED");
+                if(mA2dpService != null)
+                {
+                    List<BluetoothDevice> audioDevices = mA2dpService.getConnectedDevices();
+                    for(int i = 0; i < audioDevices.size(); i++) {
+                        if(mA2dpService.isA2dpPlaying(audioDevices.get(i)) == true) {
+                            mConnectionManager.setA2dpAudioActive(true);
+                            return;
+                        }
+                    }
+                    mConnectionManager.setA2dpAudioActive(false);
+                } else {
+                    Log.e(TAG, "BluetoothA2dp service not available");
+                }
+            } else if (BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
+                Log.i(TAG, "Input connection state change" + action);
+                int state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                int prevState =
+                    intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, 0);
+                BluetoothDevice inputDevice =
+                        intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+
+                sendConnectionStateChange(inputDevice, BluetoothProfile.INPUT_DEVICE, state,
+                                                    prevState);
+            } else if (BluetoothPan.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
+                Log.i(TAG, "Pan connection state change" + action);
+                int state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                int prevState =
+                    intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, 0);
+                BluetoothDevice panDevice =
+                        intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+
+                sendConnectionStateChange(panDevice, BluetoothProfile.PAN, state,
+                                                    prevState);
+            } else if (BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY.equals(action)) {
+                Log.i(TAG, "Received ACTION_CONNECTION_ACCESS_REPLY");
+                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                if (device == null) {
+                    return;
+                }
+
+                if (mEventLoop.getAuthorizationRequestData().get(device.getAddress()) == null) {
+                    Log.i(TAG, "SAP authorization not in progress, ignoring this intent");
+                    return;
+                }
+
+                if (intent.getIntExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT,
+                                   BluetoothDevice.CONNECTION_ACCESS_NO) ==
+                                   BluetoothDevice.CONNECTION_ACCESS_YES) {
+                   if (SAP_UUID.equals(intent.getStringExtra("uuid"))){
+                       sapAuthorize(device.getAddress(), true);
+                   } else if (DUN_UUID.equals(intent.getStringExtra("uuid"))) {
+                       DUNAuthorize(device.getAddress(), true);
+                   }
+                    if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
+                        Log.i(TAG, "Setting trust state to true");
+                        setTrust(device.getAddress(),true);
+                    }
+                } else {
+                    Log.i(TAG, "User did not accept the SIM access request");
+                    if (SAP_UUID.equals(intent.getStringExtra("uuid"))){
+                       sapAuthorize(device.getAddress(), false);
+                    } else if (DUN_UUID.equals(intent.getStringExtra("uuid"))) {
+                       DUNAuthorize(device.getAddress(), false);
+                    }
+                }
+            } else if (BluetoothA2dp.ACTION_PLAYING_STATE_CHANGED.equals(action)) {
+                Log.i(TAG, "Received ACTION_PLAYING_STATE_CHANGED");
+                int playingState = intent.getIntExtra(BluetoothA2dp.EXTRA_STATE,
+                        BluetoothA2dp.STATE_PLAYING);
+                mConnectionManager.setA2dpAudioActive(playingState == BluetoothA2dp.STATE_PLAYING);
+            } else if (BluetoothDevice.ACTION_ACL_DISCONNECTED.equals(action)) {
+                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                if (device == null) {
+                    return;
+                }
+                // There are no services for HID and PAN profiles. So having
+                // Broadcast Listeners there can cause leak as we dont have
+                // point to unregister Listener. Currently handling the device
+                // connection state change to update the Profile States.
+                if (getInputDeviceConnectionState(device) !=
+                           BluetoothInputDevice.STATE_DISCONNECTED) {
+                    handleInputDevicePropertyChange(device.getAddress(), false);
+                }
+                if (getPanDeviceConnectionState(device) != BluetoothPan.STATE_DISCONNECTED &&
+                    mBluetoothPanProfileHandler != null) {
+                        handlePanDeviceStateChange(device,  BluetoothPan.STATE_DISCONNECTED,
+                                   mBluetoothPanProfileHandler.getPanDeviceRole(device));
+                }
+                if ((listConnectionNative() == 0) &&
+                    (getBluetoothStateInternal() == BluetoothAdapter.STATE_TURNING_OFF)) {
+                    Log.i(TAG, "All connections disconnected");
+                    mBluetoothState.sendMessage(
+                        BluetoothAdapterStateMachine.ALL_DEVICES_DISCONNECTED);
+                }
+                gattAclDisconnected("ACTION_ACL_DISCONNECTED", device);
+            } else if (ACTION_BT_DISCOVERABLE_TIMEOUT.equals(action)) {
+                Log.i(TAG, "ACTION_BT_DISCOVERABLE_TIMEOUT");
+                setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE, 0);
+            } else if (BluetoothAdapter.ACTION_STATE_CHANGED.equalsIgnoreCase(action)) {
+                  if(intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -1) ==
+                          BluetoothAdapter.STATE_OFF) {
+                      Log.d(TAG, "Bluetooth is off");
+                      preferredDevicesList = null;
+                      btDeviceInPreferredDevList = null;
+                      isScanInProgress = false;
+                      callerPreferredDevApi = null;
+                      callerIntent = null;
+                      sPListCallBack = null;
+                  }
+            } else if (BluetoothDevice.ACTION_ACL_CONNECTED.equals(action)) {
+                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                if (device == null) {
+                    return;
+                }
+                gattAclConnected(device);
+            }
+        }
+    };
+
+    private void registerForAirplaneMode(IntentFilter filter) {
+        final ContentResolver resolver = mContext.getContentResolver();
+        final String airplaneModeRadios = Settings.System.getString(resolver,
+                Settings.System.AIRPLANE_MODE_RADIOS);
+        final String toggleableRadios = Settings.System.getString(resolver,
+                Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS);
+
+        mIsAirplaneSensitive = airplaneModeRadios == null ? true :
+                airplaneModeRadios.contains(Settings.System.RADIO_BLUETOOTH);
+        mIsAirplaneToggleable = toggleableRadios == null ? false :
+                toggleableRadios.contains(Settings.System.RADIO_BLUETOOTH);
+
+        if (mIsAirplaneSensitive) {
+            filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+        }
+    }
+
+    /* Returns true if airplane mode is currently on */
+    /*package*/ final boolean isAirplaneModeOn() {
+        return Settings.System.getInt(mContext.getContentResolver(),
+                Settings.System.AIRPLANE_MODE_ON, 0) == 1;
+    }
+
+    /* Broadcast the Uuid intent */
+    /*package*/ synchronized void sendUuidIntent(String address) {
+        ParcelUuid[] uuid = getUuidFromCache(address);
+        Intent intent = new Intent(BluetoothDevice.ACTION_UUID);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_UUID, uuid);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        mUuidIntentTracker.remove(address);
+    }
+
+    /*package*/ synchronized void makeServiceChannelCallbacks(String address) {
+        for (Iterator<RemoteService> iter = mUuidCallbackTracker.keySet().iterator();
+                iter.hasNext();) {
+            RemoteService service = iter.next();
+            if (service.address.equals(address)) {
+                if (DBG) Log.d(TAG, "Cleaning up failed UUID channel lookup: "
+                    + service.address + " " + service.uuid);
+                IBluetoothCallback callback = mUuidCallbackTracker.get(service);
+                if (callback != null) {
+                    try {
+                        callback.onRfcommChannelFound(-1);
+                    } catch (RemoteException e) {Log.e(TAG, "", e);}
+                }
+
+                iter.remove();
+            }
+        }
+    }
+
+    @Override
+    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
+
+        if (getBluetoothStateInternal() != BluetoothAdapter.STATE_ON) {
+            return;
+        }
+
+        pw.println("mIsAirplaneSensitive = " + mIsAirplaneSensitive);
+        pw.println("mIsAirplaneToggleable = " + mIsAirplaneToggleable);
+
+        pw.println("Local address = " + getAddress());
+        pw.println("Local name = " + getName());
+        pw.println("isDiscovering() = " + isDiscovering());
+
+        mAdapter.getProfileProxy(mContext,
+                                 mBluetoothProfileServiceListener, BluetoothProfile.HEADSET);
+        mAdapter.getProfileProxy(mContext,
+                mBluetoothProfileServiceListener, BluetoothProfile.INPUT_DEVICE);
+        mAdapter.getProfileProxy(mContext,
+                mBluetoothProfileServiceListener, BluetoothProfile.PAN);
+
+        dumpKnownDevices(pw);
+        dumpAclConnectedDevices(pw);
+        dumpHeadsetService(pw);
+        dumpInputDeviceProfile(pw);
+        dumpPanProfile(pw);
+        dumpApplicationServiceRecords(pw);
+        dumpProfileState(pw);
+        //Balancing calls to unbind Headset service and trigger
+        //GC for service listener references
+        mAdapter.closeProfileProxy(BluetoothProfile.HEADSET, mHeadsetProxy);
+        mAdapter.closeProfileProxy(BluetoothProfile.INPUT_DEVICE, mInputDevice);
+        mAdapter.closeProfileProxy(BluetoothProfile.PAN, mPan);
+    }
+
+    private void dumpProfileState(PrintWriter pw) {
+        pw.println("\n--Profile State dump--");
+        pw.println("\n Headset profile state:" +
+                mAdapter.getProfileConnectionState(BluetoothProfile.HEADSET));
+        pw.println("\n A2dp profile state:" +
+                mAdapter.getProfileConnectionState(BluetoothProfile.A2DP));
+        pw.println("\n HID profile state:" +
+                mAdapter.getProfileConnectionState(BluetoothProfile.INPUT_DEVICE));
+        pw.println("\n PAN profile state:" +
+                mAdapter.getProfileConnectionState(BluetoothProfile.PAN));
+    }
+
+    private void dumpHeadsetService(PrintWriter pw) {
+        pw.println("\n--Headset Service--");
+        if (mHeadsetProxy != null) {
+            List<BluetoothDevice> deviceList = mHeadsetProxy.getConnectedDevices();
+            if (deviceList.size() == 0) {
+                pw.println("No headsets connected");
+            } else {
+                BluetoothDevice device = deviceList.get(0);
+                pw.println("\ngetConnectedDevices[0] = " + device);
+                dumpHeadsetConnectionState(pw, device);
+                pw.println("getBatteryUsageHint() = " +
+                             mHeadsetProxy.getBatteryUsageHint(device));
+            }
+
+            deviceList.clear();
+            deviceList = mHeadsetProxy.getDevicesMatchingConnectionStates(new int[] {
+                     BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_DISCONNECTED});
+            pw.println("--Connected and Disconnected Headsets");
+            for (BluetoothDevice device: deviceList) {
+                pw.println(device);
+                if (mHeadsetProxy.isAudioConnected(device)) {
+                    pw.println("SCO audio connected to device:" + device);
+                }
+            }
+        }
+    }
+
+    private void dumpInputDeviceProfile(PrintWriter pw) {
+        pw.println("\n--Bluetooth Service- Input Device Profile");
+        if (mInputDevice != null) {
+            List<BluetoothDevice> deviceList = mInputDevice.getConnectedDevices();
+            if (deviceList.size() == 0) {
+                pw.println("No input devices connected");
+            } else {
+                pw.println("Number of connected devices:" + deviceList.size());
+                BluetoothDevice device = deviceList.get(0);
+                pw.println("getConnectedDevices[0] = " + device);
+                pw.println("Priority of Connected device = " + mInputDevice.getPriority(device));
+
+                switch (mInputDevice.getConnectionState(device)) {
+                    case BluetoothInputDevice.STATE_CONNECTING:
+                        pw.println("getConnectionState() = STATE_CONNECTING");
+                        break;
+                    case BluetoothInputDevice.STATE_CONNECTED:
+                        pw.println("getConnectionState() = STATE_CONNECTED");
+                        break;
+                    case BluetoothInputDevice.STATE_DISCONNECTING:
+                        pw.println("getConnectionState() = STATE_DISCONNECTING");
+                        break;
+                }
+            }
+            deviceList.clear();
+            deviceList = mInputDevice.getDevicesMatchingConnectionStates(new int[] {
+                     BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_DISCONNECTED});
+            pw.println("--Connected and Disconnected input devices");
+            for (BluetoothDevice device: deviceList) {
+                pw.println(device);
+            }
+        }
+    }
+
+    private void dumpPanProfile(PrintWriter pw) {
+        pw.println("\n--Bluetooth Service- Pan Profile");
+        if (mPan != null) {
+            List<BluetoothDevice> deviceList = mPan.getConnectedDevices();
+            if (deviceList.size() == 0) {
+                pw.println("No Pan devices connected");
+            } else {
+                pw.println("Number of connected devices:" + deviceList.size());
+                BluetoothDevice device = deviceList.get(0);
+                pw.println("getConnectedDevices[0] = " + device);
+
+                switch (mPan.getConnectionState(device)) {
+                    case BluetoothInputDevice.STATE_CONNECTING:
+                        pw.println("getConnectionState() = STATE_CONNECTING");
+                        break;
+                    case BluetoothInputDevice.STATE_CONNECTED:
+                        pw.println("getConnectionState() = STATE_CONNECTED");
+                        break;
+                    case BluetoothInputDevice.STATE_DISCONNECTING:
+                        pw.println("getConnectionState() = STATE_DISCONNECTING");
+                        break;
+                }
+            }
+            deviceList.clear();
+            deviceList = mPan.getDevicesMatchingConnectionStates(new int[] {
+                     BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_DISCONNECTED});
+            pw.println("--Connected and Disconnected Pan devices");
+            for (BluetoothDevice device: deviceList) {
+                pw.println(device);
+            }
+        }
+    }
+
+    private void dumpHeadsetConnectionState(PrintWriter pw,
+            BluetoothDevice device) {
+        switch (mHeadsetProxy.getConnectionState(device)) {
+            case BluetoothHeadset.STATE_CONNECTING:
+                pw.println("getConnectionState() = STATE_CONNECTING");
+                break;
+            case BluetoothHeadset.STATE_CONNECTED:
+                pw.println("getConnectionState() = STATE_CONNECTED");
+                break;
+            case BluetoothHeadset.STATE_DISCONNECTING:
+                pw.println("getConnectionState() = STATE_DISCONNECTING");
+                break;
+            case BluetoothHeadset.STATE_AUDIO_CONNECTED:
+                pw.println("getConnectionState() = STATE_AUDIO_CONNECTED");
+                break;
+        }
+    }
+
+    private void dumpApplicationServiceRecords(PrintWriter pw) {
+        pw.println("\n--Application Service Records--");
+        for (Integer handle : mServiceRecordToPid.keySet()) {
+            Integer pid = mServiceRecordToPid.get(handle).pid;
+            pw.println("\tpid " + pid + " handle " + Integer.toHexString(handle));
+        }
+    }
+
+    private void dumpAclConnectedDevices(PrintWriter pw) {
+        String[] devicesObjectPath = getKnownDevices();
+        pw.println("\n--ACL connected devices--");
+        if (devicesObjectPath != null) {
+            for (String device : devicesObjectPath) {
+                pw.println(getAddressFromObjectPath(device));
+            }
+        }
+    }
+
+    private void dumpKnownDevices(PrintWriter pw) {
+        pw.println("\n--Known devices--");
+        for (String address : mDeviceProperties.keySet()) {
+            int bondState = mBondState.getBondState(address);
+            pw.printf("%s %10s (%d) %s\n", address,
+                       toBondStateString(bondState),
+                       mBondState.getAttempt(address),
+                       getRemoteName(address));
+
+            Map<ParcelUuid, Integer> uuidChannels = mDeviceServiceChannelCache.get(address);
+            if (uuidChannels == null) {
+                pw.println("\tuuids = null");
+            } else {
+                for (ParcelUuid uuid : uuidChannels.keySet()) {
+                    Integer channel = uuidChannels.get(uuid);
+                    if (channel == null) {
+                        pw.println("\t" + uuid);
+                    } else {
+                        pw.println("\t" + uuid + " RFCOMM channel = " + channel);
+                    }
+                }
+            }
+
+            Map<ParcelUuid, Integer> uuidPsms = mDeviceL2capPsmCache.get(address);
+            if (uuidPsms == null) {
+                pw.println("\tuuids = null");
+            } else {
+                for (ParcelUuid uuid : uuidPsms.keySet()) {
+                    Integer psm = uuidPsms.get(uuid);
+                    if (psm == null) {
+                        pw.println("\t" + uuid);
+                    } else {
+                        pw.println("\t" + uuid + " L2CAP PSM = " + psm);
+                    }
+                }
+            }
+
+            for (RemoteService service : mUuidCallbackTracker.keySet()) {
+                if (service.address.equals(address)) {
+                    pw.println("\tPENDING CALLBACK: " + service.uuid);
+                }
+            }
+        }
+    }
+
+    private void getProfileProxy() {
+        mAdapter.getProfileProxy(mContext,
+                                 mBluetoothProfileServiceListener, BluetoothProfile.HEADSET);
+    }
+
+    private BluetoothProfile.ServiceListener mBluetoothProfileServiceListener =
+        new BluetoothProfile.ServiceListener() {
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            if (profile == BluetoothProfile.HEADSET) {
+                mHeadsetProxy = (BluetoothHeadset) proxy;
+            } else if (profile == BluetoothProfile.INPUT_DEVICE) {
+                mInputDevice = (BluetoothInputDevice) proxy;
+            } else if (profile == BluetoothProfile.PAN) {
+                mPan = (BluetoothPan) proxy;
+            }
+        }
+        public void onServiceDisconnected(int profile) {
+            if (profile == BluetoothProfile.HEADSET) {
+                mHeadsetProxy = null;
+            } else if (profile == BluetoothProfile.INPUT_DEVICE) {
+                mInputDevice = null;
+            } else if (profile == BluetoothProfile.PAN) {
+                mPan = null;
+            }
+        }
+    };
+
+    /* package */ static int bluezStringToScanMode(boolean pairable, boolean discoverable) {
+        if (pairable && discoverable)
+            return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;
+        else if (pairable && !discoverable)
+            return BluetoothAdapter.SCAN_MODE_CONNECTABLE;
+        else
+            return BluetoothAdapter.SCAN_MODE_NONE;
+    }
+
+    /* package */ static String scanModeToBluezString(int mode) {
+        switch (mode) {
+        case BluetoothAdapter.SCAN_MODE_NONE:
+            return "off";
+        case BluetoothAdapter.SCAN_MODE_CONNECTABLE:
+            return "connectable";
+        case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:
+            return "discoverable";
+        }
+        return null;
+    }
+
+    /*package*/ String getAddressFromObjectPath(String objectPath) {
+        String adapterObjectPath = mAdapterProperties.getObjectPath();
+        if (adapterObjectPath == null || objectPath == null) {
+            Log.e(TAG, "getAddressFromObjectPath: AdapterObjectPath:" + adapterObjectPath +
+                    "  or deviceObjectPath:" + objectPath + " is null");
+            return null;
+        }
+        if (!objectPath.startsWith(adapterObjectPath)) {
+            Log.e(TAG, "getAddressFromObjectPath: AdapterObjectPath:" + adapterObjectPath +
+                    "  is not a prefix of deviceObjectPath:" + objectPath +
+                    "bluetoothd crashed ?");
+            return null;
+        }
+        String address = objectPath.substring(adapterObjectPath.length());
+        if (address != null) return address.replace('_', ':');
+
+        Log.e(TAG, "getAddressFromObjectPath: Address being returned is null");
+        return null;
+    }
+
+    /*package*/ String getObjectPathFromAddress(String address) {
+        String path = mAdapterProperties.getObjectPath();
+        if (path == null) {
+            Log.e(TAG, "Error: Object Path is null");
+            return null;
+        }
+        path = path + address.replace(":", "_");
+        return path;
+    }
+
+    /*package */ void setLinkTimeout(String address, int num_slots) {
+        String path = getObjectPathFromAddress(address);
+        boolean result = setLinkTimeoutNative(path, num_slots);
+
+        if (!result) Log.d(TAG, "Set Link Timeout to " + num_slots + " slots failed");
+    }
+
+    /**** Handlers for PAN  Profile ****/
+    // TODO: This needs to be converted to a state machine.
+
+    public boolean isTetheringOn() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.isTetheringOn();
+        }
+    }
+
+    /*package*/boolean allowIncomingTethering() {
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.allowIncomingTethering();
+        }
+    }
+
+    public void setBluetoothTethering(boolean value) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            mBluetoothPanProfileHandler.setBluetoothTethering(value);
+        }
+    }
+
+    public int getPanDeviceConnectionState(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.getPanDeviceConnectionState(device);
+        }
+    }
+
+    public boolean connectPanDevice(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+            "Need BLUETOOTH_ADMIN permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.connectPanDevice(device);
+        }
+    }
+
+    public List<BluetoothDevice> getConnectedPanDevices() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.getConnectedPanDevices();
+        }
+    }
+
+    public List<BluetoothDevice> getPanDevicesMatchingConnectionStates(
+            int[] states) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.getPanDevicesMatchingConnectionStates(states);
+        }
+    }
+
+    public boolean disconnectPanDevice(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+            "Need BLUETOOTH_ADMIN permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.disconnectPanDevice(device);
+        }
+    }
+
+    /*package*/void handlePanDeviceStateChange(BluetoothDevice device,
+                                                             String iface,
+                                                             int state,
+                                                             int role) {
+        synchronized (mBluetoothPanProfileHandler) {
+            mBluetoothPanProfileHandler.handlePanDeviceStateChange(device, iface, state, role);
+        }
+    }
+
+    /*package*/void handlePanDeviceStateChange(BluetoothDevice device,
+                                                             int state, int role) {
+        synchronized (mBluetoothPanProfileHandler) {
+            mBluetoothPanProfileHandler.handlePanDeviceStateChange(device, null, state, role);
+        }
+    }
+
+    /**** Handlers for Input Device Profile ****/
+    // This needs to be converted to state machine
+
+    public boolean connectInputDevice(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(device.getAddress());
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.connectInputDevice(device, state);
+        }
+    }
+
+    public boolean connectInputDeviceInternal(BluetoothDevice device) {
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.connectInputDeviceInternal(device);
+        }
+    }
+
+    public boolean disconnectInputDevice(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(device.getAddress());
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.disconnectInputDevice(device, state);
+        }
+    }
+
+    public boolean disconnectInputDeviceInternal(BluetoothDevice device) {
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.disconnectInputDeviceInternal(device);
+        }
+    }
+
+    public int getInputDeviceConnectionState(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.getInputDeviceConnectionState(device);
+        }
+    }
+
+    public List<BluetoothDevice> getConnectedInputDevices() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.getConnectedInputDevices();
+        }
+    }
+
+    public List<BluetoothDevice> getInputDevicesMatchingConnectionStates(
+            int[] states) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.getInputDevicesMatchingConnectionStates(states);
+        }
+    }
+
+
+    public int getInputDevicePriority(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.getInputDevicePriority(device);
+        }
+    }
+
+    public boolean setInputDevicePriority(BluetoothDevice device, int priority) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.setInputDevicePriority(device, priority);
+        }
+    }
+
+    /**
+     * Handle incoming profile acceptance for profiles handled by Bluetooth Service,
+     * currently PAN and HID. This also is the catch all for all rejections for profiles
+     * that is not supported.
+     *
+     * @param device - Bluetooth Device
+     * @param allow - true / false
+     * @return
+     */
+    public boolean allowIncomingProfileConnect(BluetoothDevice device, boolean allow) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        String address = device.getAddress();
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+
+        Integer data = getAuthorizationAgentRequestData(address);
+        if (data == null) {
+            Log.w(TAG, "allowIncomingProfileConnect(" + device +
+                  ") called but no native data available");
+            return false;
+        }
+        if (DBG) log("allowIncomingProfileConnect: " + device + " : " + allow + " : " + data);
+        return setAuthorizationNative(address, allow, data.intValue());
+    }
+
+    /*package*/List<BluetoothDevice> lookupInputDevicesMatchingStates(int[] states) {
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.lookupInputDevicesMatchingStates(states);
+        }
+    }
+
+    /*package*/void handleInputDevicePropertyChange(String address, boolean connected) {
+        synchronized (mBluetoothInputProfileHandler) {
+            mBluetoothInputProfileHandler.handleInputDevicePropertyChange(address, connected);
+        }
+    }
+
+    /**** Handlers for Health Device Profile ****/
+    // TODO: All these need to be converted to a state machine.
+
+    public boolean registerAppConfiguration(BluetoothHealthAppConfiguration config,
+                                            IBluetoothHealthCallback callback) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+                return mBluetoothHealthProfileHandler.registerAppConfiguration(config, callback);
+        }
+    }
+
+    public boolean unregisterAppConfiguration(BluetoothHealthAppConfiguration config) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+                return mBluetoothHealthProfileHandler.unregisterAppConfiguration(config);
+        }
+    }
+
+
+    public boolean connectChannelToSource(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.connectChannelToSource(device,
+                    config);
+        }
+    }
+
+    public boolean connectChannelToSink(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config, int channelType) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.connectChannel(device, config,
+                    channelType);
+        }
+    }
+
+    public boolean disconnectChannel(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config, int id) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.disconnectChannel(device, config, id);
+        }
+    }
+
+    public ParcelFileDescriptor getMainChannelFd(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.getMainChannelFd(device, config);
+        }
+    }
+
+    /*package*/ void onHealthDevicePropertyChanged(String devicePath,
+            String channelPath) {
+        synchronized (mBluetoothHealthProfileHandler) {
+            mBluetoothHealthProfileHandler.onHealthDevicePropertyChanged(devicePath,
+                    channelPath);
+        }
+    }
+
+    /*package*/ void onHealthDeviceChannelChanged(String devicePath,
+            String channelPath, boolean exists) {
+        synchronized(mBluetoothHealthProfileHandler) {
+            mBluetoothHealthProfileHandler.onHealthDeviceChannelChanged(devicePath,
+                    channelPath, exists);
+        }
+    }
+
+    /*package*/ void onHealthDeviceChannelConnectionError(int channelCode,
+            int newState) {
+        synchronized(mBluetoothHealthProfileHandler) {
+            mBluetoothHealthProfileHandler.onHealthDeviceChannelConnectionError(channelCode,
+                                                                                newState);
+        }
+    }
+
+    public int getHealthDeviceConnectionState(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.getHealthDeviceConnectionState(device);
+        }
+    }
+
+    public List<BluetoothDevice> getConnectedHealthDevices() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.getConnectedHealthDevices();
+        }
+    }
+
+    public List<BluetoothDevice> getHealthDevicesMatchingConnectionStates(
+            int[] states) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.
+                    getHealthDevicesMatchingConnectionStates(states);
+        }
+    }
+
+    /*package*/boolean notifyIncomingHidConnection(String address) {
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state == null)  state = addProfileState(address, false);
+        if (state == null) {
+            return false;
+        }
+        Message msg = new Message();
+        msg.what = BluetoothDeviceProfileState.CONNECT_HID_INCOMING;
+        state.sendMessage(msg);
+        return true;
+    }
+
+    public boolean connectHeadset(String address) {
+        if (getBondState(address) != BluetoothDevice.BOND_BONDED) return false;
+
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state != null) {
+            Message msg = new Message();
+            msg.arg1 = BluetoothDeviceProfileState.CONNECT_HFP_OUTGOING;
+            msg.obj = state;
+            mHfpProfileState.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    public boolean disconnectHeadset(String address) {
+        if (getBondState(address) != BluetoothDevice.BOND_BONDED) return false;
+
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state != null) {
+            Message msg = new Message();
+            msg.arg1 = BluetoothDeviceProfileState.DISCONNECT_HFP_OUTGOING;
+            msg.obj = state;
+            mHfpProfileState.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    public boolean connectSink(String address) {
+        if (getBondState(address) != BluetoothDevice.BOND_BONDED) return false;
+
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state != null) {
+            Message msg = new Message();
+            msg.arg1 = BluetoothDeviceProfileState.CONNECT_A2DP_OUTGOING;
+            msg.obj = state;
+            mA2dpProfileState.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    public boolean disconnectSink(String address) {
+        if (getBondState(address) != BluetoothDevice.BOND_BONDED) return false;
+
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state != null) {
+            Message msg = new Message();
+            msg.arg1 = BluetoothDeviceProfileState.DISCONNECT_A2DP_OUTGOING;
+            msg.obj = state;
+            mA2dpProfileState.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    BluetoothDeviceProfileState addProfileState(String address, boolean setTrust) {
+        BluetoothDeviceProfileState state ;
+        synchronized (mDeviceProfileState) {
+            if (mDeviceProfileState.containsKey(address)) {
+                state = mDeviceProfileState.get(address);
+                return state;
+            }
+            state =
+                new BluetoothDeviceProfileState(mContext, address, this, mA2dpService, setTrust);
+            mDeviceProfileState.put(address, state);
+            state.start();
+         }
+        return state;
+    }
+
+    synchronized void removeAllProfileState() {
+        for (BluetoothDeviceProfileState state : mDeviceProfileState.values()) {
+            if (state != null) {
+                // MR1 change
+                state.my_quit();
+            }
+        }
+        mDeviceProfileState.clear();
+    }
+
+    void removeProfileState(String address) {
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state == null) return;
+        // MR1 change
+        state.my_quit();
+        mDeviceProfileState.remove(address);
+    }
+
+    String[] getKnownDevices() {
+        String[] bonds = null;
+        String val = getProperty("Devices", true);
+        if (val != null) {
+            bonds = val.split(",");
+        }
+        return bonds;
+    }
+
+    private void initProfileState() {
+        String[] bonds = null;
+        String val = getProperty("Devices", false);
+        if (val != null) {
+            bonds = val.split(",");
+        }
+        if (bonds == null) {
+            return;
+        }
+        for (String path : bonds) {
+            String address = getAddressFromObjectPath(path);
+            BluetoothDeviceProfileState state = addProfileState(address, false);
+        }
+    }
+
+    private void autoConnect() {
+        synchronized (mAllowConnectLock) {
+            if (!mAllowConnect) {
+                Log.d(TAG, "Not auto-connecting devices because of temporary BT on state.");
+                return;
+            }
+        }
+
+        String[] bonds = getKnownDevices();
+        if (bonds == null) {
+            return;
+        }
+        for (String path : bonds) {
+            String address = getAddressFromObjectPath(path);
+            if ((mHostPatchForIOP != null) &&
+                (mHostPatchForIOP.isHostPatchRequired(address,
+                 BluetoothAdapter.HOST_PATCH_AVOID_AUTO_CONNECT))) {
+                 Log.w(TAG, "No autoconnect with specific carkit : " + address);
+                 continue;
+            }
+            BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+            if (state != null) {
+                Message msg = new Message();
+                msg.what = BluetoothDeviceProfileState.AUTO_CONNECT_PROFILES;
+                state.sendMessage(msg);
+            }
+        }
+    }
+
+    public boolean notifyConnectA2dp(String address) {
+        BluetoothDeviceProfileState state =
+             mDeviceProfileState.get(address);
+        if (state == null)  state = addProfileState(address, false);
+        if (state != null) {
+            Message msg = new Message();
+            msg.what = BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES;
+            msg.arg1 = BluetoothDeviceProfileState.CONNECT_A2DP_OUTGOING;
+            state.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    public boolean notifyIncomingConnection(String address, boolean rejected) {
+        synchronized (mAllowConnectLock) {
+            if (!mAllowConnect) {
+                Log.d(TAG, "Not allowing incoming connection because of temporary BT on state.");
+                return false;
+            }
+        }
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state == null)  state = addProfileState(address, false);
+        if (state != null) {
+            Message msg = new Message();
+            if (rejected) {
+                if (mA2dpService.getPriority(getRemoteDevice(address)) >=
+                    BluetoothProfile.PRIORITY_ON) {
+                    msg.what = BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES;
+                    msg.arg1 = BluetoothDeviceProfileState.CONNECT_A2DP_OUTGOING;
+                    state.sendMessageDelayed(msg,
+                        BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES_DELAY);
+                }
+            } else {
+                msg.what = BluetoothDeviceProfileState.CONNECT_HFP_INCOMING;
+                state.sendMessage(msg);
+            }
+            return true;
+        }
+        return false;
+    }
+
+    /*package*/ boolean notifyIncomingA2dpConnection(String address, boolean rejected) {
+        synchronized (mAllowConnectLock) {
+            if (!mAllowConnect) {
+                Log.d(TAG, "Not allowing a2dp connection because of temporary BT on state.");
+                return false;
+            }
+        }
+
+       BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+       if (state == null)  state = addProfileState(address, false);
+       if (state != null) {
+           Message msg = new Message();
+           if (rejected) {
+               if (mHeadsetProxy.getPriority(getRemoteDevice(address)) >=
+                   BluetoothProfile.PRIORITY_ON) {
+                   msg.what = BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES;
+                   msg.arg1 = BluetoothDeviceProfileState.CONNECT_HFP_OUTGOING;
+                   state.sendMessageDelayed(msg,
+                             BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES_DELAY);
+               }
+           } else {
+               msg.what = BluetoothDeviceProfileState.CONNECT_A2DP_INCOMING;
+               state.sendMessage(msg);
+           }
+           return true;
+       }
+       return false;
+    }
+
+    /*package*/ void setA2dpService(BluetoothA2dpService a2dpService) {
+        mA2dpService = a2dpService;
+    }
+
+    /*package*/ Integer getAuthorizationAgentRequestData(String address) {
+        Integer data = mEventLoop.getAuthorizationAgentRequestData().remove(address);
+        return data;
+    }
+
+    public void sendProfileStateMessage(int profile, int cmd) {
+        Message msg = new Message();
+        msg.what = cmd;
+        if (profile == BluetoothProfileState.HFP) {
+            mHfpProfileState.sendMessage(msg);
+        } else if (profile == BluetoothProfileState.A2DP) {
+            mA2dpProfileState.sendMessage(msg);
+        }
+    }
+
+    public int getAdapterConnectionState() {
+        return mAdapterConnectionState;
+    }
+
+    public int getAdapterConnectionCount() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        return listConnectionNative();
+    }
+
+    public int getProfileConnectionState(int profile) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+        Pair<Integer, Integer> state = mProfileConnectionState.get(profile);
+        if (state == null) return BluetoothProfile.STATE_DISCONNECTED;
+
+        return state.first;
+    }
+
+    private void updateProfileConnectionState(int profile, int newState, int oldState) {
+        // mProfileConnectionState is a hashmap -
+        // <Integer, Pair<Integer, Integer>>
+        // The key is the profile, the value is a pair. first element
+        // is the state and the second element is the number of devices
+        // in that state.
+        int numDev = 1;
+        int newHashState = newState;
+        boolean update = true;
+
+        // The following conditions are considered in this function:
+        // 1. If there is no record of profile and state - update
+        // 2. If a new device's state is current hash state - increment
+        //    number of devices in the state.
+        // 3. If a state change has happened to Connected or Connecting
+        //    (if current state is not connected), update.
+        // 4. If numDevices is 1 and that device state is being updated, update
+        // 5. If numDevices is > 1 and one of the devices is changing state,
+        //    decrement numDevices but maintain oldState if it is Connected or
+        //    Connecting
+        Pair<Integer, Integer> stateNumDev = mProfileConnectionState.get(profile);
+        if (stateNumDev != null) {
+            int currHashState = stateNumDev.first;
+            numDev = stateNumDev.second;
+
+            if (newState == currHashState) {
+                numDev ++;
+            } else if (newState == BluetoothProfile.STATE_CONNECTED ||
+                   (newState == BluetoothProfile.STATE_CONNECTING &&
+                    currHashState != BluetoothProfile.STATE_CONNECTED)) {
+                 numDev = 1;
+            } else if (numDev == 1 && oldState == currHashState) {
+                 update = true;
+            } else if (numDev > 1 && oldState == currHashState) {
+                 numDev --;
+
+                 if (currHashState == BluetoothProfile.STATE_CONNECTED ||
+                     currHashState == BluetoothProfile.STATE_CONNECTING) {
+                    newHashState = currHashState;
+                 }
+            } else {
+                 update = false;
+            }
+        }
+
+        if (update) {
+            mProfileConnectionState.put(profile, new Pair<Integer, Integer>(newHashState,
+                    numDev));
+        }
+    }
+
+    public synchronized void sendConnectionStateChange(BluetoothDevice
+            device, int profile, int state, int prevState) {
+        // Since this is a binder call check if Bluetooth is on still
+        if (getBluetoothStateInternal() == BluetoothAdapter.STATE_OFF) return;
+
+        if (!validateProfileConnectionState(state) ||
+                !validateProfileConnectionState(prevState)) {
+            // Previously, an invalid state was broadcast anyway,
+            // with the invalid state converted to -1 in the intent.
+            // Better to log an error and not send an intent with
+            // invalid contents or set mAdapterConnectionState to -1.
+            Log.e(TAG, "Error in sendConnectionStateChange: "
+                    + "prevState " + prevState + " state " + state);
+            return;
+        }
+
+        updateProfileConnectionState(profile, state, prevState);
+
+        if (updateCountersAndCheckForConnectionStateChange(state, prevState)) {
+            mAdapterConnectionState = state;
+
+            if (state == BluetoothProfile.STATE_DISCONNECTED) {
+                if ((getBluetoothStateInternal() == BluetoothAdapter.STATE_TURNING_OFF) &&
+                    (listConnectionNative() > 0)) {
+                    disconnectAllConnectionsNative();
+                } else {
+                    mBluetoothState.sendMessage(
+                        BluetoothAdapterStateMachine.ALL_DEVICES_DISCONNECTED);
+                }
+            }
+
+            if((state == BluetoothProfile.STATE_DISCONNECTED ||
+                state == BluetoothProfile.STATE_DISCONNECTING) &&
+               (mDeviceConnected > 0)) {
+               Log.d(TAG, "More Gatt profiles are connected count : " + mDeviceConnected);
+               return;
+            }
+
+            Intent intent = new Intent(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.putExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE,
+                    convertToAdapterState(state));
+            intent.putExtra(BluetoothAdapter.EXTRA_PREVIOUS_CONNECTION_STATE,
+                    convertToAdapterState(prevState));
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+            Log.d(TAG, "CONNECTION_STATE_CHANGE: " + device + ": "
+                    + prevState + " -> " + state);
+        }
+    }
+
+    public synchronized void sendDeviceConnectionStateChange(BluetoothDevice device, int state) {
+        // Since this is a binder call check if Bluetooth is on still
+        if (getBluetoothStateInternal() == BluetoothAdapter.STATE_OFF) return;
+
+        String devType = getDeviceProperties().getProperty(device.getAddress(), "Type");
+        if (!"LE".equals(devType)) return;
+
+        if (updateDeviceCountersAndCheckForConnStateChange(state)) {
+
+            if ((state == BluetoothAdapter.STATE_DISCONNECTED) &&
+               (mProfilesConnected > 0)) {
+                Log.d(TAG, "More BR/EDR profiles connected count: " + mProfilesConnected);
+                return;
+            }
+
+            Intent connStateIntent = null;
+            connStateIntent = new Intent(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
+            connStateIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            connStateIntent.putExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE, state);
+            connStateIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(connStateIntent, BLUETOOTH_PERM);
+            Log.d(TAG, " Sent BluetoothAdapte.ACTION_CONNECTION_STATE_CHANGED "+
+                       "with state : " + state);
+        }
+    }
+
+    private boolean validateProfileConnectionState(int state) {
+        return (state == BluetoothProfile.STATE_DISCONNECTED ||
+                state == BluetoothProfile.STATE_CONNECTING ||
+                state == BluetoothProfile.STATE_CONNECTED ||
+                state == BluetoothProfile.STATE_DISCONNECTING);
+    }
+
+    private int convertToAdapterState(int state) {
+        switch (state) {
+            case BluetoothProfile.STATE_DISCONNECTED:
+                return BluetoothAdapter.STATE_DISCONNECTED;
+            case BluetoothProfile.STATE_DISCONNECTING:
+                return BluetoothAdapter.STATE_DISCONNECTING;
+            case BluetoothProfile.STATE_CONNECTED:
+                return BluetoothAdapter.STATE_CONNECTED;
+            case BluetoothProfile.STATE_CONNECTING:
+                return BluetoothAdapter.STATE_CONNECTING;
+        }
+        Log.e(TAG, "Error in convertToAdapterState");
+        return -1;
+    }
+
+    private boolean updateCountersAndCheckForConnectionStateChange(int state, int prevState) {
+        switch (prevState) {
+            case BluetoothProfile.STATE_CONNECTING:
+                if (mProfilesConnecting > 0) { // always expected to be > 0
+                    mProfilesConnecting--;
+                }
+                break;
+
+            case BluetoothProfile.STATE_CONNECTED:
+                if (mProfilesConnected > 0) { // always expected to be > 0
+                    mProfilesConnected--;
+                }
+                break;
+
+            case BluetoothProfile.STATE_DISCONNECTING:
+                if (mProfilesDisconnecting > 0) { // always expected to be > 0
+                    mProfilesDisconnecting--;
+                }
+                break;
+        }
+
+        switch (state) {
+            case BluetoothProfile.STATE_CONNECTING:
+                mProfilesConnecting++;
+                return (mProfilesConnected == 0 && mProfilesConnecting == 1);
+
+            case BluetoothProfile.STATE_CONNECTED:
+                mProfilesConnected++;
+                return (mProfilesConnected == 1);
+
+            case BluetoothProfile.STATE_DISCONNECTING:
+                mProfilesDisconnecting++;
+                return (mProfilesConnected == 0 && mProfilesDisconnecting == 1);
+
+            case BluetoothProfile.STATE_DISCONNECTED:
+                return (mProfilesConnected == 0 && mProfilesConnecting == 0);
+
+            default:
+                return true;
+        }
+    }
+
+    private boolean updateDeviceCountersAndCheckForConnStateChange(int state) {
+        switch (state) {
+            case BluetoothAdapter.STATE_CONNECTED:
+                ++mDeviceConnected;
+                Log.d(TAG, "Device connected : " + mDeviceConnected);
+                return (mDeviceConnected == 1);
+
+            case BluetoothAdapter.STATE_DISCONNECTED:
+                --mDeviceConnected;
+                Log.d(TAG, "Device connected : " + mDeviceConnected);
+                return (mDeviceConnected == 0);
+
+            default:
+                return false;
+        }
+    }
+
+    private void createIncomingConnectionStateFile() {
+        File f = new File(INCOMING_CONNECTION_FILE);
+        if (!f.exists()) {
+            try {
+                f.createNewFile();
+            } catch (IOException e) {
+                Log.e(TAG, "IOException: cannot create file");
+            }
+        }
+    }
+
+    /** @hide */
+    public Pair<Integer, String> getIncomingState(String address) {
+        if (mIncomingConnections.isEmpty()) {
+            createIncomingConnectionStateFile();
+            readIncomingConnectionState();
+        }
+        return mIncomingConnections.get(address);
+    }
+
+    private void readIncomingConnectionState() {
+        synchronized(mIncomingConnections) {
+            FileInputStream fstream = null;
+            try {
+              fstream = new FileInputStream(INCOMING_CONNECTION_FILE);
+              DataInputStream in = new DataInputStream(fstream);
+              BufferedReader file = new BufferedReader(new InputStreamReader(in));
+              String line;
+              while((line = file.readLine()) != null) {
+                  line = line.trim();
+                  if (line.length() == 0) continue;
+                  String[] value = line.split(",");
+                  if (value != null && value.length == 3) {
+                      Integer val1 = Integer.parseInt(value[1]);
+                      Pair<Integer, String> val = new Pair(val1, value[2]);
+                      mIncomingConnections.put(value[0], val);
+                  }
+              }
+            } catch (FileNotFoundException e) {
+                log("FileNotFoundException: readIncomingConnectionState" + e.toString());
+            } catch (IOException e) {
+                log("IOException: readIncomingConnectionState" + e.toString());
+            } finally {
+                if (fstream != null) {
+                    try {
+                        fstream.close();
+                    } catch (IOException e) {
+                        // Ignore
+                    }
+                }
+            }
+        }
+    }
+
+    private void truncateIncomingConnectionFile() {
+        RandomAccessFile r = null;
+        try {
+            r = new RandomAccessFile(INCOMING_CONNECTION_FILE, "rw");
+            r.setLength(0);
+        } catch (FileNotFoundException e) {
+            log("FileNotFoundException: truncateIncomingConnectionState" + e.toString());
+        } catch (IOException e) {
+            log("IOException: truncateIncomingConnectionState" + e.toString());
+        } finally {
+            if (r != null) {
+                try {
+                    r.close();
+                } catch (IOException e) {
+                    // ignore
+                 }
+            }
+        }
+    }
+
+    /** @hide */
+    public void writeIncomingConnectionState(String address, Pair<Integer, String> data) {
+        synchronized(mIncomingConnections) {
+            mIncomingConnections.put(address, data);
+
+            truncateIncomingConnectionFile();
+            BufferedWriter out = null;
+            StringBuilder value = new StringBuilder();
+            try {
+                out = new BufferedWriter(new FileWriter(INCOMING_CONNECTION_FILE, true));
+                for (String devAddress: mIncomingConnections.keySet()) {
+                  Pair<Integer, String> val = mIncomingConnections.get(devAddress);
+                  value.append(devAddress);
+                  value.append(",");
+                  value.append(val.first.toString());
+                  value.append(",");
+                  value.append(val.second);
+                  value.append("\n");
+                }
+                out.write(value.toString());
+            } catch (FileNotFoundException e) {
+                log("FileNotFoundException: writeIncomingConnectionState" + e.toString());
+            } catch (IOException e) {
+                log("IOException: writeIncomingConnectionState" + e.toString());
+            } finally {
+                if (out != null) {
+                    try {
+                        out.close();
+                    } catch (IOException e) {
+                        // Ignore
+                    }
+                }
+            }
+        }
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+
+
+    /**** Remote GATT Service handlers ****/
+
+    public synchronized String getGattServiceProperty(String path, String property) {
+        Map<String, String> properties = mGattProperties.get(path);
+        Log.d(TAG, "getGattServiceProperty: " + property + ", path "+ path);
+        if (properties != null) {
+            return properties.get(property);
+        } else {
+            // Query for GATT service properties, again.
+            if (updateGattServicePropertiesCache(path))
+                return getGattServiceProperty(path, property);
+        }
+        Log.e(TAG, "getGattServiceProperty: " + property + " not present: " + path);
+        return null;
+    }
+
+    /* package */ synchronized boolean updateGattServicePropertiesCache(String path) {
+        String[] propValues = (String []) getGattServicePropertiesNative(path);
+        if (propValues != null) {
+            addGattServiceProperties(path, propValues);
+            return true;
+        }
+        return false;
+    }
+
+    /* package */ synchronized void addGattServiceProperties(String path, String[] properties) {
+        Map<String, String> propertyValues = mGattProperties.get(path);
+        if (propertyValues == null) {
+            propertyValues = new HashMap<String, String>();
+        }
+
+        for (int i = 0; i < properties.length; i++) {
+            String name = properties[i];
+            String newValue = null;
+            int len;
+            if (name == null) {
+                Log.e(TAG, "Error: Gatt Service Property at index" + i + "is null");
+                continue;
+            }
+            if (name.equals("Characteristics")) {
+                StringBuilder str = new StringBuilder();
+                len = Integer.valueOf(properties[++i]);
+                for (int j = 0; j < len; j++) {
+                    str.append(properties[++i]);
+                    str.append(",");
+                }
+                if (len > 0) {
+                    newValue = str.toString();
+                }
+            } else {
+                newValue = properties[++i];
+            }
+            propertyValues.put(name, newValue);
+        }
+
+        mGattProperties.put(path, propertyValues);
+
+    }
+
+    /* package */ void removeGattServiceProperties(String path) {
+        mGattProperties.remove(path);
+    }
+
+    private synchronized String[] getRemoteGattServices(String address) {
+        Log.d (TAG, "getRemoteGattServices");
+
+        String value = mDeviceProperties.getProperty(address, "Services");
+        if (value == null) {
+            Log.d(TAG, "getRemoteGattServicese: no services found");
+            return null;
+        }
+
+        String[] path = null;
+        // The paths are stored as a "," separated string.
+        path = value.split(",");
+
+        return path;
+    }
+
+    private String[] matchGattService(String address, ParcelUuid uuid)
+    {
+        // The properties should be cached at this point
+        String value = mDeviceProperties.getProperty(address, "Services");
+        if (value == null) {
+            Log.e(TAG, "matchGattService: No GATT based services were found on " + address);
+            return null;
+        } else {
+            Log.d(TAG, "matchGattService: Value " + value);
+        }
+
+        String[] gattServicePaths = null;
+        // The  object paths are stored as a "," separated string.
+        gattServicePaths = value.split(",");
+
+        ArrayList<String> matchList = new ArrayList<String>();
+        int count = 0;
+        String stringUuid;
+
+        stringUuid = uuid.toString();
+
+        Log.d(TAG, "Requested GATT UUID to match: " + stringUuid);
+
+        for (int i  = 0; i < gattServicePaths.length; i++) {
+            boolean match = true;
+            String serviceUuid = getGattServiceProperty(gattServicePaths[i], "UUID");
+
+            if (serviceUuid != null) {
+                Log.d(TAG, "Found GATT UUID: " + serviceUuid);
+
+                if (!serviceUuid.equalsIgnoreCase(stringUuid)){
+                        Log.d(TAG,"UUID does not match");
+                        match = false;
+                }
+
+                if (match) {
+                    matchList.add(gattServicePaths[i]);
+                    count++;
+                }
+            }
+        }
+
+        if (count == 0)
+            return null;
+
+        Log.d(TAG,"Found " + count+ " instances of service " + stringUuid);
+
+        String[] ret = new String[count];
+
+        matchList.toArray(ret);
+
+        return ret;
+    }
+
+   /* Broadcast the GATT services intent */
+    /*package*/ synchronized void sendGattIntent(String address, int result) {
+        Intent intent = new Intent(BluetoothDevice.ACTION_GATT);
+        ParcelUuid[] uuids = null;
+        String[] gattPath;
+        int count = 1;
+        int i;
+        boolean isScheduled = false;
+
+        synchronized (this) {
+            if (mGattIntentTracker.containsKey(address)) {
+
+                ArrayList<ParcelUuid> serviceUuids = mGattIntentTracker.get(address);
+                isScheduled = true;
+
+                if(serviceUuids != null) {
+                    uuids = new ParcelUuid[serviceUuids.size()];
+                    uuids = serviceUuids.toArray(uuids);
+                }
+
+                Log.d(TAG, "Clear GATT INTENT tracker");
+                mGattIntentTracker.remove(address);
+            }
+        }
+
+        if (!isScheduled)
+            return;
+
+        if (uuids != null) {
+            count = uuids.length;
+            for (i = 0; i < count; i++) {
+
+                gattPath = matchGattService (address, uuids[i]);
+
+                intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+                intent.putExtra(BluetoothDevice.EXTRA_UUID, uuids[i]);
+                intent.putExtra(BluetoothDevice.EXTRA_GATT, gattPath);
+                intent.putExtra(BluetoothDevice.EXTRA_GATT_RESULT, result);
+                mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+            }
+        } else {
+            Log.d(TAG, "Send intents about all services found on the remote devices");
+
+            String value = mDeviceProperties.getProperty(address, "Services");
+            if (value == null) {
+                Log.e(TAG, "No GATT based services were found on " + address);
+                return;
+            }
+            Log.d(TAG, "GattServices: " + value);
+
+            String[] gattServicePaths = null;
+            // The  object paths are stored as a "," separated string.
+            gattServicePaths = value.split(",");
+
+            //Send one intent per GATT service
+            for (i  = 0; i < gattServicePaths.length; i++) {
+                String serviceUuid = getGattServiceProperty(gattServicePaths[i], "UUID");
+                ParcelUuid svcUuid = ParcelUuid.fromString(serviceUuid);
+                intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+                intent.putExtra(BluetoothDevice.EXTRA_UUID, svcUuid);
+                intent.putExtra(BluetoothDevice.EXTRA_GATT, gattServicePaths[i]);
+                intent.putExtra(BluetoothDevice.EXTRA_GATT_RESULT, result);
+                mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+            }
+        }
+    }
+
+    private String[] getCharacteristicsFromCache(String servicePath) {
+        String value = getGattServiceProperty(servicePath, "Characteristics");
+        if (value == null) {
+            return null;
+        }
+
+        String[] paths = null;
+        // The Charateristic paths are stored as a "," separated string.
+        paths = value.split(",");
+        return paths;
+    }
+
+    /*package*/ synchronized void makeDiscoverCharacteristicsCallback(String servicePath,
+                 String index, boolean result) {
+        Log.d(TAG, "makeDiscoverCharacteristicsCallback for service: " + servicePath);
+        Log.d(TAG, "makeDiscoverCharacteristicsCallback for index: " + index);
+
+        ArrayList<String> objPathSrvIdList = mGattOperationTracker.get("discoverChar");
+        if(objPathSrvIdList != null) {
+            Log.d(TAG, "objPathSrvIdList not null");
+            Log.d(TAG, "objPathSrvIdList length::"+objPathSrvIdList.size());
+            for(int i=0; i < objPathSrvIdList.size(); i++) {
+                String pathSrvId = objPathSrvIdList.get(i);
+                String[] arrStr = pathSrvId.split("#");
+                Log.d(TAG, "pathSrvId::"+pathSrvId);
+                //Get the callback only when the Arraylist's objPath matches with
+                //the servicePath in this function
+                if(arrStr[0] != null && arrStr[0].equalsIgnoreCase(servicePath)){
+                    Log.d(TAG, "The Arraylist's objPath matches with the servicePath in this functio"+
+                               "n");
+                    IBluetoothGattService callback = mGattServiceTracker.get(pathSrvId);
+                    if (callback != null) {
+                        Log.d(TAG, "CallBack retrieved");
+                        String[]  charPaths = null;
+                        if (result)
+                            charPaths = getCharacteristicsFromCache(servicePath);
+                        try {
+                            callback.onCharacteristicsDiscovered(charPaths, result);
+                            objPathSrvIdList.remove(i);
+                        } catch (Exception e) {
+                            Log.e(TAG, "", e);
+                            forceCloseGattService(servicePath, Integer.parseInt(index));
+                        }
+                    } else
+                        Log.d(TAG, "Discover Characteristics Callback for  service " + servicePath +
+" not queued");
+                }
+            }
+            mGattOperationTracker.put("discoverChar", objPathSrvIdList);
+        }
+    }
+
+    /*package*/ synchronized void makeSetCharacteristicPropertyCallback(
+        String charPath, String index, String property, boolean result) {
+        Log.d(TAG, "makeSetCharacteristicPropertyCallback for char: " + charPath);
+
+        if (charPath == null) {
+            return;
+        }
+
+        String servicePath = charPath.substring(0, charPath.indexOf("/characteristic"));
+
+        if (servicePath == null) {
+            return;
+        }
+
+        IBluetoothGattService callback = mGattServiceTracker.get(servicePath+"#"+index);
+
+        if (callback != null) {
+            try {
+                callback.onSetCharacteristicProperty(charPath, property, result);
+            }  catch (Exception e) {
+                Log.e(TAG, "", e);
+                forceCloseGattService(servicePath, Integer.parseInt(index));
+            }
+
+        } else
+            Log.d(TAG, "Set Characteristics Property Callback for  service " + servicePath + " not queued");
+
+    }
+
+    /*package*/ synchronized void makeWatcherValueChangedCallback(String charPath, String value) {
+
+        if (charPath == null) {
+            return;
+        }
+
+        String servicePath = charPath.substring(0, charPath.indexOf("/characteristic"));
+
+        if (servicePath == null) {
+            return;
+        }
+
+        Log.d(TAG, "WatcherValueChanged : service Path = " + servicePath);
+
+        HashMap<Integer, IBluetoothGattService> callbacks = mGattWatcherTracker.get(servicePath);
+
+        if (callbacks != null) {
+            Log.d(TAG, "Watcher services exist for the path " + servicePath);
+            try {
+                for(Map.Entry<Integer, IBluetoothGattService> entry : callbacks.entrySet()) {
+                    IBluetoothGattService callback = entry.getValue();
+                    if(callback != null) {
+                        Log.d(TAG, "Calling on onValueChanged for : " + callback);
+                        callback.onValueChanged(charPath, value);
+                    }
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "", e);
+                forceCloseGattService(servicePath, -1);
+            }
+        } else {
+            Log.d(TAG, "Callback for service " + servicePath + " not registered");
+        }
+    }
+
+    /*package*/ synchronized void makeUpdateCharacteristicValueCallback(
+        String charPath, String index, boolean result) {
+
+        String servicePath = charPath.substring(0, charPath.indexOf("/characteristic"));
+
+        if (servicePath == null) {
+            return;
+        }
+
+        IBluetoothGattService callback = mGattServiceTracker.get(servicePath+"#"+index);
+
+        Log.d(TAG, "makeCharacteristicValueUpdatedCallback for service: " + charPath);
+
+        if (callback != null) {
+            try {
+                callback.onCharacteristicValueUpdated(charPath, result);
+            } catch (Exception e) {
+                Log.e(TAG, "", e);
+                forceCloseGattService(servicePath, Integer.parseInt(index));
+            }
+        } else {
+            Log.d(TAG, "Callback for service " + servicePath + " not registered");
+        }
+    }
+
+   /**
+     * Bluetooth: Support for GATT Update Characteristic Value
+     * Returns the user-friendly name of a GATT based service. This value is
+     * returned from our local cache.
+     */
+    public String getGattServiceName(String path) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!BluetoothAdapter.checkBluetoothAddress(getAddressFromObjectPath(path))) {
+            return null;
+        }
+
+        return getGattServiceProperty(path, "Name");
+
+    }
+
+   /**
+     * Connect and fetch object paths for GATT based services.
+     * TODO: for BR/EDR use SDP mechanism
+     */
+    public synchronized boolean getGattServices(String address, ParcelUuid uuid) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+
+        Log.d(TAG, "getGattServices");
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+
+        boolean ret = true;
+        boolean delay = false;
+        boolean discovering = false;
+
+        synchronized (this) {
+            discovering = mGattIntentTracker.containsKey(address);
+        }
+
+        if (!discovering) {
+            if (isRemoteDeviceInCache(address) && findDeviceNative(address) != null) {
+                if (getRemoteGattServices(address) == null) {
+                        Log.e(TAG, "No GATT based services were found on " + address);
+                        String devType = getDeviceProperties().getProperty(address, "Type");
+                        String path = getObjectPathFromAddress(address);
+                        if("LE".equals(devType)) {
+                            ret = discoverPrimaryServicesNative(path);
+                            delay = true;
+                        } else
+                            ret = false;
+                }
+            } else {
+                Log.d(TAG, "Need to Create Remote Device" + address + " before accessing properties");
+                ret = createDeviceNative(address);
+                delay = true;
+            }
+        } else
+                Log.d(TAG, "GATT service discovery for remote device " + address + "is in progress");
+
+        if (!ret)
+            return false;
+
+        ArrayList<ParcelUuid> serviceUuids;
+        synchronized (this) {
+            if (mGattIntentTracker.containsKey(address)) {
+                serviceUuids = mGattIntentTracker.get(address);
+                mGattIntentTracker.remove(address);
+            } else {
+                serviceUuids = new ArrayList<ParcelUuid>();
+            }
+            if(uuid != null) {
+                serviceUuids.add(uuid);
+                mGattIntentTracker.put(address, serviceUuids);
+            }
+            else {
+                mGattIntentTracker.put(address, null);
+            }
+        }
+
+        if (!discovering) {
+            Message message = mHandler.obtainMessage(MESSAGE_GATT_INTENT);
+            message.obj = address;
+            if (delay)
+                mHandler.sendMessageDelayed(message, GATT_INTENT_DELAY);
+            else
+                mHandler.sendMessage(message);
+        }
+
+        return true;
+    }
+
+    public synchronized boolean discoverCharacteristics(String path, int serviceId) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+         if (!isEnabledInternal()) return false;
+
+         Log.d(TAG, "discoverCharacteristics Id : " + serviceId);
+         Log.d(TAG, "path : " + path);
+
+        if (!mGattServices.containsKey(path)) {
+             Log.d(TAG, "Service not present " + path);
+             return false;
+         }
+
+        boolean ret = false;
+        ArrayList<String> objPathSrvIdList = mGattOperationTracker.get("discoverChar");
+        String pathSrvId = path+"#"+Integer.toString(serviceId);
+        if(objPathSrvIdList != null && (objPathSrvIdList.size() > 0)) {
+            Log.d(TAG, "objPathSrvIdList not null");
+            Log.d(TAG, "objPathSrvIdList length:"+objPathSrvIdList.size());
+            for(int i=0;i < objPathSrvIdList.size();i++) {
+                String objSvId = objPathSrvIdList.get(i);
+                String[] arrStr = objSvId.split("#");
+                Log.d(TAG, "objSvId::"+objSvId);
+                if(arrStr[0] != null && !arrStr[0].equalsIgnoreCase(path)){
+                    //start discovery only when the srv path is not already registered for
+                    //discover char in mGattOperationTracker
+                    Log.d(TAG, "srv path is not already registered for discover char in mGattOperationTracker");
+                    if(serviceId >= 0) {
+                        Log.d(TAG, "Calling discoverCharacteristicsNative " + path + "#" +Integer.toString(serviceId));
+                        ret = discoverCharacteristicsNative(path, "#"+Integer.toString(serviceId));
+                    }
+                }
+                else {
+                    Log.d(TAG, "srv path is already registered for discover char in mGattOperationTracker. So will not call discover char again");
+                }
+                if(!objPathSrvIdList.contains(pathSrvId)) {
+                    objPathSrvIdList.add(pathSrvId);
+                }
+                mGattOperationTracker.put("discoverChar",objPathSrvIdList);
+            }
+        }
+        else {
+            Log.d(TAG, "objPathSrvIdList is null");
+            objPathSrvIdList = new ArrayList<String>();
+            objPathSrvIdList.add(pathSrvId);
+            mGattOperationTracker.put("discoverChar",objPathSrvIdList);
+            if(serviceId >= 0) {
+                Log.d(TAG, "Calling discoverCharacteristicsNative " + path + "#" +Integer.toString(serviceId));
+                ret = discoverCharacteristicsNative(path, "#"+Integer.toString(serviceId));
+            }
+        }
+        return ret;
+    }
+
+    public synchronized int gattConnect(String address, String path, byte prohibitRemoteChg,
+                               byte filterPolicy, int scanInterval,
+                               int scanWindow, int intervalMin,
+                               int intervalMax, int latency,
+                               int superVisionTimeout, int minCeLen,
+                               int maxCeLen, int connTimeOut) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return BluetoothDevice.GATT_RESULT_FAIL;
+
+        Log.d(TAG, "gattConnect");
+        String devPath = null;
+        int result;
+
+        if (path == null) {
+            /* Connect to remote LE device */
+            if (isRemoteDeviceInCache(address) && findDeviceNative(address) != null) {
+                devPath = getObjectPathFromAddress(address);
+            } else {
+                devPath = createLeDeviceNative(address);
+            }
+
+            if (devPath == null)
+                return BluetoothDevice.GATT_RESULT_FAIL;
+
+            result =  gattLeConnectNative(devPath, (int) prohibitRemoteChg, (int) filterPolicy,
+                                              scanInterval, scanWindow,
+                                              intervalMin, intervalMax,
+                                              latency, superVisionTimeout,
+                                              minCeLen, maxCeLen, connTimeOut);
+        } else /* Connect to GATT service (client initiated) */
+            result =  gattConnectNative(path, (int) prohibitRemoteChg, (int) filterPolicy,
+                                              scanInterval, scanWindow,
+                                              intervalMin, intervalMax,
+                                              latency, superVisionTimeout,
+                                              minCeLen, maxCeLen, connTimeOut);
+        return result;
+    }
+
+    public synchronized boolean gattConnectCancel(String address, String path) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+
+        Log.d(TAG, "gattConnectCancel");
+        if (path == null) {
+            if (isRemoteDeviceInCache(address) && findDeviceNative(address) != null)  {
+                path = getObjectPathFromAddress(address);
+                return gattLeConnectCancelNative(path);
+            } else
+                return false;
+        } else
+            return gattConnectCancelNative(path);
+    }
+
+    public synchronized String[] getCharacteristicProperties(String path) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return null;
+
+        Log.d(TAG, "getCharacteristicProperties");
+
+        if (path == null) {
+            return null;
+        }
+
+        String servicePath = path.substring(0, path.indexOf("/characteristic"));
+
+        if (servicePath == null) {
+            return null;
+        }
+
+       if (!mGattServices.containsKey(servicePath)) {
+            Log.d(TAG, "Service not present " + servicePath);
+            return null;
+        }
+
+        String[] propValues = (String []) getCharacteristicPropertiesNative(path);
+        return propValues;
+    }
+
+    public synchronized boolean setCharacteristicProperty(String path, String key, byte[] value,
+            boolean reliable, int serviceId) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+
+        if (path == null) {
+            return false;
+        }
+
+        String servicePath = path.substring(0, path.indexOf("/characteristic"));
+
+        if (servicePath == null) {
+            return false;
+        }
+
+        if (!mGattServices.containsKey(servicePath)) {
+            Log.d(TAG, "Service not present " + servicePath);
+            return false;
+        }
+
+        boolean ret = false;
+        if(serviceId >= 0) {
+             Log.d(TAG, "Calling setCharacteristicPropertyNative " + path + "#" +
+                   Integer.toString(serviceId));
+             ret = setCharacteristicPropertyNative(path, key, "#"+Integer.toString(serviceId), value,
+                                                   value.length, reliable);
+        }
+
+        return ret;
+    }
+
+    public synchronized boolean updateCharacteristicValue(String path, int serviceId) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+
+        Log.d(TAG, "updateCharacteristicValue");
+
+        if (path == null) {
+            return false;
+        }
+
+        String servicePath = path.substring(0, path.indexOf("/characteristic"));
+
+        if (servicePath == null) {
+            return false;
+        }
+
+       if (!mGattServices.containsKey(servicePath)) {
+            Log.d(TAG, "Service not present " + servicePath);
+            return false;
+        }
+
+        boolean ret = false;
+        if(serviceId >= 0) {
+           Log.d(TAG, "Calling updateCharacteristicValueNative " + path + "#" +Integer.toString(serviceId));
+           ret = updateCharacteristicValueNative(path, "#"+Integer.toString(serviceId));
+        }
+
+        return ret;
+    }
+
+    public synchronized boolean registerCharacteristicsWatcher(String path,
+                                                               IBluetoothGattService gattCallback,
+                                                               int serviceId) {
+       mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+
+        Log.d(TAG, "registerCharacteristicsWatcher");
+        boolean ret = false;
+
+       if (!mGattServices.containsKey(path)) {
+            Log.d(TAG, "Service not present " + path);
+            return false;
+        }
+
+       HashMap<Integer, IBluetoothGattService> watcherServices;
+       if (mGattWatcherTracker.containsKey(path)) {
+           Log.d(TAG, "Object path exists in the watcher tracker");
+           watcherServices = mGattWatcherTracker.get(path);
+
+           if(watcherServices.containsKey(serviceId)) {
+               // Do not add this callback
+               Log.d(TAG, "registerCharacteristicsWatcher: already registered for " + path);
+               return false;
+           }
+           watcherServices.put(new Integer(serviceId), gattCallback);
+           ret = true;
+       } else {
+           Log.d(TAG, "Create new watcher service");
+           watcherServices = new HashMap<Integer, IBluetoothGattService>();
+           ret = registerCharacteristicsWatcherNative(path);
+
+           if (ret) {
+               Log.d(TAG, "wactcher registered successfully adding " +
+                     serviceId + " " + gattCallback);
+               watcherServices.put(new Integer(serviceId), gattCallback);
+           }
+       }
+
+       mGattWatcherTracker.put(path, watcherServices);
+
+        return ret;
+   }
+
+    public synchronized boolean deregisterCharacteristicsWatcher(String path, int serviceId) {
+       mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+
+       if (!mGattServices.containsKey(path)) {
+            Log.d(TAG, "Service not present " + path);
+            return false;
+        }
+
+        Log.d(TAG, "deregisterCharacteristicsWatcher");
+
+        boolean ret = false;
+
+        Log.d(TAG, "deregisterCharacteristicsWatcher id " + serviceId);
+        HashMap<Integer, IBluetoothGattService> watcherServices = mGattWatcherTracker.get(path);
+        if(watcherServices != null) {
+            if(watcherServices.size() == 1) {
+                Log.d(TAG, "Only watcher service..deregister");
+                ret = deregisterCharacteristicsWatcherNative(path);
+                mGattWatcherTracker.remove(path);
+            } else {
+                Log.d(TAG, "other watcher services exist for the obj path");
+                watcherServices.remove(new Integer(serviceId));
+                return true;
+            }
+        }
+
+        return ret;
+    }
+
+    public synchronized int startRemoteGattService(String path, IBluetoothGattService gattCallback) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return -1;
+
+        Log.d(TAG, "startRemoteGattService(");
+        int serviceId = -1;
+
+        Log.d(TAG, "add : " + gattCallback + "path" + path);
+        if(usedSrvIds != null) {
+            for(int i=1; i < 200; i++) {
+                if(!usedSrvIds.contains(new Integer(i))) {
+                    serviceId = i;
+                    break;
+                }
+            }
+        }
+        Log.d(TAG, "Service id for path "+path+" assigned is "+serviceId);
+        usedSrvIds.add(serviceId);
+
+        Log.d(TAG, "serviceId in startRemoteGattService"+serviceId);
+
+        String objPath = path + "#" + serviceId;
+        Log.d(TAG, "Add obj path to service tracker " + objPath + "size " + objPath.length());
+
+        if (mGattServiceTracker.get(objPath) != null) {
+            // Do not add this callback, its already there
+            Log.d(TAG, "startRemoteGattService: callback already registered " + path);
+            return -1;
+        }
+
+        mGattServiceTracker.put(objPath, gattCallback);
+
+        if (!mGattServices.containsKey(path))
+            mGattServices.put(path, 1);
+        else {
+            Integer refCount = mGattServices.get(path);
+            refCount++;
+            mGattServices.remove(path);
+            mGattServices.put(path, refCount);
+        }
+
+        return serviceId;
+    }
+
+    private void clearGattService(String path, boolean flush, int serviceId) {
+
+        Map<String, String> properties = mGattProperties.get(path);
+
+        if (properties != null) {
+            String chars = properties.get("Characteristics");
+
+            if (chars != null) {
+                String[] charPaths = chars.split(",");
+
+                for (int i = 0; i < charPaths.length; i++)
+                    mGattServiceTracker.remove(charPaths[i]);
+            }
+        }
+
+        if (flush)
+            removeGattServiceProperties(path);
+
+        if(serviceId < 0) {
+            Log.d(TAG, "Clear all gatt services callback for the obj path " + path);
+            Iterator<Map.Entry<String, IBluetoothGattService>> it = mGattServiceTracker.entrySet().iterator();
+            while(it.hasNext()) {
+                Map.Entry<String, IBluetoothGattService> entry = it.next();
+                String objPath = entry.getKey();
+                String[] splits = objPath.split("#");
+                Log.d(TAG, "Splits " + splits[0]);
+                if(path.equals(splits[0])) {
+                    Log.d(TAG, "Remove matched path in service tracker " + splits[0]);
+                    it.remove();
+                }
+            }
+        } else {
+            Log.d(TAG, "Clear the gatt service callback for path : " + path);
+            mGattServiceTracker.remove(path);
+        }
+
+        mGattWatcherTracker.remove(path);
+    }
+
+    private void forceCloseGattService(String path, int serviceId) {
+
+        Log.d(TAG, "Cleanup GATT service " + path);
+        clearGattService(path, false, serviceId);
+        mGattServices.remove(path);
+    }
+
+    public synchronized void closeRemoteGattService(String path, int serviceId) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+        if (!mGattServices.containsKey(path)) {
+            Log.d(TAG, "removeRemoteGattService: service not found " + path);
+            return;
+        }
+
+        Integer refCount = mGattServices.get(path);
+        refCount--;
+
+        Log.d(TAG, "removeRemoteGattService: refCount for " + path + " is " + refCount);
+        String objPath = path + "#" + serviceId;
+        //Remove the service id from used srv ids list
+        usedSrvIds.remove(new Integer(serviceId));
+        mGattServiceTracker.remove(objPath);
+        Log.d(TAG, "Removing service Id "+serviceId+ "from used service list");
+
+        if (refCount > 0) {
+            mGattServices.remove(path);
+            mGattServices.put(path, refCount);
+            return;
+        }
+
+        forceCloseGattService(path, serviceId);
+
+        if (!isEnabledInternal()) return;
+
+        //Check if we should request GATT disconnect
+        String devicePath = path.substring(0, path.indexOf("/service"));
+
+        if (devicePath == null)
+            return;
+
+        String address = getAddressFromObjectPath(devicePath);
+
+        if(address == null) {
+            Log.d(TAG, "adress is null????");
+            return;
+        }
+
+        SortedMap subMap = mGattServices.tailMap(devicePath);
+
+        if (!subMap.isEmpty()) {
+            String nextServicePath = (String) subMap.firstKey();
+            if (devicePath.equals(nextServicePath.substring(0, path.indexOf("/service")))) {
+                Log.d(TAG, "removeRemoteGattService: more GATT services are running on device " + nextServicePath);
+                // There are still other GATT services used on this remote device
+            }
+        }
+
+        Log.d(TAG, "removeRemoteGattService: disconnect" + address);
+
+        boolean res;
+        res = disconnectGattNative(path);
+        Log.d(TAG, "disconnectGatt " + res);
+    }
+
+    public synchronized void disconnectSap() {
+        Log.d(TAG, "disconnectSap");
+        int res = disConnectSapNative();
+        Log.d(TAG, "disconnectSap returns -" + res);
+        return;
+    }
+
+    public synchronized void disconnectDUN() {
+        Log.d(TAG, "disconnectDUN");
+        int res = disConnectDUNNative();
+        Log.d(TAG, "disconnectDUN returns -" + res);
+        return;
+    }
+
+
+    /*package*/ synchronized void  clearRemoteDeviceGattServices(String address) {
+        Log.d(TAG, "clearRemoteDeviceGattServices");
+
+        String value = mDeviceProperties.getProperty(address, "Services");
+        if (value == null) {
+            return;
+        }
+
+        String[] services = null;
+        services = value.split(",");
+
+        for(int i = 0; i < services.length; i++)
+            clearGattService(services[i], true, -1);
+
+        setRemoteDeviceProperty(address, "Services", null);
+    }
+
+    /*package*/ synchronized void  clearGattServicesRefCount(String address) {
+        Log.d(TAG, "clearGattServicesRefCount for dev " + address);
+
+        String value = mDeviceProperties.getProperty(address, "Services");
+        if (value == null) {
+            Log.e(TAG, "No GATT based services were found on " + address);
+            return;
+        }
+
+        String[] gattServicePaths = null;
+        // The  object paths are stored as a "," separated string.
+        gattServicePaths = value.split(",");
+
+        for (int i  = 0; i < gattServicePaths.length; i++) {
+            if(mGattServices.remove(gattServicePaths[i]) != null) {
+                Log.d(TAG, "Clearing ref count for " + gattServicePaths[i]);
+                mGattServices.put(gattServicePaths[i], 0);
+            }
+        }
+
+    }
+
+    /**** Local GATT Server handlers ****/
+    public synchronized boolean closeGattLeConnection(BluetoothGattAppConfiguration config,
+                                                      String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                                "Need BLUETOOTH permission");
+        String devPath;
+        devPath = getObjectPathFromAddress(address);
+
+        if (devPath == null)
+            return false;
+
+        synchronized (mBluetoothGattProfileHandler) {
+            return mBluetoothGattProfileHandler.closeGattLeConnection(config, devPath);
+        }
+    }
+
+    public boolean registerGattAppConfiguration(BluetoothGattAppConfiguration config,
+                                            IBluetoothGattCallback callback) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothGattProfileHandler) {
+                return mBluetoothGattProfileHandler.registerAppConfiguration(config, callback);
+        }
+    }
+
+    public boolean unregisterGattAppConfiguration(BluetoothGattAppConfiguration config) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothGattProfileHandler) {
+                return mBluetoothGattProfileHandler.unregisterAppConfiguration(config);
+        }
+    }
+
+    public boolean sendIndication(BluetoothGattAppConfiguration config,
+                                  int handle, byte[] value, boolean notify, int sessionHandle) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothGattProfileHandler) {
+            return mBluetoothGattProfileHandler.sendIndication(config, handle, value, notify, sessionHandle);
+        }
+    }
+
+    public boolean discoverPrimaryResponse(BluetoothGattAppConfiguration config,
+                                   ParcelUuid uuid, int handle, int end, int status, int reqHandle) {
+        Log.d(TAG, "discoverPrimaryResponse");
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+
+        int index = mEventLoop.getGattRequestData().indexOf(new Integer(reqHandle));
+        if(index < 0) {
+            Log.e(TAG, "Request handle was not found");
+            return false;
+        } else {
+            mEventLoop.getGattRequestData().remove(index);
+        }
+
+        synchronized (mBluetoothGattProfileHandler) {
+            String uuidStr = null;
+            if(uuid != null) {
+                uuidStr = uuid.toString();
+            }
+
+            return mBluetoothGattProfileHandler.discoverPrimaryResponse(config,
+                                                                      uuidStr,
+                                                                      handle,
+                                                                      end,
+                                                                      status,
+                                                                      reqHandle);
+            }
+    }
+
+    public boolean discoverPrimaryByUuidResponse(BluetoothGattAppConfiguration config,
+                                                 int handle, int end, int status, int reqHandle) {
+        Log.d(TAG, "discoverPrimaryByUuidResponse");
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+
+        int index = mEventLoop.getGattRequestData().indexOf(new Integer(reqHandle));
+        if(index < 0) {
+            Log.e(TAG, "Request handle was not found");
+            return false;
+        } else {
+            mEventLoop.getGattRequestData().remove(index);
+        }
+
+        synchronized (mBluetoothGattProfileHandler) {
+            return mBluetoothGattProfileHandler.discoverPrimaryByUuidResponse(config, handle,
+                                                                              end, status,
+                                                                              reqHandle);
+            }
+    }
+
+    public boolean findIncludedResponse(BluetoothGattAppConfiguration config, ParcelUuid uuid,
+                                        int handle, int start, int end, int status, int reqHandle) {
+        Log.d(TAG, "findIncludedResponse");
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+
+        int index = mEventLoop.getGattRequestData().indexOf(new Integer(reqHandle));
+        if(index < 0) {
+            Log.e(TAG, "Request handle was not found");
+            return false;
+        } else {
+            mEventLoop.getGattRequestData().remove(index);
+        }
+
+        synchronized (mBluetoothGattProfileHandler) {
+            String uuidStr = null;
+            if(uuid != null) {
+                uuidStr = uuid.toString();
+            }
+
+            return mBluetoothGattProfileHandler.findIncludedResponse(config, uuidStr,handle,
+                                                                     start, end,
+                                                                     status, reqHandle);
+            }
+    }
+
+    public boolean discoverCharacteristicResponse(BluetoothGattAppConfiguration config, ParcelUuid uuid,
+                                        int handle, byte property, int valueHandle, int status, int reqHandle) {
+        Log.d(TAG, "discoverCharacteristicResponse");
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+
+        int index = mEventLoop.getGattRequestData().indexOf(new Integer(reqHandle));
+        if(index < 0) {
+            Log.e(TAG, "Request handle was not found");
+            return false;
+        } else {
+            mEventLoop.getGattRequestData().remove(index);
+        }
+
+        synchronized (mBluetoothGattProfileHandler) {
+            String uuidStr = null;
+            if(uuid != null) {
+                uuidStr = uuid.toString();
+            }
+
+            return mBluetoothGattProfileHandler.discoverCharacteristicsResponse(config, uuidStr, handle,
+                                                                     property, valueHandle,
+                                                                     status, reqHandle);
+            }
+    }
+
+    public boolean findInfoResponse(BluetoothGattAppConfiguration config, ParcelUuid uuid,
+                                    int handle, int status, int reqHandle) {
+        Log.d(TAG, "findInfoResponse");
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+
+        int index = mEventLoop.getGattRequestData().indexOf(new Integer(reqHandle));
+        if(index < 0) {
+            Log.e(TAG, "Request handle was not found");
+            return false;
+        } else {
+            mEventLoop.getGattRequestData().remove(index);
+        }
+
+        synchronized (mBluetoothGattProfileHandler) {
+            String uuidStr = null;
+            if(uuid != null) {
+                uuidStr = uuid.toString();
+            }
+
+            return mBluetoothGattProfileHandler.findInfoResponse(config, uuidStr,
+                                                                 handle,
+                                                                 status, reqHandle);
+            }
+    }
+
+    public boolean readByTypeResponse(BluetoothGattAppConfiguration config, int handle, ParcelUuid uuid,
+                                        byte[] payload, int status, int reqHandle) {
+        Log.d(TAG, "readByTypeResponse");
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+
+        int index = mEventLoop.getGattRequestData().indexOf(new Integer(reqHandle));
+        if(index < 0) {
+            Log.e(TAG, "Request handle was not found");
+            return false;
+        } else {
+            mEventLoop.getGattRequestData().remove(index);
+        }
+
+        synchronized (mBluetoothGattProfileHandler) {
+            String uuidStr = null;
+            if(uuid != null) {
+                uuidStr = uuid.toString();
+            }
+
+            return mBluetoothGattProfileHandler.readByTypeResponse(config, uuidStr, handle,
+                                                                   payload, status, reqHandle);
+            }
+    }
+
+    public boolean readResponse(BluetoothGattAppConfiguration config, ParcelUuid uuid,
+                                byte[] payload, int status, int reqHandle) {
+        Log.d(TAG, "readResponse");
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+
+        int index = mEventLoop.getGattRequestData().indexOf(new Integer(reqHandle));
+        if(index < 0) {
+            Log.e(TAG, "Request handle was not found");
+            return false;
+        } else {
+            mEventLoop.getGattRequestData().remove(index);
+        }
+
+        synchronized (mBluetoothGattProfileHandler) {
+            String uuidStr = null;
+            if(uuid != null) {
+                uuidStr = uuid.toString();
+            }
+
+            return mBluetoothGattProfileHandler.readResponse(config, uuidStr,
+                                                             payload, status, reqHandle);
+            }
+    }
+
+    public boolean writeResponse(BluetoothGattAppConfiguration config, ParcelUuid uuid,
+                                 int status, int reqHandle) {
+        Log.d(TAG, "writeResponse");
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+
+        int index = mEventLoop.getGattRequestData().indexOf(new Integer(reqHandle));
+        if(index < 0) {
+            Log.e(TAG, "Request handle was not found");
+            return false;
+        } else {
+            mEventLoop.getGattRequestData().remove(index);
+        }
+
+        synchronized (mBluetoothGattProfileHandler) {
+            String uuidStr = null;
+            if(uuid != null) {
+                uuidStr = uuid.toString();
+            }
+
+            return mBluetoothGattProfileHandler.writeResponse(config, uuidStr, status, reqHandle);
+            }
+    }
+    public boolean addToPreferredDeviceListWrapper(BluetoothDevice btDevObj, IBluetoothPreferredDeviceListCallback pListCallBack,
+            String caller) {
+        boolean status = false;
+        Log.d(TAG, "addToPreferredDeviceListWrapper");
+        sPListCallBack = pListCallBack;
+        callerPreferredDevApi = caller;
+        btDeviceInPreferredDevList = btDevObj;
+        //Stop the scan if it is running
+        if(isScanInProgress == true) {
+            gattCancelConnectToPreferredDeviceList(sPListCallBack);
+        }
+        else {
+            status = addToPreferredDeviceList(btDevObj.getAddress(), sPListCallBack);
+        }
+        return status;
+    }
+    public boolean addToPreferredDeviceList(String address, IBluetoothPreferredDeviceListCallback pListCallBack) {
+        Log.d(TAG, "addToPreferredDeviceList");
+        sPListCallBack = pListCallBack;
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        String path = getObjectPathFromAddress(address);
+
+        synchronized (mBluetoothGattProfileHandler) {
+            return mBluetoothGattProfileHandler.addToPreferredDeviceList(path);
+        }
+    }
+
+    public boolean removeFromPreferredDeviceList(String address, IBluetoothPreferredDeviceListCallback pListCallBack) {
+        Log.d(TAG, "removeFromPreferredDeviceList");
+        sPListCallBack = pListCallBack;
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        String path = getObjectPathFromAddress(address);
+
+        synchronized (mBluetoothGattProfileHandler) {
+            return mBluetoothGattProfileHandler.removeFromPreferredDeviceList(path);
+        }
+    }
+
+    public boolean clearPreferredDeviceList(IBluetoothPreferredDeviceListCallback pListCallBack) {
+        Log.d(TAG, "clearPreferredDeviceList");
+        sPListCallBack = pListCallBack;
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothGattProfileHandler) {
+            return mBluetoothGattProfileHandler.clearPreferredDeviceList();
+        }
+    }
+    public boolean gattConnectToPreferredDeviceList(IBluetoothPreferredDeviceListCallback pListCallBack) {
+        Log.d(TAG, "gattConnectToPreferredDeviceList");
+        sPListCallBack = pListCallBack;
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+        synchronized (mBluetoothGattProfileHandler) {
+            return mBluetoothGattProfileHandler.gattConnectToPreferredDeviceList();
+        }
+    }
+    public boolean gattCancelConnectToPreferredDeviceList(IBluetoothPreferredDeviceListCallback pListCallBack) {
+        Log.d(TAG, "gattCancelConnectToPreferredDeviceList");
+        sPListCallBack = pListCallBack;
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+        synchronized (mBluetoothGattProfileHandler) {
+            return mBluetoothGattProfileHandler.gattCancelConnectToPreferredDeviceList();
+        }
+    }
+    public boolean gattCancelConnectToPreferredDeviceListWrapper(IBluetoothPreferredDeviceListCallback pListCallBack,
+            BluetoothDevice btDevice, String caller) {
+        Log.d(TAG, "gattCancelConnectToPreferredDeviceListWrapper");
+        sPListCallBack = pListCallBack;
+        btDeviceInPreferredDevList = btDevice;
+        callerPreferredDevApi = caller;
+        boolean isDevInPreferredDevList = false;
+        Log.d(TAG, "gattCancelConnectToPreferredDeviceListWrapper isScanInProgress ::"+isScanInProgress);
+        //If scan is in progress, stop the scan
+        if(isScanInProgress == true){
+            mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+            synchronized (mBluetoothGattProfileHandler) {
+                return mBluetoothGattProfileHandler.gattCancelConnectToPreferredDeviceList();
+            }
+        }
+        //else remove device from preferred devices list
+        else {
+            if(preferredDevicesList != null) {
+                for(Map.Entry<BluetoothDevice, Integer> entry : preferredDevicesList.entrySet()) {
+                    if(btDeviceInPreferredDevList.getAddress().equalsIgnoreCase(entry.getKey().getAddress())) {
+                        isDevInPreferredDevList = true;
+                        break;
+                    }
+                }
+            }
+            if(isDevInPreferredDevList == true) {
+                //call remove device from preferred devices list
+                removeFromPreferredDeviceList(btDeviceInPreferredDevList.getAddress(), sPListCallBack);
+            }
+        }
+        return true;
+    }
+    public void gattAclDisconnected(String caller, BluetoothDevice btDevice) {
+        Log.d(TAG, "gattAclDisconnected");
+        try {
+            callerIntent = caller;
+            btDeviceInPreferredDevList = btDevice;
+            String btAddress = btDevice.getAddress();
+            boolean isDevInPreferredDevList = false;
+            Log.d(TAG, "gattAclDisconnected  isScanInProgress ::"+isScanInProgress);
+            if(preferredDevicesList != null) {
+                for(Map.Entry<BluetoothDevice, Integer> entry : preferredDevicesList.entrySet()) {
+                    Log.d(TAG, "key ::"+entry.getKey().getAddress());
+                    Log.d(TAG, "value ::"+entry.getValue());
+                    if(btAddress.equalsIgnoreCase(entry.getKey().getAddress())) {
+                        isDevInPreferredDevList = true;
+                        break;
+                    }
+                }
+            }
+            //Stop the scan if the scan is in progress
+            if(isScanInProgress == true) {
+                gattCancelConnectToPreferredDeviceList(sPListCallBack);
+            }
+            //If the ACL_DISCONNECTED intent is received after a preferred devices list device disconnects,
+            //add device to preferred devices list again for auto connection
+            else if(isDevInPreferredDevList == true){
+                addToPreferredDeviceList(btDeviceInPreferredDevList.getAddress(), sPListCallBack);
+            }
+            else {
+                callerIntent = null;
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "gattAclDisconnected", e);
+        }
+    }
+    public void gattAclConnected(BluetoothDevice btDevice) {
+        Log.d(TAG, "gattAclConnected");
+        try {
+            btDeviceInPreferredDevList = btDevice;
+            callerIntent = "ACTION_ACL_CONNECTED";
+            isScanInProgress = false;
+            Log.d(TAG, "gattAclConnected isScanInProgress ::"+isScanInProgress);
+            //false means device connected is not in preferred devices list
+            boolean isDevInPreferredDevList = false;
+            Log.d(TAG, "ACL connected bluetooth device address::"+btDevice.getAddress());
+            if(preferredDevicesList != null) {
+                for(Map.Entry<BluetoothDevice, Integer> entry : preferredDevicesList.entrySet()) {
+                    if(btDevice.getAddress().equalsIgnoreCase(entry.getKey().getAddress())) {
+                        if(entry.getValue() == DEVICE_IN_PREFERRED_DEVICES_LIST) {
+                            isDevInPreferredDevList = true;
+                        }
+                        break;
+                    }
+                }
+            }
+            //check whether this device is in preferred devices list
+            if(isDevInPreferredDevList == true) {
+                //call remove_device_from_preferred_devices_list
+                removeFromPreferredDeviceList(btDeviceInPreferredDevList.getAddress(),
+                        sPListCallBack);
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "gattAclConnected", e);
+        }
+    }
+    private native static void classInitNative();
+    private native void initializeNativeDataNative();
+    private native boolean setupNativeDataNative();
+    private native boolean tearDownNativeDataNative();
+    private native void cleanupNativeDataNative();
+    /*package*/ native String getAdapterPathNative();
+
+    private native int isEnabledNative();
+    /*package*/ native int enableNative();
+    /*package*/ native int disableNative();
+
+    /*package*/ native Object[] getAdapterPropertiesNative();
+    private native Object[] getDevicePropertiesNative(String objectPath);
+    private native boolean setAdapterPropertyStringNative(String key, String value);
+    private native boolean setAdapterPropertyIntegerNative(String key, int value);
+    private native boolean setAdapterPropertyBooleanNative(String key, int value);
+
+    private native boolean startDiscoveryNative();
+    private native boolean stopDiscoveryNative();
+
+    private native boolean createPairedDeviceNative(String address, int timeout_ms);
+    private native boolean createPairedDeviceOutOfBandNative(String address, int timeout_ms);
+    private native byte[] readAdapterOutOfBandDataNative();
+
+    private native boolean cancelDeviceCreationNative(String address);
+    private native boolean removeDeviceNative(String objectPath);
+    private native int getDeviceServiceChannelNative(String objectPath, String uuid,
+            int attributeId);
+    private native String getDeviceStringAttrValue(String objectPath, String uuid,
+            int attributeId);
+
+    private native boolean cancelPairingUserInputNative(String address, int nativeData);
+    private native boolean setPinNative(String address, String pin, int nativeData);
+    private native boolean sapAuthorizeNative(String address, boolean access, int nativeData);
+    private native boolean DUNAuthorizeNative(String address, boolean access, int nativeData);
+    private native boolean setPasskeyNative(String address, int passkey, int nativeData);
+    private native boolean setPairingConfirmationNative(String address, boolean confirm,
+            int nativeData);
+    private native boolean setRemoteOutOfBandDataNative(String address, byte[] hash,
+                                                        byte[] randomizer, int nativeData);
+
+    private native boolean setDevicePropertyBooleanNative(String objectPath, String key,
+            int value);
+    private native boolean setDevicePropertyStringNative(String objectPath, String key,
+            String value);
+    private native boolean setDevicePropertyIntegerNative(String objectPath, String key,
+            int value);
+    private native boolean updateLEConnectionParametersNative(String objectPath,
+            int prohibitRemoteChg, int intervalMin, int intervalMax, int slaveLatency,
+            int supervisionTimeout);
+    private native boolean setLEConnectionParamNative(String objectPath, int prohibitRemoteChg,
+            int filterPolicy, int scanInterval, int scanWindow, int intervalMin, int intervalMax,
+            int latency, int superVisionTimeout, int minCeLen, int maxCeLen, int connTimeout);
+    private native boolean registerRssiUpdateWatcherNative(String objectPath,
+            int rssiThreshold, int interval, boolean updateOnThreshExceed);
+    private native boolean unregisterRssiUpdateWatcherNative(String objectPath);
+    private native boolean createDeviceNative(String address);
+    /*package*/ native boolean discoverServicesNative(String objectPath, String pattern);
+
+    private native int addRfcommServiceRecordNative(String name, long uuidMsb, long uuidLsb,
+            short channel);
+    private native boolean removeServiceRecordNative(int handle);
+    private native boolean setLinkTimeoutNative(String path, int num_slots);
+
+    native boolean connectInputDeviceNative(String path);
+    native boolean disconnectInputDeviceNative(String path);
+
+    native boolean setBluetoothTetheringNative(boolean value, String nap, String bridge);
+    native boolean connectPanDeviceNative(String path, String dstRole);
+    native boolean disconnectPanDeviceNative(String path);
+    native boolean disconnectPanServerDeviceNative(String path,
+            String address, String iface);
+
+    private native int[] addReservedServiceRecordsNative(int[] uuuids);
+    private native boolean removeReservedServiceRecordsNative(int[] handles);
+    private native String findDeviceNative(String address);
+
+    // Health API
+    native String registerHealthApplicationNative(int dataType, String role, String name,
+            String channelType);
+    native String registerHealthApplicationNative(int dataType, String role, String name);
+    native boolean unregisterHealthApplicationNative(String path);
+    native boolean createChannelNative(String devicePath, String appPath, String channelType,
+                                       int code);
+    native boolean destroyChannelNative(String devicePath, String channelpath, int code);
+    native String getMainChannelNative(String path);
+    native String getChannelApplicationNative(String channelPath);
+    native ParcelFileDescriptor getChannelFdNative(String channelPath);
+    native boolean releaseChannelFdNative(String channelPath);
+    native boolean setAuthorizationNative(String address, boolean value, int data);
+    native boolean discoverPrimaryServicesNative(String path);
+    private native String createLeDeviceNative(String address);
+    private native Object[] getGattServicePropertiesNative(String path);
+    private native boolean discoverCharacteristicsNative(String path, String data);
+    private native int gattConnectNative(String path, int prohibitRemoteChg, int filterPolicy,
+                                             int scanInterval, int scanWindow, int intervalMin,
+                                             int intervalMax, int latency, int superVisionTimeout,
+                                             int minCeLen, int maxCeLen, int connTimeOut);
+    private native boolean gattConnectCancelNative(String path);
+    private native int gattLeConnectNative(String path, int prohibitRemoteChg, int filterPolicy,
+                                             int scanInterval, int scanWindow, int intervalMin,
+                                             int intervalMax, int latency, int superVisionTimeout,
+                                             int minCeLen, int maxCeLen, int connTimeOut);
+    private native boolean gattLeConnectCancelNative(String path);
+    private native Object[] getCharacteristicPropertiesNative(String path);
+    private native boolean setCharacteristicPropertyNative(String path, String key, String serviceId,
+                                                           byte[] value, int length, boolean reliable);
+    private native boolean updateCharacteristicValueNative(String path, String serviceId);
+    private native boolean registerCharacteristicsWatcherNative(String path);
+    private native boolean deregisterCharacteristicsWatcherNative(String path);
+    private native boolean disconnectGattNative(String path);
+    private native int disConnectSapNative();
+    private native int listConnectionNative();
+    private native boolean disconnectAllConnectionsNative();
+
+    //GattServer API
+    native boolean gattLeDisconnectRequestNative(String devPath);
+    native Object[] getGattServersNative();
+    native boolean registerGattServerNative(String objPath, int handleCount, boolean isNew);
+    native boolean unregisterGattServerNative(String objPath, boolean complete);
+    native boolean notifyNative(String objPath, int sessionHandle, int handle, byte[] payload, int cnt);
+    native boolean indicateNative(String objPath, int sessionHandle, int handle, byte[] payload, int cnt);
+    native boolean discoverPrimaryResponseNative(String uuid, String status, int handle, int end, int nativeData);
+    native boolean discoverPrimaryByUuidResponseNative(String status, int handle, int end, int nativeData);
+    native boolean findIncludedResponseNative(String uuid, String status, int handle, int start, int end, int nativeData);
+    native boolean discoverCharacteristicsResponseNative(String uuid, String status, int handle, int property, int valueHandle, int nativeData);
+    native boolean findInfoResponseNative(String uuid, String status, int handle, int nativeData);
+    native boolean readByTypeResponseNative(String uuid, String status, int handle, byte[] payload, int cnt, int nativeData);
+    native boolean readResponseNative(String uuid, String status, byte[] payload, int cnt, int nativeData);
+    native boolean writeResponseNative(String uuid, String status, int nativeData);
+    private native int disConnectDUNNative();
+    //White list API
+    native boolean addToPreferredDeviceListNative(String path);
+    native boolean removeFromPreferredDeviceListNative(String path);
+    native boolean clearPreferredDeviceListNative();
+    native boolean gattConnectToPreferredDeviceListNative();
+    native boolean gattCancelConnectToPreferredDeviceListNative();
+}
diff --git a/bluetoothmsm/java/android/server/package.html b/bluetoothmsm/java/android/server/package.html
new file mode 100644
index 0000000..c9f96a6
--- /dev/null
+++ b/bluetoothmsm/java/android/server/package.html
@@ -0,0 +1,5 @@
+<body>
+
+{@hide}
+
+</body>
diff --git a/btobex/Android.mk b/btobex/Android.mk
new file mode 100644
index 0000000..fe97c80
--- /dev/null
+++ b/btobex/Android.mk
@@ -0,0 +1,11 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := $(call all-subdir-java-files)
+
+LOCAL_MODULE:= javax.btobex
+
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_JAVA_LIBRARY)
diff --git a/btobex/javax/btobex/ApplicationParameter.java b/btobex/javax/btobex/ApplicationParameter.java
new file mode 100644
index 0000000..4bf95af
--- /dev/null
+++ b/btobex/javax/btobex/ApplicationParameter.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+/**
+ * @hide
+ */
+public final class ApplicationParameter {
+
+    private byte[] mArray;
+
+    private int mLength;
+
+    private int mMaxLength = 1000;
+
+    public static class TRIPLET_TAGID {
+        public static final byte ORDER_TAGID = 0x01;
+
+        public static final byte SEARCH_VALUE_TAGID = 0x02;
+
+        public static final byte SEARCH_ATTRIBUTE_TAGID = 0x03;
+
+        // if equals to "0", PSE only reply number of contacts
+        public static final byte MAXLISTCOUNT_TAGID = 0x04;
+
+        public static final byte LISTSTARTOFFSET_TAGID = 0x05;
+
+        public static final byte FILTER_TAGID = 0x06;
+
+        public static final byte FORMAT_TAGID = 0x07;
+
+        // only used if max list count = 0
+        public static final byte PHONEBOOKSIZE_TAGID = 0x08;
+
+        // only used in "mch" in response
+        public static final byte NEWMISSEDCALLS_TAGID = 0x09;
+    }
+
+    public static class TRIPLET_VALUE {
+        public static class ORDER {
+            public static final byte ORDER_BY_INDEX = 0x00;
+
+            public static final byte ORDER_BY_ALPHANUMERIC = 0x01;
+
+            public static final byte ORDER_BY_PHONETIC = 0x02;
+        }
+
+        public static class SEARCHATTRIBUTE {
+            public static final byte SEARCH_BY_NAME = 0x00;
+
+            public static final byte SEARCH_BY_NUMBER = 0x01;
+
+            public static final byte SEARCH_BY_SOUND = 0x02;
+        }
+
+        public static class FORMAT {
+            public static final byte VCARD_VERSION_21 = 0x00;
+
+            public static final byte VCARD_VERSION_30 = 0x01;
+        }
+    }
+
+    public static class TRIPLET_LENGTH {
+        public static final byte ORDER_LENGTH = 1;
+
+        public static final byte SEARCH_ATTRIBUTE_LENGTH = 1;
+
+        public static final byte MAXLISTCOUNT_LENGTH = 2;
+
+        public static final byte LISTSTARTOFFSET_LENGTH = 2;
+
+        public static final byte FILTER_LENGTH = 8;
+
+        public static final byte FORMAT_LENGTH = 1;
+
+        public static final byte PHONEBOOKSIZE_LENGTH = 2;
+
+        public static final byte NEWMISSEDCALLS_LENGTH = 1;
+    }
+
+    public ApplicationParameter() {
+        mArray = new byte[mMaxLength];
+        mLength = 0;
+    }
+
+    public void addAPPHeader(byte tag, byte len, byte[] value) {
+        if ((mLength + len + 2) > mMaxLength) {
+            byte[] array_tmp = new byte[mLength + 4 * len];
+            System.arraycopy(mArray, 0, array_tmp, 0, mLength);
+            mArray = array_tmp;
+            mMaxLength = mLength + 4 * len;
+        }
+        mArray[mLength++] = tag;
+        mArray[mLength++] = len;
+        System.arraycopy(value, 0, mArray, mLength, len);
+        mLength += len;
+    }
+
+    public byte[] getAPPparam() {
+        byte[] para = new byte[mLength];
+        System.arraycopy(mArray, 0, para, 0, mLength);
+        return para;
+    }
+}
diff --git a/btobex/javax/btobex/Authenticator.java b/btobex/javax/btobex/Authenticator.java
new file mode 100644
index 0000000..6b54dbb
--- /dev/null
+++ b/btobex/javax/btobex/Authenticator.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+/**
+ * This interface provides a way to respond to authentication challenge and
+ * authentication response headers. When a client or server receives an
+ * authentication challenge or authentication response header, the
+ * <code>onAuthenticationChallenge()</code> or
+ * <code>onAuthenticationResponse()</code> will be called, respectively, by the
+ * implementation.
+ * <P>
+ * For more information on how the authentication procedure works in OBEX,
+ * please review the IrOBEX specification at <A
+ * HREF="http://www.irda.org">http://www.irda.org</A>.
+ * <P>
+ * <STRONG>Authentication Challenges</STRONG>
+ * <P>
+ * When a client or server receives an authentication challenge header, the
+ * <code>onAuthenticationChallenge()</code> method will be invoked by the OBEX
+ * API implementation. The application will then return the user name (if
+ * needed) and password via a <code>PasswordAuthentication</code> object. The
+ * password in this object is not sent in the authentication response. Instead,
+ * the 16-byte challenge received in the authentication challenge is combined
+ * with the password returned from the <code>onAuthenticationChallenge()</code>
+ * method and passed through the MD5 hash algorithm. The resulting value is sent
+ * in the authentication response along with the user name if it was provided.
+ * <P>
+ * <STRONG>Authentication Responses</STRONG>
+ * <P>
+ * When a client or server receives an authentication response header, the
+ * <code>onAuthenticationResponse()</code> method is invoked by the API
+ * implementation with the user name received in the authentication response
+ * header. (The user name will be <code>null</code> if no user name was provided
+ * in the authentication response header.) The application must determine the
+ * correct password. This value should be returned from the
+ * <code>onAuthenticationResponse()</code> method. If the authentication request
+ * should fail without the implementation checking the password,
+ * <code>null</code> should be returned by the application. (This is needed for
+ * reasons like not recognizing the user name, etc.) If the returned value is
+ * not <code>null</code>, the OBEX API implementation will combine the password
+ * returned from the <code>onAuthenticationResponse()</code> method and
+ * challenge sent via the authentication challenge, apply the MD5 hash
+ * algorithm, and compare the result to the response hash received in the
+ * authentication response header. If the values are not equal, an
+ * <code>IOException</code> will be thrown if the client requested
+ * authentication. If the server requested authentication, the
+ * <code>onAuthenticationFailure()</code> method will be called on the
+ * <code>ServerRequestHandler</code> that failed authentication. The connection
+ * is <B>not</B> closed if authentication failed.
+ * @hide
+ */
+public interface Authenticator {
+
+    /**
+     * Called when a client or a server receives an authentication challenge
+     * header. It should respond to the challenge with a
+     * <code>PasswordAuthentication</code> that contains the correct user name
+     * and password for the challenge.
+     * @param description the description of which user name and password should
+     *        be used; if no description is provided in the authentication
+     *        challenge or the description is encoded in an encoding scheme that
+     *        is not supported, an empty string will be provided
+     * @param isUserIdRequired <code>true</code> if the user ID is required;
+     *        <code>false</code> if the user ID is not required
+     * @param isFullAccess <code>true</code> if full access to the server will
+     *        be granted; <code>false</code> if read only access will be granted
+     * @return a <code>PasswordAuthentication</code> object containing the user
+     *         name and password used for authentication
+     */
+    PasswordAuthentication onAuthenticationChallenge(String description, boolean isUserIdRequired,
+            boolean isFullAccess);
+
+    /**
+     * Called when a client or server receives an authentication response
+     * header. This method will provide the user name and expect the correct
+     * password to be returned.
+     * @param userName the user name provided in the authentication response; may
+     *        be <code>null</code>
+     * @return the correct password for the user name provided; if
+     *         <code>null</code> is returned then the authentication request
+     *         failed
+     */
+    byte[] onAuthenticationResponse(byte[] userName);
+}
diff --git a/btobex/javax/btobex/BaseStream.java b/btobex/javax/btobex/BaseStream.java
new file mode 100644
index 0000000..35fff98
--- /dev/null
+++ b/btobex/javax/btobex/BaseStream.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import java.io.IOException;
+
+/**
+ * This interface defines the methods needed by a parent that uses the
+ * PrivateInputStream and PrivateOutputStream objects defined in this package.
+ * @hide
+ */
+public interface BaseStream {
+
+    /**
+     * Verifies that this object is still open.
+     * @throws IOException if the object is closed
+     */
+    void ensureOpen() throws IOException;
+
+    /**
+     * Verifies that additional information may be sent. In other words, the
+     * operation is not done.
+     * @throws IOException if the operation is completed
+     */
+    void ensureNotDone() throws IOException;
+
+    /**
+     * Continues the operation since there is no data to read.
+     * @param sendEmpty <code>true</code> if the operation should send an empty
+     *        packet or not send anything if there is no data to send
+     * @param inStream <code>true</code> if the stream is input stream or is
+     *        output stream
+     * @return <code>true</code> if the operation was completed;
+     *         <code>false</code> if no operation took place
+     * @throws IOException if an IO error occurs
+     */
+    boolean continueOperation(boolean sendEmpty, boolean inStream) throws IOException;
+
+    /**
+     * Called when the output or input stream is closed.
+     * @param inStream <code>true</code> if the input stream is closed;
+     *        <code>false</code> if the output stream is closed
+     * @throws IOException if an IO error occurs
+     */
+    void streamClosed(boolean inStream) throws IOException;
+}
diff --git a/btobex/javax/btobex/ClientOperation.java b/btobex/javax/btobex/ClientOperation.java
new file mode 100644
index 0000000..7cde776
--- /dev/null
+++ b/btobex/javax/btobex/ClientOperation.java
@@ -0,0 +1,831 @@
+/*
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import android.util.Log;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.ByteArrayOutputStream;
+
+/**
+ * This class implements the <code>Operation</code> interface. It will read and
+ * write data via puts and gets.
+ * @hide
+ */
+public final class ClientOperation implements Operation, BaseStream {
+    private static final String TAG = "Obex ClientOperation";
+
+    private static final boolean VERBOSE = false;
+
+    private ClientSession mParent;
+
+    private boolean mInputOpen;
+
+    private PrivateInputStream mPrivateInput;
+
+    private boolean mPrivateInputOpen;
+
+    private PrivateOutputStream mPrivateOutput;
+
+    private boolean mPrivateOutputOpen;
+
+    private String mExceptionMessage;
+
+    private int mMaxPacketSize;
+
+    private boolean mOperationDone;
+
+    private boolean mGetOperation;
+
+    private HeaderSet mRequestHeader;
+
+    private HeaderSet mReplyHeader;
+
+    private boolean mEndOfBodySent;
+
+    private boolean mSingleResponseActiveClient;
+
+    private boolean mSrmGetActiveClient;
+
+    private ObexHelper mSrmClientSession;
+    /**
+     * Creates new OperationImpl to read and write data to a server
+     * @param maxSize the maximum packet size
+     * @param p the parent to this object
+     * @param type <code>true</code> if this is a get request;
+     *        <code>false</code. if this is a put request
+     * @param header the header to set in the initial request
+     * @throws IOException if the an IO error occurred
+     */
+    public ClientOperation(int maxSize, ClientSession p, HeaderSet header, boolean type)
+            throws IOException {
+
+        mParent = p;
+        mEndOfBodySent = false;
+        mSingleResponseActiveClient = false;
+        mSrmGetActiveClient = false;
+        mInputOpen = true;
+        mOperationDone = false;
+        mMaxPacketSize = maxSize;
+        mGetOperation = type;
+
+        mPrivateInputOpen = false;
+        mPrivateOutputOpen = false;
+        mPrivateInput = null;
+        mPrivateOutput = null;
+
+        mReplyHeader = new HeaderSet();
+
+        mRequestHeader = new HeaderSet();
+
+        mSrmClientSession = p.mSrmClient;
+        int[] headerList = header.getHeaderList();
+
+        if (headerList != null) {
+
+            for (int i = 0; i < headerList.length; i++) {
+                if (VERBOSE) Log.v(TAG, "SetHeader "+headerList[i]);
+                mRequestHeader.setHeader(headerList[i], header.getHeader(headerList[i]));
+            }
+        }
+
+        if ((header).mAuthChall != null) {
+            mRequestHeader.mAuthChall = new byte[(header).mAuthChall.length];
+            System.arraycopy((header).mAuthChall, 0, mRequestHeader.mAuthChall, 0,
+                    (header).mAuthChall.length);
+        }
+
+        if ((header).mAuthResp != null) {
+            mRequestHeader.mAuthResp = new byte[(header).mAuthResp.length];
+            System.arraycopy((header).mAuthResp, 0, mRequestHeader.mAuthResp, 0,
+                    (header).mAuthResp.length);
+
+        }
+        if ((header).mConnectionID != null) {
+            mRequestHeader.mConnectionID = new byte[4];
+            System.arraycopy((header).mConnectionID, 0, mRequestHeader.mConnectionID, 0,
+                    4);
+
+        }
+    }
+
+    /**
+     * Sends an ABORT message to the server. By calling this method, the
+     * corresponding input and output streams will be closed along with this
+     * object.
+     * @throws IOException if the transaction has already ended or if an OBEX
+     *         server called this method
+     */
+    public synchronized void abort() throws IOException {
+        ensureOpen();
+        //no compatible with sun-ri
+        if ((mOperationDone) && (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE)) {
+            throw new IOException("Operation has already ended");
+        }
+
+        mExceptionMessage = "Operation aborted";
+        if ((!mOperationDone) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
+            mOperationDone = true;
+            /*
+             * Since we are not sending any headers or returning any headers then
+             * we just need to write and read the same bytes
+             */
+            mParent.sendRequest(ObexHelper.OBEX_OPCODE_ABORT, null, mReplyHeader, null, false,false);
+
+            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_OK) {
+                throw new IOException("Invalid response code from server");
+            }
+
+            mExceptionMessage = null;
+        }
+
+        close();
+    }
+
+    /**
+     * Retrieves the response code retrieved from the server. Response codes are
+     * defined in the <code>ResponseCodes</code> interface.
+     * @return the response code retrieved from the server
+     * @throws IOException if an error occurred in the transport layer during
+     *         the transaction; if this method is called on a
+     *         <code>HeaderSet</code> object created by calling
+     *         <code>createHeaderSet</code> in a <code>ClientSession</code>
+     *         object
+     */
+    public synchronized int getResponseCode() throws IOException {
+        //avoid dup validateConnection
+        if ((mReplyHeader.responseCode == -1)
+                || (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
+            validateConnection();
+        }
+
+        return mReplyHeader.responseCode;
+    }
+
+    /**
+     * This method will always return <code>null</code>
+     * @return <code>null</code>
+     */
+    public String getEncoding() {
+        return null;
+    }
+
+    /**
+     * Returns the type of content that the resource connected to is providing.
+     * E.g. if the connection is via HTTP, then the value of the content-type
+     * header field is returned.
+     * @return the content type of the resource that the URL references, or
+     *         <code>null</code> if not known
+     */
+    public String getType() {
+        try {
+            return (String)mReplyHeader.getHeader(HeaderSet.TYPE);
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the length of the content which is being provided. E.g. if the
+     * connection is via HTTP, then the value of the content-length header field
+     * is returned.
+     * @return the content length of the resource that this connection's URL
+     *         references, or -1 if the content length is not known
+     */
+    public long getLength() {
+        try {
+            Long temp = (Long)mReplyHeader.getHeader(HeaderSet.LENGTH);
+
+            if (temp == null) {
+                return -1;
+            } else {
+                return temp.longValue();
+            }
+        } catch (IOException e) {
+            return -1;
+        }
+    }
+
+    /**
+     * Open and return an input stream for a connection.
+     * @return an input stream
+     * @throws IOException if an I/O error occurs
+     */
+    public InputStream openInputStream() throws IOException {
+
+        ensureOpen();
+
+        if (mPrivateInputOpen)
+            throw new IOException("no more input streams available");
+        if (mGetOperation) {
+            // send the GET request here
+            validateConnection();
+        } else {
+            if (mPrivateInput == null) {
+                mPrivateInput = new PrivateInputStream(this);
+            }
+        }
+
+        mPrivateInputOpen = true;
+
+        return mPrivateInput;
+    }
+
+    /**
+     * Open and return a data input stream for a connection.
+     * @return an input stream
+     * @throws IOException if an I/O error occurs
+     */
+    public DataInputStream openDataInputStream() throws IOException {
+        return new DataInputStream(openInputStream());
+    }
+
+    /**
+     * Open and return an output stream for a connection.
+     * @return an output stream
+     * @throws IOException if an I/O error occurs
+     */
+    public OutputStream openOutputStream() throws IOException {
+
+        ensureOpen();
+        ensureNotDone();
+
+        if (mPrivateOutputOpen)
+            throw new IOException("no more output streams available");
+
+        if (mPrivateOutput == null) {
+            // there are 3 bytes operation headers and 3 bytes body headers //
+            mPrivateOutput = new PrivateOutputStream(this, getMaxPacketSize());
+        }
+
+        mPrivateOutputOpen = true;
+
+        return mPrivateOutput;
+    }
+
+    public int getMaxPacketSize() {
+        return mMaxPacketSize - 6 - getHeaderLength();
+    }
+
+    public int getHeaderLength() {
+        // OPP may need it
+        byte[] headerArray = ObexHelper.createHeader(mRequestHeader, false);
+        return headerArray.length;
+    }
+
+    /**
+     * Open and return a data output stream for a connection.
+     * @return an output stream
+     * @throws IOException if an I/O error occurs
+     */
+    public DataOutputStream openDataOutputStream() throws IOException {
+        return new DataOutputStream(openOutputStream());
+    }
+
+    /**
+     * Closes the connection and ends the transaction
+     * @throws IOException if the operation has already ended or is closed
+     */
+    public void close() throws IOException {
+        mInputOpen = false;
+        mPrivateInputOpen = false;
+        mPrivateOutputOpen = false;
+        mParent.setRequestInactive();
+    }
+
+    /**
+     * Returns the headers that have been received during the operation.
+     * Modifying the object returned has no effect on the headers that are sent
+     * or retrieved.
+     * @return the headers received during this <code>Operation</code>
+     * @throws IOException if this <code>Operation</code> has been closed
+     */
+    public HeaderSet getReceivedHeader() throws IOException {
+        ensureOpen();
+
+        return mReplyHeader;
+    }
+
+    /**
+     * Specifies the headers that should be sent in the next OBEX message that
+     * is sent.
+     * @param headers the headers to send in the next message
+     * @throws IOException if this <code>Operation</code> has been closed or the
+     *         transaction has ended and no further messages will be exchanged
+     * @throws IllegalArgumentException if <code>headers</code> was not created
+     *         by a call to <code>ServerRequestHandler.createHeaderSet()</code>
+     * @throws NullPointerException if <code>headers</code> is <code>null</code>
+     */
+    public void sendHeaders(HeaderSet headers) throws IOException {
+        ensureOpen();
+        if (mOperationDone) {
+            throw new IOException("Operation has already exchanged all data");
+        }
+
+        if (headers == null) {
+            throw new IOException("Headers may not be null");
+        }
+
+        int[] headerList = headers.getHeaderList();
+        if (headerList != null) {
+            for (int i = 0; i < headerList.length; i++) {
+                mRequestHeader.setHeader(headerList[i], headers.getHeader(headerList[i]));
+            }
+        }
+    }
+
+    /**
+     * Verifies that additional information may be sent. In other words, the
+     * operation is not done.
+     * @throws IOException if the operation is completed
+     */
+    public void ensureNotDone() throws IOException {
+        if (mOperationDone) {
+            throw new IOException("Operation has completed");
+        }
+    }
+
+    /**
+     * Verifies that the connection is open and no exceptions should be thrown.
+     * @throws IOException if an exception needs to be thrown
+     */
+    public void ensureOpen() throws IOException {
+        mParent.ensureOpen();
+
+        if (mExceptionMessage != null) {
+            throw new IOException(mExceptionMessage);
+        }
+        if (!mInputOpen) {
+            throw new IOException("Operation has already ended");
+        }
+    }
+
+    /**
+     * Verifies that the connection is open and the proper data has been read.
+     * @throws IOException if an IO error occurs
+     */
+    private void validateConnection() throws IOException {
+        ensureOpen();
+
+        // to sure only one privateInput object exist.
+        if (mPrivateInput == null) {
+            startProcessing();
+        }
+    }
+
+    /**
+     * Sends a request to the client of the specified type
+     * @param opCode the request code to send to the client
+     * @return <code>true</code> if there is more data to send;
+     *         <code>false</code> if there is no more data to send
+     * @throws IOException if an IO error occurs
+     */
+    private boolean sendRequest(int opCode) throws IOException {
+
+        if (VERBOSE) Log.v(TAG, "sendRequest mSingleResponseActiveClient "
+                                             + mSingleResponseActiveClient);
+
+        boolean returnValue = false;
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        int bodyLength = -1;
+        byte[] headerArray = ObexHelper.createHeader(mRequestHeader, true);
+        if (mPrivateOutput != null) {
+            bodyLength = mPrivateOutput.size();
+        }
+
+        /*
+         * Determine if there is space to add a body request.  At present
+         * this method checks to see if there is room for at least a 17
+         * byte body header.  This number needs to be at least 6 so that
+         * there is room for the header ID and length and the reply ID and
+         * length, but it is a waste of resources if we can't send much of
+         * the body.
+         */
+        if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketSize) {
+            int end = 0;
+            int start = 0;
+            // split & send the headerArray in multiple packets.
+
+            while (end != headerArray.length) {
+                //split the headerArray
+                end = ObexHelper.findHeaderEnd(headerArray, start, mMaxPacketSize
+                        - ObexHelper.BASE_PACKET_LENGTH);
+                // can not split
+                if (end == -1) {
+                    mOperationDone = true;
+                    abort();
+                    mExceptionMessage = "Header larger then can be sent in a packet";
+                    mInputOpen = false;
+
+                    if (mPrivateInput != null) {
+                        mPrivateInput.close();
+                    }
+
+                    if (mPrivateOutput != null) {
+                        mPrivateOutput.close();
+                    }
+                    throw new IOException("OBEX Packet exceeds max packet size");
+                }
+
+                byte[] sendHeader = new byte[end - start];
+                System.arraycopy(headerArray, start, sendHeader, 0, sendHeader.length);
+                if (!mParent.sendRequest(opCode, sendHeader, mReplyHeader,
+                        mPrivateInput, mSingleResponseActiveClient,mSrmGetActiveClient)) {
+                    return false;
+                }
+
+                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
+                    return false;
+                }
+
+                start = end;
+            }
+
+            if (bodyLength > 0) {
+                return true;
+            } else {
+                return false;
+            }
+        } else {
+            out.write(headerArray);
+        }
+
+        if (bodyLength > 0) {
+            /*
+             * Determine if we can send the whole body or just part of
+             * the body.  Remember that there is the 3 bytes for the
+             * response message and 3 bytes for the header ID and length
+             */
+            if (bodyLength > (mMaxPacketSize - headerArray.length - 6)) {
+                returnValue = true;
+
+                bodyLength = mMaxPacketSize - headerArray.length - 6;
+            }
+
+            byte[] body = mPrivateOutput.readBytes(bodyLength);
+
+            /*
+             * Since this is a put request if the final bit is set or
+             * the output stream is closed we need to send the 0x49
+             * (End of Body) otherwise, we need to send 0x48 (Body)
+             */
+            if ((mPrivateOutput.isClosed()) && (!returnValue) && (!mEndOfBodySent)
+                    && ((opCode & 0x80) != 0)) {
+                out.write(0x49);
+                mEndOfBodySent = true;
+            } else {
+                out.write(0x48);
+            }
+
+            bodyLength += 3;
+            out.write((byte)(bodyLength >> 8));
+            out.write((byte)bodyLength);
+
+            if (body != null) {
+                out.write(body);
+            }
+        }
+
+        if (mPrivateOutputOpen && bodyLength <= 0 && !mEndOfBodySent) {
+            // only 0x82 or 0x83 can send 0x49
+            if ((opCode & 0x80) == 0) {
+                out.write(0x48);
+            } else {
+                out.write(0x49);
+                mEndOfBodySent = true;
+
+            }
+
+            bodyLength = 3;
+            out.write((byte)(bodyLength >> 8));
+            out.write((byte)bodyLength);
+        }
+
+        if (VERBOSE) Log.v(TAG, "sendRequest with out.size " + out.size()
+                             +"mSingleResponseActiveClient "+mSingleResponseActiveClient);
+
+        if (out.size() == 0) {
+            if (!mParent.sendRequest(opCode, null, mReplyHeader, mPrivateInput,
+                    mSingleResponseActiveClient,mSrmGetActiveClient)) {
+                return false;
+            }
+            return returnValue;
+        }
+        if ((out.size() > 0)
+                && (!mParent.sendRequest(opCode, out.toByteArray(), mReplyHeader,
+                    mPrivateInput, mSingleResponseActiveClient,mSrmGetActiveClient))) {
+            return false;
+        }
+
+        // send all of the output data in 0x48,
+        // send 0x49 with empty body
+        if ((mPrivateOutput != null) && (mPrivateOutput.size() > 0))
+            returnValue = true;
+
+        return returnValue;
+    }
+
+    /**
+     * This method starts the processing thread results. It will send the
+     * initial request. If the response takes more then one packet, a thread
+     * will be started to handle additional requests
+     * @throws IOException if an IO error occurs
+     */
+    private synchronized void startProcessing() throws IOException {
+
+        if (VERBOSE)  Log.v(TAG, "startProcessing mSingleResponseActiveClient "
+                                                       +mSingleResponseActiveClient);
+
+        if (mPrivateInput == null) {
+            mPrivateInput = new PrivateInputStream(this);
+        }
+        boolean more = true;
+
+        if (mGetOperation) {
+            if (!mOperationDone) {
+                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
+                while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
+                    if (VERBOSE) Log.v(TAG,"startProcessing SendRequest(0x03)");
+                    more = sendRequest(0x03);
+                    if (VERBOSE) Log.v(TAG,"more "+more);
+                }
+
+                if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
+                    if (VERBOSE) Log.v(TAG,"startProcessing mParent.sendRequest(0x83)");
+                    mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput, false,false);
+                }
+                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
+                    mOperationDone = true;
+                }
+            }
+        } else {
+
+            if (!mOperationDone) {
+                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
+                while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
+                    more = sendRequest(0x02);
+
+                }
+            }
+
+            if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
+                mParent.sendRequest(0x82, null, mReplyHeader, mPrivateInput, false,false);
+            }
+
+            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
+                mOperationDone = true;
+            }
+        }
+    }
+
+    /**
+     * Continues the operation since there is no data to read.
+     * @param sendEmpty <code>true</code> if the operation should send an empty
+     *        packet or not send anything if there is no data to send
+     * @param inStream <code>true</code> if the stream is input stream or is
+     *        output stream
+     * @throws IOException if an IO error occurs
+     */
+    public synchronized boolean continueOperation(boolean sendEmpty, boolean inStream)
+            throws IOException {
+
+        if (VERBOSE)  Log.v(TAG, "continueOperation mSingleResponseActiveClient "
+                                                       + mSingleResponseActiveClient);
+
+        if (mGetOperation) {
+            if ((inStream) && (!mOperationDone)) {
+                // to deal with inputstream in get operation
+                if (VERBOSE)  Log.v(TAG, "continueOperation inStream&&!mOperationDone"
+                                            +" mReplyHeader.responseCode = "+mReplyHeader.responseCode);
+
+                Byte srm = (Byte)mReplyHeader.getHeader(HeaderSet.SINGLE_RESPONSE_MODE);
+                if ((srm == ObexHelper.OBEX_SRM_SUPPORTED)||(srm == ObexHelper.OBEX_SRM_ENABLED)) {
+                    mSrmClientSession.setRemoteSrmStatus(ObexHelper.SRM_CAPABLE);
+                    if (VERBOSE) Log.v(TAG, "Remote SRM status: Enabled by Server response");
+                }
+
+               // Turn on SRM only if supported by both Client and Server. Otherwise, don't turn on SRM.
+                if (mSrmClientSession.getRemoteSrmStatus()) {
+                    if (VERBOSE)  Log.v(TAG, "continueOperation: Remote SRM Enabled");
+                    mSrmGetActiveClient = mSrmClientSession.getLocalSrmStatus();
+                }
+
+                mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput, false, mSrmGetActiveClient);
+
+                /*
+                  * Determine if that was not the last packet in the operation
+                  */
+                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
+                    mOperationDone = true;
+                }
+
+                return true;
+
+            } else if ((!inStream) && (!mOperationDone)) {
+                // to deal with outputstream in get operation
+                if (VERBOSE)  Log.v(TAG, "continueOperation (!inStream) && (!mOperationDone) ");
+
+                if (mPrivateInput == null) {
+                    mPrivateInput = new PrivateInputStream(this);
+                }
+                sendRequest(0x03);
+                return true;
+
+            } else if (mOperationDone) {
+                if (VERBOSE)  Log.v(TAG, "continueOperation mOperationDone ");
+                return false;
+            }
+
+        } else {
+            if ((!inStream) && (!mOperationDone)) {
+                // to deal with outputstream in put operation
+                if (mReplyHeader.responseCode == -1) {
+                    mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
+                }
+
+                sendRequest(0x02);
+
+                if (VERBOSE)  Log.v(TAG, "continueOperation: Client setting SRM, sendEmpty clause");
+                Byte srm = (Byte)mReplyHeader.getHeader(HeaderSet.SINGLE_RESPONSE_MODE);
+                if ((srm == ObexHelper.OBEX_SRM_SUPPORTED)||(srm == ObexHelper.OBEX_SRM_ENABLED)) {
+                    mSrmClientSession.setRemoteSrmStatus(ObexHelper.SRM_CAPABLE);
+                    if (VERBOSE) Log.v(TAG, "Remote SRM status: Enabled by Server response");
+                }
+
+                // Turn on SRM only if supported by both Client and Server. Otherwise, don't turn on SRM.
+                if (mSrmClientSession.getRemoteSrmStatus()) {
+                    if (VERBOSE)  Log.v(TAG, "continueOperation: Remote SRM Enabled");
+                    mSingleResponseActiveClient = mSrmClientSession.getLocalSrmStatus();
+                }
+                if (VERBOSE)  Log.v(TAG, "continueOperation: Client SRM status: " + mSingleResponseActiveClient);
+
+                if (mSingleResponseActiveClient == ObexHelper.LOCAL_SRM_ENABLED) {
+                    if (VERBOSE)  Log.v(TAG, "continueOperation: Client SRM enabled");
+                    Byte srmp = (Byte)mReplyHeader.getHeader(HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER);
+                    if (VERBOSE)  Log.v(TAG, "SRMP header (CONTINUE): " + srmp);
+                    if (srmp == ObexHelper.OBEX_SRM_PARAM_WAIT) {
+                        if (VERBOSE)  Log.v(TAG, "continueOperation: Client SRMP WAIT requested by Server");
+                        mSrmClientSession.setLocalSrmpWait(true);
+                        mSingleResponseActiveClient = ObexHelper.LOCAL_SRM_DISABLED;
+                    } else {
+                        if (VERBOSE)  Log.v(TAG, "continueOperation: Client SRMP NONE");
+                        mSrmClientSession.setLocalSrmpWait(false);
+                    }
+                    mReplyHeader.setHeader(HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER, ObexHelper.OBEX_SRM_PARAM_NONE);
+                } else {
+                   if (VERBOSE) Log.v(TAG, "continueOperation: Client SRM disabled");
+                }
+                return true;
+            } else if ((inStream) && (!mOperationDone)) {
+                // How to deal with inputstream  in put operation ?
+                return false;
+
+            } else if (mOperationDone) {
+                return false;
+            }
+
+        }
+        return false;
+    }
+
+    /**
+     * Called when the output or input stream is closed.
+     * @param inStream <code>true</code> if the input stream is closed;
+     *        <code>false</code> if the output stream is closed
+     * @throws IOException if an IO error occurs
+     */
+    public void streamClosed(boolean inStream) throws IOException {
+        if (!mGetOperation) {
+            if ((!inStream) && (!mOperationDone)) {
+                // to deal with outputstream in put operation
+
+                boolean more = true;
+
+                if ((mPrivateOutput != null) && (mPrivateOutput.size() <= 0)) {
+                    byte[] headerArray = ObexHelper.createHeader(mRequestHeader, false);
+                    if (headerArray.length <= 0)
+                        more = false;
+                }
+                // If have not sent any data so send  all now
+                if (mReplyHeader.responseCode == -1) {
+                    mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
+                }
+
+                while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
+                    more = sendRequest(0x02);
+                }
+
+                if (VERBOSE)  Log.v(TAG, "streamClosed: Client SRM Disabled");
+
+                mSrmClientSession.resetSrmStatus();
+                mSingleResponseActiveClient = ObexHelper.LOCAL_SRM_DISABLED;
+
+                /*
+                 * According to the IrOBEX specification, after the final put, you
+                 * only have a single reply to send.  so we don't need the while
+                 * loop.
+                 */
+                while (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
+
+                    sendRequest(0x82);
+                }
+                mOperationDone = true;
+            } else if ((inStream) && (mOperationDone)) {
+                // how to deal with input stream in put stream ?
+                mOperationDone = true;
+            }
+        } else {
+            if ((inStream) && (!mOperationDone)) {
+
+                // to deal with inputstream in get operation
+                // Have not sent any data so send it all now
+
+                if (mReplyHeader.responseCode == -1) {
+                    mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
+                }
+                if (VERBOSE)  Log.v(TAG,"(inStream) && (!mOperationDone) StreamClosed");
+                while (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
+                    if (VERBOSE)  Log.v(TAG,"StreamClosed sendRequest(0x83)");
+                    if (!sendRequest(0x83)) {
+                        break;
+                    }
+                }
+                if (VERBOSE)  Log.v(TAG, "streamClosed: Client SRM Disabled");
+                /* Reset Srm status once the operation completes */
+                mSrmClientSession.resetSrmStatus();
+                mSrmGetActiveClient = ObexHelper.LOCAL_SRM_DISABLED;
+
+                while (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
+                    if (VERBOSE)  Log.v(TAG,"StreamClosed  mParent.sendRequest(0x83)");
+                    mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput, false,false);
+                }
+                mOperationDone = true;
+            } else if ((!inStream) && (!mOperationDone)) {
+                // to deal with outputstream in get operation
+                // part of the data may have been sent in continueOperation.
+
+                boolean more = true;
+
+                if ((mPrivateOutput != null) && (mPrivateOutput.size() <= 0)) {
+                    byte[] headerArray = ObexHelper.createHeader(mRequestHeader, false);
+                    if (headerArray.length <= 0)
+                        more = false;
+                }
+
+                if (mPrivateInput == null) {
+                    mPrivateInput = new PrivateInputStream(this);
+                }
+                if ((mPrivateOutput != null) && (mPrivateOutput.size() <= 0))
+                    more = false;
+
+                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
+                while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
+                    more = sendRequest(0x03);
+                }
+                sendRequest(0x83);
+                //                parent.sendRequest(0x83, null, replyHeaders, privateInput, false);
+                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
+                    mOperationDone = true;
+                }
+            }
+        }
+    }
+    public void noEndofBody() {
+
+    }
+}
diff --git a/btobex/javax/btobex/ClientSession.java b/btobex/javax/btobex/ClientSession.java
new file mode 100644
index 0000000..dad3c2b
--- /dev/null
+++ b/btobex/javax/btobex/ClientSession.java
@@ -0,0 +1,748 @@
+/*
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import android.util.Log;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import android.os.Handler;
+import android.os.Message;
+import android.os.Looper;
+import android.os.HandlerThread;
+
+/**
+ * This class in an implementation of the OBEX ClientSession.
+ * @hide
+ */
+public final class ClientSession extends ObexSession {
+    private static final String TAG = "Obex ClientSession";
+
+    private static final boolean VERBOSE = false;
+
+    private boolean mOpen;
+
+    // Determines if an OBEX layer connection has been established
+    private boolean mObexConnected;
+
+    private byte[] mConnectionId = null;
+
+    /*
+     * The max Packet size must be at least 256 according to the OBEX
+     * specification.
+     */
+    private int maxPacketSize = 256;
+
+    private static final int OBEX_RESPONSE_TIME_OUT = 1;
+
+    /* Response timeout for OBEX request sent */
+    private static final int OBEX_RESPONSE_TIME_OUT_VALUE = 30000;
+
+    private boolean mRequestActive;
+
+    private final InputStream mInput;
+
+    private final OutputStream mOutput;
+
+    private eventParser mEp;
+
+    private long mTotalSize = 0;
+
+    public ObexHelper mSrmClient;
+
+    private ClientSessionHandler mClientSessionHandler = null;
+
+    private HandlerThread mHandlerThread = null;
+
+    public ClientSession(final ObexTransport trans) throws IOException {
+        mInput = trans.openInputStream();
+        mOutput = trans.openOutputStream();
+        mOpen = true;
+        mRequestActive = false;
+        mEp = null;
+        mSrmClient = new ObexHelper();
+        mHandlerThread = new HandlerThread("OBEX Time Out Handler");
+        mHandlerThread.start();
+        mClientSessionHandler = new ClientSessionHandler(mHandlerThread.getLooper());
+    }
+
+    public void setMaxPacketSize(int size) {
+        if (VERBOSE) Log.v(TAG, "setMaxPacketSize" + size);
+        maxPacketSize = size;
+    }
+
+    public HeaderSet connect(final HeaderSet header) throws IOException {
+        ensureOpen();
+        if (mObexConnected) {
+            throw new IOException("Already connected to server");
+        }
+        setRequestActive();
+
+        int totalLength = 4;
+        byte[] head = null;
+
+        // Determine the header byte array
+        if (header != null) {
+            if (header.nonce != null) {
+                mChallengeDigest = new byte[16];
+                System.arraycopy(header.nonce, 0, mChallengeDigest, 0, 16);
+            }
+            head = ObexHelper.createHeader(header, false);
+            totalLength += head.length;
+        }
+        /*
+        * Write the OBEX CONNECT packet to the server.
+        * Byte 0: 0x80
+        * Byte 1&2: Connect Packet Length
+        * Byte 3: OBEX Version Number (Presently, 0x10)
+        * Byte 4: Flags (For TCP 0x00)
+        * Byte 5&6: Max OBEX Packet Length
+        * Byte 7 to n: headers
+        */
+        byte[] requestPacket = new byte[totalLength];
+        // We just need to start at  byte 3 since the sendRequest() method will
+        // handle the length and 0x80.
+        requestPacket[0] = (byte)0x10;
+        requestPacket[1] = (byte)0x00;
+        requestPacket[2] = (byte)(maxPacketSize >> 8);
+        requestPacket[3] = (byte)(maxPacketSize & 0xFF);
+        if (head != null) {
+            System.arraycopy(head, 0, requestPacket, 4, head.length);
+        }
+
+        // check with local max packet size
+        if ((requestPacket.length + 3) > maxPacketSize) {
+            throw new IOException("Packet size exceeds max packet size");
+        }
+
+        HeaderSet returnHeaderSet = new HeaderSet();
+        sendRequest(ObexHelper.OBEX_OPCODE_CONNECT, requestPacket, returnHeaderSet, null, false,false);
+
+        /*
+        * Read the response from the OBEX server.
+        * Byte 0: Response Code (If successful then OBEX_HTTP_OK)
+        * Byte 1&2: Packet Length
+        * Byte 3: OBEX Version Number
+        * Byte 4: Flags3
+        * Byte 5&6: Max OBEX packet Length
+        * Byte 7 to n: Optional HeaderSet
+        */
+        if (returnHeaderSet.responseCode == ResponseCodes.OBEX_HTTP_OK) {
+            if(returnHeaderSet.mConnectionID != null ){
+                System.arraycopy(returnHeaderSet.mConnectionID, 0, mConnectionId, 0, 4);
+            }
+            mObexConnected = true;
+
+            Byte srm = (Byte)returnHeaderSet.getHeader(HeaderSet.SINGLE_RESPONSE_MODE);
+            if (srm == ObexHelper.OBEX_SRM_SUPPORTED) {
+                mSrmClient.setRemoteSrmStatus(ObexHelper.SRM_CAPABLE);
+                if (VERBOSE) Log.v(TAG, "SRM status: Enabled by Server response");
+            } else {
+                mSrmClient.setRemoteSrmStatus(ObexHelper.SRM_INCAPABLE);
+                if (VERBOSE) Log.v(TAG, "SRM status: Disabled by Server response");
+            }
+        }
+        setRequestInactive();
+
+        return returnHeaderSet;
+    }
+
+    public Operation get(HeaderSet header) throws IOException {
+
+        if (!mObexConnected) {
+            throw new IOException("Not connected to the server");
+        }
+        setRequestActive();
+
+        ensureOpen();
+
+        HeaderSet head;
+        if (header == null) {
+            head = new HeaderSet();
+        } else {
+            head = header;
+            if (head.nonce != null) {
+                mChallengeDigest = new byte[16];
+                System.arraycopy(head.nonce, 0, mChallengeDigest, 0, 16);
+            }
+        }
+        // Add the connection ID if one exists
+        if (mConnectionId != null) {
+            head.mConnectionID = new byte[4];
+            System.arraycopy(mConnectionId, 0, head.mConnectionID, 0, 4);
+        }
+
+        return new ClientOperation(maxPacketSize, this, head, true);
+    }
+
+    /**
+     * 0xCB Connection Id an identifier used for OBEX connection multiplexing
+     */
+    public void setConnectionID(long id) {
+        if ((id < 0) || (id > 0xFFFFFFFFL)) {
+            throw new IllegalArgumentException("Connection ID is not in a valid range");
+        }
+        mConnectionId = ObexHelper.convertToByteArray(id);
+    }
+
+    public HeaderSet delete(HeaderSet header) throws IOException {
+
+        Operation op = put(header);
+        op.getResponseCode();
+        HeaderSet returnValue = op.getReceivedHeader();
+        op.close();
+
+        return returnValue;
+    }
+
+    public HeaderSet disconnect(HeaderSet header) throws IOException {
+        if (!mObexConnected) {
+            throw new IOException("Not connected to the server");
+        }
+        setRequestActive();
+
+        ensureOpen();
+        // Determine the header byte array
+        byte[] head = null;
+        if (header != null) {
+            if (header.nonce != null) {
+                mChallengeDigest = new byte[16];
+                System.arraycopy(header.nonce, 0, mChallengeDigest, 0, 16);
+            }
+            // Add the connection ID if one exists
+            if (mConnectionId != null) {
+                header.mConnectionID = new byte[4];
+                System.arraycopy(mConnectionId, 0, header.mConnectionID, 0, 4);
+            }
+            head = ObexHelper.createHeader(header, false);
+
+            if ((head.length + 3) > maxPacketSize) {
+                throw new IOException("Packet size exceeds max packet size");
+            }
+        } else {
+            // Add the connection ID if one exists
+            if (mConnectionId != null) {
+                head = new byte[5];
+                head[0] = (byte)HeaderSet.CONNECTION_ID;
+                System.arraycopy(mConnectionId, 0, head, 1, 4);
+            }
+        }
+
+        HeaderSet returnHeaderSet = new HeaderSet();
+        sendRequest(ObexHelper.OBEX_OPCODE_DISCONNECT, head, returnHeaderSet, null, false,false);
+
+        /*
+         * An OBEX DISCONNECT reply from the server:
+         * Byte 1: Response code
+         * Bytes 2 & 3: packet size
+         * Bytes 4 & up: headers
+         */
+
+        /* response code , and header are ignored
+         * */
+
+        synchronized (this) {
+            mObexConnected = false;
+            setRequestInactive();
+        }
+
+        /* OBEX disconnect from app.  Stop the handler thread */
+        if (mHandlerThread != null ) {
+          mHandlerThread.quit();
+          mHandlerThread = null;
+          mClientSessionHandler = null;
+        }
+        return returnHeaderSet;
+    }
+
+    public long getConnectionID() {
+
+        if (mConnectionId == null) {
+            return -1;
+        }
+        return ObexHelper.convertToLong(mConnectionId);
+    }
+
+    public Operation put(HeaderSet header) throws IOException {
+        if (!mObexConnected) {
+            throw new IOException("Not connected to the server");
+        }
+        setRequestActive();
+
+        ensureOpen();
+        HeaderSet head;
+        if (header == null) {
+            head = new HeaderSet();
+        } else {
+            head = header;
+            // when auth is initiated by client ,save the digest
+            if (head.nonce != null) {
+                mChallengeDigest = new byte[16];
+                System.arraycopy(head.nonce, 0, mChallengeDigest, 0, 16);
+            }
+        }
+
+        // Add the connection ID if one exists
+        if (mConnectionId != null) {
+
+            head.mConnectionID = new byte[4];
+            System.arraycopy(mConnectionId, 0, head.mConnectionID, 0, 4);
+        }
+
+        return new ClientOperation(maxPacketSize, this, head, false);
+    }
+
+    public void setAuthenticator(Authenticator auth) throws IOException {
+        if (auth == null) {
+            throw new IOException("Authenticator may not be null");
+        }
+        mAuthenticator = auth;
+    }
+
+    public HeaderSet setPath(HeaderSet header, boolean backup, boolean create) throws IOException {
+        if (!mObexConnected) {
+            throw new IOException("Not connected to the server");
+        }
+        setRequestActive();
+        ensureOpen();
+
+        int totalLength = 2;
+        byte[] head = null;
+        HeaderSet headset;
+        if (header == null) {
+            headset = new HeaderSet();
+        } else {
+            headset = header;
+            if (headset.nonce != null) {
+                mChallengeDigest = new byte[16];
+                System.arraycopy(headset.nonce, 0, mChallengeDigest, 0, 16);
+            }
+        }
+
+        // when auth is initiated by client ,save the digest
+        if (headset.nonce != null) {
+            mChallengeDigest = new byte[16];
+            System.arraycopy(headset.nonce, 0, mChallengeDigest, 0, 16);
+        }
+
+        // Add the connection ID if one exists
+        if (mConnectionId != null) {
+            headset.mConnectionID = new byte[4];
+            System.arraycopy(mConnectionId, 0, headset.mConnectionID, 0, 4);
+        }
+
+        head = ObexHelper.createHeader(headset, false);
+        totalLength += head.length;
+
+        if (totalLength > maxPacketSize) {
+            throw new IOException("Packet size exceeds max packet size");
+        }
+
+        int flags = 0;
+        /*
+         * The backup flag bit is bit 0 so if we add 1, this will set that bit
+         */
+        if (backup) {
+            flags++;
+        }
+        /*
+         * The create bit is bit 1 so if we or with 2 the bit will be set.
+         */
+        if (!create) {
+            flags |= 2;
+        }
+
+        /*
+         * An OBEX SETPATH packet to the server:
+         * Byte 1: 0x85
+         * Byte 2 & 3: packet size
+         * Byte 4: flags
+         * Byte 5: constants
+         * Byte 6 & up: headers
+         */
+        byte[] packet = new byte[totalLength];
+        packet[0] = (byte)flags;
+        packet[1] = (byte)0x00;
+        if (headset != null) {
+            System.arraycopy(head, 0, packet, 2, head.length);
+        }
+
+        HeaderSet returnHeaderSet = new HeaderSet();
+        sendRequest(ObexHelper.OBEX_OPCODE_SETPATH, packet, returnHeaderSet, null, false,false);
+
+        /*
+         * An OBEX SETPATH reply from the server:
+         * Byte 1: Response code
+         * Bytes 2 & 3: packet size
+         * Bytes 4 & up: headers
+         */
+
+        setRequestInactive();
+
+        return returnHeaderSet;
+    }
+
+    /**
+     * Verifies that the connection is open.
+     * @throws IOException if the connection is closed
+     */
+    public synchronized void ensureOpen() throws IOException {
+        if (!mOpen) {
+            throw new IOException("Connection closed");
+        }
+    }
+
+    /**
+     * Set request inactive. Allows Put and get operation objects to tell this
+     * object when they are done.
+     */
+    /*package*/synchronized void setRequestInactive() {
+        mRequestActive = false;
+    }
+
+    /**
+     * Set request to active.
+     * @throws IOException if already active
+     */
+    private synchronized void setRequestActive() throws IOException {
+        if (mRequestActive) {
+            throw new IOException("OBEX request is already being performed");
+        }
+        mRequestActive = true;
+    }
+
+    /**
+     * Sends a standard request to the client. If ignoreResponse is not set, it
+     * will then wait for the reply and update the header set object provided.
+     * If any authentication headers (i.e. authentication challenge or
+     * authentication response) are received, they will be processed.
+     *
+     * If ignoreResponse is set, this will not wait for a reply and the header
+     * set object will not be updated.  This is intended for use during Single
+     * Response Mode operation.
+     *
+     * @param opCode the type of request to send to the client
+     * @param head the headers to send to the client
+     * @param header the header object to update with the response
+     * @param privateInput the input stream used by the Operation object; null
+     *        if this is called on a CONNECT, SETPATH or DISCONNECT return
+     *        <code>true</code> if the operation completed successfully;
+     *        <code>false</code> if an authentication response failed to pass
+     * @param ignoreResponse true if a response shouldn't be received (e.g.,
+     *        when operating under Single Response Mode (SRM).  false otherwise.
+     * @throws IOException if an IO error occurs
+     */
+    public boolean sendRequest(int opCode, byte[] head, HeaderSet header,
+            PrivateInputStream privateInput,
+            boolean ignoreResponse,
+            boolean supressSend) throws IOException {
+
+        if (VERBOSE) Log.v(TAG, "sendRequest ignore: " + ignoreResponse
+                                   + ", SRMP WAIT: " + mSrmClient.getLocalSrmpWait()
+                                   + " supressSend : "+supressSend);
+
+        //check header length with local max size
+        if (head != null) {
+            if ((head.length + 3) > maxPacketSize) {
+                throw new IOException("header too large ");
+            }
+        }
+
+        int bytesReceived;
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        out.write((byte)opCode);
+        if (VERBOSE) Log.v(TAG, "sendRequest opCode = "+opCode);
+
+        // Determine if there are any headers to send
+        if (head == null) {
+            out.write(0x00);
+            out.write(0x03);
+        } else {
+            out.write((byte)((head.length + 3) >> 8));
+            out.write((byte)(head.length + 3));
+            out.write(head);
+            if (VERBOSE) Log.v(TAG, "sendRequest head.length = "+head.length);
+        }
+
+        if(!supressSend) {
+            // Write the request to the output stream and flush the stream
+            mOutput.write(out.toByteArray());
+            mOutput.flush();
+        }
+
+        if ( (!ignoreResponse) || (mSrmClient.getLocalSrmpWait()) ) {
+            startResponseTimer();
+            try {
+              header.responseCode = mInput.read();
+              if (VERBOSE) Log.v(TAG, "sendRequest responseCode "+header.responseCode);
+            } catch (IOException e) {
+                Log.v(TAG, "Response timed out. Clean up the handler: " + e);
+                if (mHandlerThread != null ) {
+                  mHandlerThread.quit();
+                  mHandlerThread = null;
+                  mClientSessionHandler = null;
+                }
+            }
+
+            if (mClientSessionHandler != null) stopResponseTimer();
+
+            int length = ((mInput.read() << 8) | (mInput.read()));
+            if (VERBOSE) Log.v(TAG, "sendRequest response length "+length);
+
+            if (length > maxPacketSize) {
+                throw new IOException("Packet received exceeds packet size limit");
+            }
+            if (length > ObexHelper.BASE_PACKET_LENGTH) {
+                byte[] data = null;
+                if (opCode == ObexHelper.OBEX_OPCODE_CONNECT) {
+                    @SuppressWarnings("unused")
+                    int version = mInput.read();
+                    @SuppressWarnings("unused")
+                    int flags = mInput.read();
+                    maxPacketSize = (mInput.read() << 8) + mInput.read();
+
+                    //check with local max size
+                    if (maxPacketSize > ObexHelper.MAX_CLIENT_PACKET_SIZE) {
+                        maxPacketSize = ObexHelper.MAX_CLIENT_PACKET_SIZE;
+                    }
+
+                    if (length > 7) {
+                        data = new byte[length - 7];
+
+                        bytesReceived = mInput.read(data);
+                        while (bytesReceived != (length - 7)) {
+                            bytesReceived += mInput.read(data, bytesReceived, data.length
+                                                   - bytesReceived);
+                        }
+                    } else {
+                        return true;
+                    }
+                } else {
+                    data = new byte[length - 3];
+                    bytesReceived = mInput.read(data);
+
+                    /*
+                                   * In case of BPP Operation, it needs to get parser earlier to get proper data
+                                   * to interpret to stop. Otherwise, there is no way to stop infinite wait response
+                                   * duirng read poll()
+                                   */
+                    if(mEp != null){
+                        if(mEp.Callback(new String(data))){
+                            if (VERBOSE) Log.v(TAG, "mEp.Callback - ABORT invoke !!");
+                            ByteArrayOutputStream abort = new ByteArrayOutputStream();
+                            abort.write(0xFF); /* ABORT*/
+                            abort.write(0x00);
+                            abort.write(0x03);
+                            mOutput.write(abort.toByteArray());
+                            mOutput.flush();
+
+                            header.responseCode = mInput.read();
+                            if (VERBOSE) Log.v(TAG, "ABORT responseCode - " + header.responseCode);
+                            int len = ((mInput.read() << 8) | (mInput.read()));
+                            if (VERBOSE) Log.v(TAG, "length - " + len);
+                            return true;
+                        }
+                    }
+                    while (bytesReceived != (length - 3)) {
+                        bytesReceived += mInput.read(data, bytesReceived, data.length
+                                                    - bytesReceived);
+                    }
+                    if (opCode == ObexHelper.OBEX_OPCODE_ABORT) {
+                        return true;
+                    }
+                }
+
+                byte[] body = ObexHelper.updateHeaderSet(header, data);
+                if ((privateInput != null) && (body != null)) {
+                    privateInput.writeBytes(body, 1);
+                    mTotalSize += (long)(body.length - 1);
+                    if((body[0] == HeaderSet.END_OF_BODY) &&
+                                            (header.getHeader(HeaderSet.LENGTH) == null)){
+                        header.setHeader(HeaderSet.LENGTH, mTotalSize);
+                        if (VERBOSE) Log.v(TAG, " header.mLength : "
+                                                + header.getHeader(HeaderSet.LENGTH));
+                        mTotalSize = 0;
+                    }
+                }
+
+                if (header.mConnectionID != null) {
+                    mConnectionId = new byte[4];
+                    System.arraycopy(header.mConnectionID, 0, mConnectionId, 0, 4);
+                }
+
+                if (header.mAuthResp != null) {
+                    if (!handleAuthResp(header.mAuthResp)) {
+                        setRequestInactive();
+                        throw new IOException("Authentication Failed");
+                    }
+                }
+
+                if ((header.responseCode == ResponseCodes.OBEX_HTTP_UNAUTHORIZED)
+                       && (header.mAuthChall != null)) {
+
+                    if (handleAuthChall(header)) {
+                        out.write((byte)HeaderSet.AUTH_RESPONSE);
+                        out.write((byte)((header.mAuthResp.length + 3) >> 8));
+                        out.write((byte)(header.mAuthResp.length + 3));
+                        out.write(header.mAuthResp);
+                        header.mAuthChall = null;
+                        header.mAuthResp = null;
+                        byte[] sendHeaders = new byte[out.size() - 3];
+                        System.arraycopy(out.toByteArray(), 3, sendHeaders, 0, sendHeaders.length);
+
+                        return sendRequest(opCode, sendHeaders, header, privateInput, false,false);
+                    }
+	        }
+            }
+        }
+
+        return true;
+    }
+
+    public HeaderSet action(HeaderSet header,int action) throws IOException {
+        if (!mObexConnected) {
+            throw new IOException("Not connected to the server");
+        }
+        setRequestActive();
+        ensureOpen();
+
+        int totalLength = 2;
+        byte[] head = null;
+        HeaderSet headset;
+        if (header == null) {
+            headset = new HeaderSet();
+        } else {
+            headset = header;
+            if (headset.nonce != null) {
+                mChallengeDigest = new byte[16];
+                System.arraycopy(headset.nonce, 0, mChallengeDigest, 0, 16);
+            }
+        }
+
+        // when auth is initiated by client ,save the digest
+        if (headset.nonce != null) {
+            mChallengeDigest = new byte[16];
+            System.arraycopy(headset.nonce, 0, mChallengeDigest, 0, 16);
+        }
+
+        // Add the connection ID if one exists
+        if (mConnectionId != null) {
+            headset.mConnectionID = new byte[4];
+            System.arraycopy(mConnectionId, 0, headset.mConnectionID, 0, 4);
+        }
+
+        head = ObexHelper.createHeader(headset, false);
+        totalLength += head.length;
+
+        if (totalLength > maxPacketSize) {
+            throw new IOException("Packet size exceeds max packet size");
+        }
+
+        /*
+         * An OBEX ACTION packet to the server:
+         * Byte 1: 0x86
+         * Byte 2 & 3: packet size
+         * Byte 4: 0x94
+         * Byte 5: action
+         * Byte 6 & up: headers
+         */
+        byte[] packet = new byte[totalLength];
+        packet[0] = (byte)0x94;
+        packet[1] = (byte)action;
+
+        if (headset != null) {
+            System.arraycopy(head, 0, packet, 2, head.length);
+        }
+
+        HeaderSet returnHeaderSet = new HeaderSet();
+        sendRequest(ObexHelper.OBEX_OPCODE_ACTION, packet, returnHeaderSet, null, false,false);
+
+        setRequestInactive();
+
+        return returnHeaderSet;
+    }
+
+    public void close() throws IOException {
+        mOpen = false;
+        mInput.close();
+        mOutput.close();
+    }
+
+    public void enableEventParser(eventParser ep){
+        mEp = ep;
+    }
+
+    public interface eventParser{
+        public boolean Callback(String data);
+    }
+
+    private final class ClientSessionHandler extends Handler {
+        public ClientSessionHandler (Looper looper) {
+          super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+           if (VERBOSE) Log.v(TAG, "Handler(): Response Time out. Close the socket");
+           switch (msg.what) {
+              case OBEX_RESPONSE_TIME_OUT:
+                try {
+                  close();
+                } catch (IOException e) {
+                    if (VERBOSE) Log.v(TAG, "Response time out: "  + e);
+                }
+                break;
+           }
+        }
+    }
+
+    private void startResponseTimer() {
+        if (VERBOSE) Log.v(TAG, "OBEX: Start response timer");
+        if (mClientSessionHandler != null) {
+           mClientSessionHandler.sendMessageDelayed(mClientSessionHandler
+              .obtainMessage(OBEX_RESPONSE_TIME_OUT), OBEX_RESPONSE_TIME_OUT_VALUE);
+        }
+        return;
+    }
+
+    private void stopResponseTimer() {
+        if (VERBOSE) Log.v(TAG, "OBEX: Stop response timer");
+        if (mClientSessionHandler != null) {
+          mClientSessionHandler.removeMessages(OBEX_RESPONSE_TIME_OUT);
+        }
+        return;
+    }
+}
diff --git a/btobex/javax/btobex/HeaderSet.java b/btobex/javax/btobex/HeaderSet.java
new file mode 100644
index 0000000..162e5da
--- /dev/null
+++ b/btobex/javax/btobex/HeaderSet.java
@@ -0,0 +1,741 @@
+/*
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Calendar;
+import java.security.SecureRandom;
+
+/**
+ * This class implements the javax.obex.HeaderSet interface for OBEX over
+ * RFCOMM.
+ * @hide
+ */
+public final class HeaderSet {
+
+    /**
+     * Represents the OBEX Count header. This allows the connection statement to
+     * tell the server how many objects it plans to send or retrieve.
+     * <P>
+     * The value of <code>COUNT</code> is 0xC0 (192).
+     */
+    public static final int COUNT = 0xC0;
+
+    /**
+     * Represents the OBEX Name header. This specifies the name of the object.
+     * <P>
+     * The value of <code>NAME</code> is 0x01 (1).
+     */
+    public static final int NAME = 0x01;
+
+    /**
+     * Represents the OBEX Type header. This allows a request to specify the
+     * type of the object (e.g. text, html, binary, etc.).
+     * <P>
+     * The value of <code>TYPE</code> is 0x42 (66).
+     */
+    public static final int TYPE = 0x42;
+
+    /**
+     * Represents the OBEX Length header. This is the length of the object in
+     * bytes.
+     * <P>
+     * The value of <code>LENGTH</code> is 0xC3 (195).
+     */
+    public static final int LENGTH = 0xC3;
+
+    /**
+     * Represents the OBEX Time header using the ISO 8601 standards. This is the
+     * preferred time header.
+     * <P>
+     * The value of <code>TIME_ISO_8601</code> is 0x44 (68).
+     */
+    public static final int TIME_ISO_8601 = 0x44;
+
+    /**
+     * Represents the OBEX Time header using the 4 byte representation. This is
+     * only included for backwards compatibility. It represents the number of
+     * seconds since January 1, 1970.
+     * <P>
+     * The value of <code>TIME_4_BYTE</code> is 0xC4 (196).
+     */
+    public static final int TIME_4_BYTE = 0xC4;
+
+    /**
+     * Represents the OBEX Description header. This is a text description of the
+     * object.
+     * <P>
+     * The value of <code>DESCRIPTION</code> is 0x05 (5).
+     */
+    public static final int DESCRIPTION = 0x05;
+
+    /**
+     * Represents the OBEX Target header. This is the name of the service an
+     * operation is targeted to.
+     * <P>
+     * The value of <code>TARGET</code> is 0x46 (70).
+     */
+    public static final int TARGET = 0x46;
+
+    /**
+     * Represents the OBEX HTTP header. This allows an HTTP 1.X header to be
+     * included in a request or reply.
+     * <P>
+     * The value of <code>HTTP</code> is 0x47 (71).
+     */
+    public static final int HTTP = 0x47;
+
+    /**
+     * Represents the OBEX BODY header.
+     * <P>
+     * The value of <code>BODY</code> is 0x48 (72).
+     */
+    public static final int BODY = 0x48;
+
+    /**
+     * Represents the OBEX End of BODY header.
+     * <P>
+     * The value of <code>BODY</code> is 0x49 (73).
+     */
+    public static final int END_OF_BODY = 0x49;
+
+    /**
+     * Represents the OBEX Who header. Identifies the OBEX application to
+     * determine if the two peers are talking to each other.
+     * <P>
+     * The value of <code>WHO</code> is 0x4A (74).
+     */
+    public static final int WHO = 0x4A;
+
+    /**
+     * Represents the OBEX Connection ID header. Identifies used for OBEX
+     * connection multiplexing.
+     * <P>
+     * The value of <code>CONNECTION_ID</code> is 0xCB (203).
+     */
+
+    public static final int CONNECTION_ID = 0xCB;
+
+    /**
+     * Represents the OBEX Application Parameter header. This header specifies
+     * additional application request and response information.
+     * <P>
+     * The value of <code>APPLICATION_PARAMETER</code> is 0x4C (76).
+     */
+    public static final int APPLICATION_PARAMETER = 0x4C;
+
+    /**
+     * Represents the OBEX authentication digest-challenge.
+     * <P>
+     * The value of <code>AUTH_CHALLENGE</code> is 0x4D (77).
+     */
+    public static final int AUTH_CHALLENGE = 0x4D;
+
+    /**
+     * Represents the OBEX authentication digest-response.
+     * <P>
+     * The value of <code>AUTH_RESPONSE</code> is 0x4E (78).
+     */
+    public static final int AUTH_RESPONSE = 0x4E;
+
+    /**
+     * Represents the OBEX Object Class header. This header specifies the OBEX
+     * object class of the object.
+     * <P>
+     * The value of <code>OBJECT_CLASS</code> is 0x4F (79).
+     */
+    public static final int OBJECT_CLASS = 0x4F;
+
+    /**
+     * Represents the OBEX Single Response Mode (SRM).
+     * <P>
+     * The value of <code>SINGLE_RESPONSE_MODE</code> is 0x97 (151).
+     */
+    public static final int SINGLE_RESPONSE_MODE = 0x97;
+
+    /**
+     * Represents the OBEX Single Response Mode (SRM) Parameter.
+     * <P>
+     * The value of <code>SINGLE_RESPONSE_MODE_PARAMETER</code> is 0x98 (152).
+     */
+    public static final int SINGLE_RESPONSE_MODE_PARAMETER = 0x98;
+
+     /**
+     * Represents the OBEX Action Id.
+     * <P>
+     * The value of <code>ACTION_ID</code> is 0x94 (148).
+     */
+    public static final int ACTION_ID = 0x94;
+
+     /**
+     * Represents the OBEX Destination name.
+     * <P>
+     * The value of <code>DEST_NAME</code> is 0x15 (21).
+     */
+    public static final int DEST_NAME = 0x15;
+
+     /**
+     * Represents the OBEX Permissions.
+     * <P>
+     * The value of <code>PERMISSION</code> is 0xD6 (214).
+     */
+    public static final int PERMISSION = 0xD6;
+
+    private Long mCount; // 4 byte unsigned integer
+
+    private Byte mActionId; // 4 byte unsigned integer
+
+    private String mName; // null terminated Unicode text string
+
+    private String mDestName; // null terminated Unicode text string
+
+    private String mType; // null terminated ASCII text string
+
+    private Long mLength; // 4 byte unsigend integer
+
+    private Long mPermission; // 4 byte unsigend integer
+
+    private Calendar mIsoTime; // String of the form YYYYMMDDTHHMMSSZ
+
+    private Calendar mByteTime; // 4 byte unsigned integer
+
+    private String mDescription; // null terminated Unicode text String
+
+    private byte[] mTarget; // byte sequence
+
+    private byte[] mHttpHeader; // byte sequence
+
+    private byte[] mWho; // length prefixed byte sequence
+
+    private byte[] mAppParam; // byte sequence of the form tag length value
+
+    private byte[] mObjectClass; // byte sequence
+
+    private String[] mUnicodeUserDefined; //null terminated unicode string
+
+    private byte[][] mSequenceUserDefined; // byte sequence user defined
+
+    private Byte[] mByteUserDefined; // 1 byte
+
+    private Long[] mIntegerUserDefined; // 4 byte unsigned integer
+
+    private final SecureRandom mRandom;
+
+    private Byte mSingleRespMode; // 1 byte value to setup the OBEX Single Response Mode (SRM)
+
+    private Byte mSingleRespModeParam; // 1 byte value for setting parameters used during the OBEX Single Response Mode (SRM)
+
+    /*package*/ byte[] nonce;
+
+    public byte[] mAuthChall; // The authentication challenge header
+
+    public byte[] mAuthResp; // The authentication response header
+
+    public byte[] mConnectionID; // THe connection ID
+
+    public int responseCode;
+
+    /**
+     * Creates new <code>HeaderSet</code> object.
+     * @param size the max packet size for this connection
+     */
+    public HeaderSet() {
+        mUnicodeUserDefined = new String[16];
+        mSequenceUserDefined = new byte[16][];
+        mByteUserDefined = new Byte[16];
+        mIntegerUserDefined = new Long[16];
+        responseCode = -1;
+        mRandom = new SecureRandom();
+    }
+
+    /**
+     * Sets the value of the header identifier to the value provided. The type
+     * of object must correspond to the Java type defined in the description of
+     * this interface. If <code>null</code> is passed as the
+     * <code>headerValue</code> then the header will be removed from the set of
+     * headers to include in the next request.
+     * @param headerID the identifier to include in the message
+     * @param headerValue the value of the header identifier
+     * @throws IllegalArgumentException if the header identifier provided is not
+     *         one defined in this interface or a user-defined header; if the
+     *         type of <code>headerValue</code> is not the correct Java type as
+     *         defined in the description of this interface\
+     */
+    public void setHeader(int headerID, Object headerValue) {
+        long temp = -1;
+
+        switch (headerID) {
+            case COUNT:
+                if (!(headerValue instanceof Long)) {
+                    if (headerValue == null) {
+                        mCount = null;
+                        break;
+                    }
+                    throw new IllegalArgumentException("Count must be a Long");
+                }
+                temp = ((Long)headerValue).longValue();
+                if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
+                    throw new IllegalArgumentException("Count must be between 0 and 0xFFFFFFFF");
+                }
+                mCount = (Long)headerValue;
+                break;
+            case ACTION_ID:
+                if ((headerValue != null) && (!(headerValue instanceof Byte))) {
+                    throw new IllegalArgumentException(
+                        "Action Id must be a Byte");
+                }
+                mActionId = (Byte)headerValue;
+
+                break;
+            case NAME:
+                if ((headerValue != null) && (!(headerValue instanceof String))) {
+                    throw new IllegalArgumentException("Name must be a String");
+                }
+                mName = (String)headerValue;
+                break;
+            case DEST_NAME:
+                if ((headerValue != null) && (!(headerValue instanceof String))) {
+                    throw new IllegalArgumentException("Name must be a String");
+                }
+                mDestName = (String)headerValue;
+
+                break;
+            case TYPE:
+                if ((headerValue != null) && (!(headerValue instanceof String))) {
+                    throw new IllegalArgumentException("Type must be a String");
+                }
+                mType = (String)headerValue;
+                break;
+            case PERMISSION:
+               if (!(headerValue instanceof Long)) {
+                    if (headerValue == null) {
+                        mPermission = null;
+                        break;
+                    }
+                    throw new IllegalArgumentException("Length must be a Long");
+                }
+                temp = ((Long)headerValue).longValue();
+                if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
+                    throw new IllegalArgumentException("Length must be between 0 and 0xFFFFFFFF");
+                }
+                mPermission = (Long)headerValue;
+                break;
+            case LENGTH:
+                if (!(headerValue instanceof Long)) {
+                    if (headerValue == null) {
+                        mLength = null;
+                        break;
+                    }
+                    throw new IllegalArgumentException("Length must be a Long");
+                }
+                temp = ((Long)headerValue).longValue();
+                if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
+                    throw new IllegalArgumentException("Length must be between 0 and 0xFFFFFFFF");
+                }
+                mLength = (Long)headerValue;
+                break;
+            case TIME_ISO_8601:
+                if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
+                    throw new IllegalArgumentException("Time ISO 8601 must be a Calendar");
+                }
+                mIsoTime = (Calendar)headerValue;
+                break;
+            case TIME_4_BYTE:
+                if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
+                    throw new IllegalArgumentException("Time 4 Byte must be a Calendar");
+                }
+                mByteTime = (Calendar)headerValue;
+                break;
+            case DESCRIPTION:
+                if ((headerValue != null) && (!(headerValue instanceof String))) {
+                    throw new IllegalArgumentException("Description must be a String");
+                }
+                mDescription = (String)headerValue;
+                break;
+            case TARGET:
+                if (headerValue == null) {
+                    mTarget = null;
+                } else {
+                    if (!(headerValue instanceof byte[])) {
+                        throw new IllegalArgumentException("Target must be a byte array");
+                    } else {
+                        mTarget = new byte[((byte[])headerValue).length];
+                        System.arraycopy(headerValue, 0, mTarget, 0, mTarget.length);
+                    }
+                }
+                break;
+            case HTTP:
+                if (headerValue == null) {
+                    mHttpHeader = null;
+                } else {
+                    if (!(headerValue instanceof byte[])) {
+                        throw new IllegalArgumentException("HTTP must be a byte array");
+                    } else {
+                        mHttpHeader = new byte[((byte[])headerValue).length];
+                        System.arraycopy(headerValue, 0, mHttpHeader, 0, mHttpHeader.length);
+                    }
+                }
+                break;
+            case WHO:
+                if (headerValue == null) {
+                    mWho = null;
+                } else {
+                    if (!(headerValue instanceof byte[])) {
+                        throw new IllegalArgumentException("WHO must be a byte array");
+                    } else {
+                        mWho = new byte[((byte[])headerValue).length];
+                        System.arraycopy(headerValue, 0, mWho, 0, mWho.length);
+                    }
+                }
+                break;
+            case OBJECT_CLASS:
+                if (headerValue == null) {
+                    mObjectClass = null;
+                } else {
+                    if (!(headerValue instanceof byte[])) {
+                        throw new IllegalArgumentException("Object Class must be a byte array");
+                    } else {
+                        mObjectClass = new byte[((byte[])headerValue).length];
+                        System.arraycopy(headerValue, 0, mObjectClass, 0, mObjectClass.length);
+                    }
+                }
+                break;
+            case APPLICATION_PARAMETER:
+                if (headerValue == null) {
+                    mAppParam = null;
+                } else {
+                    if (!(headerValue instanceof byte[])) {
+                        throw new IllegalArgumentException(
+                                "Application Parameter must be a byte array");
+                    } else {
+                        mAppParam = new byte[((byte[])headerValue).length];
+                        System.arraycopy(headerValue, 0, mAppParam, 0, mAppParam.length);
+                    }
+                }
+                break;
+            case SINGLE_RESPONSE_MODE:
+                if ((headerValue != null) && (!(headerValue instanceof Byte))) {
+                    throw new IllegalArgumentException(
+                        "Single Response Mode must be a Byte");
+                }
+                mSingleRespMode = (Byte)headerValue;
+                break;
+            case SINGLE_RESPONSE_MODE_PARAMETER:
+                if ((headerValue != null) && (!(headerValue instanceof Byte))) {
+                    throw new IllegalArgumentException(
+                        "Single Response Mode Parameter must be a Byte");
+                }
+                mSingleRespModeParam = (Byte)headerValue;
+                break;
+            default:
+                // Verify that it was not a Unicode String user Defined
+                if ((headerID >= 0x30) && (headerID <= 0x3F)) {
+                    if ((headerValue != null) && (!(headerValue instanceof String))) {
+                        throw new IllegalArgumentException(
+                                "Unicode String User Defined must be a String");
+                    }
+                    mUnicodeUserDefined[headerID - 0x30] = (String)headerValue;
+
+                    break;
+                }
+                // Verify that it was not a byte sequence user defined value
+                if ((headerID >= 0x70) && (headerID <= 0x7F)) {
+
+                    if (headerValue == null) {
+                        mSequenceUserDefined[headerID - 0x70] = null;
+                    } else {
+                        if (!(headerValue instanceof byte[])) {
+                            throw new IllegalArgumentException(
+                                    "Byte Sequence User Defined must be a byte array");
+                        } else {
+                            mSequenceUserDefined[headerID - 0x70] = new byte[((byte[])headerValue).length];
+                            System.arraycopy(headerValue, 0, mSequenceUserDefined[headerID - 0x70],
+                                    0, mSequenceUserDefined[headerID - 0x70].length);
+                        }
+                    }
+                    break;
+                }
+                // Verify that it was not a Byte user Defined
+                if ((headerID >= 0xB0) && (headerID <= 0xBF)) {
+                    if ((headerValue != null) && (!(headerValue instanceof Byte))) {
+                        throw new IllegalArgumentException("ByteUser Defined must be a Byte");
+                    }
+                    mByteUserDefined[headerID - 0xB0] = (Byte)headerValue;
+
+                    break;
+                }
+                // Verify that is was not the 4 byte unsigned integer user
+                // defined header
+                if ((headerID >= 0xF0) && (headerID <= 0xFF)) {
+                    if (!(headerValue instanceof Long)) {
+                        if (headerValue == null) {
+                            mIntegerUserDefined[headerID - 0xF0] = null;
+                            break;
+                        }
+                        throw new IllegalArgumentException("Integer User Defined must be a Long");
+                    }
+                    temp = ((Long)headerValue).longValue();
+                    if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
+                        throw new IllegalArgumentException(
+                                "Integer User Defined must be between 0 and 0xFFFFFFFF");
+                    }
+                    mIntegerUserDefined[headerID - 0xF0] = (Long)headerValue;
+                    break;
+                }
+                throw new IllegalArgumentException("Invalid Header Identifier");
+        }
+    }
+
+    /**
+     * Retrieves the value of the header identifier provided. The type of the
+     * Object returned is defined in the description of this interface.
+     * @param headerID the header identifier whose value is to be returned
+     * @return the value of the header provided or <code>null</code> if the
+     *         header identifier specified is not part of this
+     *         <code>HeaderSet</code> object
+     * @throws IllegalArgumentException if the <code>headerID</code> is not one
+     *         defined in this interface or any of the user-defined headers
+     * @throws IOException if an error occurred in the transport layer during
+     *         the operation or if the connection has been closed
+     */
+    public Object getHeader(int headerID) throws IOException {
+
+        switch (headerID) {
+            case COUNT:
+                return mCount;
+            case ACTION_ID:
+                return mActionId;
+            case NAME:
+                return mName;
+            case DEST_NAME:
+                return mDestName;
+            case TYPE:
+                return mType;
+            case LENGTH:
+                return mLength;
+            case PERMISSION:
+                return mPermission;
+            case TIME_ISO_8601:
+                return mIsoTime;
+            case TIME_4_BYTE:
+                return mByteTime;
+            case DESCRIPTION:
+                return mDescription;
+            case TARGET:
+                return mTarget;
+            case HTTP:
+                return mHttpHeader;
+            case WHO:
+                return mWho;
+            case OBJECT_CLASS:
+                return mObjectClass;
+            case APPLICATION_PARAMETER:
+                return mAppParam;
+            case SINGLE_RESPONSE_MODE:
+                return mSingleRespMode;
+            case SINGLE_RESPONSE_MODE_PARAMETER:
+                return mSingleRespModeParam;
+            default:
+                // Verify that it was not a Unicode String user Defined
+                if ((headerID >= 0x30) && (headerID <= 0x3F)) {
+                    return mUnicodeUserDefined[headerID - 0x30];
+                }
+                // Verify that it was not a byte sequence user defined header
+                if ((headerID >= 0x70) && (headerID <= 0x7F)) {
+                    return mSequenceUserDefined[headerID - 0x70];
+                }
+                // Verify that it was not a byte user defined header
+                if ((headerID >= 0xB0) && (headerID <= 0xBF)) {
+                    return mByteUserDefined[headerID - 0xB0];
+                }
+                // Verify that it was not a integer user defined header
+                if ((headerID >= 0xF0) && (headerID <= 0xFF)) {
+                    return mIntegerUserDefined[headerID - 0xF0];
+                }
+                throw new IllegalArgumentException("Invalid Header Identifier");
+        }
+    }
+
+    /**
+     * Retrieves the list of headers that may be retrieved via the
+     * <code>getHeader</code> method that will not return <code>null</code>. In
+     * other words, this method returns all the headers that are available in
+     * this object.
+     * @see #getHeader
+     * @return the array of headers that are set in this object or
+     *         <code>null</code> if no headers are available
+     * @throws IOException if an error occurred in the transport layer during
+     *         the operation or the connection has been closed
+     */
+    public int[] getHeaderList() throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+        if (mCount != null) {
+            out.write(COUNT);
+        }
+        if(mActionId != null) {
+             out.write(ACTION_ID);
+        }
+        if (mName != null) {
+            out.write(NAME);
+        }
+        if (mDestName != null) {
+            out.write(DEST_NAME);
+        }
+        if (mType != null) {
+            out.write(TYPE);
+        }
+        if (mLength != null) {
+            out.write(LENGTH);
+        }
+        if (mPermission != null) {
+            out.write(PERMISSION);
+        }
+        if (mIsoTime != null) {
+            out.write(TIME_ISO_8601);
+        }
+        if (mByteTime != null) {
+            out.write(TIME_4_BYTE);
+        }
+        if (mDescription != null) {
+            out.write(DESCRIPTION);
+        }
+        if (mTarget != null) {
+            out.write(TARGET);
+        }
+        if (mHttpHeader != null) {
+            out.write(HTTP);
+        }
+        if (mWho != null) {
+            out.write(WHO);
+        }
+        if (mAppParam != null) {
+            out.write(APPLICATION_PARAMETER);
+        }
+        if (mObjectClass != null) {
+            out.write(OBJECT_CLASS);
+        }
+        if (mSingleRespMode != null) {
+            out.write(SINGLE_RESPONSE_MODE);
+        }
+        if (mSingleRespModeParam != null) {
+            out.write(SINGLE_RESPONSE_MODE_PARAMETER);
+        }
+        for (int i = 0x30; i < 0x40; i++) {
+            if (mUnicodeUserDefined[i - 0x30] != null) {
+                out.write(i);
+            }
+        }
+
+        for (int i = 0x70; i < 0x80; i++) {
+            if (mSequenceUserDefined[i - 0x70] != null) {
+                out.write(i);
+            }
+        }
+
+        for (int i = 0xB0; i < 0xC0; i++) {
+            if (mByteUserDefined[i - 0xB0] != null) {
+                out.write(i);
+            }
+        }
+
+        for (int i = 0xF0; i < 0x100; i++) {
+            if (mIntegerUserDefined[i - 0xF0] != null) {
+                out.write(i);
+            }
+        }
+
+        byte[] headers = out.toByteArray();
+        out.close();
+
+        if ((headers == null) || (headers.length == 0)) {
+            return null;
+        }
+
+        int[] result = new int[headers.length];
+        for (int i = 0; i < headers.length; i++) {
+            // Convert the byte to a positive integer.  That is, an integer
+            // between 0 and 256.
+            result[i] = headers[i] & 0xFF;
+        }
+
+        return result;
+    }
+
+    /**
+     * Sets the authentication challenge header. The <code>realm</code> will be
+     * encoded based upon the default encoding scheme used by the implementation
+     * to encode strings. Therefore, the encoding scheme used to encode the
+     * <code>realm</code> is application dependent.
+     * @param realm a short description that describes what password to use; if
+     *        <code>null</code> no realm will be sent in the authentication
+     *        challenge header
+     * @param userID if <code>true</code>, a user ID is required in the reply;
+     *        if <code>false</code>, no user ID is required
+     * @param access if <code>true</code> then full access will be granted if
+     *        successful; if <code>false</code> then read-only access will be
+     *        granted if successful
+     * @throws IOException
+     */
+    public void createAuthenticationChallenge(String realm, boolean userID, boolean access)
+            throws IOException {
+
+        nonce = new byte[16];
+        for (int i = 0; i < 16; i++) {
+            nonce[i] = (byte)mRandom.nextInt();
+        }
+
+        mAuthChall = ObexHelper.computeAuthenticationChallenge(nonce, realm, access, userID);
+    }
+
+    /**
+     * Returns the response code received from the server. Response codes are
+     * defined in the <code>ResponseCodes</code> class.
+     * @see ResponseCodes
+     * @return the response code retrieved from the server
+     * @throws IOException if an error occurred in the transport layer during
+     *         the transaction; if this method is called on a
+     *         <code>HeaderSet</code> object created by calling
+     *         <code>createHeaderSet()</code> in a <code>ClientSession</code>
+     *         object; if this object was created by an OBEX server
+     */
+    public int getResponseCode() throws IOException {
+        if (responseCode == -1) {
+            throw new IOException("May not be called on a server");
+        } else {
+            return responseCode;
+        }
+    }
+}
diff --git a/btobex/javax/btobex/ObexHelper.java b/btobex/javax/btobex/ObexHelper.java
new file mode 100644
index 0000000..3855ce5
--- /dev/null
+++ b/btobex/javax/btobex/ObexHelper.java
@@ -0,0 +1,1223 @@
+/*
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import android.os.SystemProperties;
+import android.util.Log;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.TimeZone;
+
+/**
+ * This class defines a set of helper methods for the implementation of Obex.
+ * @hide
+ */
+public final class ObexHelper {
+    private static final String TAG = "ObexHelper";
+    private static final boolean VERBOSE = false;
+
+    /* Debugging hooks to control AMP-related operations */
+    private static final String DEBUG_FORCE_SRM = "debug.obex.force_srm_capable";
+    private static final String DEBUG_FORCE_SRMP = "debug.obex.force_srmp_enabled";
+
+    /**
+     * Defines the basic packet length used by OBEX. Every OBEX packet has the
+     * same basic format:<BR>
+     * Byte 0: Request or Response Code Byte 1&2: Length of the packet.
+     */
+    public static final int BASE_PACKET_LENGTH = 3;
+
+    /** Object construction of helper class */
+    public ObexHelper() {
+    }
+
+    /**
+     * The maximum packet size for OBEX packets that this client can handle. At
+     * present, this must be changed for each port. TODO: The max packet size
+     * should be the Max incoming MTU minus TODO: L2CAP package headers and
+     * RFCOMM package headers. TODO: Retrieve the max incoming MTU from TODO:
+     * LocalDevice.getProperty().
+     */
+    /*
+     * android note set as 0xFFFE to match remote MPS
+     */
+    public static final int MAX_PACKET_SIZE_INT = 0xFFFE;
+
+    /**
+     * Temporary workaround to be able to push files to Windows 7.
+     * TODO: Should be removed as soon as Microsoft updates their driver.
+     */
+    public static final int MAX_CLIENT_PACKET_SIZE = 0xFC00;
+
+    public static final int OBEX_OPCODE_CONNECT = 0x80;
+
+    public static final int OBEX_OPCODE_DISCONNECT = 0x81;
+
+    public static final int OBEX_OPCODE_PUT = 0x02;
+
+    public static final int OBEX_OPCODE_PUT_FINAL = 0x82;
+
+    public static final int OBEX_OPCODE_GET = 0x03;
+
+    public static final int OBEX_OPCODE_GET_FINAL = 0x83;
+
+    public static final int OBEX_OPCODE_RESERVED = 0x04;
+
+    public static final int OBEX_OPCODE_RESERVED_FINAL = 0x84;
+
+    public static final int OBEX_OPCODE_SETPATH = 0x85;
+
+    public static final int OBEX_OPCODE_ACTION = 0x86;
+
+    public static final int OBEX_OPCODE_ABORT = 0xFF;
+
+    public static final int OBEX_AUTH_REALM_CHARSET_ASCII = 0x00;
+
+    public static final int OBEX_AUTH_REALM_CHARSET_ISO_8859_1 = 0x01;
+
+    public static final int OBEX_AUTH_REALM_CHARSET_ISO_8859_2 = 0x02;
+
+    public static final int OBEX_AUTH_REALM_CHARSET_ISO_8859_3 = 0x03;
+
+    public static final int OBEX_AUTH_REALM_CHARSET_ISO_8859_4 = 0x04;
+
+    public static final int OBEX_AUTH_REALM_CHARSET_ISO_8859_5 = 0x05;
+
+    public static final int OBEX_AUTH_REALM_CHARSET_ISO_8859_6 = 0x06;
+
+    public static final int OBEX_AUTH_REALM_CHARSET_ISO_8859_7 = 0x07;
+
+    public static final int OBEX_AUTH_REALM_CHARSET_ISO_8859_8 = 0x08;
+
+    public static final int OBEX_AUTH_REALM_CHARSET_ISO_8859_9 = 0x09;
+
+    public static final int OBEX_AUTH_REALM_CHARSET_UNICODE = 0xFF;
+
+    /**
+     * The values used for various ACTION commands
+     */
+    public static final Byte OBEX_ACTION_COPY = 0x0;
+
+    public static final Byte OBEX_ACTION_MOVE_RENAME = 0x1;
+
+    public static final Byte OBEX_ACTION_SET_PERM = 0x2;
+
+    /**
+     * The value that is used for the OBEX Single Response Mode (SRM)
+     */
+    public static final Byte OBEX_SRM_DISABLED = 0x0;
+
+    public static final Byte OBEX_SRM_ENABLED = 0x1;
+
+    public static final Byte OBEX_SRM_SUPPORTED = 0x2;
+
+    /**
+     * The value that is used for the OBEX Single Response Mode (SRM) Parameters
+     */
+    public static final Byte OBEX_SRM_PARAM_RSVP = 0x0;
+
+    public static final Byte OBEX_SRM_PARAM_WAIT = 0x1;
+
+    public static final Byte OBEX_SRM_PARAM_RSVP_AND_WAIT = 0x2;
+
+    /** An invalid SRM parameter value to indicate no parameter set */
+    public static final Byte OBEX_SRM_PARAM_NONE = 0xF;
+
+    /**
+     * The value that is used for the SRM capability of Bluetooth device
+     */
+    public static final boolean SRM_INCAPABLE = false;
+
+    public static final boolean SRM_CAPABLE = true;
+
+    private boolean mLocalSingleResponseCapability = SRM_INCAPABLE;
+
+    public boolean getLocalSrmCapability() {
+        if (VERBOSE) Log.v(TAG, "getLocalSrmCapability: " + mLocalSingleResponseCapability);
+        return mLocalSingleResponseCapability;
+    }
+
+    public void setLocalSrmCapability(boolean SrmCapable) {
+        if (!SystemProperties.get(DEBUG_FORCE_SRM).equals("")) {
+            if (SystemProperties.getBoolean(DEBUG_FORCE_SRM, false)) {
+                if (VERBOSE) Log.v(TAG, "DEBUG: Forcing SRM on");
+                mLocalSingleResponseCapability = SRM_CAPABLE;
+            } else {
+                if (VERBOSE) Log.v(TAG, "DEBUG: Forcing SRM off");
+                mLocalSingleResponseCapability = SRM_INCAPABLE;
+            }
+        } else {
+            mLocalSingleResponseCapability = SrmCapable ? SRM_CAPABLE : SRM_INCAPABLE;
+        }
+
+        Log.d(TAG, "setLocalSrmCapability: " + mLocalSingleResponseCapability);
+    }
+
+    /**
+     * The value that is used for the SRM status of current operation
+     */
+    public static final boolean LOCAL_SRM_DISABLED = false;
+
+    public static final boolean LOCAL_SRM_ENABLED = true;
+
+    /**
+     * This is used for the SRM status of local device
+     */
+    private boolean mLocalSingleResponseActive;
+
+    public boolean getLocalSrmStatus() {
+        if (VERBOSE) Log.v(TAG, "getLocalSrmStatus: " + mLocalSingleResponseActive);
+        return mLocalSingleResponseActive;
+    }
+
+    public void setLocalSrmStatus(boolean SrmEnabled) {
+        mLocalSingleResponseActive = SrmEnabled ? LOCAL_SRM_ENABLED : LOCAL_SRM_DISABLED;
+        if (VERBOSE) Log.v(TAG, "setLocalSrmStatus: " + mLocalSingleResponseActive);
+    }
+
+    /**
+     * This is used for the SRM status of remote device
+     */
+    private boolean mRemoteSingleResponseActive;
+
+    public boolean getRemoteSrmStatus() {
+        if (VERBOSE) Log.v(TAG, "getRemoteSrmStatus: " + mRemoteSingleResponseActive);
+        return mRemoteSingleResponseActive;
+    }
+
+    public void setRemoteSrmStatus(boolean SrmCapable) {
+        mRemoteSingleResponseActive = SrmCapable ? SRM_CAPABLE : SRM_INCAPABLE;
+        if (VERBOSE) Log.v(TAG, "setRemoteSrmStatus: " + mRemoteSingleResponseActive);
+    }
+
+    /**
+     * This is used for the Single Response Mode Parameters (SRMP) value
+     */
+    private boolean mLocalSrmpWait;
+
+    public boolean getLocalSrmpWait() {
+        if (VERBOSE) Log.v(TAG, "getLocalSrmpWait: " + mLocalSrmpWait);
+        return mLocalSrmpWait;
+    }
+
+    public void setLocalSrmpWait(boolean SrmpWait) {
+        if (VERBOSE) Log.v(TAG, "setLocalSrmpWait: " + SrmpWait);
+        mLocalSrmpWait = SrmpWait;
+    }
+
+    /**
+     * The value that is used for the SRMP status of local device
+     */
+    public static final boolean SRMP_DISABLED = false;
+
+    public static final boolean SRMP_ENABLED = true;
+
+    private boolean mLocalSrmpActive = SRMP_DISABLED;
+
+    public boolean getLocalSrmParamStatus() {
+        if (!SystemProperties.get(DEBUG_FORCE_SRMP).equals("")) {
+            if (SystemProperties.getBoolean(DEBUG_FORCE_SRMP, false)) {
+                if (VERBOSE) Log.v(TAG, "DEBUG: Forcing SRMP on");
+                mLocalSrmpActive = SRMP_ENABLED;
+            } else {
+                if (VERBOSE) Log.v(TAG, "DEBUG: Forcing SRMP off");
+                mLocalSrmpActive = SRMP_DISABLED;
+            }
+        }
+        if (VERBOSE) Log.v(TAG, "getLocalSrmParamStatus: " + mLocalSrmpActive);
+        return mLocalSrmpActive;
+    }
+
+    public void setLocalSrmParamStatus(boolean SrmpEnabled) {
+        if (!SystemProperties.get(DEBUG_FORCE_SRMP).equals("")) {
+            if (SystemProperties.getBoolean(DEBUG_FORCE_SRMP, false)) {
+                if (VERBOSE) Log.v(TAG, "DEBUG: Forcing SRMP on");
+                mLocalSrmpActive = SRMP_ENABLED;
+            } else {
+                if (VERBOSE) Log.v(TAG, "DEBUG: Forcing SRMP off");
+                mLocalSrmpActive = SRMP_DISABLED;
+            }
+        } else {
+            mLocalSrmpActive = SrmpEnabled ? SRMP_ENABLED : SRMP_DISABLED;
+        }
+        if (VERBOSE) Log.v(TAG, "setLocalSrmParamStatus: " + mLocalSrmpActive);
+    }
+
+    /**
+     * This is used to reset the SRM status to default
+     */
+    public void resetSrmStatus() {
+        if (VERBOSE) Log.v(TAG, "resetSrmStatus");
+        setLocalSrmStatus(LOCAL_SRM_DISABLED);
+        setLocalSrmpWait(false);
+        setRemoteSrmStatus(SRM_INCAPABLE);
+    }
+
+    /**
+     * Updates the HeaderSet with the headers received in the byte array
+     * provided. Invalid headers are ignored.
+     * <P>
+     * The first two bits of an OBEX Header specifies the type of object that is
+     * being sent. The table below specifies the meaning of the high bits.
+     * <TABLE>
+     * <TR>
+     * <TH>Bits 8 and 7</TH>
+     * <TH>Value</TH>
+     * <TH>Description</TH>
+     * </TR>
+     * <TR>
+     * <TD>00</TD>
+     * <TD>0x00</TD>
+     * <TD>Null Terminated Unicode text, prefixed with 2 byte unsigned integer</TD>
+     * </TR>
+     * <TR>
+     * <TD>01</TD>
+     * <TD>0x40</TD>
+     * <TD>Byte Sequence, length prefixed with 2 byte unsigned integer</TD>
+     * </TR>
+     * <TR>
+     * <TD>10</TD>
+     * <TD>0x80</TD>
+     * <TD>1 byte quantity</TD>
+     * </TR>
+     * <TR>
+     * <TD>11</TD>
+     * <TD>0xC0</TD>
+     * <TD>4 byte quantity - transmitted in network byte order (high byte first</TD>
+     * </TR>
+     * </TABLE>
+     * This method uses the information in this table to determine the type of
+     * Java object to create and passes that object with the full header to
+     * setHeader() to update the HeaderSet object. Invalid headers will cause an
+     * exception to be thrown. When it is thrown, it is ignored.
+     * @param header the HeaderSet to update
+     * @param headerArray the byte array containing headers
+     * @return the result of the last start body or end body header provided;
+     *         the first byte in the result will specify if a body or end of
+     *         body is received
+     * @throws IOException if an invalid header was found
+     */
+    public static byte[] updateHeaderSet(HeaderSet header, byte[] headerArray) throws IOException {
+        int index = 0;
+        int length = 0;
+        int headerID;
+        byte[] value = null;
+        byte[] body = null;
+        HeaderSet headerImpl = header;
+        try {
+            while (index < headerArray.length) {
+                headerID = 0xFF & headerArray[index];
+                if (VERBOSE) Log.e(TAG,"updateHeaderSet headerID = "+ headerID);
+                switch (headerID & (0xC0)) {
+
+                    /*
+                     * 0x00 is a unicode null terminate string with the first
+                     * two bytes after the header identifier being the length
+                     */
+                    case 0x00:
+                        // Fall through
+                        /*
+                         * 0x40 is a byte sequence with the first
+                         * two bytes after the header identifier being the length
+                         */
+                    case 0x40:
+                        boolean trimTail = true;
+                        index++;
+                        length = 0xFF & headerArray[index];
+                        length = length << 8;
+                        index++;
+                        length += 0xFF & headerArray[index];
+                        length -= 3;
+                        index++;
+                        value = new byte[length];
+                        System.arraycopy(headerArray, index, value, 0, length);
+                        if (length == 0 || (length > 0 && (value[length - 1] != 0))) {
+                            trimTail = false;
+                        }
+                        switch (headerID) {
+                            case HeaderSet.TYPE:
+                                try {
+                                    // Remove trailing null
+                                    if (trimTail == false) {
+                                        headerImpl.setHeader(headerID, new String(value, 0,
+                                                value.length, "ISO8859_1"));
+                                    } else {
+                                        headerImpl.setHeader(headerID, new String(value, 0,
+                                                value.length - 1, "ISO8859_1"));
+                                    }
+                                } catch (UnsupportedEncodingException e) {
+                                    throw e;
+                                }
+                                break;
+
+                            case HeaderSet.AUTH_CHALLENGE:
+                                headerImpl.mAuthChall = new byte[length];
+                                System.arraycopy(headerArray, index, headerImpl.mAuthChall, 0,
+                                        length);
+                                break;
+
+                            case HeaderSet.AUTH_RESPONSE:
+                                headerImpl.mAuthResp = new byte[length];
+                                System.arraycopy(headerArray, index, headerImpl.mAuthResp, 0,
+                                        length);
+                                break;
+
+                            case HeaderSet.BODY:
+                                /* Fall Through */
+                            case HeaderSet.END_OF_BODY:
+                                body = new byte[length + 1];
+                                body[0] = (byte)headerID;
+                                System.arraycopy(headerArray, index, body, 1, length);
+                                break;
+
+                            case HeaderSet.TIME_ISO_8601:
+                                try {
+                                    String dateString = new String(value, "ISO8859_1");
+                                    Calendar temp = Calendar.getInstance();
+                                    if ((dateString.length() == 16)
+                                            && (dateString.charAt(15) == 'Z')) {
+                                        temp.setTimeZone(TimeZone.getTimeZone("UTC"));
+                                    }
+                                    temp.set(Calendar.YEAR, Integer.parseInt(dateString.substring(
+                                            0, 4)));
+                                    temp.set(Calendar.MONTH, Integer.parseInt(dateString.substring(
+                                            4, 6)));
+                                    temp.set(Calendar.DAY_OF_MONTH, Integer.parseInt(dateString
+                                            .substring(6, 8)));
+                                    temp.set(Calendar.HOUR_OF_DAY, Integer.parseInt(dateString
+                                            .substring(9, 11)));
+                                    temp.set(Calendar.MINUTE, Integer.parseInt(dateString
+                                            .substring(11, 13)));
+                                    temp.set(Calendar.SECOND, Integer.parseInt(dateString
+                                            .substring(13, 15)));
+                                    headerImpl.setHeader(HeaderSet.TIME_ISO_8601, temp);
+                                } catch (UnsupportedEncodingException e) {
+                                    throw e;
+                                }
+                                break;
+
+                            default:
+                                if ((headerID & 0xC0) == 0x00) {
+                                    headerImpl.setHeader(headerID, ObexHelper.convertToUnicode(
+                                            value, true));
+                                } else {
+                                    headerImpl.setHeader(headerID, value);
+                                }
+                        }
+
+                        index += length;
+                        break;
+
+                    /*
+                     * 0x80 is a byte header.  The only valid byte headers are
+                     * the 16 user defined byte headers.
+                     */
+                    case 0x80:
+                        index++;
+                        try {
+                            headerImpl.setHeader(headerID, Byte.valueOf(headerArray[index]));
+                        } catch (Exception e) {
+                            // Not a valid header so ignore
+                        }
+                        index++;
+                        break;
+
+                    /*
+                     * 0xC0 is a 4 byte unsigned integer header and with the
+                     * exception of TIME_4_BYTE will be converted to a Long
+                     * and added.
+                     */
+                    case 0xC0:
+                        index++;
+                        value = new byte[4];
+                        System.arraycopy(headerArray, index, value, 0, 4);
+                        try {
+                            if (headerID != HeaderSet.TIME_4_BYTE) {
+                                // Determine if it is a connection ID.  These
+                                // need to be handled differently
+                                if (headerID == HeaderSet.CONNECTION_ID) {
+                                    headerImpl.mConnectionID = new byte[4];
+                                    System.arraycopy(value, 0, headerImpl.mConnectionID, 0, 4);
+                                } else {
+                                    headerImpl.setHeader(headerID, Long
+                                            .valueOf(convertToLong(value)));
+                                }
+                            } else {
+                                Calendar temp = Calendar.getInstance();
+                                temp.setTime(new Date(convertToLong(value) * 1000L));
+                                headerImpl.setHeader(HeaderSet.TIME_4_BYTE, temp);
+                            }
+                        } catch (Exception e) {
+                            // Not a valid header so ignore
+                            throw new IOException("Header was not formatted properly");
+                        }
+                        index += 4;
+                        break;
+                }
+
+            }
+        } catch (IOException e) {
+            throw new IOException("Header was not formatted properly");
+        }
+
+        return body;
+    }
+
+    /**
+     * Creates the header part of OBEX packet based on the header provided.
+     * TODO: Could use getHeaderList() to get the array of headers to include
+     * and then use the high two bits to determine the the type of the object
+     * and construct the byte array from that. This will make the size smaller.
+     * @param head the header used to construct the byte array
+     * @param nullOut <code>true</code> if the header should be set to
+     *        <code>null</code> once it is added to the array or
+     *        <code>false</code> if it should not be nulled out
+     * @return the header of an OBEX packet
+     */
+    public static byte[] createHeader(HeaderSet head, boolean nullOut) {
+        Long intHeader = null;
+        String stringHeader = null;
+        Calendar dateHeader = null;
+        Byte byteHeader = null;
+        StringBuffer buffer = null;
+        byte[] value = null;
+        byte[] result = null;
+        byte[] lengthArray = new byte[2];
+        int length;
+        HeaderSet headImpl = null;
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        headImpl = head;
+
+        try {
+            /*
+             * Determine if there is a connection ID to send.  If there is,
+             * then it should be the first header in the packet.
+             */
+            if (VERBOSE) Log.e(TAG,"createHeader = "+ head);
+            if ((headImpl.mConnectionID != null) && (headImpl.getHeader(HeaderSet.TARGET) == null)) {
+                if (VERBOSE) Log.e(TAG," Add Header = "+ HeaderSet.CONNECTION_ID);
+                out.write((byte)HeaderSet.CONNECTION_ID);
+                out.write(headImpl.mConnectionID);
+            }
+
+            // Count Header
+            intHeader = (Long)headImpl.getHeader(HeaderSet.COUNT);
+            if (intHeader != null) {
+                if (VERBOSE) Log.e(TAG," Add Header = "+ HeaderSet.COUNT);
+                out.write((byte)HeaderSet.COUNT);
+                value = ObexHelper.convertToByteArray(intHeader.longValue());
+                out.write(value);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.COUNT, null);
+                }
+            }
+
+            // Name Header
+            stringHeader = (String)headImpl.getHeader(HeaderSet.NAME);
+            if (stringHeader != null) {
+                if (VERBOSE) Log.e(TAG," Add Header = "+ HeaderSet.NAME);
+                out.write((byte)HeaderSet.NAME);
+                value = ObexHelper.convertToUnicodeByteArray(stringHeader);
+                length = value.length + 3;
+                lengthArray[0] = (byte)(0xFF & (length >> 8));
+                lengthArray[1] = (byte)(0xFF & length);
+                out.write(lengthArray);
+                out.write(value);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.NAME, null);
+                }
+            }
+
+            // Dest Name Header
+            stringHeader = (String)headImpl.getHeader(HeaderSet.DEST_NAME);
+            if (stringHeader != null) {
+                if (VERBOSE) Log.e(TAG," Add Header = "+ HeaderSet.DEST_NAME);
+                out.write((byte)HeaderSet.DEST_NAME);
+                value = ObexHelper.convertToUnicodeByteArray(stringHeader);
+                length = value.length + 3;
+                lengthArray[0] = (byte)(0xFF & (length >> 8));
+                lengthArray[1] = (byte)(0xFF & length);
+                out.write(lengthArray);
+                out.write(value);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.DEST_NAME, null);
+                }
+            }
+
+
+            // Type Header
+            stringHeader = (String)headImpl.getHeader(HeaderSet.TYPE);
+            if (stringHeader != null) {
+                if (VERBOSE) Log.e(TAG," Add Header = "+ HeaderSet.TYPE);
+                out.write((byte)HeaderSet.TYPE);
+                try {
+                    value = stringHeader.getBytes("ISO8859_1");
+                } catch (UnsupportedEncodingException e) {
+                    throw e;
+                }
+
+                length = value.length + 4;
+                lengthArray[0] = (byte)(255 & (length >> 8));
+                lengthArray[1] = (byte)(255 & length);
+                out.write(lengthArray);
+                out.write(value);
+                out.write(0x00);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.TYPE, null);
+                }
+            }
+
+            // Length Header
+            intHeader = (Long)headImpl.getHeader(HeaderSet.LENGTH);
+            if (intHeader != null) {
+                if (VERBOSE) Log.e(TAG," Add Header = "+ HeaderSet.LENGTH);
+                out.write((byte)HeaderSet.LENGTH);
+                value = ObexHelper.convertToByteArray(intHeader.longValue());
+                out.write(value);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.LENGTH, null);
+                }
+            }
+
+            // Time ISO Header
+            dateHeader = (Calendar)headImpl.getHeader(HeaderSet.TIME_ISO_8601);
+            if (dateHeader != null) {
+
+                /*
+                 * The ISO Header should take the form YYYYMMDDTHHMMSSZ.  The
+                 * 'Z' will only be included if it is a UTC time.
+                 */
+                buffer = new StringBuffer();
+                int temp = dateHeader.get(Calendar.YEAR);
+                for (int i = temp; i < 1000; i = i * 10) {
+                    buffer.append("0");
+                }
+                buffer.append(temp);
+                temp = dateHeader.get(Calendar.MONTH);
+                if (temp < 10) {
+                    buffer.append("0");
+                }
+                buffer.append(temp);
+                temp = dateHeader.get(Calendar.DAY_OF_MONTH);
+                if (temp < 10) {
+                    buffer.append("0");
+                }
+                buffer.append(temp);
+                buffer.append("T");
+                temp = dateHeader.get(Calendar.HOUR_OF_DAY);
+                if (temp < 10) {
+                    buffer.append("0");
+                }
+                buffer.append(temp);
+                temp = dateHeader.get(Calendar.MINUTE);
+                if (temp < 10) {
+                    buffer.append("0");
+                }
+                buffer.append(temp);
+                temp = dateHeader.get(Calendar.SECOND);
+                if (temp < 10) {
+                    buffer.append("0");
+                }
+                buffer.append(temp);
+
+                if (dateHeader.getTimeZone().getID().equals("UTC")) {
+                    buffer.append("Z");
+                }
+
+                try {
+                    value = buffer.toString().getBytes("ISO8859_1");
+                } catch (UnsupportedEncodingException e) {
+                    throw e;
+                }
+
+                length = value.length + 3;
+                lengthArray[0] = (byte)(255 & (length >> 8));
+                lengthArray[1] = (byte)(255 & length);
+                out.write(HeaderSet.TIME_ISO_8601);
+                out.write(lengthArray);
+                out.write(value);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.TIME_ISO_8601, null);
+                }
+            }
+
+            // Time 4 Byte Header
+            dateHeader = (Calendar)headImpl.getHeader(HeaderSet.TIME_4_BYTE);
+            if (dateHeader != null) {
+                out.write(HeaderSet.TIME_4_BYTE);
+
+                /*
+                 * Need to call getTime() twice.  The first call will return
+                 * a java.util.Date object.  The second call returns the number
+                 * of milliseconds since January 1, 1970.  We need to convert
+                 * it to seconds since the TIME_4_BYTE expects the number of
+                 * seconds since January 1, 1970.
+                 */
+                value = ObexHelper.convertToByteArray(dateHeader.getTime().getTime() / 1000L);
+                out.write(value);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.TIME_4_BYTE, null);
+                }
+            }
+
+            // Description Header
+            stringHeader = (String)headImpl.getHeader(HeaderSet.DESCRIPTION);
+            if (stringHeader != null) {
+                out.write((byte)HeaderSet.DESCRIPTION);
+                value = ObexHelper.convertToUnicodeByteArray(stringHeader);
+                length = value.length + 3;
+                lengthArray[0] = (byte)(255 & (length >> 8));
+                lengthArray[1] = (byte)(255 & length);
+                out.write(lengthArray);
+                out.write(value);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.DESCRIPTION, null);
+                }
+            }
+
+            // Target Header
+            value = (byte[])headImpl.getHeader(HeaderSet.TARGET);
+            if (value != null) {
+                if (VERBOSE) Log.e(TAG," Add Header = "+ HeaderSet.TARGET);
+                out.write((byte)HeaderSet.TARGET);
+                length = value.length + 3;
+                lengthArray[0] = (byte)(255 & (length >> 8));
+                lengthArray[1] = (byte)(255 & length);
+                out.write(lengthArray);
+                out.write(value);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.TARGET, null);
+                }
+            }
+
+            // HTTP Header
+            value = (byte[])headImpl.getHeader(HeaderSet.HTTP);
+            if (value != null) {
+                out.write((byte)HeaderSet.HTTP);
+                length = value.length + 3;
+                lengthArray[0] = (byte)(255 & (length >> 8));
+                lengthArray[1] = (byte)(255 & length);
+                out.write(lengthArray);
+                out.write(value);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.HTTP, null);
+                }
+            }
+
+            // Who Header
+            value = (byte[])headImpl.getHeader(HeaderSet.WHO);
+            if (value != null) {
+                if (VERBOSE) Log.e(TAG," Add Header = "+ HeaderSet.WHO);
+                out.write((byte)HeaderSet.WHO);
+                length = value.length + 3;
+                lengthArray[0] = (byte)(255 & (length >> 8));
+                lengthArray[1] = (byte)(255 & length);
+                out.write(lengthArray);
+                out.write(value);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.WHO, null);
+                }
+            }
+
+            // Application Parameter Header
+            value = (byte[])headImpl.getHeader(HeaderSet.APPLICATION_PARAMETER);
+            if (value != null) {
+                out.write((byte)HeaderSet.APPLICATION_PARAMETER);
+                length = value.length + 3;
+                lengthArray[0] = (byte)(255 & (length >> 8));
+                lengthArray[1] = (byte)(255 & length);
+                out.write(lengthArray);
+                out.write(value);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.APPLICATION_PARAMETER, null);
+                }
+            }
+
+            // Object Class Header
+            value = (byte[])headImpl.getHeader(HeaderSet.OBJECT_CLASS);
+            if (value != null) {
+                out.write((byte)HeaderSet.OBJECT_CLASS);
+                length = value.length + 3;
+                lengthArray[0] = (byte)(255 & (length >> 8));
+                lengthArray[1] = (byte)(255 & length);
+                out.write(lengthArray);
+                out.write(value);
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.OBJECT_CLASS, null);
+                }
+            }
+
+            // Single Response Mode (SRM) Header
+            byteHeader = (Byte)headImpl.getHeader(HeaderSet.SINGLE_RESPONSE_MODE);
+            if (byteHeader != null) {
+                if (VERBOSE) Log.e(TAG," Add Header = "+ HeaderSet.SINGLE_RESPONSE_MODE);
+                out.write((byte)HeaderSet.SINGLE_RESPONSE_MODE);
+                out.write(byteHeader.byteValue());
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.SINGLE_RESPONSE_MODE, null);
+                }
+            }
+
+            // Single Response Mode (SRM) Parameter Header
+            byteHeader = (Byte)headImpl.getHeader(HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER);
+            if (byteHeader != null) {
+                if (VERBOSE) Log.e(TAG," Add Header = "+ HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER);
+                out.write((byte)HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER);
+                out.write(byteHeader.byteValue());
+                if (nullOut) {
+                    headImpl.setHeader(HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER, null);
+                }
+            }
+
+            // Check User Defined Headers
+            for (int i = 0; i < 16; i++) {
+
+                //Unicode String Header
+                stringHeader = (String)headImpl.getHeader(i + 0x30);
+                if (stringHeader != null) {
+                    out.write((byte)i + 0x30);
+                    value = ObexHelper.convertToUnicodeByteArray(stringHeader);
+                    length = value.length + 3;
+                    lengthArray[0] = (byte)(255 & (length >> 8));
+                    lengthArray[1] = (byte)(255 & length);
+                    out.write(lengthArray);
+                    out.write(value);
+                    if (nullOut) {
+                        headImpl.setHeader(i + 0x30, null);
+                    }
+                }
+
+                // Byte Sequence Header
+                value = (byte[])headImpl.getHeader(i + 0x70);
+                if (value != null) {
+                    out.write((byte)i + 0x70);
+                    length = value.length + 3;
+                    lengthArray[0] = (byte)(255 & (length >> 8));
+                    lengthArray[1] = (byte)(255 & length);
+                    out.write(lengthArray);
+                    out.write(value);
+                    if (nullOut) {
+                        headImpl.setHeader(i + 0x70, null);
+                    }
+                }
+
+                // Byte Header
+                byteHeader = (Byte)headImpl.getHeader(i + 0xB0);
+                if (byteHeader != null) {
+                    out.write((byte)i + 0xB0);
+                    out.write(byteHeader.byteValue());
+                    if (nullOut) {
+                        headImpl.setHeader(i + 0xB0, null);
+                    }
+                }
+
+                // Integer header
+                intHeader = (Long)headImpl.getHeader(i + 0xF0);
+                if (intHeader != null) {
+                    out.write((byte)i + 0xF0);
+                    out.write(ObexHelper.convertToByteArray(intHeader.longValue()));
+                    if (nullOut) {
+                        headImpl.setHeader(i + 0xF0, null);
+                    }
+                }
+            }
+
+            // Add the authentication challenge header
+            if (headImpl.mAuthChall != null) {
+                out.write((byte)HeaderSet.AUTH_CHALLENGE);
+                length = headImpl.mAuthChall.length + 3;
+                lengthArray[0] = (byte)(255 & (length >> 8));
+                lengthArray[1] = (byte)(255 & length);
+                out.write(lengthArray);
+                out.write(headImpl.mAuthChall);
+                if (nullOut) {
+                    headImpl.mAuthChall = null;
+                }
+            }
+
+            // Add the authentication response header
+            if (headImpl.mAuthResp != null) {
+                out.write((byte)HeaderSet.AUTH_RESPONSE);
+                length = headImpl.mAuthResp.length + 3;
+                lengthArray[0] = (byte)(255 & (length >> 8));
+                lengthArray[1] = (byte)(255 & length);
+                out.write(lengthArray);
+                out.write(headImpl.mAuthResp);
+                if (nullOut) {
+                    headImpl.mAuthResp = null;
+                }
+            }
+
+        } catch (IOException e) {
+        } finally {
+            result = out.toByteArray();
+            try {
+                out.close();
+            } catch (Exception ex) {
+            }
+        }
+
+        return result;
+
+    }
+
+    /**
+     * Determines where the maximum divide is between headers. This method is
+     * used by put and get operations to separate headers to a size that meets
+     * the max packet size allowed.
+     * @param headerArray the headers to separate
+     * @param start the starting index to search
+     * @param maxSize the maximum size of a packet
+     * @return the index of the end of the header block to send or -1 if the
+     *         header could not be divided because the header is too large
+     */
+    public static int findHeaderEnd(byte[] headerArray, int start, int maxSize) {
+
+        int fullLength = 0;
+        int lastLength = -1;
+        int index = start;
+        int length = 0;
+
+        while ((fullLength < maxSize) && (index < headerArray.length)) {
+            int headerID = (headerArray[index] < 0 ? headerArray[index] + 256 : headerArray[index]);
+            lastLength = fullLength;
+
+            switch (headerID & (0xC0)) {
+
+                case 0x00:
+                    // Fall through
+                case 0x40:
+
+                    index++;
+                    length = (headerArray[index] < 0 ? headerArray[index] + 256
+                            : headerArray[index]);
+                    length = length << 8;
+                    index++;
+                    length += (headerArray[index] < 0 ? headerArray[index] + 256
+                            : headerArray[index]);
+                    length -= 3;
+                    index++;
+                    index += length;
+                    fullLength += length + 3;
+                    break;
+
+                case 0x80:
+
+                    index++;
+                    index++;
+                    fullLength += 2;
+                    break;
+
+                case 0xC0:
+
+                    index += 5;
+                    fullLength += 5;
+                    break;
+
+            }
+
+        }
+
+        /*
+         * Determine if this is the last header or not
+         */
+        if (lastLength == 0) {
+            /*
+             * Since this is the last header, check to see if the size of this
+             * header is less then maxSize.  If it is, return the length of the
+             * header, otherwise return -1.  The length of the header is
+             * returned since it would be the start of the next header
+             */
+            if (fullLength < maxSize) {
+                return headerArray.length;
+            } else {
+                return -1;
+            }
+        } else {
+            return lastLength + start;
+        }
+    }
+
+    /**
+     * Converts the byte array to a long.
+     * @param b the byte array to convert to a long
+     * @return the byte array as a long
+     */
+    public static long convertToLong(byte[] b) {
+        long result = 0;
+        long value = 0;
+        long power = 0;
+
+        for (int i = (b.length - 1); i >= 0; i--) {
+            value = b[i];
+            if (value < 0) {
+                value += 256;
+            }
+
+            result = result | (value << power);
+            power += 8;
+        }
+
+        return result;
+    }
+
+    /**
+     * Converts the long to a 4 byte array. The long must be non negative.
+     * @param l the long to convert
+     * @return a byte array that is the same as the long
+     */
+    public static byte[] convertToByteArray(long l) {
+        byte[] b = new byte[4];
+
+        b[0] = (byte)(255 & (l >> 24));
+        b[1] = (byte)(255 & (l >> 16));
+        b[2] = (byte)(255 & (l >> 8));
+        b[3] = (byte)(255 & l);
+
+        return b;
+    }
+
+    /**
+     * Converts the String to a UNICODE byte array. It will also add the ending
+     * null characters to the end of the string.
+     * @param s the string to convert
+     * @return the unicode byte array of the string
+     */
+    public static byte[] convertToUnicodeByteArray(String s) {
+        if (s == null) {
+            return null;
+        }
+
+        char c[] = s.toCharArray();
+        byte[] result = new byte[(c.length * 2) + 2];
+        for (int i = 0; i < c.length; i++) {
+            result[(i * 2)] = (byte)(c[i] >> 8);
+            result[((i * 2) + 1)] = (byte)c[i];
+        }
+
+        // Add the UNICODE null character
+        result[result.length - 2] = 0;
+        result[result.length - 1] = 0;
+
+        return result;
+    }
+
+    /**
+     * Retrieves the value from the byte array for the tag value specified. The
+     * array should be of the form Tag - Length - Value triplet.
+     * @param tag the tag to retrieve from the byte array
+     * @param triplet the byte sequence containing the tag length value form
+     * @return the value of the specified tag
+     */
+    public static byte[] getTagValue(byte tag, byte[] triplet) {
+
+        int index = findTag(tag, triplet);
+        if (index == -1) {
+            return null;
+        }
+
+        index++;
+        int length = triplet[index] & 0xFF;
+
+        byte[] result = new byte[length];
+        index++;
+        System.arraycopy(triplet, index, result, 0, length);
+
+        return result;
+    }
+
+    /**
+     * Finds the index that starts the tag value pair in the byte array provide.
+     * @param tag the tag to look for
+     * @param value the byte array to search
+     * @return the starting index of the tag or -1 if the tag could not be found
+     */
+    public static int findTag(byte tag, byte[] value) {
+        int length = 0;
+
+        if (value == null) {
+            return -1;
+        }
+
+        int index = 0;
+
+        while ((index < value.length) && (value[index] != tag)) {
+            length = value[index + 1] & 0xFF;
+            index += length + 2;
+        }
+
+        if (index >= value.length) {
+            return -1;
+        }
+
+        return index;
+    }
+
+    /**
+     * Converts the byte array provided to a unicode string.
+     * @param b the byte array to convert to a string
+     * @param includesNull determine if the byte string provided contains the
+     *        UNICODE null character at the end or not; if it does, it will be
+     *        removed
+     * @return a Unicode string
+     * @throws IllegalArgumentException if the byte array has an odd length
+     */
+    public static String convertToUnicode(byte[] b, boolean includesNull) {
+        if (b == null || b.length == 0) {
+            return null;
+        }
+        int arrayLength = b.length;
+        if (!((arrayLength % 2) == 0)) {
+            throw new IllegalArgumentException("Byte array not of a valid form");
+        }
+        arrayLength = (arrayLength >> 1);
+        if (includesNull) {
+            arrayLength -= 1;
+        }
+
+        char[] c = new char[arrayLength];
+        for (int i = 0; i < arrayLength; i++) {
+            int upper = b[2 * i];
+            int lower = b[(2 * i) + 1];
+            if (upper < 0) {
+                upper += 256;
+            }
+            if (lower < 0) {
+                lower += 256;
+            }
+            // If upper and lower both equal 0, it should be the end of string.
+            // Ignore left bytes from array to avoid potential issues
+            if (upper == 0 && lower == 0) {
+                return new String(c, 0, i);
+            }
+
+            c[i] = (char)((upper << 8) | lower);
+        }
+
+        return new String(c);
+    }
+
+    /**
+     * Compute the MD5 hash of the byte array provided. Does not accumulate
+     * input.
+     * @param in the byte array to hash
+     * @return the MD5 hash of the byte array
+     */
+    public static byte[] computeMd5Hash(byte[] in) {
+        try {
+            MessageDigest md5 = MessageDigest.getInstance("MD5");
+            return md5.digest(in);
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Computes an authentication challenge header.
+     * @param nonce the challenge that will be provided to the peer; the
+     *        challenge must be 16 bytes long
+     * @param realm a short description that describes what password to use
+     * @param access if <code>true</code> then full access will be granted if
+     *        successful; if <code>false</code> then read only access will be
+     *        granted if successful
+     * @param userID if <code>true</code>, a user ID is required in the reply;
+     *        if <code>false</code>, no user ID is required
+     * @throws IllegalArgumentException if the challenge is not 16 bytes long;
+     *         if the realm can not be encoded in less then 255 bytes
+     * @throws IOException if the encoding scheme ISO 8859-1 is not supported
+     */
+    public static byte[] computeAuthenticationChallenge(byte[] nonce, String realm, boolean access,
+            boolean userID) throws IOException {
+        byte[] authChall = null;
+
+        if (nonce.length != 16) {
+            throw new IllegalArgumentException("Nonce must be 16 bytes long");
+        }
+
+        /*
+         * The authentication challenge is a byte sequence of the following form
+         * byte 0: 0x00 - the tag for the challenge
+         * byte 1: 0x10 - the length of the challenge; must be 16
+         * byte 2-17: the authentication challenge
+         * byte 18: 0x01 - the options tag; this is optional in the spec, but
+         *                 we are going to include it in every message
+         * byte 19: 0x01 - length of the options; must be 1
+         * byte 20: the value of the options; bit 0 is set if user ID is
+         *          required; bit 1 is set if access mode is read only
+         * byte 21: 0x02 - the tag for authentication realm; only included if
+         *                 an authentication realm is specified
+         * byte 22: the length of the authentication realm; only included if
+         *          the authentication realm is specified
+         * byte 23: the encoding scheme of the authentication realm; we will use
+         *          the ISO 8859-1 encoding scheme since it is part of the KVM
+         * byte 24 & up: the realm if one is specified.
+         */
+        if (realm == null) {
+            authChall = new byte[21];
+        } else {
+            if (realm.length() >= 255) {
+                throw new IllegalArgumentException("Realm must be less then 255 bytes");
+            }
+            authChall = new byte[24 + realm.length()];
+            authChall[21] = 0x02;
+            authChall[22] = (byte)(realm.length() + 1);
+            authChall[23] = 0x01; // ISO 8859-1 Encoding
+            System.arraycopy(realm.getBytes("ISO8859_1"), 0, authChall, 24, realm.length());
+        }
+
+        // Include the nonce field in the header
+        authChall[0] = 0x00;
+        authChall[1] = 0x10;
+        System.arraycopy(nonce, 0, authChall, 2, 16);
+
+        // Include the options header
+        authChall[18] = 0x01;
+        authChall[19] = 0x01;
+        authChall[20] = 0x00;
+
+        if (!access) {
+            authChall[20] = (byte)(authChall[20] | 0x02);
+        }
+        if (userID) {
+            authChall[20] = (byte)(authChall[20] | 0x01);
+        }
+
+        return authChall;
+    }
+}
diff --git a/btobex/javax/btobex/ObexSession.java b/btobex/javax/btobex/ObexSession.java
new file mode 100644
index 0000000..53f5411
--- /dev/null
+++ b/btobex/javax/btobex/ObexSession.java
@@ -0,0 +1,218 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import java.io.IOException;
+
+/**
+ * The <code>ObexSession</code> interface characterizes the term
+ * "OBEX Connection" as defined in the IrDA Object Exchange Protocol v1.2, which
+ * could be the server-side view of an OBEX connection, or the client-side view
+ * of the same connection, which is established by server's accepting of a
+ * client issued "CONNECT".
+ * <P>
+ * This interface serves as the common super class for
+ * <CODE>ClientSession</CODE> and <CODE>ServerSession</CODE>.
+ * @hide
+ */
+public class ObexSession {
+
+    protected Authenticator mAuthenticator;
+
+    protected byte[] mChallengeDigest;
+
+    /**
+     * Called when the server received an authentication challenge header. This
+     * will cause the authenticator to handle the authentication challenge.
+     * @param header the header with the authentication challenge
+     * @return <code>true</code> if the last request should be resent;
+     *         <code>false</code> if the last request should not be resent
+     * @throws IOException
+     */
+    public boolean handleAuthChall(HeaderSet header) throws IOException {
+        if (mAuthenticator == null) {
+            return false;
+        }
+
+        /*
+         * An authentication challenge is made up of one required and two
+         * optional tag length value triplets. The tag 0x00 is required to be in
+         * the authentication challenge and it represents the challenge digest
+         * that was received. The tag 0x01 is the options tag. This tag tracks
+         * if user ID is required and if full access will be granted. The tag
+         * 0x02 is the realm, which provides a description of which user name
+         * and password to use.
+         */
+        byte[] challenge = ObexHelper.getTagValue((byte)0x00, header.mAuthChall);
+        byte[] option = ObexHelper.getTagValue((byte)0x01, header.mAuthChall);
+        byte[] description = ObexHelper.getTagValue((byte)0x02, header.mAuthChall);
+
+        String realm = null;
+        if (description != null) {
+            byte[] realmString = new byte[description.length - 1];
+            System.arraycopy(description, 1, realmString, 0, realmString.length);
+
+            switch (description[0] & 0xFF) {
+
+                case ObexHelper.OBEX_AUTH_REALM_CHARSET_ASCII:
+                    // ASCII encoding
+                    // Fall through
+                case ObexHelper.OBEX_AUTH_REALM_CHARSET_ISO_8859_1:
+                    // ISO-8859-1 encoding
+                    try {
+                        realm = new String(realmString, "ISO8859_1");
+                    } catch (Exception e) {
+                        throw new IOException("Unsupported Encoding Scheme");
+                    }
+                    break;
+
+                case ObexHelper.OBEX_AUTH_REALM_CHARSET_UNICODE:
+                    // UNICODE Encoding
+                    realm = ObexHelper.convertToUnicode(realmString, false);
+                    break;
+
+                default:
+                    throw new IOException("Unsupported Encoding Scheme");
+            }
+        }
+
+        boolean isUserIDRequired = false;
+        boolean isFullAccess = true;
+        if (option != null) {
+            if ((option[0] & 0x01) != 0) {
+                isUserIDRequired = true;
+            }
+
+            if ((option[0] & 0x02) != 0) {
+                isFullAccess = false;
+            }
+        }
+
+        PasswordAuthentication result = null;
+        header.mAuthChall = null;
+
+        try {
+            result = mAuthenticator
+                    .onAuthenticationChallenge(realm, isUserIDRequired, isFullAccess);
+        } catch (Exception e) {
+            return false;
+        }
+
+        /*
+         * If no password is provided then we not resent the request
+         */
+        if (result == null) {
+            return false;
+        }
+
+        byte[] password = result.getPassword();
+        if (password == null) {
+            return false;
+        }
+
+        byte[] userName = result.getUserName();
+
+        /*
+         * Create the authentication response header. It includes 1 required and
+         * 2 option tag length value triples. The required triple has a tag of
+         * 0x00 and is the response digest. The first optional tag is 0x01 and
+         * represents the user ID. If no user ID is provided, then no user ID
+         * will be sent. The second optional tag is 0x02 and is the challenge
+         * that was received. This will always be sent
+         */
+        if (userName != null) {
+            header.mAuthResp = new byte[38 + userName.length];
+            header.mAuthResp[36] = (byte)0x01;
+            header.mAuthResp[37] = (byte)userName.length;
+            System.arraycopy(userName, 0, header.mAuthResp, 38, userName.length);
+        } else {
+            header.mAuthResp = new byte[36];
+        }
+
+        // Create the secret String
+        byte[] digest = new byte[challenge.length + password.length + 1];
+        System.arraycopy(challenge, 0, digest, 0, challenge.length);
+        // Insert colon between challenge and password
+        digest[challenge.length] = (byte)0x3A;
+        System.arraycopy(password, 0, digest, challenge.length + 1, password.length);
+
+        // Add the Response Digest
+        header.mAuthResp[0] = (byte)0x00;
+        header.mAuthResp[1] = (byte)0x10;
+
+        System.arraycopy(ObexHelper.computeMd5Hash(digest), 0, header.mAuthResp, 2, 16);
+
+        // Add the challenge
+        header.mAuthResp[18] = (byte)0x02;
+        header.mAuthResp[19] = (byte)0x10;
+        System.arraycopy(challenge, 0, header.mAuthResp, 20, 16);
+
+        return true;
+    }
+
+    /**
+     * Called when the server received an authentication response header. This
+     * will cause the authenticator to handle the authentication response.
+     * @param authResp the authentication response
+     * @return <code>true</code> if the response passed; <code>false</code> if
+     *         the response failed
+     */
+    public boolean handleAuthResp(byte[] authResp) {
+        if (mAuthenticator == null) {
+            return false;
+        }
+        // get the correct password from the application
+        byte[] correctPassword = mAuthenticator.onAuthenticationResponse(ObexHelper.getTagValue(
+                (byte)0x01, authResp));
+        if (correctPassword == null) {
+            return false;
+        }
+
+        byte[] temp = new byte[correctPassword.length + 16];
+
+        System.arraycopy(mChallengeDigest, 0, temp, 0, 16);
+        System.arraycopy(correctPassword, 0, temp, 16, correctPassword.length);
+
+        byte[] correctResponse = ObexHelper.computeMd5Hash(temp);
+        byte[] actualResponse = ObexHelper.getTagValue((byte)0x00, authResp);
+
+        // compare the MD5 hash array .
+        for (int i = 0; i < 16; i++) {
+            if (correctResponse[i] != actualResponse[i]) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/btobex/javax/btobex/ObexTransport.java b/btobex/javax/btobex/ObexTransport.java
new file mode 100644
index 0000000..7998814
--- /dev/null
+++ b/btobex/javax/btobex/ObexTransport.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * The <code>ObexTransport</code> interface defines the underlying transport
+ * connection which carries the OBEX protocol( such as TCP, RFCOMM device file
+ * exposed by Bluetooth or USB in kernel, RFCOMM socket emulated in Android
+ * platform, Irda). This interface provides an abstract layer to be used by the
+ * <code>ObexConnection</code>. Each kind of medium shall have its own
+ * implementation to wrap and follow the same interface.
+ * <P>
+ * See section 1.2.2 of IrDA Object Exchange Protocol specification.
+ * <P>
+ * Different kind of medium may have different construction - for example, the
+ * RFCOMM device file medium may be constructed from a file descriptor or simply
+ * a string while the TCP medium usually from a socket.
+ * @hide
+ */
+public interface ObexTransport {
+
+    void create() throws IOException;
+
+    void listen() throws IOException;
+
+    void close() throws IOException;
+
+    void connect() throws IOException;
+
+    void disconnect() throws IOException;
+
+    InputStream openInputStream() throws IOException;
+
+    OutputStream openOutputStream() throws IOException;
+
+    DataInputStream openDataInputStream() throws IOException;
+
+    DataOutputStream openDataOutputStream() throws IOException;
+
+}
diff --git a/btobex/javax/btobex/Operation.java b/btobex/javax/btobex/Operation.java
new file mode 100644
index 0000000..92b3dbd
--- /dev/null
+++ b/btobex/javax/btobex/Operation.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * The <code>Operation</code> interface provides ways to manipulate a single
+ * OBEX PUT or GET operation. The implementation of this interface sends OBEX
+ * packets as they are built. If during the operation the peer in the operation
+ * ends the operation, an <code>IOException</code> is thrown on the next read
+ * from the input stream, write to the output stream, or call to
+ * <code>sendHeaders()</code>.
+ * <P>
+ * <STRONG>Definition of methods inherited from <code>ContentConnection</code>
+ * </STRONG>
+ * <P>
+ * <code>getEncoding()</code> will always return <code>null</code>. <BR>
+ * <code>getLength()</code> will return the length specified by the OBEX Length
+ * header or -1 if the OBEX Length header was not included. <BR>
+ * <code>getType()</code> will return the value specified in the OBEX Type
+ * header or <code>null</code> if the OBEX Type header was not included.<BR>
+ * <P>
+ * <STRONG>How Headers are Handled</STRONG>
+ * <P>
+ * As headers are received, they may be retrieved through the
+ * <code>getReceivedHeaders()</code> method. If new headers are set during the
+ * operation, the new headers will be sent during the next packet exchange.
+ * <P>
+ * <STRONG>PUT example</STRONG>
+ * <P>
+ * <PRE>
+ * void putObjectViaOBEX(ClientSession conn, HeaderSet head, byte[] obj) throws IOException {
+ *     // Include the length header
+ *     head.setHeader(head.LENGTH, new Long(obj.length));
+ *     // Initiate the PUT request
+ *     Operation op = conn.put(head);
+ *     // Open the output stream to put the object to it
+ *     DataOutputStream out = op.openDataOutputStream();
+ *     // Send the object to the server
+ *     out.write(obj);
+ *     // End the transaction
+ *     out.close();
+ *     op.close();
+ * }
+ * </PRE>
+ * <P>
+ * <STRONG>GET example</STRONG>
+ * <P>
+ * <PRE>
+ * byte[] getObjectViaOBEX(ClientSession conn, HeaderSet head) throws IOException {
+ *     // Send the initial GET request to the server
+ *     Operation op = conn.get(head);
+ *     // Retrieve the length of the object being sent back
+ *     int length = op.getLength();
+ *     // Create space for the object
+ *     byte[] obj = new byte[length];
+ *     // Get the object from the input stream
+ *     DataInputStream in = trans.openDataInputStream();
+ *     in.read(obj);
+ *     // End the transaction
+ *     in.close();
+ *     op.close();
+ *     return obj;
+ * }
+ * </PRE>
+ *
+ * <H3>Client PUT Operation Flow</H3> For PUT operations, a call to
+ * <code>close()</code> the <code>OutputStream</code> returned from
+ * <code>openOutputStream()</code> or <code>openDataOutputStream()</code> will
+ * signal that the request is done. (In OBEX terms, the End-Of-Body header
+ * should be sent and the final bit in the request will be set.) At this point,
+ * the reply from the server may begin to be processed. A call to
+ * <code>getResponseCode()</code> will do an implicit close on the
+ * <code>OutputStream</code> and therefore signal that the request is done.
+ * <H3>Client GET Operation Flow</H3> For GET operation, a call to
+ * <code>openInputStream()</code> or <code>openDataInputStream()</code> will
+ * signal that the request is done. (In OBEX terms, the final bit in the request
+ * will be set.) A call to <code>getResponseCode()</code> will cause an implicit
+ * close on the <code>InputStream</code>. No further data may be read at this
+ * point.
+ * @hide
+ */
+public interface Operation {
+
+    /**
+     * Sends an ABORT message to the server. By calling this method, the
+     * corresponding input and output streams will be closed along with this
+     * object. No headers are sent in the abort request. This will end the
+     * operation since <code>close()</code> will be called by this method.
+     * @throws IOException if the transaction has already ended or if an OBEX
+     *         server calls this method
+     */
+    void abort() throws IOException;
+
+    /**
+     * Returns the headers that have been received during the operation.
+     * Modifying the object returned has no effect on the headers that are sent
+     * or retrieved.
+     * @return the headers received during this <code>Operation</code>
+     * @throws IOException if this <code>Operation</code> has been closed
+     */
+    HeaderSet getReceivedHeader() throws IOException;
+
+    /**
+     * Specifies the headers that should be sent in the next OBEX message that
+     * is sent.
+     * @param headers the headers to send in the next message
+     * @throws IOException if this <code>Operation</code> has been closed or the
+     *         transaction has ended and no further messages will be exchanged
+     * @throws IllegalArgumentException if <code>headers</code> was not created
+     *         by a call to <code>ServerRequestHandler.createHeaderSet()</code>
+     *         or <code>ClientSession.createHeaderSet()</code>
+     * @throws NullPointerException if <code>headers</code> if <code>null</code>
+     */
+    void sendHeaders(HeaderSet headers) throws IOException;
+
+    /**
+     * Returns the response code received from the server. Response codes are
+     * defined in the <code>ResponseCodes</code> class.
+     * @see ResponseCodes
+     * @return the response code retrieved from the server
+     * @throws IOException if an error occurred in the transport layer during
+     *         the transaction; if this object was created by an OBEX server
+     */
+    int getResponseCode() throws IOException;
+
+    String getEncoding();
+
+    long getLength();
+
+    int getHeaderLength();
+
+    String getType();
+
+    InputStream openInputStream() throws IOException;
+
+    DataInputStream openDataInputStream() throws IOException;
+
+    OutputStream openOutputStream() throws IOException;
+
+    DataOutputStream openDataOutputStream() throws IOException;
+
+    void close() throws IOException;
+
+    void noEndofBody();
+
+    int getMaxPacketSize();
+}
diff --git a/btobex/javax/btobex/PasswordAuthentication.java b/btobex/javax/btobex/PasswordAuthentication.java
new file mode 100644
index 0000000..5055b64
--- /dev/null
+++ b/btobex/javax/btobex/PasswordAuthentication.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+/**
+ * This class holds user name and password combinations.
+ * @hide
+ */
+public final class PasswordAuthentication {
+
+    private byte[] mUserName;
+
+    private final byte[] mPassword;
+
+    /**
+     * Creates a new <code>PasswordAuthentication</code> with the user name and
+     * password provided.
+     * @param userName the user name to include; this may be <code>null</code>
+     * @param password the password to include in the response
+     * @throws NullPointerException if <code>password</code> is
+     *         <code>null</code>
+     */
+    public PasswordAuthentication(final byte[] userName, final byte[] password) {
+        if (userName != null) {
+            mUserName = new byte[userName.length];
+            System.arraycopy(userName, 0, mUserName, 0, userName.length);
+        }
+
+        mPassword = new byte[password.length];
+        System.arraycopy(password, 0, mPassword, 0, password.length);
+    }
+
+    /**
+     * Retrieves the user name that was specified in the constructor. The user
+     * name may be <code>null</code>.
+     * @return the user name
+     */
+    public byte[] getUserName() {
+        return mUserName;
+    }
+
+    /**
+     * Retrieves the password.
+     * @return the password
+     */
+    public byte[] getPassword() {
+        return mPassword;
+    }
+}
diff --git a/btobex/javax/btobex/PrivateInputStream.java b/btobex/javax/btobex/PrivateInputStream.java
new file mode 100644
index 0000000..135080f
--- /dev/null
+++ b/btobex/javax/btobex/PrivateInputStream.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import java.io.InputStream;
+import java.io.IOException;
+
+/**
+ * This object provides an input stream to the Operation objects used in this
+ * package.
+ * @hide
+ */
+public final class PrivateInputStream extends InputStream {
+
+    private BaseStream mParent;
+
+    private byte[] mData;
+
+    private int mIndex;
+
+    private boolean mOpen;
+
+    /**
+     * Creates an input stream for the <code>Operation</code> to read from
+     * @param p the connection this input stream is for
+     */
+    public PrivateInputStream(BaseStream p) {
+        mParent = p;
+        mData = new byte[0];
+        mIndex = 0;
+        mOpen = true;
+    }
+
+    /**
+     * Returns the number of bytes that can be read (or skipped over) from this
+     * input stream without blocking by the next caller of a method for this
+     * input stream. The next caller might be the same thread or or another
+     * thread.
+     * @return the number of bytes that can be read from this input stream
+     *         without blocking
+     * @throws IOException if an I/O error occurs
+     */
+    @Override
+    public synchronized int available() throws IOException {
+        ensureOpen();
+        return mData.length - mIndex;
+    }
+
+    /**
+     * Reads the next byte of data from the input stream. The value byte is
+     * returned as an int in the range 0 to 255. If no byte is available because
+     * the end of the stream has been reached, the value -1 is returned. This
+     * method blocks until input data is available, the end of the stream is
+     * detected, or an exception is thrown.
+     * @return the byte read from the input stream or -1 if it reaches the end of
+     *         stream
+     * @throws IOException if an I/O error occurs
+     */
+    @Override
+    public synchronized int read() throws IOException {
+        ensureOpen();
+        while (mData.length == mIndex) {
+            if (!mParent.continueOperation(true, true)) {
+                return -1;
+            }
+        }
+        return (mData[mIndex++] & 0xFF);
+    }
+
+    @Override
+    public int read(byte[] b) throws IOException {
+        return read(b, 0, b.length);
+    }
+
+    @Override
+    public synchronized int read(byte[] b, int offset, int length) throws IOException {
+
+        if (b == null) {
+            throw new IOException("buffer is null");
+        }
+        if ((offset | length) < 0 || length > b.length - offset) {
+            throw new ArrayIndexOutOfBoundsException("index outof bound");
+        }
+        ensureOpen();
+
+        int currentDataLength = mData.length - mIndex;
+        int remainReadLength = length;
+        int offset1 = offset;
+        int result = 0;
+
+        while (currentDataLength <= remainReadLength) {
+            System.arraycopy(mData, mIndex, b, offset1, currentDataLength);
+            mIndex += currentDataLength;
+            offset1 += currentDataLength;
+            result += currentDataLength;
+            remainReadLength -= currentDataLength;
+
+            if (!mParent.continueOperation(true, true)) {
+                return result == 0 ? -1 : result;
+            }
+            currentDataLength = mData.length - mIndex;
+        }
+        if (remainReadLength > 0) {
+            System.arraycopy(mData, mIndex, b, offset1, remainReadLength);
+            mIndex += remainReadLength;
+            result += remainReadLength;
+        }
+        return result;
+    }
+
+    /**
+     * Allows the <code>OperationImpl</code> thread to add body data to the
+     * input stream.
+     * @param body the data to add to the stream
+     * @param start the start of the body to array to copy
+     */
+    public synchronized void writeBytes(byte[] body, int start) {
+
+        int length = (body.length - start) + (mData.length - mIndex);
+        byte[] temp = new byte[length];
+
+        System.arraycopy(mData, mIndex, temp, 0, mData.length - mIndex);
+        System.arraycopy(body, start, temp, mData.length - mIndex, body.length - start);
+
+        mData = temp;
+        mIndex = 0;
+        notifyAll();
+    }
+
+    /**
+     * Verifies that this stream is open
+     * @throws IOException if the stream is not open
+     */
+    private void ensureOpen() throws IOException {
+        mParent.ensureOpen();
+        if (!mOpen) {
+            throw new IOException("Input stream is closed");
+        }
+    }
+
+    /**
+     * Closes the input stream. If the input stream is already closed, do
+     * nothing.
+     * @throws IOException this will never happen
+     */
+    @Override
+    public void close() throws IOException {
+        mOpen = false;
+        mParent.streamClosed(true);
+    }
+}
diff --git a/btobex/javax/btobex/PrivateOutputStream.java b/btobex/javax/btobex/PrivateOutputStream.java
new file mode 100644
index 0000000..fda3a4c
--- /dev/null
+++ b/btobex/javax/btobex/PrivateOutputStream.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.ByteArrayOutputStream;
+
+/**
+ * This object provides an output stream to the Operation objects used in this
+ * package.
+ * @hide
+ */
+public final class PrivateOutputStream extends OutputStream {
+
+    private BaseStream mParent;
+
+    private ByteArrayOutputStream mArray;
+
+    private boolean mOpen;
+
+    private int mMaxPacketSize;
+
+    /**
+     * Creates an empty <code>PrivateOutputStream</code> to write to.
+     * @param p the connection that this stream runs over
+     */
+    public PrivateOutputStream(BaseStream p, int maxSize) {
+        mParent = p;
+        mArray = new ByteArrayOutputStream();
+        mMaxPacketSize = maxSize;
+        mOpen = true;
+    }
+
+    /**
+     * Determines how many bytes have been written to the output stream.
+     * @return the number of bytes written to the output stream
+     */
+    public int size() {
+        return mArray.size();
+    }
+
+    /**
+     * Writes the specified byte to this output stream. The general contract for
+     * write is that one byte is written to the output stream. The byte to be
+     * written is the eight low-order bits of the argument b. The 24 high-order
+     * bits of b are ignored.
+     * @param b the byte to write
+     * @throws IOException if an I/O error occurs
+     */
+    @Override
+    public synchronized void write(int b) throws IOException {
+        ensureOpen();
+        mParent.ensureNotDone();
+        mArray.write(b);
+        if (mArray.size() == mMaxPacketSize) {
+            mParent.continueOperation(true, false);
+        }
+    }
+
+    @Override
+    public void write(byte[] buffer) throws IOException {
+        write(buffer, 0, buffer.length);
+    }
+
+    @Override
+    public synchronized void write(byte[] buffer, int offset, int count) throws IOException {
+        int offset1 = offset;
+        int remainLength = count;
+
+        if (buffer == null) {
+            throw new IOException("buffer is null");
+        }
+        if ((offset | count) < 0 || count > buffer.length - offset) {
+            throw new IndexOutOfBoundsException("index outof bound");
+        }
+
+        ensureOpen();
+        mParent.ensureNotDone();
+        while ((mArray.size() + remainLength) >= mMaxPacketSize) {
+            int bufferLeft = mMaxPacketSize - mArray.size();
+            mArray.write(buffer, offset1, bufferLeft);
+            offset1 += bufferLeft;
+            remainLength -= bufferLeft;
+            mParent.continueOperation(true, false);
+        }
+        if (remainLength > 0) {
+            mArray.write(buffer, offset1, remainLength);
+        }
+    }
+
+    /**
+     * Reads the bytes that have been written to this stream.
+     * @param size the size of the array to return
+     * @return the byte array that is written
+     */
+    public synchronized byte[] readBytes(int size) {
+        if (mArray.size() > 0) {
+            byte[] temp = mArray.toByteArray();
+            mArray.reset();
+            byte[] result = new byte[size];
+            System.arraycopy(temp, 0, result, 0, size);
+            if (temp.length != size) {
+                mArray.write(temp, size, temp.length - size);
+            }
+            return result;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Verifies that this stream is open
+     * @throws IOException if the stream is not open
+     */
+    private void ensureOpen() throws IOException {
+        mParent.ensureOpen();
+        if (!mOpen) {
+            throw new IOException("Output stream is closed");
+        }
+    }
+
+    /**
+     * Closes the output stream. If the input stream is already closed, do
+     * nothing.
+     * @throws IOException this will never happen
+     */
+    @Override
+    public void close() throws IOException {
+        mOpen = false;
+        mParent.streamClosed(false);
+    }
+
+    /**
+     * Determines if the connection is closed
+     * @return <code>true</code> if the connection is closed; <code>false</code>
+     *         if the connection is open
+     */
+    public boolean isClosed() {
+        return !mOpen;
+    }
+}
diff --git a/btobex/javax/btobex/ResponseCodes.java b/btobex/javax/btobex/ResponseCodes.java
new file mode 100644
index 0000000..0afab1f
--- /dev/null
+++ b/btobex/javax/btobex/ResponseCodes.java
@@ -0,0 +1,326 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+/**
+ * The <code>ResponseCodes</code> class contains the list of valid response
+ * codes a server may send to a client.
+ * <P>
+ * <STRONG>IMPORTANT NOTE</STRONG>
+ * <P>
+ * The values in this interface represent the values defined in the IrOBEX
+ * specification, which is different with the HTTP specification.
+ * <P>
+ * <code>OBEX_DATABASE_FULL</code> and <code>OBEX_DATABASE_LOCKED</code> require
+ * further description since they are not defined in HTTP. The server will send
+ * an <code>OBEX_DATABASE_FULL</code> message when the client requests that
+ * something be placed into a database but the database is full (cannot take
+ * more data). <code>OBEX_DATABASE_LOCKED</code> will be returned when the
+ * client wishes to access a database, database table, or database record that
+ * has been locked.
+ * @hide
+ */
+public final class ResponseCodes {
+
+    /**
+     * Defines the OBEX CONTINUE response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_CONTINUE</code> is 0x90 (144).
+     */
+    public static final int OBEX_HTTP_CONTINUE = 0x90;
+
+    /**
+     * Defines the OBEX SUCCESS response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_OK</code> is 0xA0 (160).
+     */
+    public static final int OBEX_HTTP_OK = 0xA0;
+
+    /**
+     * Defines the OBEX CREATED response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_CREATED</code> is 0xA1 (161).
+     */
+    public static final int OBEX_HTTP_CREATED = 0xA1;
+
+    /**
+     * Defines the OBEX ACCEPTED response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_ACCEPTED</code> is 0xA2 (162).
+     */
+    public static final int OBEX_HTTP_ACCEPTED = 0xA2;
+
+    /**
+     * Defines the OBEX NON-AUTHORITATIVE INFORMATION response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_NOT_AUTHORITATIVE</code> is 0xA3 (163).
+     */
+    public static final int OBEX_HTTP_NOT_AUTHORITATIVE = 0xA3;
+
+    /**
+     * Defines the OBEX NO CONTENT response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_NO_CONTENT</code> is 0xA4 (164).
+     */
+    public static final int OBEX_HTTP_NO_CONTENT = 0xA4;
+
+    /**
+     * Defines the OBEX RESET CONTENT response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_RESET</code> is 0xA5 (165).
+     */
+    public static final int OBEX_HTTP_RESET = 0xA5;
+
+    /**
+     * Defines the OBEX PARTIAL CONTENT response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_PARTIAL</code> is 0xA6 (166).
+     */
+    public static final int OBEX_HTTP_PARTIAL = 0xA6;
+
+    /**
+     * Defines the OBEX MULTIPLE_CHOICES response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_MULT_CHOICE</code> is 0xB0 (176).
+     */
+    public static final int OBEX_HTTP_MULT_CHOICE = 0xB0;
+
+    /**
+     * Defines the OBEX MOVED PERMANENTLY response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_MOVED_PERM</code> is 0xB1 (177).
+     */
+    public static final int OBEX_HTTP_MOVED_PERM = 0xB1;
+
+    /**
+     * Defines the OBEX MOVED TEMPORARILY response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_MOVED_TEMP</code> is 0xB2 (178).
+     */
+    public static final int OBEX_HTTP_MOVED_TEMP = 0xB2;
+
+    /**
+     * Defines the OBEX SEE OTHER response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_SEE_OTHER</code> is 0xB3 (179).
+     */
+    public static final int OBEX_HTTP_SEE_OTHER = 0xB3;
+
+    /**
+     * Defines the OBEX NOT MODIFIED response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_NOT_MODIFIED</code> is 0xB4 (180).
+     */
+    public static final int OBEX_HTTP_NOT_MODIFIED = 0xB4;
+
+    /**
+     * Defines the OBEX USE PROXY response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_USE_PROXY</code> is 0xB5 (181).
+     */
+    public static final int OBEX_HTTP_USE_PROXY = 0xB5;
+
+    /**
+     * Defines the OBEX BAD REQUEST response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_BAD_REQUEST</code> is 0xC0 (192).
+     */
+    public static final int OBEX_HTTP_BAD_REQUEST = 0xC0;
+
+    /**
+     * Defines the OBEX UNAUTHORIZED response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_UNAUTHORIZED</code> is 0xC1 (193).
+     */
+    public static final int OBEX_HTTP_UNAUTHORIZED = 0xC1;
+
+    /**
+     * Defines the OBEX PAYMENT REQUIRED response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_PAYMENT_REQUIRED</code> is 0xC2 (194).
+     */
+    public static final int OBEX_HTTP_PAYMENT_REQUIRED = 0xC2;
+
+    /**
+     * Defines the OBEX FORBIDDEN response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_FORBIDDEN</code> is 0xC3 (195).
+     */
+    public static final int OBEX_HTTP_FORBIDDEN = 0xC3;
+
+    /**
+     * Defines the OBEX NOT FOUND response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_NOT_FOUND</code> is 0xC4 (196).
+     */
+    public static final int OBEX_HTTP_NOT_FOUND = 0xC4;
+
+    /**
+     * Defines the OBEX METHOD NOT ALLOWED response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_BAD_METHOD</code> is 0xC5 (197).
+     */
+    public static final int OBEX_HTTP_BAD_METHOD = 0xC5;
+
+    /**
+     * Defines the OBEX NOT ACCEPTABLE response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_NOT_ACCEPTABLE</code> is 0xC6 (198).
+     */
+    public static final int OBEX_HTTP_NOT_ACCEPTABLE = 0xC6;
+
+    /**
+     * Defines the OBEX PROXY AUTHENTICATION REQUIRED response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_PROXY_AUTH</code> is 0xC7 (199).
+     */
+    public static final int OBEX_HTTP_PROXY_AUTH = 0xC7;
+
+    /**
+     * Defines the OBEX REQUEST TIME OUT response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_TIMEOUT</code> is 0xC8 (200).
+     */
+    public static final int OBEX_HTTP_TIMEOUT = 0xC8;
+
+    /**
+     * Defines the OBEX METHOD CONFLICT response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_CONFLICT</code> is 0xC9 (201).
+     */
+    public static final int OBEX_HTTP_CONFLICT = 0xC9;
+
+    /**
+     * Defines the OBEX METHOD GONE response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_GONE</code> is 0xCA (202).
+     */
+    public static final int OBEX_HTTP_GONE = 0xCA;
+
+    /**
+     * Defines the OBEX METHOD LENGTH REQUIRED response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_LENGTH_REQUIRED</code> is 0xCB (203).
+     */
+    public static final int OBEX_HTTP_LENGTH_REQUIRED = 0xCB;
+
+    /**
+     * Defines the OBEX PRECONDITION FAILED response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_PRECON_FAILED</code> is 0xCC (204).
+     */
+    public static final int OBEX_HTTP_PRECON_FAILED = 0xCC;
+
+    /**
+     * Defines the OBEX REQUESTED ENTITY TOO LARGE response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_ENTITY_TOO_LARGE</code> is 0xCD (205).
+     */
+    public static final int OBEX_HTTP_ENTITY_TOO_LARGE = 0xCD;
+
+    /**
+     * Defines the OBEX REQUESTED URL TOO LARGE response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_REQ_TOO_LARGE</code> is 0xCE (206).
+     */
+    public static final int OBEX_HTTP_REQ_TOO_LARGE = 0xCE;
+
+    /**
+     * Defines the OBEX UNSUPPORTED MEDIA TYPE response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_UNSUPPORTED_TYPE</code> is 0xCF (207).
+     */
+    public static final int OBEX_HTTP_UNSUPPORTED_TYPE = 0xCF;
+
+    /**
+     * Defines the OBEX INTERNAL SERVER ERROR response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_INTERNAL_ERROR</code> is 0xD0 (208).
+     */
+    public static final int OBEX_HTTP_INTERNAL_ERROR = 0xD0;
+
+    /**
+     * Defines the OBEX NOT IMPLEMENTED response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_NOT_IMPLEMENTED</code> is 0xD1 (209).
+     */
+    public static final int OBEX_HTTP_NOT_IMPLEMENTED = 0xD1;
+
+    /**
+     * Defines the OBEX BAD GATEWAY response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_BAD_GATEWAY</code> is 0xD2 (210).
+     */
+    public static final int OBEX_HTTP_BAD_GATEWAY = 0xD2;
+
+    /**
+     * Defines the OBEX SERVICE UNAVAILABLE response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_UNAVAILABLE</code> is 0xD3 (211).
+     */
+    public static final int OBEX_HTTP_UNAVAILABLE = 0xD3;
+
+    /**
+     * Defines the OBEX GATEWAY TIMEOUT response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_GATEWAY_TIMEOUT</code> is 0xD4 (212).
+     */
+    public static final int OBEX_HTTP_GATEWAY_TIMEOUT = 0xD4;
+
+    /**
+     * Defines the OBEX HTTP VERSION NOT SUPPORTED response code.
+     * <P>
+     * The value of <code>OBEX_HTTP_VERSION</code> is 0xD5 (213).
+     */
+    public static final int OBEX_HTTP_VERSION = 0xD5;
+
+    /**
+     * Defines the OBEX DATABASE FULL response code.
+     * <P>
+     * The value of <code>OBEX_DATABASE_FULL</code> is 0xE0 (224).
+     */
+    public static final int OBEX_DATABASE_FULL = 0xE0;
+
+    /**
+     * Defines the OBEX DATABASE LOCKED response code.
+     * <P>
+     * The value of <code>OBEX_DATABASE_LOCKED</code> is 0xE1 (225).
+     */
+    public static final int OBEX_DATABASE_LOCKED = 0xE1;
+
+    /**
+     * Constructor does nothing.
+     */
+    private ResponseCodes() {
+    }
+}
diff --git a/btobex/javax/btobex/ServerOperation.java b/btobex/javax/btobex/ServerOperation.java
new file mode 100644
index 0000000..1e47ce6
--- /dev/null
+++ b/btobex/javax/btobex/ServerOperation.java
@@ -0,0 +1,847 @@
+/*
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import android.util.Log;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.DataInputStream;
+import java.io.OutputStream;
+import java.io.DataOutputStream;
+import java.io.ByteArrayOutputStream;
+
+/**
+ * This class implements the Operation interface for server side connections.
+ * <P>
+ * <STRONG>Request Codes</STRONG> There are four different request codes that
+ * are in this class. 0x02 is a PUT request that signals that the request is not
+ * complete and requires an additional OBEX packet. 0x82 is a PUT request that
+ * says that request is complete. In this case, the server can begin sending the
+ * response. The 0x03 is a GET request that signals that the request is not
+ * finished. When the server receives a 0x83, the client is signaling the server
+ * that it is done with its request. TODO: Extend the ClientOperation and reuse
+ * the methods defined TODO: in that class.
+ * @hide
+ */
+public final class ServerOperation implements Operation, BaseStream {
+    private static final String TAG = "Obex ServerOperation";
+
+    private static final boolean VERBOSE = false;
+
+    public boolean isAborted;
+
+    public HeaderSet requestHeader;
+
+    public HeaderSet replyHeader;
+
+    public boolean finalBitSet;
+
+    private InputStream mInput;
+
+    private ServerSession mParent;
+
+    private int mMaxPacketLength;
+
+    private int mResponseSize;
+
+    private boolean mClosed;
+
+    private boolean mGetOperation;
+
+    private PrivateInputStream mPrivateInput;
+
+    private PrivateOutputStream mPrivateOutput;
+
+    private boolean mPrivateOutputOpen;
+
+    private String mExceptionString;
+
+    private ServerRequestHandler mListener;
+
+    private boolean mRequestFinished;
+
+    private boolean mHasBody;
+
+    private boolean mEndofBody = true;
+
+    public boolean mSingleResponseActive;
+
+    public boolean mSrmGetActive;
+
+    public Byte mSingleResponseModeParameter;
+
+    public ObexHelper mSrmServerSession;
+
+    /**
+     * Creates new ServerOperation
+     * @param p the parent that created this object
+     * @param in the input stream to read from
+     * @param out the output stream to write to
+     * @param request the initial request that was received from the client
+     * @param maxSize the max packet size that the client will accept
+     * @param listen the listener that is responding to the request
+     * @throws IOException if an IO error occurs
+     */
+    public ServerOperation(ServerSession p, InputStream in, int request, int maxSize,
+            ServerRequestHandler listen) throws IOException {
+
+        if (VERBOSE)  Log.v(TAG, "ServerOperation");
+
+        isAborted = false;
+        mParent = p;
+        mInput = in;
+        mMaxPacketLength = maxSize;
+        mClosed = false;
+        requestHeader = new HeaderSet();
+        replyHeader = new HeaderSet();
+        mPrivateInput = new PrivateInputStream(this);
+        mResponseSize = 3;
+        mListener = listen;
+        mRequestFinished = false;
+        mPrivateOutputOpen = false;
+        mHasBody = false;
+        mSingleResponseActive = false;
+        mSrmGetActive = false;
+        mSingleResponseModeParameter = ObexHelper.OBEX_SRM_PARAM_NONE;
+        mSrmServerSession = p.mSrmServer;
+        int bytesReceived;
+        Byte rmtRqstSRM = ObexHelper.OBEX_SRM_DISABLED;
+
+        /*
+         * Determine if this is a PUT request
+         */
+        if ((request == 0x02) || (request == 0x82)) {
+            /*
+             * It is a PUT request.
+             */
+            mGetOperation = false;
+
+            /*
+             * Determine if the final bit is set
+             */
+            if ((request & 0x80) == 0) {
+                finalBitSet = false;
+            } else {
+                finalBitSet = true;
+                mRequestFinished = true;
+            }
+        } else if ((request == 0x03) || (request == 0x83)) {
+            /*
+             * It is a GET request.
+             */
+            mGetOperation = true;
+
+            // For Get request, final bit set is decided by server side logic
+            finalBitSet = false;
+
+            if (request == 0x83) {
+                mRequestFinished = true;
+            }
+        } else {
+            throw new IOException("ServerOperation can not handle such request");
+        }
+
+        int length = in.read();
+        length = (length << 8) + in.read();
+
+        /*
+         * Determine if the packet length is larger than this device can receive
+         */
+        if (length > mParent.getMaxPacketSize()) {
+            mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE, null);
+            throw new IOException("Packet received was too large");
+        }
+
+        /*
+         * Determine if any headers were sent in the initial request
+         */
+        if (length > 3) {
+            byte[] data = new byte[length - 3];
+            bytesReceived = in.read(data);
+
+            while (bytesReceived != data.length) {
+                bytesReceived += in.read(data, bytesReceived, data.length - bytesReceived);
+            }
+
+            byte[] body = ObexHelper.updateHeaderSet(requestHeader, data);
+            rmtRqstSRM  = (Byte)this.requestHeader.getHeader(HeaderSet.SINGLE_RESPONSE_MODE);
+            if (body != null) {
+                mHasBody = true;
+            }
+
+            if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
+                mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
+            } else {
+                mListener.setConnectionId(1);
+            }
+
+            if (requestHeader.mAuthResp != null) {
+                if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
+                    mExceptionString = "Authentication Failed";
+                    mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED, null);
+                    mClosed = true;
+                    requestHeader.mAuthResp = null;
+                    return;
+                }
+            }
+
+            if (requestHeader.mAuthChall != null) {
+                mParent.handleAuthChall(requestHeader);
+                // send the  authResp to the client
+                replyHeader.mAuthResp = new byte[requestHeader.mAuthResp.length];
+                System.arraycopy(requestHeader.mAuthResp, 0, replyHeader.mAuthResp, 0,
+                        replyHeader.mAuthResp.length);
+                requestHeader.mAuthResp = null;
+                requestHeader.mAuthChall = null;
+
+            }
+
+            if (body != null) {
+                mPrivateInput.writeBytes(body, 1);
+             /* Don't Pre-Send continue when Remote requested for SRM
+              * Let the Application confirm
+              */
+            } else if (rmtRqstSRM != ObexHelper.OBEX_SRM_ENABLED) {
+                while ((!mGetOperation) && (!finalBitSet)) {
+                    if (VERBOSE) Log.v(TAG, "length > 3 ServerOperation pre-sendreply");
+                    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE, mSingleResponseActive, false);
+                    if (mPrivateInput.available() > 0) {
+                        break;
+                    }
+                }
+            }
+        }
+
+        /* Don't Pre-Send continue when Remote requested for SRM
+         * Let the Application confirm
+         */
+        while ((rmtRqstSRM != ObexHelper.OBEX_SRM_ENABLED) && (!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
+            if (VERBOSE)  Log.v(TAG, "mPrivateInput.available() == 0 ServerOperation pre-sendreply");
+            sendReply(ResponseCodes.OBEX_HTTP_CONTINUE, mSingleResponseActive,false);
+
+            if (mPrivateInput.available() > 0) {
+                break;
+            }
+        }
+
+        // wait for get request finished !!!!
+        while (mGetOperation && !mRequestFinished) {
+            sendReply(ResponseCodes.OBEX_HTTP_CONTINUE, false,false);
+        }
+    }
+
+    public boolean isValidBody() {
+        return mHasBody;
+    }
+
+    /**
+     * Determines if the operation should continue or should wait. If it should
+     * continue, this method will continue the operation.
+     * @param sendEmpty if <code>true</code> then this will continue the
+     *        operation even if no headers will be sent; if <code>false</code>
+     *        then this method will only continue the operation if there are
+     *        headers to send
+     * @param inStream if<code>true</code> the stream is input stream, otherwise
+     *        output stream
+     * @return <code>true</code> if the operation was completed;
+     *         <code>false</code> if no operation took place
+     */
+    public synchronized boolean continueOperation(boolean sendEmpty, boolean inStream)
+            throws IOException {
+        if (VERBOSE) Log.v(TAG, "continueOperation");
+        if (!mGetOperation) {
+
+            if (!finalBitSet) {
+                if (sendEmpty) {
+                    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE, mSingleResponseActive,false);
+
+                    if (VERBOSE) Log.v(TAG, "continueOperation: Server setting SRM, sendEmpty clause");
+
+                    mSingleResponseActive = mSrmServerSession.getLocalSrmStatus();
+                    if (mSingleResponseActive == ObexHelper.LOCAL_SRM_ENABLED) {
+                        if (VERBOSE) Log.v(TAG, "continueOperation: Server SRM enabled");
+                        if (mSrmServerSession.getLocalSrmpWait()) {
+                            if (mSingleResponseModeParameter == ObexHelper.OBEX_SRM_PARAM_WAIT) {
+                                if (VERBOSE) Log.v(TAG, "continueOperation: Server sent SRMP NONE to stop SRMP WAIT");
+                                mSingleResponseActive = ObexHelper.LOCAL_SRM_ENABLED;
+                                mSrmServerSession.setLocalSrmpWait(false);
+                            } else {
+                                if (VERBOSE) Log.v(TAG, "continueOperation: Server SRMP WAIT");
+                                mSingleResponseActive = ObexHelper.LOCAL_SRM_DISABLED;
+                                mSingleResponseModeParameter = ObexHelper.OBEX_SRM_PARAM_WAIT;
+                            }
+                        }
+                    } else {
+                        if (VERBOSE) Log.v(TAG, "continueOperation: Server SRM disabled");
+                    }
+                    return true;
+                } else {
+                    if ((mResponseSize > 3) || (mPrivateOutput.size() > 0)) {
+                        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE, mSingleResponseActive,false);
+
+                        if (VERBOSE) Log.v(TAG, "continueOperation: Server setting SRM");
+
+                        mSingleResponseActive = mSrmServerSession.getLocalSrmStatus();
+                        if (mSingleResponseActive == ObexHelper.LOCAL_SRM_ENABLED) {
+                            if (VERBOSE) Log.v(TAG, "continueOperation: Server SRM enabled");
+                            if (mSrmServerSession.getLocalSrmpWait()) {
+                                if (mSingleResponseModeParameter == ObexHelper.OBEX_SRM_PARAM_WAIT) {
+                                    if (VERBOSE) Log.v(TAG, "continueOperation: Server sent SRMP NONE to stop SRMP WAIT");
+                                    mSingleResponseActive = ObexHelper.LOCAL_SRM_ENABLED;
+                                    mSrmServerSession.setLocalSrmpWait(false);
+                                } else {
+                                    if (VERBOSE) Log.v(TAG, "continueOperation: Server SRMP WAIT");
+                                    mSingleResponseActive = ObexHelper.LOCAL_SRM_DISABLED;
+                                    mSingleResponseModeParameter = ObexHelper.OBEX_SRM_PARAM_WAIT;
+                                }
+                            }
+                        } else {
+                            if (VERBOSE) Log.v(TAG, "continueOperation: Server SRM disabled");
+                        }
+                        return true;
+                    } else {
+                        return false;
+                    }
+                }
+            } else {
+                return false;
+            }
+        } else {
+            mSrmGetActive = mSrmServerSession.getLocalSrmStatus();
+            requestHeader.setHeader(HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER, ObexHelper.OBEX_SRM_PARAM_NONE);
+            sendReply(ResponseCodes.OBEX_HTTP_CONTINUE, mSingleResponseActive,mSrmGetActive);
+
+            if (VERBOSE) Log.v(TAG, "Get continueOperation");
+            return true;
+        }
+    }
+
+    /**
+     * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it
+     * will wait for a response from the client before ending.
+     * @param type the response code to send back to the client
+     * @param suppressSend suppress sending the reply, e.g., for SRM mode
+     * @return <code>true</code> if the final bit was not set on the reply;
+     *         <code>false</code> if no reply was received because the operation
+     *         ended, an abort was received, or the final bit was set in the
+     *         reply
+     * @throws IOException if an IO error occurs
+     */
+    public synchronized boolean sendReply(int type,
+            boolean suppressSend,boolean supressReceive) throws IOException {
+
+        if (VERBOSE) Log.v(TAG, "sendReply type: " + type + ", suppress: "
+                       + suppressSend + ", SRMP WAIT: "+ mSrmServerSession.getLocalSrmpWait()
+                       + "supressReceive: "+supressReceive);
+
+        int bytesReceived;
+
+        if ((!suppressSend) || (mSrmServerSession.getLocalSrmpWait())) {
+            ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+            long id = mListener.getConnectionId();
+            if (id == -1) {
+                replyHeader.mConnectionID = null;
+            } else {
+                replyHeader.mConnectionID = ObexHelper.convertToByteArray(id);
+            }
+
+            byte[] headerArray = ObexHelper.createHeader(replyHeader, true);
+            int bodyLength = -1;
+            int orginalBodyLength = -1;
+
+            if (mPrivateOutput != null) {
+                bodyLength = mPrivateOutput.size();
+                orginalBodyLength = bodyLength;
+            }
+
+            if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
+
+                int end = 0;
+                int start = 0;
+
+                while (end != headerArray.length) {
+                    end = ObexHelper.findHeaderEnd(headerArray, start, mMaxPacketLength
+                            - ObexHelper.BASE_PACKET_LENGTH);
+                    if (end == -1) {
+
+                        mClosed = true;
+
+                        if (mPrivateInput != null) {
+                            mPrivateInput.close();
+                        }
+
+                        if (mPrivateOutput != null) {
+                            mPrivateOutput.close();
+                        }
+                        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
+                        throw new IOException("OBEX Packet exceeds max packet size");
+                    }
+                    byte[] sendHeader = new byte[end - start];
+                    System.arraycopy(headerArray, start, sendHeader, 0, sendHeader.length);
+
+                    mParent.sendResponse(type, sendHeader);
+                    start = end;
+                }
+
+                if (bodyLength > 0) {
+                    return true;
+                } else {
+                    return false;
+                }
+
+            } else {
+                out.write(headerArray);
+            }
+
+            // For Get operation: if response code is OBEX_HTTP_OK, then this is the
+            // last packet; so set finalBitSet to true.
+            if (mGetOperation && type == ResponseCodes.OBEX_HTTP_OK) {
+                finalBitSet = true;
+            }
+
+            if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
+                if (bodyLength > 0) {
+                    /*
+                     * Determine if I can send the whole body or just part of
+                     * the body.  Remember that there is the 3 bytes for the
+                     * response message and 3 bytes for the header ID and length
+                     */
+                    if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
+                        bodyLength = mMaxPacketLength - headerArray.length - 6;
+                    }
+
+                    byte[] body = mPrivateOutput.readBytes(bodyLength);
+                    if(VERBOSE) Log.e(TAG,"Get Operation bodyLength = "+bodyLength);
+
+                    /*
+                     * Since this is a put request if the final bit is set or
+                     * the output stream is closed we need to send the 0x49
+                     * (End of Body) otherwise, we need to send 0x48 (Body)
+                     */
+                    if ((finalBitSet) || (mPrivateOutput.isClosed())) {
+                        if (mEndofBody) {
+                            out.write(0x49);
+                            if(VERBOSE) Log.e(TAG," write 0x49 + "+bodyLength);
+                            bodyLength += 3;
+                            out.write((byte)(bodyLength >> 8));
+                            out.write((byte)bodyLength);
+                            out.write(body);
+                        }
+                    } else {
+                        out.write(0x48);
+                        if(VERBOSE) Log.e(TAG," write 0x48 = "+bodyLength);
+                        bodyLength += 3;
+                        out.write((byte)(bodyLength >> 8));
+                        out.write((byte)bodyLength);
+                        out.write(body);
+                    }
+                }
+            }
+
+            if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
+                if (mEndofBody) {
+                    out.write(0x49);
+                    if(VERBOSE) Log.e(TAG,"type == ResponseCodes.OBEX_HTTP_OK write 0x49");
+                    orginalBodyLength = 3;
+                    out.write((byte)(orginalBodyLength >> 8));
+                    out.write((byte)orginalBodyLength);
+                }
+            }
+            mResponseSize = 3;
+            mParent.sendResponse(type, out.toByteArray());
+	    }
+
+        if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
+            if((!supressReceive) || (mSrmServerSession.getLocalSrmpWait())) {
+                int headerID = mInput.read();
+                int length = mInput.read();
+                length = (length << 8) + mInput.read();
+                if (VERBOSE) Log.v(TAG, "sendReply reading headerID " + headerID + " length " + length);
+                if ((headerID != ObexHelper.OBEX_OPCODE_PUT)
+                        && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL)
+                        && (headerID != ObexHelper.OBEX_OPCODE_GET)
+                        && (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
+
+                    if (length > 3) {
+                        byte[] temp = new byte[length - 3];
+                        // First three bytes already read, compensating for this
+                        bytesReceived = mInput.read(temp);
+
+                        while (bytesReceived != temp.length) {
+                            bytesReceived += mInput.read(temp, bytesReceived,
+                                    temp.length - bytesReceived);
+                        }
+                    }
+
+                    /*
+                     * Determine if an ABORT was sent as the reply
+                     */
+                    if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
+                        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK, null);
+                        mClosed = true;
+                        isAborted = true;
+                        mExceptionString = "Abort Received";
+                        throw new IOException("Abort Received");
+                    } else {
+                        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST, null);
+                        mClosed = true;
+                        mExceptionString = "Bad Request Received";
+                        throw new IOException("Bad Request Received");
+                    }
+                } else {
+
+                    if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL)) {
+                        finalBitSet = true;
+                    } else if (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL) {
+                        mRequestFinished = true;
+                    }
+
+                    /*
+                     * Determine if the packet length is larger then this device can receive
+                     */
+                    if (length > mParent.getMaxPacketSize()) {
+                        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE, null);
+                        throw new IOException("Packet received was too large");
+                    }
+
+                    /*
+                     * Determine if any headers were sent in the initial request
+                     */
+                    if (length > 3) {
+                        if (VERBOSE) Log.v(TAG, "sendReply reading " + (length-3));
+                        byte[] data = new byte[length - 3];
+                        bytesReceived = mInput.read(data);
+
+                        while (bytesReceived != data.length) {
+                            bytesReceived += mInput.read(data, bytesReceived, data.length
+                                    - bytesReceived);
+                        }
+                        if (VERBOSE) Log.v(TAG, "sendReply read " + bytesReceived);
+                        byte[] body = ObexHelper.updateHeaderSet(requestHeader, data);
+                        if (body != null) {
+                            mHasBody = true;
+                        }
+                        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
+                            mListener.setConnectionId(ObexHelper
+                                    .convertToLong(requestHeader.mConnectionID));
+                        } else {
+                            mListener.setConnectionId(1);
+                        }
+
+                        if (requestHeader.mAuthResp != null) {
+                            if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
+                                mExceptionString = "Authentication Failed";
+                                mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED, null);
+                                mClosed = true;
+                                requestHeader.mAuthResp = null;
+                                return false;
+                            }
+                            requestHeader.mAuthResp = null;
+                        }
+
+                        if (requestHeader.mAuthChall != null) {
+                            mParent.handleAuthChall(requestHeader);
+                            // send the auhtResp to the client
+                            replyHeader.mAuthResp = new byte[requestHeader.mAuthResp.length];
+                            System.arraycopy(requestHeader.mAuthResp, 0, replyHeader.mAuthResp, 0,
+                                    replyHeader.mAuthResp.length);
+                            requestHeader.mAuthResp = null;
+                            requestHeader.mAuthChall = null;
+                        }
+
+                        if (body != null) {
+                            mPrivateInput.writeBytes(body, 1);
+                        }
+                    }
+                }
+                return true;
+            }else {
+                return false;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Sends an ABORT message to the server. By calling this method, the
+     * corresponding input and output streams will be closed along with this
+     * object.
+     * @throws IOException if the transaction has already ended or if an OBEX
+     *         server called this method
+     */
+    public void abort() throws IOException {
+        throw new IOException("Called from a server");
+    }
+
+    /**
+     * Returns the headers that have been received during the operation.
+     * Modifying the object returned has no effect on the headers that are sent
+     * or retrieved.
+     * @return the headers received during this <code>Operation</code>
+     * @throws IOException if this <code>Operation</code> has been closed
+     */
+    public HeaderSet getReceivedHeader() throws IOException {
+        ensureOpen();
+        return requestHeader;
+    }
+
+    /**
+     * Specifies the headers that should be sent in the next OBEX message that
+     * is sent.
+     * @param headers the headers to send in the next message
+     * @throws IOException if this <code>Operation</code> has been closed or the
+     *         transaction has ended and no further messages will be exchanged
+     * @throws IllegalArgumentException if <code>headers</code> was not created
+     *         by a call to <code>ServerRequestHandler.createHeaderSet()</code>
+     */
+    public void sendHeaders(HeaderSet headers) throws IOException {
+        ensureOpen();
+
+        if (headers == null) {
+            throw new IOException("Headers may not be null");
+        }
+
+        int[] headerList = headers.getHeaderList();
+        if (headerList != null) {
+            for (int i = 0; i < headerList.length; i++) {
+                replyHeader.setHeader(headerList[i], headers.getHeader(headerList[i]));
+            }
+
+        }
+    }
+
+    /**
+     * Retrieves the response code retrieved from the server. Response codes are
+     * defined in the <code>ResponseCodes</code> interface.
+     * @return the response code retrieved from the server
+     * @throws IOException if an error occurred in the transport layer during
+     *         the transaction; if this method is called on a
+     *         <code>HeaderSet</code> object created by calling
+     *         <code>createHeaderSet</code> in a <code>ClientSession</code>
+     *         object; if this is called from a server
+     */
+    public int getResponseCode() throws IOException {
+        throw new IOException("Called from a server");
+    }
+
+    /**
+     * Always returns <code>null</code>
+     * @return <code>null</code>
+     */
+    public String getEncoding() {
+        return null;
+    }
+
+    /**
+     * Returns the type of content that the resource connected to is providing.
+     * E.g. if the connection is via HTTP, then the value of the content-type
+     * header field is returned.
+     * @return the content type of the resource that the URL references, or
+     *         <code>null</code> if not known
+     */
+    public String getType() {
+        try {
+            return (String)requestHeader.getHeader(HeaderSet.TYPE);
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the length of the content which is being provided. E.g. if the
+     * connection is via HTTP, then the value of the content-length header field
+     * is returned.
+     * @return the content length of the resource that this connection's URL
+     *         references, or -1 if the content length is not known
+     */
+    public long getLength() {
+        try {
+            Long temp = (Long)requestHeader.getHeader(HeaderSet.LENGTH);
+
+            if (temp == null) {
+                return -1;
+            } else {
+                return temp.longValue();
+            }
+        } catch (IOException e) {
+            return -1;
+        }
+    }
+
+    public int getMaxPacketSize() {
+        return mMaxPacketLength - 6 - getHeaderLength();
+    }
+
+    public int getHeaderLength() {
+        long id = mListener.getConnectionId();
+        if (id == -1) {
+            replyHeader.mConnectionID = null;
+        } else {
+            replyHeader.mConnectionID = ObexHelper.convertToByteArray(id);
+        }
+
+        byte[] headerArray = ObexHelper.createHeader(replyHeader, false);
+
+        return headerArray.length;
+    }
+
+    /**
+     * Open and return an input stream for a connection.
+     * @return an input stream
+     * @throws IOException if an I/O error occurs
+     */
+    public InputStream openInputStream() throws IOException {
+        ensureOpen();
+        return mPrivateInput;
+    }
+
+    /**
+     * Open and return a data input stream for a connection.
+     * @return an input stream
+     * @throws IOException if an I/O error occurs
+     */
+    public DataInputStream openDataInputStream() throws IOException {
+        return new DataInputStream(openInputStream());
+    }
+
+    /**
+     * Open and return an output stream for a connection.
+     * @return an output stream
+     * @throws IOException if an I/O error occurs
+     */
+    public OutputStream openOutputStream() throws IOException {
+        ensureOpen();
+
+        if (mPrivateOutputOpen) {
+            throw new IOException("no more input streams available, stream already opened");
+        }
+
+        if (!mRequestFinished) {
+            throw new IOException("no  output streams available ,request not finished");
+        }
+
+        if (mPrivateOutput == null) {
+            mPrivateOutput = new PrivateOutputStream(this, getMaxPacketSize());
+        }
+        mPrivateOutputOpen = true;
+        return mPrivateOutput;
+    }
+
+    /**
+     * Open and return a data output stream for a connection.
+     * @return an output stream
+     * @throws IOException if an I/O error occurs
+     */
+    public DataOutputStream openDataOutputStream() throws IOException {
+        return new DataOutputStream(openOutputStream());
+    }
+
+    /**
+     * Closes the connection and ends the transaction
+     * @throws IOException if the operation has already ended or is closed
+     */
+    public void close() throws IOException {
+        ensureOpen();
+        mClosed = true;
+    }
+
+    /**
+     * Verifies that the connection is open and no exceptions should be thrown.
+     * @throws IOException if an exception needs to be thrown
+     */
+    public void ensureOpen() throws IOException {
+        if (mExceptionString != null) {
+            throw new IOException(mExceptionString);
+        }
+        if (mClosed) {
+            throw new IOException("Operation has already ended");
+        }
+    }
+
+    /**
+     * Verifies that additional information may be sent. In other words, the
+     * operation is not done.
+     * <P>
+     * Included to implement the BaseStream interface only. It does not do
+     * anything on the server side since the operation of the Operation object
+     * is not done until after the handler returns from its method.
+     * @throws IOException if the operation is completed
+     */
+    public void ensureNotDone() throws IOException {
+    }
+
+    /**
+     * Called when the output or input stream is closed. It does not do anything
+     * on the server side since the operation of the Operation object is not
+     * done until after the handler returns from its method.
+     * @param inStream <code>true</code> if the input stream is closed;
+     *        <code>false</code> if the output stream is closed
+     * @throws IOException if an IO error occurs
+     */
+    public void streamClosed(boolean inStream) throws IOException {
+
+    }
+
+    public void noEndofBody() {
+        mEndofBody = false;
+    }
+
+    public boolean isAborted() {
+        try {
+            if (mInput.available() != 0) {
+               int headerID = mInput.read();
+               int length = mInput.read();
+               length = (length << 8) + mInput.read();
+               if (length > 3) {
+                  byte[] temp = new byte[length - 3];
+                  // First three bytes already read, compensating for this
+                  int bytesReceived = mInput.read(temp);
+                  while (bytesReceived != temp.length) {
+                      bytesReceived += mInput.read(temp, bytesReceived,
+                                       temp.length - bytesReceived);
+                  }
+                  if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
+                     return true;
+                  }
+               }
+            }
+        } catch (IOException e) {
+            Log.e(TAG,"IOException = "+e.toString());
+        }
+        return false;
+    }
+}
diff --git a/btobex/javax/btobex/ServerRequestHandler.java b/btobex/javax/btobex/ServerRequestHandler.java
new file mode 100644
index 0000000..8ea01c4
--- /dev/null
+++ b/btobex/javax/btobex/ServerRequestHandler.java
@@ -0,0 +1,348 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+/**
+ * The <code>ServerRequestHandler</code> class defines an event listener that
+ * will respond to OBEX requests made to the server.
+ * <P>
+ * The <code>onConnect()</code>, <code>onSetPath()</code>,
+ * <code>onDelete()</code>, <code>onGet()</code>, and <code>onPut()</code>
+ * methods may return any response code defined in the
+ * <code>ResponseCodes</code> class except for <code>OBEX_HTTP_CONTINUE</code>.
+ * If <code>OBEX_HTTP_CONTINUE</code> or a value not defined in the
+ * <code>ResponseCodes</code> class is returned, the server implementation will
+ * send an <code>OBEX_HTTP_INTERNAL_ERROR</code> response to the client.
+ * <P>
+ * <STRONG>Connection ID and Target Headers</STRONG>
+ * <P>
+ * According to the IrOBEX specification, a packet may not contain a Connection
+ * ID and Target header. Since the Connection ID header is managed by the
+ * implementation, it will not send a Connection ID header, if a Connection ID
+ * was specified, in a packet that has a Target header. In other words, if an
+ * application adds a Target header to a <code>HeaderSet</code> object used in
+ * an OBEX operation and a Connection ID was specified, no Connection ID will be
+ * sent in the packet containing the Target header.
+ * <P>
+ * <STRONG>CREATE-EMPTY Requests</STRONG>
+ * <P>
+ * A CREATE-EMPTY request allows clients to create empty objects on the server.
+ * When a CREATE-EMPTY request is received, the <code>onPut()</code> method will
+ * be called by the implementation. To differentiate between a normal PUT
+ * request and a CREATE-EMPTY request, an application must open the
+ * <code>InputStream</code> from the <code>Operation</code> object passed to the
+ * <code>onPut()</code> method. For a PUT request, the application will be able
+ * to read Body data from this <code>InputStream</code>. For a CREATE-EMPTY
+ * request, there will be no Body data to read. Therefore, a call to
+ * <code>InputStream.read()</code> will return -1.
+ * @hide
+ */
+public class ServerRequestHandler {
+
+    private long mConnectionId;
+
+    /**
+     * Creates a <code>ServerRequestHandler</code>.
+     */
+    protected ServerRequestHandler() {
+        /*
+         * A connection ID of -1 implies there is no conenction ID
+         */
+        mConnectionId = -1;
+    }
+
+    /**
+     * Sets the connection ID header to include in the reply packets.
+     * @param connectionId the connection ID to use; -1 if no connection ID
+     *        should be sent
+     * @throws IllegalArgumentException if <code>id</code> is not in the range
+     *         -1 to 2<sup>32</sup>-1
+     */
+    public void setConnectionId(final long connectionId) {
+        if ((connectionId < -1) || (connectionId > 0xFFFFFFFFL)) {
+            throw new IllegalArgumentException("Illegal Connection ID");
+        }
+        mConnectionId = connectionId;
+    }
+
+    /**
+     * Retrieves the connection ID that is being used in the present connection.
+     * This method will return -1 if no connection ID is being used.
+     * @return the connection id being used or -1 if no connection ID is being
+     *         used
+     */
+    public long getConnectionId() {
+        return mConnectionId;
+    }
+
+    /**
+     * Called when a CONNECT request is received.
+     * <P>
+     * If this method is not implemented by the class that extends this class,
+     * <code>onConnect()</code> will always return an <code>OBEX_HTTP_OK</code>
+     * response code.
+     * <P>
+     * The headers received in the request can be retrieved from the
+     * <code>request</code> argument. The headers that should be sent in the
+     * reply must be specified in the <code>reply</code> argument.
+     * @param request contains the headers sent by the client;
+     *        <code>request</code> will never be <code>null</code>
+     * @param reply the headers that should be sent in the reply;
+     *        <code>reply</code> will never be <code>null</code>
+     * @return a response code defined in <code>ResponseCodes</code> that will
+     *         be returned to the client; if an invalid response code is
+     *         provided, the <code>OBEX_HTTP_INTERNAL_ERROR</code> response code
+     *         will be used
+     */
+    public int onConnect(HeaderSet request, HeaderSet reply) {
+        return ResponseCodes.OBEX_HTTP_OK;
+    }
+
+    /**
+     * Called when a DISCONNECT request is received.
+     * <P>
+     * The headers received in the request can be retrieved from the
+     * <code>request</code> argument. The headers that should be sent in the
+     * reply must be specified in the <code>reply</code> argument.
+     * @param request contains the headers sent by the client;
+     *        <code>request</code> will never be <code>null</code>
+     * @param reply the headers that should be sent in the reply;
+     *        <code>reply</code> will never be <code>null</code>
+     */
+    public void onDisconnect(HeaderSet request, HeaderSet reply) {
+    }
+
+    /**
+     * Called when a SETPATH request is received.
+     * <P>
+     * If this method is not implemented by the class that extends this class,
+     * <code>onSetPath()</code> will always return an
+     * <code>OBEX_HTTP_NOT_IMPLEMENTED</code> response code.
+     * <P>
+     * The headers received in the request can be retrieved from the
+     * <code>request</code> argument. The headers that should be sent in the
+     * reply must be specified in the <code>reply</code> argument.
+     * @param request contains the headers sent by the client;
+     *        <code>request</code> will never be <code>null</code>
+     * @param reply the headers that should be sent in the reply;
+     *        <code>reply</code> will never be <code>null</code>
+     * @param backup <code>true</code> if the client requests that the server
+     *        back up one directory before changing to the path described by
+     *        <code>name</code>; <code>false</code> to apply the request to the
+     *        present path
+     * @param create <code>true</code> if the path should be created if it does
+     *        not already exist; <code>false</code> if the path should not be
+     *        created if it does not exist and an error code should be returned
+     * @return a response code defined in <code>ResponseCodes</code> that will
+     *         be returned to the client; if an invalid response code is
+     *         provided, the <code>OBEX_HTTP_INTERNAL_ERROR</code> response code
+     *         will be used
+     */
+    public int onSetPath(HeaderSet request, HeaderSet reply, boolean backup, boolean create) {
+
+        return ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED;
+    }
+
+    /**
+     * Called when a DELETE request is received.
+     * <P>
+     * If this method is not implemented by the class that extends this class,
+     * <code>onDelete()</code> will always return an
+     * <code>OBEX_HTTP_NOT_IMPLEMENTED</code> response code.
+     * <P>
+     * The headers received in the request can be retrieved from the
+     * <code>request</code> argument. The headers that should be sent in the
+     * reply must be specified in the <code>reply</code> argument.
+     * @param request contains the headers sent by the client;
+     *        <code>request</code> will never be <code>null</code>
+     * @param reply the headers that should be sent in the reply;
+     *        <code>reply</code> will never be <code>null</code>
+     * @return a response code defined in <code>ResponseCodes</code> that will
+     *         be returned to the client; if an invalid response code is
+     *         provided, the <code>OBEX_HTTP_INTERNAL_ERROR</code> response code
+     *         will be used
+     */
+    public int onDelete(HeaderSet request, HeaderSet reply) {
+        return ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED;
+    }
+
+    /**
+     * Called when a COPY request is received.
+     * <P>
+     * If this method is not implemented by the class that extends this class,
+     * <code>onCopy()</code> will always return an
+     * <code>OBEX_HTTP_NOT_IMPLEMENTED</code> response code.
+     * <P>
+     * The headers received in the request can be retrieved from the
+     * <code>request</code> argument. The headers that should be sent in the
+     * reply must be specified in the <code>reply</code> argument.
+     * @param request contains the headers sent by the client;
+     *        <code>request</code> will never be <code>null</code>
+     * @param reply the headers that should be sent in the reply;
+     *        <code>reply</code> will never be <code>null</code>
+     * @return a response code defined in <code>ResponseCodes</code> that will
+     *         be returned to the client; if an invalid response code is
+     *         provided, the <code>OBEX_HTTP_INTERNAL_ERROR</code> response code
+     *         will be used
+     */
+    public int onCopy(HeaderSet request, HeaderSet reply) {
+        return ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED;
+    }
+
+    /**
+     * Called when a RENAME request is received.
+     * <P>
+     * If this method is not implemented by the class that extends this class,
+     * <code>onRename()</code> will always return an
+     * <code>OBEX_HTTP_NOT_IMPLEMENTED</code> response code.
+     * <P>
+     * The headers received in the request can be retrieved from the
+     * <code>request</code> argument. The headers that should be sent in the
+     * reply must be specified in the <code>reply</code> argument.
+     * @param request contains the headers sent by the client;
+     *        <code>request</code> will never be <code>null</code>
+     * @param reply the headers that should be sent in the reply;
+     *        <code>reply</code> will never be <code>null</code>
+     * @return a response code defined in <code>ResponseCodes</code> that will
+     *         be returned to the client; if an invalid response code is
+     *         provided, the <code>OBEX_HTTP_INTERNAL_ERROR</code> response code
+     *         will be used
+     */
+    public int onRename(HeaderSet request, HeaderSet reply) {
+        return ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED;
+    }
+
+    /**
+     * Called when a SET Permission request is received.
+     * <P>
+     * If this method is not implemented by the class that extends this class,
+     * <code>onSetPermissions()</code> will always return an
+     * <code>OBEX_HTTP_NOT_IMPLEMENTED</code> response code.
+     * <P>
+     * The headers received in the request can be retrieved from the
+     * <code>request</code> argument. The headers that should be sent in the
+     * reply must be specified in the <code>reply</code> argument.
+     * @param request contains the headers sent by the client;
+     *        <code>request</code> will never be <code>null</code>
+     * @param reply the headers that should be sent in the reply;
+     *        <code>reply</code> will never be <code>null</code>
+     * @return a response code defined in <code>ResponseCodes</code> that will
+     *         be returned to the client; if an invalid response code is
+     *         provided, the <code>OBEX_HTTP_INTERNAL_ERROR</code> response code
+     *         will be used
+     */
+    public int onSetPermissions(HeaderSet request, HeaderSet reply) {
+        return ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED;
+    }
+
+
+    /**
+     * Called when a ABORT request is received.
+     */
+    public int onAbort(HeaderSet request, HeaderSet reply) {
+        return ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED;
+    }
+
+    /**
+     * Called when a PUT request is received.
+     * <P>
+     * If this method is not implemented by the class that extends this class,
+     * <code>onPut()</code> will always return an
+     * <code>OBEX_HTTP_NOT_IMPLEMENTED</code> response code.
+     * <P>
+     * If an ABORT request is received during the processing of a PUT request,
+     * <code>op</code> will be closed by the implementation.
+     * @param operation contains the headers sent by the client and allows new
+     *        headers to be sent in the reply; <code>op</code> will never be
+     *        <code>null</code>
+     * @return a response code defined in <code>ResponseCodes</code> that will
+     *         be returned to the client; if an invalid response code is
+     *         provided, the <code>OBEX_HTTP_INTERNAL_ERROR</code> response code
+     *         will be used
+     */
+    public int onPut(Operation operation) {
+        return ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED;
+    }
+
+    /**
+     * Called when a GET request is received.
+     * <P>
+     * If this method is not implemented by the class that extends this class,
+     * <code>onGet()</code> will always return an
+     * <code>OBEX_HTTP_NOT_IMPLEMENTED</code> response code.
+     * <P>
+     * If an ABORT request is received during the processing of a GET request,
+     * <code>op</code> will be closed by the implementation.
+     * @param operation contains the headers sent by the client and allows new
+     *        headers to be sent in the reply; <code>op</code> will never be
+     *        <code>null</code>
+     * @return a response code defined in <code>ResponseCodes</code> that will
+     *         be returned to the client; if an invalid response code is
+     *         provided, the <code>OBEX_HTTP_INTERNAL_ERROR</code> response code
+     *         will be used
+     */
+    public int onGet(Operation operation) {
+        return ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED;
+    }
+
+    /**
+     * Called when this object attempts to authenticate a client and the
+     * authentication request fails because the response digest in the
+     * authentication response header was wrong.
+     * <P>
+     * If this method is not implemented by the class that extends this class,
+     * this method will do nothing.
+     * @param userName the user name returned in the authentication response;
+     *        <code>null</code> if no user name was provided in the response
+     */
+    public void onAuthenticationFailure(byte[] userName) {
+    }
+
+    /**
+     * Called by ServerSession to update the status of current transaction
+     * <P>
+     * If this method is not implemented by the class that extends this class,
+     * this method will do nothing.
+     */
+    public void updateStatus(String message) {
+    }
+
+    /**
+     * Called when session is closed.
+     * <P>
+     * If this method is not implemented by the class that extends this class,
+     * this method will do nothing.
+     */
+    public void onClose() {
+    }
+}
diff --git a/btobex/javax/btobex/ServerSession.java b/btobex/javax/btobex/ServerSession.java
new file mode 100644
index 0000000..49879cc
--- /dev/null
+++ b/btobex/javax/btobex/ServerSession.java
@@ -0,0 +1,830 @@
+/*
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import android.util.Log;
+
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * This class in an implementation of the OBEX ServerSession.
+ * @hide
+ */
+public final class ServerSession extends ObexSession implements Runnable {
+
+    private static final String TAG = "Obex ServerSession";
+
+    private static final boolean VERBOSE = false;
+
+    private ObexTransport mTransport;
+
+    private InputStream mInput;
+
+    private OutputStream mOutput;
+
+    private ServerRequestHandler mListener;
+
+    private Thread mProcessThread;
+
+    private int mMaxPacketLength;
+
+    private boolean mClosed;
+
+    public ObexHelper mSrmServer;
+    /**
+     * Creates new ServerSession.
+     * @param trans the connection to the client
+     * @param handler the event listener that will process requests
+     * @param auth the authenticator to use with this connection
+     * @throws IOException if an error occurred while opening the input and
+     *         output streams
+     */
+    public ServerSession(ObexTransport trans, ServerRequestHandler handler, Authenticator auth)
+            throws IOException {
+        mAuthenticator = auth;
+        mTransport = trans;
+        mInput = mTransport.openInputStream();
+        mOutput = mTransport.openOutputStream();
+        mListener = handler;
+        mMaxPacketLength = 256;
+        mSrmServer = new ObexHelper();
+        mClosed = false;
+        mProcessThread = new Thread(this);
+        mProcessThread.start();
+    }
+
+    public void setMaxPacketSize(int size) {
+        if (VERBOSE)  Log.v(TAG, "setMaxPacketSize" + size);
+        mMaxPacketLength = size;
+    }
+
+    public int getMaxPacketSize() {
+        return mMaxPacketLength;
+    }
+
+    /**
+     * Processes requests made to the server and forwards them to the
+     * appropriate event listener.
+     */
+    public void run() {
+        try {
+
+            boolean done = false;
+            while (!done && !mClosed) {
+                int requestType = mInput.read();
+                if (VERBOSE)  Log.v(TAG, "run requestType "+requestType);
+                switch (requestType) {
+                    case ObexHelper.OBEX_OPCODE_CONNECT:
+                        handleConnectRequest();
+                        break;
+
+                    case ObexHelper.OBEX_OPCODE_DISCONNECT:
+                        handleDisconnectRequest();
+                        done = true;
+                        break;
+
+                    case ObexHelper.OBEX_OPCODE_GET:
+                    case ObexHelper.OBEX_OPCODE_GET_FINAL:
+                        handleGetRequest(requestType);
+                        break;
+
+                    case ObexHelper.OBEX_OPCODE_PUT:
+                    case ObexHelper.OBEX_OPCODE_PUT_FINAL:
+                        handlePutRequest(requestType);
+                        break;
+
+                    case ObexHelper.OBEX_OPCODE_SETPATH:
+                        handleSetPathRequest();
+                        break;
+                    case ObexHelper.OBEX_OPCODE_ABORT:
+                        handleAbortRequest();
+                        break;
+                    case ObexHelper.OBEX_OPCODE_ACTION:
+                        handleActionRequest();
+                        break;
+                    case -1:
+                        done = true;
+                        break;
+
+                    default:
+
+                        /*
+                         * Received a request type that is not recognized so I am
+                         * just going to read the packet and send a not implemented
+                         * to the client
+                         */
+                        int length = mInput.read();
+                        length = (length << 8) + mInput.read();
+                        for (int i = 3; i < length; i++) {
+                            mInput.read();
+                        }
+                        sendResponse(ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED, null);
+                }
+            }
+
+        } catch (NullPointerException e) {
+            Log.d(TAG, e.toString());
+        } catch (Exception e) {
+            Log.d(TAG, e.toString());
+        }
+        close();
+    }
+
+    /**
+     * Handles a ABORT request from a client. This method will read the rest of
+     * the request from the client. Assuming the request is valid, it will
+     * create a <code>HeaderSet</code> object to pass to the
+     * <code>ServerRequestHandler</code> object. After the handler processes the
+     * request, this method will create a reply message to send to the server.
+     *
+     * @throws IOException if an error occurred at the transport layer
+     */
+    private void handleAbortRequest() throws IOException {
+        int code = ResponseCodes.OBEX_HTTP_OK;
+        HeaderSet request = new HeaderSet();
+        HeaderSet reply = new HeaderSet();
+
+        int length = mInput.read();
+        length = (length << 8) + mInput.read();
+        if (length > mMaxPacketLength) {
+            code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
+        } else {
+            for (int i = 3; i < length; i++) {
+                mInput.read();
+            }
+            code = mListener.onAbort(request, reply);
+            Log.v(TAG, "onAbort request handler return value- " + code);
+            code = validateResponseCode(code);
+        }
+        sendResponse(code, null);
+    }
+
+    /**
+     * Handles a ACTION request from a client. This method will read the rest of
+     * the request from the client. Assuming the request is valid, it will
+     * create a <code>HeaderSet</code> object to pass to the
+     * <code>ServerRequestHandler</code> object. After the handler processes the
+     * request, this method will create a reply message to send to the server.
+     *
+     * @throws IOException if an error occurred at the transport layer
+     */
+    private void handleActionRequest() throws IOException {
+        int code = ResponseCodes.OBEX_HTTP_OK;
+        HeaderSet request = new HeaderSet();
+        HeaderSet reply = new HeaderSet();
+        int length = mInput.read();
+        int bytesReceived;
+
+        length = (length << 8) + mInput.read();
+
+        if (length > mMaxPacketLength) {
+            code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
+        } else {
+            byte[] headers = new byte[length - 3];
+            bytesReceived = mInput.read(headers);
+
+            while (bytesReceived != headers.length) {
+                 bytesReceived += mInput.read(headers, bytesReceived, headers.length
+                                                                    - bytesReceived);
+            }
+            if (VERBOSE)  Log.v(TAG,"onAction headers.length = " + headers.length);
+            ObexHelper.updateHeaderSet(request, headers);
+
+            Byte actionId = (Byte)request.getHeader(HeaderSet.ACTION_ID);
+            if (actionId == ObexHelper.OBEX_ACTION_COPY) {
+                code = mListener.onCopy(request, reply);
+            } else if (actionId == ObexHelper.OBEX_ACTION_MOVE_RENAME) {
+                code = mListener.onRename(request, reply);
+            } else if (actionId == ObexHelper.OBEX_ACTION_SET_PERM) {
+                code = mListener.onSetPermissions(request, reply);
+            }
+            if (VERBOSE)  Log.v(TAG, "onAction request handler return value- " + code);
+            code = validateResponseCode(code);
+        }
+        sendResponse(code, null);
+    }
+
+    /**
+     * Handles a PUT request from a client. This method will provide a
+     * <code>ServerOperation</code> object to the request handler. The
+     * <code>ServerOperation</code> object will handle the rest of the request.
+     * It will also send replies and receive requests until the final reply
+     * should be sent. When the final reply should be sent, this method will get
+     * the response code to use and send the reply. The
+     * <code>ServerOperation</code> object will always reply with a
+     * OBEX_HTTP_CONTINUE reply. It will only reply if further information is
+     * needed.
+     * @param type the type of request received; either 0x02 or 0x82
+     * @throws IOException if an error occurred at the transport layer
+     */
+    private void handlePutRequest(int type) throws IOException {
+        if (VERBOSE)  Log.v(TAG, "handlePutRequest");
+
+        ServerOperation op = new ServerOperation(this, mInput, type, mMaxPacketLength, mListener);
+        try {
+            int response = -1;
+
+            Byte srm = (Byte)op.requestHeader.getHeader(HeaderSet.SINGLE_RESPONSE_MODE);
+            if (srm == ObexHelper.OBEX_SRM_ENABLED) {
+                if (VERBOSE)  Log.v(TAG, "handlePutRequest srm == ObexHelper.OBEX_SRM_ENABLED");
+                if (mSrmServer.getLocalSrmCapability() == ObexHelper.SRM_CAPABLE) {
+                    if (VERBOSE)  Log.v(TAG, "ObexHelper.getLocalSrmCapability() == ObexHelper.SRM_CAPABLE");
+                    op.replyHeader.setHeader(HeaderSet.SINGLE_RESPONSE_MODE, ObexHelper.OBEX_SRM_ENABLED);
+                    if (mSrmServer.getLocalSrmpWait()) {
+                        if (VERBOSE)  Log.v(TAG, "handlePutRequest: Server SRMP header set to WAIT");
+                        op.replyHeader.setHeader(HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER, ObexHelper.OBEX_SRM_PARAM_WAIT);
+                    }
+                } else {
+                    if (VERBOSE)  Log.v(TAG, "ObexHelper.getLocalSrmCapability() == ObexHelper.SRM_INCAPABLE");
+                    op.replyHeader.setHeader(HeaderSet.SINGLE_RESPONSE_MODE, ObexHelper.OBEX_SRM_DISABLED);
+                }
+            }
+
+            if ((op.finalBitSet) && !op.isValidBody()) {
+                response = validateResponseCode(mListener
+                        .onDelete(op.requestHeader, op.replyHeader));
+            } else {
+                response = validateResponseCode(mListener.onPut(op));
+            }
+            if (response != ResponseCodes.OBEX_HTTP_OK && !op.isAborted) {
+                if (VERBOSE) Log.v(TAG, "handlePutRequest pre != HTTP_OK sendReply");
+                op.sendReply(response, false,false);
+            } else if (!op.isAborted) {
+                // wait for the final bit
+                while (!op.finalBitSet) {
+                    if (VERBOSE) Log.v(TAG, "handlePutRequest pre looped sendReply");
+                    op.sendReply(ResponseCodes.OBEX_HTTP_CONTINUE, op.mSingleResponseActive,false);
+                }
+                op.sendReply(response, false,false);
+            }
+        } catch (Exception e) {
+            /*To fix bugs in aborted cases,
+             *(client abort file transfer prior to the last packet which has the end of body header,
+             *internal error should not be sent because server has already replied with
+             *OK response in "sendReply")
+             */
+            if (!op.isAborted) {
+                sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
+            }
+        }
+    }
+
+    /**
+     * Handles a GET request from a client. This method will provide a
+     * <code>ServerOperation</code> object to the request handler. The
+     * <code>ServerOperation</code> object will handle the rest of the request.
+     * It will also send replies and receive requests until the final reply
+     * should be sent. When the final reply should be sent, this method will get
+     * the response code to use and send the reply. The
+     * <code>ServerOperation</code> object will always reply with a
+     * OBEX_HTTP_CONTINUE reply. It will only reply if further information is
+     * needed.
+     * @param type the type of request received; either 0x03 or 0x83
+     * @throws IOException if an error occurred at the transport layer
+     */
+    private void handleGetRequest(int type) throws IOException {
+        if (VERBOSE)  Log.v(TAG, "handleGetRequest");
+
+        ServerOperation op = new ServerOperation(this, mInput, type, mMaxPacketLength, mListener);
+        try {
+            Byte srm = (Byte)op.requestHeader.getHeader(HeaderSet.SINGLE_RESPONSE_MODE);
+            if (VERBOSE)  Log.v(TAG, "handleGetRequest srm status" + srm );
+            if (srm == ObexHelper.OBEX_SRM_ENABLED) {
+                if (VERBOSE)  Log.v(TAG, "handleGetRequest srm == ObexHelper.OBEX_SRM_ENABLED");
+                if (mSrmServer.getLocalSrmCapability() == ObexHelper.SRM_CAPABLE) {
+                    if (VERBOSE)  Log.v(TAG, "ObexHelper.getLocalSrmCapability()" +
+                                                                       "=ObexHelper.SRM_CAPABLE");
+                    op.replyHeader.setHeader(HeaderSet.SINGLE_RESPONSE_MODE,
+                                                                     ObexHelper.OBEX_SRM_ENABLED);
+                    if (mSrmServer.getLocalSrmpWait()) {
+                        if (VERBOSE)  Log.v(TAG, "GetRequest:Server SRMP header set to WAIT");
+                        op.replyHeader.setHeader(HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER,
+                                                                  ObexHelper.OBEX_SRM_PARAM_WAIT);
+                    }
+                } else {
+                    if (VERBOSE)  Log.v(TAG, "ObexHelper.getLocalSrmCapability() == "+
+                                                                      "ObexHelper.SRM_INCAPABLE");
+                    op.replyHeader.setHeader(HeaderSet.SINGLE_RESPONSE_MODE,
+                                                                    ObexHelper.OBEX_SRM_DISABLED);
+                }
+            }
+
+            int response = validateResponseCode(mListener.onGet(op));
+
+            if (!op.isAborted) {
+                op.sendReply(response, false,false);
+            } else {
+                if(mSrmServer.getLocalSrmStatus() == ObexHelper.LOCAL_SRM_ENABLED) {
+                  sendResponse(ResponseCodes.OBEX_HTTP_OK, null);
+                }
+            }
+        } catch (Exception e) {
+            sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
+        }
+    }
+
+    /**
+     * Send standard response.
+     * @param code the response code to send
+     * @param header the headers to include in the response
+     * @throws IOException if an IO error occurs
+     */
+    public void sendResponse(int code, byte[] header) throws IOException {
+        int totalLength = 3;
+        byte[] data = null;
+        if (VERBOSE) Log.v(TAG,"sendResponse code "+code+" header : "+header);
+        if (header != null) {
+            totalLength += header.length;
+            if (VERBOSE) Log.v(TAG,"header != null totalLength = "+totalLength);
+            data = new byte[totalLength];
+            data[0] = (byte)code;
+            data[1] = (byte)(totalLength >> 8);
+            data[2] = (byte)totalLength;
+            System.arraycopy(header, 0, data, 3, header.length);
+        } else {
+            data = new byte[totalLength];
+            data[0] = (byte)code;
+            data[1] = (byte)0x00;
+            data[2] = (byte)totalLength;
+        }
+        mOutput.write(data);
+        mOutput.flush();
+    }
+
+    /**
+     * Handles a SETPATH request from a client. This method will read the rest
+     * of the request from the client. Assuming the request is valid, it will
+     * create a <code>HeaderSet</code> object to pass to the
+     * <code>ServerRequestHandler</code> object. After the handler processes the
+     * request, this method will create a reply message to send to the server
+     * with the response code provided.
+     * @throws IOException if an error occurred at the transport layer
+     */
+    private void handleSetPathRequest() throws IOException {
+        int length;
+        int flags;
+        @SuppressWarnings("unused")
+        int constants;
+        int totalLength = 3;
+        byte[] head = null;
+        int code = -1;
+        int bytesReceived;
+        HeaderSet request = new HeaderSet();
+        HeaderSet reply = new HeaderSet();
+
+        length = mInput.read();
+        length = (length << 8) + mInput.read();
+        flags = mInput.read();
+        constants = mInput.read();
+
+        if (length > mMaxPacketLength) {
+            code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
+            totalLength = 3;
+        } else {
+            if (length > 5) {
+                byte[] headers = new byte[length - 5];
+                bytesReceived = mInput.read(headers);
+
+                while (bytesReceived != headers.length) {
+                    bytesReceived += mInput.read(headers, bytesReceived, headers.length
+                            - bytesReceived);
+                }
+
+                ObexHelper.updateHeaderSet(request, headers);
+
+                if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
+                    mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
+                } else {
+                    mListener.setConnectionId(1);
+                }
+                // the Auth chan is initiated by the server, client sent back the authResp .
+                if (request.mAuthResp != null) {
+                    if (!handleAuthResp(request.mAuthResp)) {
+                        code = ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
+                        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,
+                                request.mAuthResp));
+                    }
+                    request.mAuthResp = null;
+                }
+            }
+
+            if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
+                // the Auth challenge is initiated by the client
+                // the server will send back the authResp to the client
+                if (request.mAuthChall != null) {
+                    handleAuthChall(request);
+                    reply.mAuthResp = new byte[request.mAuthResp.length];
+                    System.arraycopy(request.mAuthResp, 0, reply.mAuthResp, 0,
+                            reply.mAuthResp.length);
+                    request.mAuthChall = null;
+                    request.mAuthResp = null;
+                }
+                boolean backup = false;
+                boolean create = true;
+                if (!((flags & 1) == 0)) {
+                    backup = true;
+                }
+                if (!((flags & 2) == 0)) {
+                    create = false;
+                }
+
+                try {
+                    code = mListener.onSetPath(request, reply, backup, create);
+                } catch (Exception e) {
+                    sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
+                    return;
+                }
+
+                code = validateResponseCode(code);
+
+                if (reply.nonce != null) {
+                    mChallengeDigest = new byte[16];
+                    System.arraycopy(reply.nonce, 0, mChallengeDigest, 0, 16);
+                } else {
+                    mChallengeDigest = null;
+                }
+
+                long id = mListener.getConnectionId();
+                if (id == -1) {
+                    reply.mConnectionID = null;
+                } else {
+                    reply.mConnectionID = ObexHelper.convertToByteArray(id);
+                }
+
+                head = ObexHelper.createHeader(reply, false);
+                totalLength += head.length;
+
+                if (totalLength > mMaxPacketLength) {
+                    totalLength = 3;
+                    head = null;
+                    code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
+                }
+            }
+        }
+
+        // Compute Length of OBEX SETPATH packet
+        byte[] replyData = new byte[totalLength];
+        replyData[0] = (byte)code;
+        replyData[1] = (byte)(totalLength >> 8);
+        replyData[2] = (byte)totalLength;
+        if (head != null) {
+            System.arraycopy(head, 0, replyData, 3, head.length);
+        }
+        /*
+         * Write the OBEX SETPATH packet to the server. Byte 0: response code
+         * Byte 1&2: Connect Packet Length Byte 3 to n: headers
+         */
+        mOutput.write(replyData);
+        mOutput.flush();
+    }
+
+    /**
+     * Handles a disconnect request from a client. This method will read the
+     * rest of the request from the client. Assuming the request is valid, it
+     * will create a <code>HeaderSet</code> object to pass to the
+     * <code>ServerRequestHandler</code> object. After the handler processes the
+     * request, this method will create a reply message to send to the server.
+     * @throws IOException if an error occurred at the transport layer
+     */
+    private void handleDisconnectRequest() throws IOException {
+        int length;
+        int code = ResponseCodes.OBEX_HTTP_OK;
+        int totalLength = 3;
+        byte[] head = null;
+        int bytesReceived;
+        HeaderSet request = new HeaderSet();
+        HeaderSet reply = new HeaderSet();
+
+        length = mInput.read();
+        length = (length << 8) + mInput.read();
+
+        if (length > mMaxPacketLength) {
+            code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
+            totalLength = 3;
+        } else {
+            if (length > 3) {
+                byte[] headers = new byte[length - 3];
+                bytesReceived = mInput.read(headers);
+
+                while (bytesReceived != headers.length) {
+                    bytesReceived += mInput.read(headers, bytesReceived, headers.length
+                            - bytesReceived);
+                }
+
+                ObexHelper.updateHeaderSet(request, headers);
+            }
+
+            if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
+                mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
+            } else {
+                mListener.setConnectionId(1);
+            }
+
+            if (request.mAuthResp != null) {
+                if (!handleAuthResp(request.mAuthResp)) {
+                    code = ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
+                    mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,
+                            request.mAuthResp));
+                }
+                request.mAuthResp = null;
+            }
+
+            if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
+
+                if (request.mAuthChall != null) {
+                    handleAuthChall(request);
+                    request.mAuthChall = null;
+                }
+
+                try {
+                    mListener.onDisconnect(request, reply);
+                } catch (Exception e) {
+                    sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
+                    return;
+                }
+
+                long id = mListener.getConnectionId();
+                if (id == -1) {
+                    reply.mConnectionID = null;
+                } else {
+                    reply.mConnectionID = ObexHelper.convertToByteArray(id);
+                }
+
+                head = ObexHelper.createHeader(reply, false);
+                totalLength += head.length;
+
+                if (totalLength > mMaxPacketLength) {
+                    totalLength = 3;
+                    head = null;
+                    code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
+                }
+            }
+        }
+
+        // Compute Length of OBEX CONNECT packet
+        byte[] replyData;
+        if (head != null) {
+            replyData = new byte[3 + head.length];
+        } else {
+            replyData = new byte[3];
+        }
+        replyData[0] = (byte)code;
+        replyData[1] = (byte)(totalLength >> 8);
+        replyData[2] = (byte)totalLength;
+        if (head != null) {
+            System.arraycopy(head, 0, replyData, 3, head.length);
+        }
+        /*
+         * Write the OBEX DISCONNECT packet to the server. Byte 0: response code
+         * Byte 1&2: Connect Packet Length Byte 3 to n: headers
+         */
+        mOutput.write(replyData);
+        mOutput.flush();
+    }
+
+    /**
+     * Handles a connect request from a client. This method will read the rest
+     * of the request from the client. Assuming the request is valid, it will
+     * create a <code>HeaderSet</code> object to pass to the
+     * <code>ServerRequestHandler</code> object. After the handler processes the
+     * request, this method will create a reply message to send to the server
+     * with the response code provided.
+     * @throws IOException if an error occurred at the transport layer
+     */
+    private void handleConnectRequest() throws IOException {
+        int packetLength;
+        @SuppressWarnings("unused")
+        int version;
+        @SuppressWarnings("unused")
+        int flags;
+        int totalLength = 7;
+        byte[] head = null;
+        int code = -1;
+        HeaderSet request = new HeaderSet();
+        HeaderSet reply = new HeaderSet();
+        int bytesReceived;
+
+        /*
+         * Read in the length of the OBEX packet, OBEX version, flags, and max
+         * packet length
+         */
+        packetLength = mInput.read();
+        packetLength = (packetLength << 8) + mInput.read();
+        version = mInput.read();
+        flags = mInput.read();
+
+        mMaxPacketLength = mInput.read();
+        mMaxPacketLength = (mMaxPacketLength << 8) + mInput.read();
+
+        // should we check it?
+        if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
+            mMaxPacketLength = ObexHelper.MAX_PACKET_SIZE_INT;
+        }
+
+        if (packetLength > mMaxPacketLength) {
+            code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
+            totalLength = 7;
+        } else {
+            if (packetLength > 7) {
+                byte[] headers = new byte[packetLength - 7];
+                bytesReceived = mInput.read(headers);
+
+                while (bytesReceived != headers.length) {
+                    bytesReceived += mInput.read(headers, bytesReceived, headers.length
+                            - bytesReceived);
+                }
+
+                ObexHelper.updateHeaderSet(request, headers);
+            }
+
+            if (mSrmServer.getLocalSrmCapability() == ObexHelper.SRM_CAPABLE) {
+                /*
+                 * As per GOEP TS Spec the Server should ignore the SRM header sent in Connect
+                 */
+                Byte byteHeader = (Byte)request.getHeader(HeaderSet.SINGLE_RESPONSE_MODE);
+                if((byteHeader == ObexHelper.OBEX_SRM_SUPPORTED) ||(byteHeader == ObexHelper.OBEX_SRM_DISABLED)
+                      || (byteHeader == ObexHelper.OBEX_SRM_ENABLED)) {
+                    if (VERBOSE) Log.v(TAG, "handleConnectRequest: SRM Header received in Connect.. Ignored");
+                }
+                if (mSrmServer.getLocalSrmParamStatus()) {
+                    if (VERBOSE) Log.v(TAG, "handleConnectRequest: Enabled the SRMP WAIT");
+                    mSrmServer.setLocalSrmpWait(ObexHelper.SRMP_ENABLED);
+                } else {
+                      if (VERBOSE) Log.v(TAG, "handleConnectRequest: Disabled the SRMP WAIT");
+                      mSrmServer.setLocalSrmpWait(ObexHelper.SRMP_DISABLED);
+                }
+            }
+
+            if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
+                mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
+            } else {
+                mListener.setConnectionId(1);
+            }
+
+            if (request.mAuthResp != null) {
+                if (!handleAuthResp(request.mAuthResp)) {
+                    code = ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
+                    mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,
+                            request.mAuthResp));
+                }
+                request.mAuthResp = null;
+            }
+
+            if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
+                if (request.mAuthChall != null) {
+                    handleAuthChall(request);
+                    reply.mAuthResp = new byte[request.mAuthResp.length];
+                    System.arraycopy(request.mAuthResp, 0, reply.mAuthResp, 0,
+                            reply.mAuthResp.length);
+                    request.mAuthChall = null;
+                    request.mAuthResp = null;
+                }
+
+                try {
+                    code = mListener.onConnect(request, reply);
+                    code = validateResponseCode(code);
+
+                    if (reply.nonce != null) {
+                        mChallengeDigest = new byte[16];
+                        System.arraycopy(reply.nonce, 0, mChallengeDigest, 0, 16);
+                    } else {
+                        mChallengeDigest = null;
+                    }
+                    long id = mListener.getConnectionId();
+                    if (id == -1) {
+                        reply.mConnectionID = null;
+                    } else {
+                        reply.mConnectionID = ObexHelper.convertToByteArray(id);
+                    }
+
+                    head = ObexHelper.createHeader(reply, false);
+                    totalLength += head.length;
+
+                    if (totalLength > mMaxPacketLength) {
+                        totalLength = 7;
+                        head = null;
+                        code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
+                    }
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    totalLength = 7;
+                    head = null;
+                    code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
+                }
+
+            }
+        }
+
+        // Compute Length of OBEX CONNECT packet
+        byte[] length = ObexHelper.convertToByteArray(totalLength);
+
+        /*
+         * Write the OBEX CONNECT packet to the server. Byte 0: response code
+         * Byte 1&2: Connect Packet Length Byte 3: OBEX Version Number
+         * (Presently, 0x10) Byte 4: Flags (For TCP 0x00) Byte 5&6: Max OBEX
+         * Packet Length Byte 7 to n: headers
+         */
+        byte[] sendData = new byte[totalLength];
+        sendData[0] = (byte)code;
+        sendData[1] = length[2];
+        sendData[2] = length[3];
+        sendData[3] = (byte)0x10;
+        sendData[4] = (byte)0x00;
+        sendData[5] = (byte)(mMaxPacketLength >> 8);
+        sendData[6] = (byte)(mMaxPacketLength & 0xFF);
+
+        if (head != null) {
+            System.arraycopy(head, 0, sendData, 7, head.length);
+        }
+
+        mOutput.write(sendData);
+        mOutput.flush();
+    }
+
+    /**
+     * Closes the server session - in detail close I/O streams and the
+     * underlying transport layer. Internal flag is also set so that later
+     * attempt to read/write will throw an exception.
+     */
+    public synchronized void close() {
+        if (mListener != null) {
+            mListener.onClose();
+        }
+        try {
+            mInput.close();
+            mOutput.close();
+            mTransport.close();
+            mClosed = true;
+        } catch (Exception e) {
+        }
+        mTransport = null;
+        mInput = null;
+        mOutput = null;
+        mListener = null;
+    }
+
+    /**
+     * Verifies that the response code is valid. If it is not valid, it will
+     * return the <code>OBEX_HTTP_INTERNAL_ERROR</code> response code.
+     * @param code the response code to check
+     * @return the valid response code or <code>OBEX_HTTP_INTERNAL_ERROR</code>
+     *         if <code>code</code> is not valid
+     */
+    private int validateResponseCode(int code) {
+
+        if ((code >= ResponseCodes.OBEX_HTTP_OK) && (code <= ResponseCodes.OBEX_HTTP_PARTIAL)) {
+            return code;
+        }
+        if ((code >= ResponseCodes.OBEX_HTTP_MULT_CHOICE)
+                && (code <= ResponseCodes.OBEX_HTTP_USE_PROXY)) {
+            return code;
+        }
+        if ((code >= ResponseCodes.OBEX_HTTP_BAD_REQUEST)
+                && (code <= ResponseCodes.OBEX_HTTP_UNSUPPORTED_TYPE)) {
+            return code;
+        }
+        if ((code >= ResponseCodes.OBEX_HTTP_INTERNAL_ERROR)
+                && (code <= ResponseCodes.OBEX_HTTP_VERSION)) {
+            return code;
+        }
+        if ((code >= ResponseCodes.OBEX_DATABASE_FULL)
+                && (code <= ResponseCodes.OBEX_DATABASE_LOCKED)) {
+            return code;
+        }
+        return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
+    }
+
+}
diff --git a/btobex/javax/btobex/SessionNotifier.java b/btobex/javax/btobex/SessionNotifier.java
new file mode 100644
index 0000000..95d10dc
--- /dev/null
+++ b/btobex/javax/btobex/SessionNotifier.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package javax.btobex;
+
+import java.io.IOException;
+
+/**
+ * The <code>SessionNotifier</code> interface defines a connection notifier for
+ * server-side OBEX connections. When a <code>SessionNotifier</code> is created
+ * and calls <code>acceptAndOpen()</code>, it will begin listening for clients
+ * to create a connection at the transport layer. When the transport layer
+ * connection is received, the <code>acceptAndOpen()</code> method will return a
+ * <code>javax.microedition.io.Connection</code> that is the connection to the
+ * client. The <code>acceptAndOpen()</code> method also takes a
+ * <code>ServerRequestHandler</code> argument that will process the requests
+ * from the client that connects to the server.
+ * @hide
+ */
+public interface SessionNotifier {
+
+    /**
+     * Waits for a transport layer connection to be established and specifies
+     * the handler to handle the requests from the client. No authenticator is
+     * associated with this connection, therefore, it is implementation
+     * dependent as to how an authentication challenge and authentication
+     * response header will be received and processed.
+     * <P>
+     * <H4>Additional Note for OBEX over Bluetooth</H4> If this method is called
+     * on a <code>SessionNotifier</code> object that does not have a
+     * <code>ServiceRecord</code> in the SDDB, the <code>ServiceRecord</code>
+     * for this object will be added to the SDDB. This method requests the BCC
+     * to put the local device in connectable mode so that it will respond to
+     * connection attempts by clients.
+     * <P>
+     * The following checks are done to verify that the service record provided
+     * is valid. If any of these checks fail, then a
+     * <code>ServiceRegistrationException</code> is thrown.
+     * <UL>
+     * <LI>ServiceClassIDList and ProtocolDescriptorList, the mandatory service
+     * attributes for a <code>btgoep</code> service record, must be present in
+     * the <code>ServiceRecord</code> associated with this notifier.
+     * <LI>L2CAP, RFCOMM and OBEX must all be in the ProtocolDescriptorList
+     * <LI>The <code>ServiceRecord</code> associated with this notifier must not
+     * have changed the RFCOMM server channel number
+     * </UL>
+     * <P>
+     * This method will not ensure that <code>ServiceRecord</code> associated
+     * with this notifier is a completely valid service record. It is the
+     * responsibility of the application to ensure that the service record
+     * follows all of the applicable syntactic and semantic rules for service
+     * record correctness.
+     * @param handler the request handler that will respond to OBEX requests
+     * @return the connection to the client
+     * @throws IOException if an error occurs in the transport layer
+     * @throws NullPointerException if <code>handler</code> is <code>null</code>
+     */
+    ObexSession acceptAndOpen(ServerRequestHandler handler) throws IOException;
+
+    /**
+     * Waits for a transport layer connection to be established and specifies
+     * the handler to handle the requests from the client and the
+     * <code>Authenticator</code> to use to respond to authentication challenge
+     * and authentication response headers.
+     * <P>
+     * <H4>Additional Note for OBEX over Bluetooth</H4> If this method is called
+     * on a <code>SessionNotifier</code> object that does not have a
+     * <code>ServiceRecord</code> in the SDDB, the <code>ServiceRecord</code>
+     * for this object will be added to the SDDB. This method requests the BCC
+     * to put the local device in connectable mode so that it will respond to
+     * connection attempts by clients.
+     * <P>
+     * The following checks are done to verify that the service record provided
+     * is valid. If any of these checks fail, then a
+     * <code>ServiceRegistrationException</code> is thrown.
+     * <UL>
+     * <LI>ServiceClassIDList and ProtocolDescriptorList, the mandatory service
+     * attributes for a <code>btgoep</code> service record, must be present in
+     * the <code>ServiceRecord</code> associated with this notifier.
+     * <LI>L2CAP, RFCOMM and OBEX must all be in the ProtocolDescriptorList
+     * <LI>The <code>ServiceRecord</code> associated with this notifier must not
+     * have changed the RFCOMM server channel number
+     * </UL>
+     * <P>
+     * This method will not ensure that <code>ServiceRecord</code> associated
+     * with this notifier is a completely valid service record. It is the
+     * responsibility of the application to ensure that the service record
+     * follows all of the applicable syntactic and semantic rules for service
+     * record correctness.
+     * @param handler the request handler that will respond to OBEX requests
+     * @param auth the <code>Authenticator</code> to use with this connection;
+     *        if <code>null</code> then no <code>Authenticator</code> will be
+     *        used
+     * @return the connection to the client
+     * @throws IOException if an error occurs in the transport layer
+     * @throws NullPointerException if <code>handler</code> is <code>null</code>
+     */
+    ObexSession acceptAndOpen(ServerRequestHandler handler, Authenticator auth) throws IOException;
+}
diff --git a/core/jni/Android.mk b/core/jni/Android.mk
index c86f949..90bbc87 100644
--- a/core/jni/Android.mk
+++ b/core/jni/Android.mk
@@ -157,6 +157,18 @@ ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
 	    com_android_internal_app_ActivityTrigger.cpp
 endif
 
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ), true)
+LOCAL_SRC_FILES += \
+	bluetoothmsm/android_bluetooth_HeadsetBase.cpp \
+	bluetoothmsm/android_bluetooth_common.cpp \
+	bluetoothmsm/android_bluetooth_BluetoothAudioGateway.cpp \
+	bluetoothmsm/android_bluetooth_BluetoothSocket.cpp \
+	bluetoothmsm/android_bluetooth_c.c \
+	bluetoothmsm/android_server_BluetoothService.cpp \
+	bluetoothmsm/android_server_BluetoothEventLoop.cpp \
+	bluetoothmsm/android_server_BluetoothA2dpService.cpp
+endif #BOARD_HAVE_BLUETOOTH_BLUEZ
+
 LOCAL_C_INCLUDES += \
 	$(JNI_H_INCLUDE) \
 	$(LOCAL_PATH)/android/graphics \
@@ -219,6 +231,14 @@ LOCAL_SHARED_LIBRARIES := \
 	libharfbuzz \
 	libz
 
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ),true)
+    LOCAL_C_INCLUDES += \
+          external/dbus \
+          system/bluetooth/bluez-clean-headers
+    LOCAL_CFLAGS += -DHAVE_BLUETOOTH -DHAVE_BLUEZ_JNI
+    LOCAL_SHARED_LIBRARIES += libbluedroid libdbus
+endif #BOARD_HAVE_BLUETOOTH_BLUEZ
+
 ifeq ($(HAVE_SELINUX),true)
 LOCAL_C_INCLUDES += external/libselinux/include
 LOCAL_SHARED_LIBRARIES += libselinux
diff --git a/core/jni/AndroidRuntime.cpp b/core/jni/AndroidRuntime.cpp
index 01ad2f0..c7d9ab0 100644
--- a/core/jni/AndroidRuntime.cpp
+++ b/core/jni/AndroidRuntime.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2006 The Android Open Source Project
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -178,6 +179,15 @@ extern int register_android_content_res_PackageRedirectionMap(JNIEnv* env);
 extern int register_com_android_internal_app_ActivityTrigger(JNIEnv *env);
 #endif
 
+#ifdef HAVE_BLUEZ_JNI
+extern int register_android_bluetooth_HeadsetBase(JNIEnv* env);
+extern int register_android_bluetooth_BluetoothAudioGateway(JNIEnv* env);
+extern int register_android_bluetooth_BluetoothSocket(JNIEnv *env);
+extern int register_android_server_BluetoothService(JNIEnv* env);
+extern int register_android_server_BluetoothEventLoop(JNIEnv *env);
+extern int register_android_server_BluetoothA2dpService(JNIEnv* env);
+#endif //HAVE_BLUEZ_JNI
+
 static AndroidRuntime* gCurRuntime = NULL;
 
 static void doThrow(JNIEnv* env, const char* exc, const char* msg = NULL)
@@ -1222,6 +1232,14 @@ static const RegJNIRec gRegJNI[] = {
     REG_JNI(register_com_android_internal_app_ActivityTrigger),
 #endif
 
+#ifdef HAVE_BLUEZ_JNI
+    REG_JNI(register_android_bluetooth_HeadsetBase),
+    REG_JNI(register_android_bluetooth_BluetoothAudioGateway),
+    REG_JNI(register_android_bluetooth_BluetoothSocket),
+    REG_JNI(register_android_server_BluetoothService),
+    REG_JNI(register_android_server_BluetoothEventLoop),
+    REG_JNI(register_android_server_BluetoothA2dpService),
+#endif //HAVE_BLUEZ_JNI
 };
 
 /*
diff --git a/core/jni/bluetoothmsm/android_bluetooth_BluetoothAudioGateway.cpp b/core/jni/bluetoothmsm/android_bluetooth_BluetoothAudioGateway.cpp
new file mode 100644
index 0000000..a2af789
--- /dev/null
+++ b/core/jni/bluetoothmsm/android_bluetooth_BluetoothAudioGateway.cpp
@@ -0,0 +1,562 @@
+/*
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "BluetoothAudioGateway.cpp"
+
+#include "android_bluetooth_common.h"
+#include "android_bluetooth_c.h"
+#include "android_runtime/AndroidRuntime.h"
+#include "JNIHelp.h"
+#include "jni.h"
+#include "utils/Log.h"
+#include "utils/misc.h"
+#include <cutils/properties.h>
+#include <string.h>
+
+#define USE_ACCEPT_DIRECTLY (0)
+#define USE_SELECT (0) /* 1 for select(), 0 for poll(); used only when
+                          USE_ACCEPT_DIRECTLY == 0 */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/uio.h>
+#include <ctype.h>
+
+#if USE_SELECT
+#include <sys/select.h>
+#else
+#include <sys/poll.h>
+#endif
+
+#ifdef HAVE_BLUETOOTH
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/rfcomm.h>
+#include <bluetooth/sco.h>
+#endif
+
+namespace android {
+
+#ifdef HAVE_BLUETOOTH
+static jfieldID field_mNativeData;
+    /* in */
+static jfieldID field_mHandsfreeAgRfcommChannel;
+static jfieldID field_mHeadsetAgRfcommChannel;
+    /* out */
+static jfieldID field_mTimeoutRemainingMs; /* out */
+
+static jfieldID field_mConnectingHeadsetAddress;
+static jfieldID field_mConnectingHeadsetRfcommChannel; /* -1 when not connected */
+static jfieldID field_mConnectingHeadsetSocketFd;
+
+static jfieldID field_mConnectingHandsfreeAddress;
+static jfieldID field_mConnectingHandsfreeRfcommChannel; /* -1 when not connected */
+static jfieldID field_mConnectingHandsfreeSocketFd;
+
+
+typedef struct {
+    int hcidev;
+    int hf_ag_rfcomm_channel;
+    int hs_ag_rfcomm_channel;
+    int hf_ag_rfcomm_sock;
+    int hs_ag_rfcomm_sock;
+} native_data_t;
+
+static inline native_data_t * get_native_data(JNIEnv *env, jobject object) {
+    return (native_data_t *)(env->GetIntField(object,
+                                                 field_mNativeData));
+}
+
+static int setup_listening_socket(int dev, int channel);
+#endif
+
+static void classInitNative(JNIEnv* env, jclass clazz) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+
+    /* in */
+    field_mNativeData = get_field(env, clazz, "mNativeData", "I");
+    field_mHandsfreeAgRfcommChannel =
+        get_field(env, clazz, "mHandsfreeAgRfcommChannel", "I");
+    field_mHeadsetAgRfcommChannel =
+        get_field(env, clazz, "mHeadsetAgRfcommChannel", "I");
+
+    /* out */
+    field_mConnectingHeadsetAddress =
+        get_field(env, clazz,
+                  "mConnectingHeadsetAddress", "Ljava/lang/String;");
+    field_mConnectingHeadsetRfcommChannel =
+        get_field(env, clazz, "mConnectingHeadsetRfcommChannel", "I");
+    field_mConnectingHeadsetSocketFd =
+        get_field(env, clazz, "mConnectingHeadsetSocketFd", "I");
+
+    field_mConnectingHandsfreeAddress =
+        get_field(env, clazz,
+                  "mConnectingHandsfreeAddress", "Ljava/lang/String;");
+    field_mConnectingHandsfreeRfcommChannel =
+        get_field(env, clazz, "mConnectingHandsfreeRfcommChannel", "I");
+    field_mConnectingHandsfreeSocketFd =
+        get_field(env, clazz, "mConnectingHandsfreeSocketFd", "I");
+
+    field_mTimeoutRemainingMs =
+        get_field(env, clazz, "mTimeoutRemainingMs", "I");
+#endif
+}
+
+static void initializeNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = (native_data_t *)calloc(1, sizeof(native_data_t));
+    if (NULL == nat) {
+        ALOGE("%s: out of memory!", __FUNCTION__);
+        return;
+    }
+
+    nat->hcidev = BLUETOOTH_ADAPTER_HCI_NUM;
+
+    env->SetIntField(object, field_mNativeData, (jint)nat);
+    nat->hf_ag_rfcomm_channel =
+        env->GetIntField(object, field_mHandsfreeAgRfcommChannel);
+    nat->hs_ag_rfcomm_channel =
+        env->GetIntField(object, field_mHeadsetAgRfcommChannel);
+    ALOGV("HF RFCOMM channel = %d.", nat->hf_ag_rfcomm_channel);
+    ALOGV("HS RFCOMM channel = %d.", nat->hs_ag_rfcomm_channel);
+
+    /* Set the default values of these to -1. */
+    env->SetIntField(object, field_mConnectingHeadsetRfcommChannel, -1);
+    env->SetIntField(object, field_mConnectingHandsfreeRfcommChannel, -1);
+
+    nat->hf_ag_rfcomm_sock = -1;
+    nat->hs_ag_rfcomm_sock = -1;
+#endif
+}
+
+static void cleanupNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        free(nat);
+    }
+#endif
+}
+
+#ifdef HAVE_BLUETOOTH
+
+#if USE_ACCEPT_DIRECTLY==0
+static int set_nb(int sk, bool nb) {
+    int flags = fcntl(sk, F_GETFL);
+    if (flags < 0) {
+        ALOGE("Can't get socket flags with fcntl(): %s (%d)",
+             strerror(errno), errno);
+        close(sk);
+        return -1;
+    }
+    flags &= ~O_NONBLOCK;
+    if (nb) flags |= O_NONBLOCK;
+    int status = fcntl(sk, F_SETFL, flags);
+    if (status < 0) {
+        ALOGE("Can't set socket to nonblocking mode with fcntl(): %s (%d)",
+             strerror(errno), errno);
+        close(sk);
+        return -1;
+    }
+    return 0;
+}
+#endif /*USE_ACCEPT_DIRECTLY==0*/
+
+static int do_accept(JNIEnv* env, jobject object, int ag_fd,
+                     jfieldID out_fd,
+                     jfieldID out_address,
+                     jfieldID out_channel) {
+
+#if USE_ACCEPT_DIRECTLY==0
+    if (set_nb(ag_fd, true) < 0)
+        return -1;
+#endif
+
+    struct sockaddr_rc raddr;
+    int alen = sizeof(raddr);
+    int nsk = TEMP_FAILURE_RETRY(accept(ag_fd, (struct sockaddr *) &raddr, &alen));
+    if (nsk < 0) {
+        ALOGE("Error on accept from socket fd %d: %s (%d).",
+             ag_fd,
+             strerror(errno),
+             errno);
+#if USE_ACCEPT_DIRECTLY==0
+        set_nb(ag_fd, false);
+#endif
+        return -1;
+    }
+
+    env->SetIntField(object, out_fd, nsk);
+    env->SetIntField(object, out_channel, raddr.rc_channel);
+
+    char addr[BTADDR_SIZE];
+    get_bdaddr_as_string(&raddr.rc_bdaddr, addr);
+    env->SetObjectField(object, out_address, env->NewStringUTF(addr));
+
+    ALOGI("Successful accept() on AG socket %d: new socket %d, address %s, RFCOMM channel %d",
+         ag_fd,
+         nsk,
+         addr,
+         raddr.rc_channel);
+#if USE_ACCEPT_DIRECTLY==0
+    set_nb(ag_fd, false);
+#endif
+    return 0;
+}
+
+#if USE_SELECT
+static inline int on_accept_set_fields(JNIEnv* env, jobject object,
+                                       fd_set *rset, int ag_fd,
+                                       jfieldID out_fd,
+                                       jfieldID out_address,
+                                       jfieldID out_channel) {
+
+    env->SetIntField(object, out_channel, -1);
+
+    if (ag_fd >= 0 && FD_ISSET(ag_fd, &rset)) {
+        return do_accept(env, object, ag_fd,
+                         out_fd, out_address, out_channel);
+    }
+    else {
+        ALOGI("fd = %d, FD_ISSET() = %d",
+             ag_fd,
+             FD_ISSET(ag_fd, &rset));
+        if (ag_fd >= 0 && !FD_ISSET(ag_fd, &rset)) {
+            ALOGE("WTF???");
+            return -1;
+        }
+    }
+
+    return 0;
+}
+#endif
+#endif /* HAVE_BLUETOOTH */
+
+static jboolean waitForHandsfreeConnectNative(JNIEnv* env, jobject object,
+                                              jint timeout_ms) {
+//    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+
+    env->SetIntField(object, field_mTimeoutRemainingMs, timeout_ms);
+
+    int n = 0;
+    native_data_t *nat = get_native_data(env, object);
+#if USE_ACCEPT_DIRECTLY
+    if (nat->hf_ag_rfcomm_channel > 0) {
+        ALOGI("Setting HF AG server socket to RFCOMM port %d!",
+             nat->hf_ag_rfcomm_channel);
+        struct timeval tv;
+        int len = sizeof(tv);
+        if (getsockopt(nat->hf_ag_rfcomm_channel,
+                       SOL_SOCKET, SO_RCVTIMEO, &tv, &len) < 0) {
+            ALOGE("getsockopt(%d, SOL_SOCKET, SO_RCVTIMEO): %s (%d)",
+                 nat->hf_ag_rfcomm_channel,
+                 strerror(errno),
+                 errno);
+            return JNI_FALSE;
+        }
+        ALOGI("Current HF AG server socket RCVTIMEO is (%d(s), %d(us))!",
+             (int)tv.tv_sec, (int)tv.tv_usec);
+        if (timeout_ms >= 0) {
+            tv.tv_sec = timeout_ms / 1000;
+            tv.tv_usec = 1000 * (timeout_ms % 1000);
+            if (setsockopt(nat->hf_ag_rfcomm_channel,
+                           SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
+                ALOGE("setsockopt(%d, SOL_SOCKET, SO_RCVTIMEO): %s (%d)",
+                     nat->hf_ag_rfcomm_channel,
+                     strerror(errno),
+                     errno);
+                return JNI_FALSE;
+            }
+            ALOGI("Changed HF AG server socket RCVTIMEO to (%d(s), %d(us))!",
+                 (int)tv.tv_sec, (int)tv.tv_usec);
+        }
+
+        if (!do_accept(env, object, nat->hf_ag_rfcomm_sock,
+                       field_mConnectingHandsfreeSocketFd,
+                       field_mConnectingHandsfreeAddress,
+                       field_mConnectingHandsfreeRfcommChannel))
+        {
+            env->SetIntField(object, field_mTimeoutRemainingMs, 0);
+            return JNI_TRUE;
+        }
+        return JNI_FALSE;
+    }
+#else
+#if USE_SELECT
+    fd_set rset;
+    FD_ZERO(&rset);
+    int cnt = 0;
+    if (nat->hf_ag_rfcomm_channel > 0) {
+        ALOGI("Setting HF AG server socket to RFCOMM port %d!",
+             nat->hf_ag_rfcomm_channel);
+        cnt++;
+        FD_SET(nat->hf_ag_rfcomm_sock, &rset);
+    }
+    if (nat->hs_ag_rfcomm_channel > 0) {
+        ALOGI("Setting HS AG server socket to RFCOMM port %d!",
+             nat->hs_ag_rfcomm_channel);
+        cnt++;
+        FD_SET(nat->hs_ag_rfcomm_sock, &rset);
+    }
+    if (cnt == 0) {
+        ALOGE("Neither HF nor HS listening sockets are open!");
+        return JNI_FALSE;
+    }
+
+    struct timeval to;
+    if (timeout_ms >= 0) {
+        to.tv_sec = timeout_ms / 1000;
+        to.tv_usec = 1000 * (timeout_ms % 1000);
+    }
+    n = TEMP_FAILURE_RETRY(select(
+                   MAX(nat->hf_ag_rfcomm_sock, nat->hs_ag_rfcomm_sock) + 1,
+                   &rset,
+                   NULL,
+                   NULL,
+                   (timeout_ms < 0 ? NULL : &to)));
+    if (timeout_ms > 0) {
+        jint remaining = to.tv_sec*1000 + to.tv_usec/1000;
+        ALOGI("Remaining time %ldms", (long)remaining);
+        env->SetIntField(object, field_mTimeoutRemainingMs,
+                         remaining);
+    }
+
+    ALOGI("listening select() returned %d", n);
+
+    if (n <= 0) {
+        if (n < 0)  {
+            ALOGE("listening select() on RFCOMM sockets: %s (%d)",
+                 strerror(errno),
+                 errno);
+        }
+        return JNI_FALSE;
+    }
+
+    n = on_accept_set_fields(env, object,
+                             &rset, nat->hf_ag_rfcomm_sock,
+                             field_mConnectingHandsfreeSocketFd,
+                             field_mConnectingHandsfreeAddress,
+                             field_mConnectingHandsfreeRfcommChannel);
+
+    n += on_accept_set_fields(env, object,
+                              &rset, nat->hs_ag_rfcomm_sock,
+                              field_mConnectingHeadsetSocketFd,
+                              field_mConnectingHeadsetAddress,
+                              field_mConnectingHeadsetRfcommChannel);
+
+    return !n ? JNI_TRUE : JNI_FALSE;
+#else
+    struct pollfd fds[2];
+    int cnt = 0;
+    if (nat->hf_ag_rfcomm_channel > 0) {
+//        ALOGI("Setting HF AG server socket %d to RFCOMM port %d!",
+//             nat->hf_ag_rfcomm_sock,
+//             nat->hf_ag_rfcomm_channel);
+        fds[cnt].fd = nat->hf_ag_rfcomm_sock;
+        fds[cnt].events = POLLIN | POLLPRI | POLLOUT | POLLERR;
+        cnt++;
+    }
+    if (nat->hs_ag_rfcomm_channel > 0) {
+//        ALOGI("Setting HS AG server socket %d to RFCOMM port %d!",
+//             nat->hs_ag_rfcomm_sock,
+//             nat->hs_ag_rfcomm_channel);
+        fds[cnt].fd = nat->hs_ag_rfcomm_sock;
+        fds[cnt].events = POLLIN | POLLPRI | POLLOUT | POLLERR;
+        cnt++;
+    }
+    if (cnt == 0) {
+        ALOGE("Neither HF nor HS listening sockets are open!");
+        return JNI_FALSE;
+    }
+    n = TEMP_FAILURE_RETRY(poll(fds, cnt, timeout_ms));
+    if (n <= 0) {
+        if (n < 0)  {
+            ALOGE("listening poll() on RFCOMM sockets: %s (%d)",
+                 strerror(errno),
+                 errno);
+        }
+        else {
+            env->SetIntField(object, field_mTimeoutRemainingMs, 0);
+//            ALOGI("listening poll() on RFCOMM socket timed out");
+        }
+        return JNI_FALSE;
+    }
+
+    //ALOGI("listening poll() on RFCOMM socket returned %d", n);
+    int err = 0;
+    for (cnt = 0; cnt < (int)(sizeof(fds)/sizeof(fds[0])); cnt++) {
+        //ALOGI("Poll on fd %d revent = %d.", fds[cnt].fd, fds[cnt].revents);
+        if (fds[cnt].fd == nat->hf_ag_rfcomm_sock) {
+            if (fds[cnt].revents & (POLLIN | POLLPRI | POLLOUT)) {
+                ALOGI("Accepting HF connection.\n");
+                err += do_accept(env, object, fds[cnt].fd,
+                               field_mConnectingHandsfreeSocketFd,
+                               field_mConnectingHandsfreeAddress,
+                               field_mConnectingHandsfreeRfcommChannel);
+                n--;
+            }
+        }
+        else if (fds[cnt].fd == nat->hs_ag_rfcomm_sock) {
+            if (fds[cnt].revents & (POLLIN | POLLPRI | POLLOUT)) {
+                ALOGI("Accepting HS connection.\n");
+                err += do_accept(env, object, fds[cnt].fd,
+                               field_mConnectingHeadsetSocketFd,
+                               field_mConnectingHeadsetAddress,
+                               field_mConnectingHeadsetRfcommChannel);
+                n--;
+            }
+        }
+    } /* for */
+
+    if (n != 0) {
+        ALOGI("Bogus poll(): %d fake pollfd entrie(s)!", n);
+        return JNI_FALSE;
+    }
+
+    return !err ? JNI_TRUE : JNI_FALSE;
+#endif /* USE_SELECT */
+#endif /* USE_ACCEPT_DIRECTLY */
+#else
+    return JNI_FALSE;
+#endif /* HAVE_BLUETOOTH */
+}
+
+static jboolean setUpListeningSocketsNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+
+    nat->hf_ag_rfcomm_sock =
+        setup_listening_socket(nat->hcidev, nat->hf_ag_rfcomm_channel);
+    if (nat->hf_ag_rfcomm_sock < 0)
+        return JNI_FALSE;
+
+    nat->hs_ag_rfcomm_sock =
+        setup_listening_socket(nat->hcidev, nat->hs_ag_rfcomm_channel);
+    if (nat->hs_ag_rfcomm_sock < 0) {
+        close(nat->hf_ag_rfcomm_sock);
+        nat->hf_ag_rfcomm_sock = -1;
+        return JNI_FALSE;
+    }
+
+    return JNI_TRUE;
+#else
+    return JNI_FALSE;
+#endif /* HAVE_BLUETOOTH */
+}
+
+#ifdef HAVE_BLUETOOTH
+static int setup_listening_socket(int dev, int channel) {
+    struct sockaddr_rc laddr;
+    int sk, lm;
+    char value[PROPERTY_VALUE_MAX] = "";
+
+    sk = socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);
+    if (sk < 0) {
+        ALOGE("Can't create RFCOMM socket");
+        return -1;
+    }
+
+    if (debug_no_encrypt()) {
+        lm = RFCOMM_LM_AUTH;
+    } else {
+        lm = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;
+    }
+    /* By default we request to be the MASTER of connection */
+    property_get("ro.bluetooth.request.master", value, "true");
+    if (!strcmp("true", value)) {
+        ALOGI("Setting Master socket option");
+        lm |= RFCOMM_LM_MASTER;
+    }
+
+    if (lm && setsockopt(sk, SOL_RFCOMM, RFCOMM_LM, &lm, sizeof(lm)) < 0) {
+        ALOGE("Can't set RFCOMM link mode");
+        close(sk);
+        return -1;
+    }
+
+    laddr.rc_family = AF_BLUETOOTH;
+    bdaddr_t any = android_bluetooth_bdaddr_any();
+    memcpy(&laddr.rc_bdaddr, &any, sizeof(bdaddr_t));
+    laddr.rc_channel = channel;
+
+    if (bind(sk, (struct sockaddr *)&laddr, sizeof(laddr)) < 0) {
+        ALOGE("Can't bind RFCOMM socket");
+        close(sk);
+        return -1;
+    }
+
+    listen(sk, 10);
+    return sk;
+}
+#endif /* HAVE_BLUETOOTH */
+
+/*
+    private native void tearDownListeningSocketsNative();
+*/
+static void tearDownListeningSocketsNative(JNIEnv *env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+
+    if (nat->hf_ag_rfcomm_sock > 0) {
+        if (close(nat->hf_ag_rfcomm_sock) < 0) {
+            ALOGE("Could not close HF server socket: %s (%d)\n",
+                 strerror(errno), errno);
+        }
+        nat->hf_ag_rfcomm_sock = -1;
+    }
+    if (nat->hs_ag_rfcomm_sock > 0) {
+        if (close(nat->hs_ag_rfcomm_sock) < 0) {
+            ALOGE("Could not close HS server socket: %s (%d)\n",
+                 strerror(errno), errno);
+        }
+        nat->hs_ag_rfcomm_sock = -1;
+    }
+#endif /* HAVE_BLUETOOTH */
+}
+
+static JNINativeMethod sMethods[] = {
+     /* name, signature, funcPtr */
+
+    {"classInitNative", "()V", (void*)classInitNative},
+    {"initializeNativeDataNative", "()V", (void *)initializeNativeDataNative},
+    {"cleanupNativeDataNative", "()V", (void *)cleanupNativeDataNative},
+
+    {"setUpListeningSocketsNative", "()Z", (void *)setUpListeningSocketsNative},
+    {"tearDownListeningSocketsNative", "()V", (void *)tearDownListeningSocketsNative},
+    {"waitForHandsfreeConnectNative", "(I)Z", (void *)waitForHandsfreeConnectNative},
+};
+
+int register_android_bluetooth_BluetoothAudioGateway(JNIEnv *env) {
+    return AndroidRuntime::registerNativeMethods(env,
+            "android/bluetooth/BluetoothAudioGateway", sMethods,
+            NELEM(sMethods));
+}
+
+} /* namespace android */
diff --git a/core/jni/bluetoothmsm/android_bluetooth_BluetoothSocket.cpp b/core/jni/bluetoothmsm/android_bluetooth_BluetoothSocket.cpp
new file mode 100644
index 0000000..549f3ca
--- /dev/null
+++ b/core/jni/bluetoothmsm/android_bluetooth_BluetoothSocket.cpp
@@ -0,0 +1,725 @@
+/*
+ * Copyright 2009, The Android Open Source Project
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "BluetoothSocket.cpp"
+
+#include "android_bluetooth_common.h"
+#include "android_bluetooth_c.h"
+#include "android_runtime/AndroidRuntime.h"
+#include "JNIHelp.h"
+#include "utils/Log.h"
+#include "cutils/abort_socket.h"
+
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+
+#include <cutils/properties.h>
+#include <string.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/rfcomm.h>
+#include <bluetooth/l2cap.h>
+#include <bluetooth/sco.h>
+#endif
+
+#define TYPE_AS_STR(t) \
+    ((t) == TYPE_RFCOMM ? "RFCOMM" : ((t) == TYPE_SCO ? "SCO" : \
+     ((t) == TYPE_L2CAP ? "L2CAP" : "EL2CAP")))
+
+/* dscherba: HACK changing to 65000 to allow for ERTM overhead--hopefully this will not get tossed by the kernel in negotiations */
+#define L2CAP_MAX_MTU 65000
+
+namespace android {
+
+static jfieldID  field_mAuth;     /* read-only */
+static jfieldID  field_mEncrypt;  /* read-only */
+static jfieldID  field_mType;     /* read-only */
+static jfieldID  field_mAddress;  /* read-only */
+static jfieldID  field_mPort;     /* read-only */
+static jfieldID  field_mSocketData;
+static jmethodID method_BluetoothSocket_ctor;
+static jclass    class_BluetoothSocket;
+
+/* Keep TYPE_RFCOMM etc in sync with BluetoothSocket.java */
+static const int TYPE_RFCOMM = 1;
+static const int TYPE_SCO = 2;
+static const int TYPE_L2CAP = 3;
+static const int TYPE_EL2CAP = 4;
+static const int TYPE_SCO_WBS = 5;
+
+static const int RFCOMM_SO_SNDBUF = 70 * 1024;  // 70 KB send buffer
+static const int L2CAP_SO_SNDBUF = 400 * 1024;  // 400 KB send buffer
+static const int L2CAP_SO_RCVBUF = 400 * 1024;  // 400 KB receive buffer
+
+static void abortNative(JNIEnv *env, jobject obj);
+static void destroyNative(JNIEnv *env, jobject obj);
+
+static struct asocket *get_socketData(JNIEnv *env, jobject obj) {
+    struct asocket *s =
+            (struct asocket *) env->GetIntField(obj, field_mSocketData);
+    if (!s)
+        jniThrowException(env, "java/io/IOException", "null socketData");
+    return s;
+}
+
+static void initSocketFromFdNative(JNIEnv *env, jobject obj, jint fd) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    struct asocket *s = asocket_init(fd);
+
+    if (!s) {
+        ALOGV("asocket_init() failed, throwing");
+        jniThrowIOException(env, errno);
+        return;
+    }
+
+    env->SetIntField(obj, field_mSocketData, (jint)s);
+
+    return;
+#endif
+    jniThrowIOException(env, ENOSYS);
+}
+
+static void initSocketNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    int fd;
+    int lm = 0;
+    int sndbuf, rcvbuf;
+    jboolean auth;
+    jboolean encrypt;
+    jint type;
+    char value[PROPERTY_VALUE_MAX] = "";
+
+    type = env->GetIntField(obj, field_mType);
+
+    switch (type) {
+    case TYPE_RFCOMM:
+        fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);
+        break;
+    case TYPE_SCO_WBS:
+    case TYPE_SCO:
+        fd = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_SCO);
+        break;
+    case TYPE_L2CAP:
+        fd = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);
+        break;
+    case TYPE_EL2CAP:
+        fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);
+        break;
+    default:
+        jniThrowIOException(env, ENOSYS);
+        return;
+    }
+
+    if (fd < 0) {
+        ALOGV("socket() failed, throwing");
+        jniThrowIOException(env, errno);
+        return;
+    }
+
+    auth = env->GetBooleanField(obj, field_mAuth);
+    encrypt = env->GetBooleanField(obj, field_mEncrypt);
+
+    /* kernel does not yet support LM for SCO */
+
+    /* By default we request to be the MASTER of connection */
+    property_get("ro.bluetooth.request.master", value, "true");
+    switch (type) {
+    case TYPE_RFCOMM:
+        lm |= auth ? RFCOMM_LM_AUTH : 0;
+        lm |= encrypt ? RFCOMM_LM_ENCRYPT : 0;
+        lm |= (auth && encrypt) ? RFCOMM_LM_SECURE : 0;
+        if (!strcmp("true", value)) {
+            ALOGI("Setting Master socket option");
+            lm |= RFCOMM_LM_MASTER;
+        }
+        break;
+    case TYPE_L2CAP:
+    case TYPE_EL2CAP:
+        lm |= auth ? L2CAP_LM_AUTH : 0;
+        lm |= encrypt ? L2CAP_LM_ENCRYPT : 0;
+        lm |= (auth && encrypt) ? L2CAP_LM_SECURE : 0;
+        if (!strcmp("true", value)) {
+            ALOGI("Setting Master socket option");
+            lm |= L2CAP_LM_MASTER;
+        }
+        break;
+    }
+
+    if (lm) {
+        if (type == TYPE_RFCOMM) {
+            if (setsockopt(fd, SOL_RFCOMM, RFCOMM_LM, &lm, sizeof(lm))) {
+                ALOGV("setsockopt(RFCOMM_LM) failed, throwing");
+                close(fd);
+                jniThrowIOException(env, errno);
+                return;
+            }
+        } else if (type == TYPE_L2CAP || type == TYPE_EL2CAP) {
+            if (setsockopt(fd, SOL_L2CAP, L2CAP_LM, &lm, sizeof(lm))) {
+                ALOGV("setsockopt(L2CAP_LM) failed, throwing");
+                close(fd);
+                jniThrowIOException(env, errno);
+                return;
+            }
+        }
+    }
+
+    if (type == TYPE_RFCOMM) {
+        sndbuf = RFCOMM_SO_SNDBUF;
+        if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &sndbuf, sizeof(sndbuf))) {
+            ALOGV("setsockopt(SO_SNDBUF) failed, throwing");
+            close(fd);
+            jniThrowIOException(env, errno);
+            return;
+        }
+    }
+
+    /* Setting L2CAP socket options */
+    if (type == TYPE_L2CAP || type == TYPE_EL2CAP) {
+        struct l2cap_options opts;
+        int optlen = sizeof(opts), err;
+        err = getsockopt(fd, SOL_L2CAP, L2CAP_OPTIONS, &opts, &optlen );
+        if (!err) {
+            /* setting MTU for [E]L2CAP */
+            opts.omtu = opts.imtu = L2CAP_MAX_MTU;
+
+            /* Enable ERTM for [E]L2CAP */
+            if (type == TYPE_EL2CAP) {
+                opts.flush_to = 0xffff; /* infinite */
+                opts.mode = L2CAP_MODE_ERTM;
+                opts.fcs = 1;
+                opts.txwin_size = 64;
+                opts.max_tx = 10;
+            }
+            err = setsockopt( fd, SOL_L2CAP, L2CAP_OPTIONS, &opts, optlen );
+        }
+
+        /* Set larger SNDBUF & RCVBUF for EL2CAP connections */
+        if (type == TYPE_EL2CAP) {
+            sndbuf = L2CAP_SO_SNDBUF;
+            if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &sndbuf, sizeof(sndbuf))) {
+                ALOGV("setsockopt(SO_SNDBUF) failed, throwing");
+                close(fd);
+                jniThrowIOException(env, errno);
+                return;
+            }
+
+            rcvbuf = L2CAP_SO_RCVBUF;
+            if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(rcvbuf))) {
+                ALOGV("setsockopt(SO_RCVBUF) failed, throwing");
+                close(fd);
+                jniThrowIOException(env, errno);
+                return;
+           }
+        }
+    }
+
+
+    ALOGV("...fd %d created (%s, lm = %x)", fd, TYPE_AS_STR(type), lm);
+
+    initSocketFromFdNative(env, obj, fd);
+    return;
+#endif
+    jniThrowIOException(env, ENOSYS);
+}
+
+static void setAmpPolicyNative(JNIEnv *env, jobject obj, jint amppol) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return;
+
+    int err;
+    err = setsockopt(s->fd, SOL_BLUETOOTH, BT_AMP_POLICY, &amppol, sizeof(amppol));
+    if (err) {
+        ALOGV("setsockopt() failed, throwing");
+        jniThrowIOException(env, errno);
+        return;
+    }
+
+    return;
+#endif
+    jniThrowIOException(env, ENOSYS);
+}
+
+static int getMtuNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    jint type = env->GetIntField(obj, field_mType);
+    struct asocket *s = get_socketData(env, obj);
+
+    if (type == TYPE_RFCOMM || !s)
+        return L2CAP_MAX_MTU;
+
+    struct l2cap_options opts;
+    int optlen = sizeof(opts), err;
+    err = getsockopt(s->fd, SOL_L2CAP, L2CAP_OPTIONS, &opts, &optlen );
+    if (!err) {
+        return opts.omtu;
+    } else {
+        ALOGV("getsockopt() failed, throwing");
+        jniThrowIOException(env, errno);
+    }
+
+    return L2CAP_MAX_MTU;
+#endif
+    jniThrowIOException(env, ENOSYS);
+    return -1;
+}
+
+static void connectNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    int ret;
+    jint type;
+    const char *c_address;
+    jstring address;
+    bdaddr_t bdaddress;
+    socklen_t addr_sz;
+    struct sockaddr *addr;
+    struct asocket *s = get_socketData(env, obj);
+    int retry = 0;
+
+    if (!s)
+        return;
+
+    type = env->GetIntField(obj, field_mType);
+
+    /* parse address into bdaddress */
+    address = (jstring) env->GetObjectField(obj, field_mAddress);
+    c_address = env->GetStringUTFChars(address, NULL);
+    if (get_bdaddr(c_address, &bdaddress)) {
+        env->ReleaseStringUTFChars(address, c_address);
+        jniThrowIOException(env, EINVAL);
+        return;
+    }
+    env->ReleaseStringUTFChars(address, c_address);
+
+    switch (type) {
+    case TYPE_RFCOMM:
+        struct sockaddr_rc addr_rc;
+        addr = (struct sockaddr *)&addr_rc;
+        addr_sz = sizeof(addr_rc);
+
+        memset(addr, 0, addr_sz);
+        addr_rc.rc_family = AF_BLUETOOTH;
+        addr_rc.rc_channel = env->GetIntField(obj, field_mPort);
+        memcpy(&addr_rc.rc_bdaddr, &bdaddress, sizeof(bdaddr_t));
+
+        break;
+    case TYPE_SCO_WBS:
+    case TYPE_SCO:
+        struct sockaddr_sco addr_sco;
+        addr = (struct sockaddr *)&addr_sco;
+        addr_sz = sizeof(addr_sco);
+
+        memset(addr, 0, addr_sz);
+        addr_sco.sco_family = AF_BLUETOOTH;
+        addr_sco.is_wbs = (type == TYPE_SCO_WBS);
+        memcpy(&addr_sco.sco_bdaddr, &bdaddress, sizeof(bdaddr_t));
+
+        break;
+    case TYPE_L2CAP:
+    case TYPE_EL2CAP:
+        struct sockaddr_l2 addr_l2;
+        addr = (struct sockaddr *)&addr_l2;
+        addr_sz = sizeof(addr_l2);
+
+        memset(addr, 0, addr_sz);
+        addr_l2.l2_family = AF_BLUETOOTH;
+        addr_l2.l2_psm = env->GetIntField(obj, field_mPort);
+        memcpy(&addr_l2.l2_bdaddr, &bdaddress, sizeof(bdaddr_t));
+
+        break;
+    default:
+        jniThrowIOException(env, ENOSYS);
+        return;
+    }
+
+connect:
+    ret = asocket_connect(s, addr, addr_sz, -1);
+    ALOGV("...connect(%d, %s) = %d (errno %d)",
+            s->fd, TYPE_AS_STR(type), ret, errno);
+
+    if (ret && errno == EALREADY && retry < 2) {
+        /* workaround for bug 5082381 (EALREADY on ACL collision):
+         * retry the connect. Unfortunately we have to create a new fd.
+         * It's not ideal to switch the fd underneath the object, but
+         * is currently safe */
+        ALOGD("Hit bug 5082381 (EALREADY on ACL collision), trying workaround");
+        usleep(100000);
+        retry++;
+        abortNative(env, obj);
+        destroyNative(env, obj);
+        initSocketNative(env, obj);
+        if (env->ExceptionOccurred()) {
+            return;
+        }
+        s = get_socketData(env, obj); //Due to init socket ptr would be updated
+        goto connect;
+    }
+    if (!ret && retry > 0)
+        ALOGD("...workaround ok");
+
+    if (ret)
+        jniThrowIOException(env, errno);
+
+    return;
+#endif
+    jniThrowIOException(env, ENOSYS);
+}
+
+/* Returns errno instead of throwing, so java can check errno */
+static int bindListenNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    jint type;
+    socklen_t addr_sz;
+    struct sockaddr *addr;
+    bdaddr_t bdaddr = android_bluetooth_bdaddr_any();
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return EINVAL;
+
+    type = env->GetIntField(obj, field_mType);
+
+    switch (type) {
+    case TYPE_RFCOMM:
+        struct sockaddr_rc addr_rc;
+        addr = (struct sockaddr *)&addr_rc;
+        addr_sz = sizeof(addr_rc);
+
+        memset(addr, 0, addr_sz);
+        addr_rc.rc_family = AF_BLUETOOTH;
+        addr_rc.rc_channel = env->GetIntField(obj, field_mPort);
+        memcpy(&addr_rc.rc_bdaddr, &bdaddr, sizeof(bdaddr_t));
+        break;
+    case TYPE_SCO:
+        struct sockaddr_sco addr_sco;
+        addr = (struct sockaddr *)&addr_sco;
+        addr_sz = sizeof(addr_sco);
+
+        memset(addr, 0, addr_sz);
+        addr_sco.sco_family = AF_BLUETOOTH;
+        memcpy(&addr_sco.sco_bdaddr, &bdaddr, sizeof(bdaddr_t));
+        break;
+    case TYPE_L2CAP:
+    case TYPE_EL2CAP:
+        struct sockaddr_l2 addr_l2;
+        addr = (struct sockaddr *)&addr_l2;
+        addr_sz = sizeof(addr_l2);
+
+        memset(addr, 0, addr_sz);
+        addr_l2.l2_family = AF_BLUETOOTH;
+        addr_l2.l2_psm = env->GetIntField(obj, field_mPort);
+        memcpy(&addr_l2.l2_bdaddr, &bdaddr, sizeof(bdaddr_t));
+        break;
+    default:
+        return ENOSYS;
+    }
+
+    if (bind(s->fd, addr, addr_sz)) {
+        ALOGV("...bind(%d) gave errno %d", s->fd, errno);
+        return errno;
+    }
+
+    if (listen(s->fd, 1)) {
+        ALOGV("...listen(%d) gave errno %d", s->fd, errno);
+        return errno;
+    }
+
+    ALOGV("...bindListenNative(%d) success", s->fd);
+
+    return 0;
+
+#endif
+    return ENOSYS;
+}
+
+static jobject acceptNative(JNIEnv *env, jobject obj, int timeout) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    int fd;
+    jint type;
+    struct sockaddr *addr;
+    socklen_t addr_sz;
+    jstring addr_jstr;
+    char addr_cstr[BTADDR_SIZE];
+    bdaddr_t *bdaddr;
+    jboolean auth;
+    jboolean encrypt;
+
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return NULL;
+
+    type = env->GetIntField(obj, field_mType);
+
+    switch (type) {
+    case TYPE_RFCOMM:
+        struct sockaddr_rc addr_rc;
+        addr = (struct sockaddr *)&addr_rc;
+        addr_sz = sizeof(addr_rc);
+        bdaddr = &addr_rc.rc_bdaddr;
+        memset(addr, 0, addr_sz);
+        break;
+    case TYPE_SCO:
+        struct sockaddr_sco addr_sco;
+        addr = (struct sockaddr *)&addr_sco;
+        addr_sz = sizeof(addr_sco);
+        bdaddr = &addr_sco.sco_bdaddr;
+        memset(addr, 0, addr_sz);
+        break;
+    case TYPE_L2CAP:
+    case TYPE_EL2CAP:
+        struct sockaddr_l2 addr_l2;
+        addr = (struct sockaddr *)&addr_l2;
+        addr_sz = sizeof(addr_l2);
+        bdaddr = &addr_l2.l2_bdaddr;
+        memset(addr, 0, addr_sz);
+        break;
+    default:
+        jniThrowIOException(env, ENOSYS);
+        return NULL;
+    }
+
+    fd = asocket_accept(s, addr, &addr_sz, timeout);
+
+    ALOGV("...accept(%d, %s) = %d (errno %d)",
+            s->fd, TYPE_AS_STR(type), fd, errno);
+
+    if (fd < 0) {
+        jniThrowIOException(env, errno);
+        return NULL;
+    }
+
+    /* Connected - return new BluetoothSocket */
+    auth = env->GetBooleanField(obj, field_mAuth);
+    encrypt = env->GetBooleanField(obj, field_mEncrypt);
+
+    get_bdaddr_as_string(bdaddr, addr_cstr);
+
+    addr_jstr = env->NewStringUTF(addr_cstr);
+    return env->NewObject(class_BluetoothSocket, method_BluetoothSocket_ctor,
+            type, fd, auth, encrypt, addr_jstr, -1);
+
+#endif
+    jniThrowIOException(env, ENOSYS);
+    return NULL;
+}
+
+static jint availableNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    int available;
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return -1;
+
+    if (ioctl(s->fd, FIONREAD, &available) < 0) {
+        jniThrowIOException(env, errno);
+        return -1;
+    }
+
+    return available;
+
+#endif
+    jniThrowIOException(env, ENOSYS);
+    return -1;
+}
+
+static jint readNative(JNIEnv *env, jobject obj, jbyteArray jb, jint offset,
+        jint length) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    int ret;
+    jbyte *b;
+    int sz;
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return -1;
+    if (jb == NULL) {
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+    sz = env->GetArrayLength(jb);
+    if (offset < 0 || length < 0 || offset + length > sz) {
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+
+    b = env->GetByteArrayElements(jb, NULL);
+    if (b == NULL) {
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+
+    ret = asocket_read(s, &b[offset], length, -1);
+    if (ret < 0) {
+        jniThrowIOException(env, errno);
+        env->ReleaseByteArrayElements(jb, b, JNI_ABORT);
+        return -1;
+    }
+
+    env->ReleaseByteArrayElements(jb, b, 0);
+    return (jint)ret;
+
+#endif
+    jniThrowIOException(env, ENOSYS);
+    return -1;
+}
+
+static jint writeNative(JNIEnv *env, jobject obj, jbyteArray jb, jint offset,
+        jint length) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    int ret, total;
+    jbyte *b;
+    int sz;
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return -1;
+    if (jb == NULL) {
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+    sz = env->GetArrayLength(jb);
+    if (offset < 0 || length < 0 || offset + length > sz) {
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+
+    b = env->GetByteArrayElements(jb, NULL);
+    if (b == NULL) {
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+
+    total = 0;
+    while (length > 0) {
+        ret = asocket_write(s, &b[offset], length, -1);
+        if (ret < 0) {
+            jniThrowIOException(env, errno);
+            env->ReleaseByteArrayElements(jb, b, JNI_ABORT);
+            return -1;
+        }
+        offset += ret;
+        total += ret;
+        length -= ret;
+    }
+
+    env->ReleaseByteArrayElements(jb, b, JNI_ABORT);  // no need to commit
+    return (jint)total;
+
+#endif
+    jniThrowIOException(env, ENOSYS);
+    return -1;
+}
+
+static void abortNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return;
+
+    asocket_abort(s);
+
+    ALOGV("...asocket_abort(%d) complete", s->fd);
+    return;
+#endif
+    jniThrowIOException(env, ENOSYS);
+}
+
+static void destroyNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    struct asocket *s = get_socketData(env, obj);
+    int fd = s->fd;
+
+    if (!s)
+        return;
+
+    asocket_destroy(s);
+
+    ALOGV("...asocket_destroy(%d) complete", fd);
+    return;
+#endif
+    jniThrowIOException(env, ENOSYS);
+}
+
+static void throwErrnoNative(JNIEnv *env, jobject obj, jint err) {
+    jniThrowIOException(env, err);
+}
+
+static JNINativeMethod sMethods[] = {
+    {"initSocketNative", "()V",  (void*) initSocketNative},
+    {"initSocketFromFdNative", "(I)V",  (void*) initSocketFromFdNative},
+    {"setAmpPolicyNative", "(I)V",  (void*) setAmpPolicyNative},
+    {"getMtuNative", "()I",  (void*) getMtuNative},
+    {"connectNative", "()V", (void *) connectNative},
+    {"bindListenNative", "()I", (void *) bindListenNative},
+    {"acceptNative", "(I)Landroid/bluetooth/BluetoothSocket;", (void *) acceptNative},
+    {"availableNative", "()I",    (void *) availableNative},
+    {"readNative", "([BII)I",    (void *) readNative},
+    {"writeNative", "([BII)I",    (void *) writeNative},
+    {"abortNative", "()V",    (void *) abortNative},
+    {"destroyNative", "()V",    (void *) destroyNative},
+    {"throwErrnoNative", "(I)V",    (void *) throwErrnoNative},
+};
+
+int register_android_bluetooth_BluetoothSocket(JNIEnv *env) {
+    jclass clazz = env->FindClass("android/bluetooth/BluetoothSocket");
+    if (clazz == NULL)
+        return -1;
+    class_BluetoothSocket = (jclass) env->NewGlobalRef(clazz);
+    field_mType = env->GetFieldID(clazz, "mType", "I");
+    field_mAddress = env->GetFieldID(clazz, "mAddress", "Ljava/lang/String;");
+    field_mPort = env->GetFieldID(clazz, "mPort", "I");
+    field_mAuth = env->GetFieldID(clazz, "mAuth", "Z");
+    field_mEncrypt = env->GetFieldID(clazz, "mEncrypt", "Z");
+    field_mSocketData = env->GetFieldID(clazz, "mSocketData", "I");
+    method_BluetoothSocket_ctor = env->GetMethodID(clazz, "<init>", "(IIZZLjava/lang/String;I)V");
+    return AndroidRuntime::registerNativeMethods(env,
+        "android/bluetooth/BluetoothSocket", sMethods, NELEM(sMethods));
+}
+
+} /* namespace android */
+
diff --git a/core/jni/bluetoothmsm/android_bluetooth_HeadsetBase.cpp b/core/jni/bluetoothmsm/android_bluetooth_HeadsetBase.cpp
new file mode 100644
index 0000000..f3fc4f2
--- /dev/null
+++ b/core/jni/bluetoothmsm/android_bluetooth_HeadsetBase.cpp
@@ -0,0 +1,567 @@
+/*
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "BT HSHFP"
+
+#include "android_bluetooth_common.h"
+#include "android_runtime/AndroidRuntime.h"
+#include "JNIHelp.h"
+#include "jni.h"
+#include "utils/Log.h"
+#include "utils/misc.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/poll.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/rfcomm.h>
+#include <bluetooth/sco.h>
+#endif
+
+namespace android {
+
+#ifdef HAVE_BLUETOOTH
+static jfieldID field_mNativeData;
+static jfieldID field_mAddress;
+static jfieldID field_mRfcommChannel;
+static jfieldID field_mTimeoutRemainingMs;
+
+typedef struct {
+    jstring address;
+    const char *c_address;
+    int rfcomm_channel;
+    int last_read_err;
+    int rfcomm_sock;
+    int rfcomm_connected; // -1 in progress, 0 not connected, 1 connected
+    int rfcomm_sock_flags;
+} native_data_t;
+
+static inline native_data_t * get_native_data(JNIEnv *env, jobject object) {
+    return (native_data_t *)(env->GetIntField(object, field_mNativeData));
+}
+
+static const char CRLF[] = "\xd\xa";
+static const int CRLF_LEN = 2;
+
+static inline int write_error_check(int fd, const char* line, int len) {
+    int ret;
+    errno = 0;
+    ret = write(fd, line, len);
+    if (ret < 0) {
+        ALOGE("%s: write() failed: %s (%d)", __FUNCTION__, strerror(errno),
+             errno);
+        return -1;
+    }
+    if (ret != len) {
+        ALOGE("%s: write() only wrote %d of %d bytes", __FUNCTION__, ret, len);
+        return -1;
+    }
+    return 0;
+}
+
+static int send_line(int fd, const char* line) {
+    int nw;
+    int len = strlen(line);
+    int llen = len + CRLF_LEN * 2 + 1;
+    char *buffer = (char *)calloc(llen, sizeof(char));
+
+    snprintf(buffer, llen, "%s%s%s", CRLF, line, CRLF);
+
+    if (write_error_check(fd, buffer, llen - 1)) {
+        free(buffer);
+        return -1;
+    }
+    free(buffer);
+    return 0;
+}
+
+static void mask_eighth_bit(char *line)
+{
+   for (;;line++) {
+     if (0 == *line) return;
+     *line &= 0x7F;
+   }
+}
+
+static const char* get_line(int fd, char *buf, int len, int timeout_ms,
+                            int *err) {
+    char *bufit=buf;
+    int fd_flags = fcntl(fd, F_GETFL, 0);
+    struct pollfd pfd;
+
+again:
+    *bufit = 0;
+    pfd.fd = fd;
+    pfd.events = POLLIN;
+    *err = errno = 0;
+    int ret = TEMP_FAILURE_RETRY(poll(&pfd, 1, timeout_ms));
+    if (ret < 0) {
+        ALOGE("poll() error\n");
+        *err = errno;
+        return NULL;
+    }
+    if (ret == 0) {
+        return NULL;
+    }
+
+    if (pfd.revents & (POLLHUP | POLLERR | POLLNVAL)) {
+        ALOGW("RFCOMM poll() returned  success (%d), "
+             "but with an unexpected revents bitmask: %#x\n", ret, pfd.revents);
+        errno = EIO;
+        *err = errno;
+        return NULL;
+    }
+
+    while ((int)(bufit - buf) < (len - 1))
+    {
+        errno = 0;
+        int rc = TEMP_FAILURE_RETRY(read(fd, bufit, 1));
+
+        if (!rc)
+            break;
+
+        if (rc < 0) {
+            if (errno == EBUSY) {
+                ALOGI("read() error %s (%d): repeating read()...",
+                     strerror(errno), errno);
+                goto again;
+            }
+            *err = errno;
+            ALOGE("read() error %s (%d)", strerror(errno), errno);
+            return NULL;
+        }
+
+
+        if (*bufit=='\xd') {
+            break;
+        }
+
+        if (*bufit=='\xa')
+            bufit = buf;
+        else
+            bufit++;
+    }
+
+    *bufit = 0;
+
+    // According to ITU V.250 section 5.1, IA5 7 bit chars are used,
+    //   the eighth bit or higher bits are ignored if they exists
+    // We mask out only eighth bit, no higher bit, since we do char
+    // string here, not wide char.
+    // We added this processing due to 2 real world problems.
+    // 1 BMW 2005 E46 which sends binary junk
+    // 2 Audi 2010 A3, dial command use 0xAD (soft-hyphen) as number
+    //   formater, which was rejected by the AT handler
+    mask_eighth_bit(buf);
+
+    return buf;
+}
+#endif
+
+static void classInitNative(JNIEnv* env, jclass clazz) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    field_mNativeData = get_field(env, clazz, "mNativeData", "I");
+    field_mAddress = get_field(env, clazz, "mAddress", "Ljava/lang/String;");
+    field_mTimeoutRemainingMs = get_field(env, clazz, "mTimeoutRemainingMs", "I");
+    field_mRfcommChannel = get_field(env, clazz, "mRfcommChannel", "I");
+#endif
+}
+
+static void initializeNativeDataNative(JNIEnv* env, jobject object,
+                                       jint socketFd) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = (native_data_t *)calloc(1, sizeof(native_data_t));
+    if (NULL == nat) {
+        ALOGE("%s: out of memory!", __FUNCTION__);
+        return;
+    }
+
+    env->SetIntField(object, field_mNativeData, (jint)nat);
+    nat->address =
+        (jstring)env->NewGlobalRef(env->GetObjectField(object,
+                                                       field_mAddress));
+    nat->c_address = env->GetStringUTFChars(nat->address, NULL);
+    nat->rfcomm_channel = env->GetIntField(object, field_mRfcommChannel);
+    nat->rfcomm_sock = socketFd;
+    nat->rfcomm_connected = socketFd >= 0;
+    if (nat->rfcomm_connected)
+        ALOGI("%s: ALREADY CONNECTED!", __FUNCTION__);
+#endif
+}
+
+static void cleanupNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat =
+        (native_data_t *)env->GetIntField(object, field_mNativeData);
+    env->ReleaseStringUTFChars(nat->address, nat->c_address);
+    env->DeleteGlobalRef(nat->address);
+    if (nat)
+        free(nat);
+#endif
+}
+
+static jboolean connectNative(JNIEnv *env, jobject obj)
+{
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    int lm;
+    struct sockaddr_rc addr;
+    native_data_t *nat = get_native_data(env, obj);
+
+    nat->rfcomm_sock = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);
+
+    if (nat->rfcomm_sock < 0) {
+        ALOGE("%s: Could not create RFCOMM socket: %s\n", __FUNCTION__,
+             strerror(errno));
+        return JNI_FALSE;
+    }
+
+    if (debug_no_encrypt()) {
+        lm = RFCOMM_LM_AUTH;
+    } else {
+        lm = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;
+    }
+
+    if (lm && setsockopt(nat->rfcomm_sock, SOL_RFCOMM, RFCOMM_LM, &lm,
+                sizeof(lm)) < 0) {
+        ALOGE("%s: Can't set RFCOMM link mode", __FUNCTION__);
+        close(nat->rfcomm_sock);
+        return JNI_FALSE;
+    }
+
+    memset(&addr, 0, sizeof(struct sockaddr_rc));
+    get_bdaddr(nat->c_address, &addr.rc_bdaddr);
+    addr.rc_channel = nat->rfcomm_channel;
+    addr.rc_family = AF_BLUETOOTH;
+    nat->rfcomm_connected = 0;
+    while (nat->rfcomm_connected == 0) {
+        if (connect(nat->rfcomm_sock, (struct sockaddr *)&addr,
+                      sizeof(addr)) < 0) {
+            if (errno == EINTR) continue;
+            ALOGE("%s: connect() failed: %s\n", __FUNCTION__, strerror(errno));
+            close(nat->rfcomm_sock);
+            nat->rfcomm_sock = -1;
+            return JNI_FALSE;
+        } else {
+            nat->rfcomm_connected = 1;
+        }
+    }
+
+    return JNI_TRUE;
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jint connectAsyncNative(JNIEnv *env, jobject obj) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    struct sockaddr_rc addr;
+    native_data_t *nat = get_native_data(env, obj);
+
+    if (nat->rfcomm_connected) {
+        ALOGV("RFCOMM socket is already connected or connection is in progress.");
+        return 0;
+    }
+
+    if (nat->rfcomm_sock < 0) {
+        int lm;
+
+        nat->rfcomm_sock = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);
+        if (nat->rfcomm_sock < 0) {
+            ALOGE("%s: Could not create RFCOMM socket: %s\n", __FUNCTION__,
+                 strerror(errno));
+            return -1;
+        }
+
+        if (debug_no_encrypt()) {
+            lm = RFCOMM_LM_AUTH;
+        } else {
+            lm = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;
+        }
+
+        if (lm && setsockopt(nat->rfcomm_sock, SOL_RFCOMM, RFCOMM_LM, &lm,
+                    sizeof(lm)) < 0) {
+            ALOGE("%s: Can't set RFCOMM link mode", __FUNCTION__);
+            close(nat->rfcomm_sock);
+            return -1;
+        }
+        ALOGI("Created RFCOMM socket fd %d.", nat->rfcomm_sock);
+    }
+
+    memset(&addr, 0, sizeof(struct sockaddr_rc));
+    get_bdaddr(nat->c_address, &addr.rc_bdaddr);
+    addr.rc_channel = nat->rfcomm_channel;
+    addr.rc_family = AF_BLUETOOTH;
+    if (nat->rfcomm_sock_flags >= 0) {
+        nat->rfcomm_sock_flags = fcntl(nat->rfcomm_sock, F_GETFL, 0);
+        if (fcntl(nat->rfcomm_sock,
+                  F_SETFL, nat->rfcomm_sock_flags | O_NONBLOCK) >= 0) {
+            int rc;
+            nat->rfcomm_connected = 0;
+            errno = 0;
+            rc = connect(nat->rfcomm_sock,
+                        (struct sockaddr *)&addr,
+                         sizeof(addr));
+
+            if (rc >= 0) {
+                nat->rfcomm_connected = 1;
+                ALOGI("async connect successful");
+                return 0;
+            }
+            else if (rc < 0) {
+                if (errno == EINPROGRESS || errno == EAGAIN)
+                {
+                    ALOGI("async connect is in progress (%s)",
+                         strerror(errno));
+                    nat->rfcomm_connected = -1;
+                    return 0;
+                }
+                else
+                {
+                    ALOGE("async connect error: %s (%d)", strerror(errno), errno);
+                    close(nat->rfcomm_sock);
+                    nat->rfcomm_sock = -1;
+                    return -errno;
+                }
+            }
+        } // fcntl(nat->rfcomm_sock ...)
+    } // if (nat->rfcomm_sock_flags >= 0)
+#endif
+    return -1;
+}
+
+static jint waitForAsyncConnectNative(JNIEnv *env, jobject obj,
+                                           jint timeout_ms) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    struct sockaddr_rc addr;
+    native_data_t *nat = get_native_data(env, obj);
+
+    env->SetIntField(obj, field_mTimeoutRemainingMs, timeout_ms);
+
+    if (nat->rfcomm_connected > 0) {
+        ALOGI("RFCOMM is already connected!");
+        return 1;
+    }
+
+    if (nat->rfcomm_sock >= 0 && nat->rfcomm_connected == 0) {
+        ALOGI("Re-opening RFCOMM socket.");
+        close(nat->rfcomm_sock);
+        nat->rfcomm_sock = -1;
+    }
+    int ret = connectAsyncNative(env, obj);
+
+    if (ret < 0) {
+        ALOGI("Failed to re-open RFCOMM socket!");
+        return ret;
+    }
+
+    if (nat->rfcomm_sock >= 0) {
+        /* Do an asynchronous select() */
+        int n;
+        fd_set rset, wset;
+        struct timeval to;
+
+        FD_ZERO(&rset);
+        FD_ZERO(&wset);
+        FD_SET(nat->rfcomm_sock, &rset);
+        FD_SET(nat->rfcomm_sock, &wset);
+        if (timeout_ms >= 0) {
+            to.tv_sec = timeout_ms / 1000;
+            to.tv_usec = 1000 * (timeout_ms % 1000);
+        }
+        n = select(nat->rfcomm_sock + 1,
+                   &rset,
+                   &wset,
+                   NULL,
+                   (timeout_ms < 0 ? NULL : &to));
+
+        if (timeout_ms > 0) {
+            jint remaining = to.tv_sec*1000 + to.tv_usec/1000;
+            ALOGV("Remaining time %ldms", (long)remaining);
+            env->SetIntField(obj, field_mTimeoutRemainingMs,
+                             remaining);
+        }
+
+        if (n <= 0) {
+            if (n < 0)  {
+                ALOGE("select() on RFCOMM socket: %s (%d)",
+                     strerror(errno),
+                     errno);
+                return -errno;
+            }
+            return 0;
+        }
+        /* n must be equal to 1 and either rset or wset must have the
+           file descriptor set. */
+        ALOGV("select() returned %d.", n);
+        if (FD_ISSET(nat->rfcomm_sock, &rset) ||
+            FD_ISSET(nat->rfcomm_sock, &wset))
+        {
+            /* A trial async read() will tell us if everything is OK. */
+            {
+                char ch;
+                errno = 0;
+                int nr = TEMP_FAILURE_RETRY(read(nat->rfcomm_sock, &ch, 1));
+                /* It should be that nr != 1 because we just opened a socket
+                   and we haven't sent anything over it for the other side to
+                   respond... but one can't be paranoid enough.
+                */
+                if (nr >= 0 || errno != EAGAIN) {
+                    ALOGE("RFCOMM async connect() error: %s (%d), nr = %d\n",
+                         strerror(errno),
+                         errno,
+                         nr);
+                    /* Clear the rfcomm_connected flag to cause this function
+                       to re-create the socket and re-attempt the connect()
+                       the next time it is called.
+                    */
+                    nat->rfcomm_connected = 0;
+                    /* Restore the blocking properties of the socket. */
+                    fcntl(nat->rfcomm_sock, F_SETFL, nat->rfcomm_sock_flags);
+                    close(nat->rfcomm_sock);
+                    nat->rfcomm_sock = -1;
+                    return -errno;
+                }
+            }
+            /* Restore the blocking properties of the socket. */
+            fcntl(nat->rfcomm_sock, F_SETFL, nat->rfcomm_sock_flags);
+            ALOGI("Successful RFCOMM socket connect.");
+            nat->rfcomm_connected = 1;
+            return 1;
+        }
+    }
+    else ALOGE("RFCOMM socket file descriptor %d is bad!",
+              nat->rfcomm_sock);
+#endif
+    return -1;
+}
+
+static void disconnectNative(JNIEnv *env, jobject obj) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, obj);
+    if (nat->rfcomm_sock >= 0) {
+        close(nat->rfcomm_sock);
+        nat->rfcomm_sock = -1;
+        nat->rfcomm_connected = 0;
+    }
+#endif
+}
+
+static void pretty_log_urc(const char *urc) {
+    size_t i;
+    bool in_line_break = false;
+    char *buf = (char *)calloc(strlen(urc) + 1, sizeof(char));
+
+    strcpy(buf, urc);
+    for (i = 0; i < strlen(buf); i++) {
+        switch(buf[i]) {
+        case '\r':
+        case '\n':
+            in_line_break = true;
+            buf[i] = ' ';
+            break;
+        default:
+            if (in_line_break) {
+                in_line_break = false;
+                buf[i-1] = '\n';
+            }
+        }
+    }
+    IF_ALOGV() ALOG(LOG_VERBOSE, "Bluetooth AT sent", "%s", buf);
+
+    free(buf);
+}
+
+static jboolean sendURCNative(JNIEnv *env, jobject obj, jstring urc) {
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, obj);
+    if (nat->rfcomm_connected) {
+        const char *c_urc = env->GetStringUTFChars(urc, NULL);
+        jboolean ret = send_line(nat->rfcomm_sock, c_urc) == 0 ? JNI_TRUE : JNI_FALSE;
+        if (ret == JNI_TRUE) pretty_log_urc(c_urc);
+        env->ReleaseStringUTFChars(urc, c_urc);
+        return ret;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jstring readNative(JNIEnv *env, jobject obj, jint timeout_ms) {
+#ifdef HAVE_BLUETOOTH
+    {
+        native_data_t *nat = get_native_data(env, obj);
+        if (nat->rfcomm_connected) {
+            char buf[256];
+            const char *ret = get_line(nat->rfcomm_sock,
+                                       buf, sizeof(buf),
+                                       timeout_ms,
+                                       &nat->last_read_err);
+            return ret ? env->NewStringUTF(ret) : NULL;
+        }
+        return NULL;
+    }
+#else
+    return NULL;
+#endif
+}
+
+static jint getLastReadStatusNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    {
+        native_data_t *nat = get_native_data(env, obj);
+        if (nat->rfcomm_connected)
+            return (jint)nat->last_read_err;
+        return 0;
+    }
+#else
+    return 0;
+#endif
+}
+
+static JNINativeMethod sMethods[] = {
+     /* name, signature, funcPtr */
+    {"classInitNative", "()V", (void*)classInitNative},
+    {"initializeNativeDataNative", "(I)V", (void *)initializeNativeDataNative},
+    {"cleanupNativeDataNative", "()V", (void *)cleanupNativeDataNative},
+    {"connectNative", "()Z", (void *)connectNative},
+    {"connectAsyncNative", "()I", (void *)connectAsyncNative},
+    {"waitForAsyncConnectNative", "(I)I", (void *)waitForAsyncConnectNative},
+    {"disconnectNative", "()V", (void *)disconnectNative},
+    {"sendURCNative", "(Ljava/lang/String;)Z", (void *)sendURCNative},
+    {"readNative", "(I)Ljava/lang/String;", (void *)readNative},
+    {"getLastReadStatusNative", "()I", (void *)getLastReadStatusNative},
+};
+
+int register_android_bluetooth_HeadsetBase(JNIEnv *env) {
+    return AndroidRuntime::registerNativeMethods(env,
+            "android/bluetooth/HeadsetBase", sMethods, NELEM(sMethods));
+}
+
+} /* namespace android */
diff --git a/core/jni/bluetoothmsm/android_bluetooth_c.c b/core/jni/bluetoothmsm/android_bluetooth_c.c
new file mode 100644
index 0000000..b4c6727
--- /dev/null
+++ b/core/jni/bluetoothmsm/android_bluetooth_c.c
@@ -0,0 +1,31 @@
+/*
+** Copyright 2011, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifdef HAVE_BLUETOOTH
+
+#include "android_bluetooth_c.h"
+
+/*
+ * A C helper for creating a bdaddr_t object with the value BDADDR_ANY.
+ * We have to do this in C because the macro BDADDR_ANY in bluetooth.h
+ * is not valid C++ code.
+ */
+bdaddr_t android_bluetooth_bdaddr_any(void)
+{
+  bdaddr_t any = *BDADDR_ANY;
+  return any;
+}
+#endif
diff --git a/core/jni/bluetoothmsm/android_bluetooth_c.h b/core/jni/bluetoothmsm/android_bluetooth_c.h
new file mode 100644
index 0000000..e890244
--- /dev/null
+++ b/core/jni/bluetoothmsm/android_bluetooth_c.h
@@ -0,0 +1,39 @@
+/*
+** Copyright 2010, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifndef ANDROID_BLUETOOTH_C_H
+#define ANDROID_BLUETOOTH_C_H
+#ifdef HAVE_BLUETOOTH
+
+#include <bluetooth/bluetooth.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * A C helper for creating a bdaddr_t object with the value BDADDR_ANY.
+ * We have to do this in C because the macro BDADDR_ANY in bluetooth.h
+ * is not valid C++ code.
+ */
+bdaddr_t android_bluetooth_bdaddr_any(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*HAVE_BLUETOOTH*/
+#endif /*ANDROID_BLUETOOTH_C_H*/
diff --git a/core/jni/bluetoothmsm/android_bluetooth_common.cpp b/core/jni/bluetoothmsm/android_bluetooth_common.cpp
new file mode 100644
index 0000000..363ba10
--- /dev/null
+++ b/core/jni/bluetoothmsm/android_bluetooth_common.cpp
@@ -0,0 +1,1092 @@
+/*
+** Copyright 2006, The Android Open Source Project
+** Copyright (c) 2011, The Linux Foundation. All rights reserved.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "bluetooth_common.cpp"
+
+#include "android_bluetooth_common.h"
+#include "JNIHelp.h"
+#include "jni.h"
+#include "utils/Log.h"
+#include "utils/misc.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <cutils/properties.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <dbus/dbus.h>
+#endif
+
+namespace android {
+
+#ifdef HAVE_BLUETOOTH
+
+static Properties remote_device_properties[] = {
+    {"Address",  DBUS_TYPE_STRING},
+    {"Name", DBUS_TYPE_STRING},
+    {"Icon", DBUS_TYPE_STRING},
+    {"Class", DBUS_TYPE_UINT32},
+    {"UUIDs", DBUS_TYPE_ARRAY},
+    {"Paired", DBUS_TYPE_BOOLEAN},
+    {"Connected", DBUS_TYPE_ARRAY},
+    {"Trusted", DBUS_TYPE_BOOLEAN},
+    {"Blocked", DBUS_TYPE_BOOLEAN},
+    {"Alias", DBUS_TYPE_STRING},
+    {"Nodes", DBUS_TYPE_ARRAY},
+    {"Adapter", DBUS_TYPE_OBJECT_PATH},
+    {"LegacyPairing", DBUS_TYPE_BOOLEAN},
+    {"RSSI", DBUS_TYPE_INT16},
+    {"TX", DBUS_TYPE_UINT32},
+    {"Type", DBUS_TYPE_STRING},
+    {"Broadcaster", DBUS_TYPE_BOOLEAN},
+    {"Services", DBUS_TYPE_ARRAY},
+    {"LeConnParams", DBUS_TYPE_UINT16}
+};
+
+static Properties adapter_properties[] = {
+    {"Address", DBUS_TYPE_STRING},
+    {"Name", DBUS_TYPE_STRING},
+    {"Class", DBUS_TYPE_UINT32},
+    {"Powered", DBUS_TYPE_BOOLEAN},
+    {"Discoverable", DBUS_TYPE_BOOLEAN},
+    {"DiscoverableTimeout", DBUS_TYPE_UINT32},
+    {"Pairable", DBUS_TYPE_BOOLEAN},
+    {"PairableTimeout", DBUS_TYPE_UINT32},
+    {"Discovering", DBUS_TYPE_BOOLEAN},
+    {"Devices", DBUS_TYPE_ARRAY},
+    {"UUIDs", DBUS_TYPE_ARRAY},
+    {"Type", DBUS_TYPE_STRING},
+};
+
+static Properties input_properties[] = {
+    {"Connected", DBUS_TYPE_BOOLEAN},
+};
+
+static Properties pan_properties[] = {
+    {"Connected", DBUS_TYPE_BOOLEAN},
+    {"Interface", DBUS_TYPE_STRING},
+    {"UUID", DBUS_TYPE_STRING},
+};
+
+static Properties health_device_properties[] = {
+    {"MainChannel", DBUS_TYPE_OBJECT_PATH},
+};
+
+static Properties health_channel_properties[] = {
+    {"Type", DBUS_TYPE_STRING},
+    {"Device", DBUS_TYPE_OBJECT_PATH},
+    {"Application", DBUS_TYPE_OBJECT_PATH},
+};
+
+static Properties gatt_service_properties[] = {
+    {"Name", DBUS_TYPE_STRING},
+    {"Description", DBUS_TYPE_STRING},
+    {"UUID", DBUS_TYPE_STRING},
+    {"Characteristics", DBUS_TYPE_ARRAY},
+};
+
+static Properties gatt_characteristic_properties[] = {
+    {"UUID", DBUS_TYPE_STRING},
+    {"Name", DBUS_TYPE_STRING},
+    {"Description", DBUS_TYPE_STRING},
+    {"Format", DBUS_TYPE_STRUCT},
+    {"Value", DBUS_TYPE_ARRAY},
+    {"Representation", DBUS_TYPE_STRING},
+    {"ClientConfiguration", DBUS_TYPE_UINT16},
+    {"Properties", DBUS_TYPE_BYTE},
+};
+
+typedef union {
+    char *str_val;
+    int int_val;
+    char **array_val;
+} property_value;
+
+jfieldID get_field(JNIEnv *env, jclass clazz, const char *member,
+                   const char *mtype) {
+    jfieldID field = env->GetFieldID(clazz, member, mtype);
+    if (field == NULL) {
+        ALOGE("Can't find member %s", member);
+    }
+    return field;
+}
+
+
+void dbus_func_args_async_callback(DBusPendingCall *call, void *data) {
+
+    dbus_async_call_t *req = (dbus_async_call_t *)data;
+    DBusMessage *msg;
+
+    /* This is guaranteed to be non-NULL, because this function is called only
+       when once the remote method invokation returns. */
+    msg = dbus_pending_call_steal_reply(call);
+
+    if (msg) {
+        if (req->user_cb) {
+            // The user may not deref the message object.
+            req->user_cb(msg, req->user, req->nat);
+        }
+        dbus_message_unref(msg);
+    }
+
+    //dbus_message_unref(req->method);
+    dbus_pending_call_cancel(call);
+    dbus_pending_call_unref(call);
+    free(req);
+}
+
+static dbus_bool_t dbus_func_args_async_valist(JNIEnv *env,
+                                        DBusConnection *conn,
+                                        int timeout_ms,
+                                        void (*user_cb)(DBusMessage *,
+                                                        void *,
+                                                        void*),
+                                        void *user,
+                                        void *nat,
+                                        const char *path,
+                                        const char *ifc,
+                                        const char *func,
+                                        int first_arg_type,
+                                        va_list args) {
+    DBusMessage *msg = NULL;
+    const char *name;
+    dbus_async_call_t *pending;
+    dbus_bool_t reply = FALSE;
+
+    if (!path || !func || !ifc) {
+        return FALSE;
+    }
+
+    /* Compose the command */
+    msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC, path, ifc, func);
+
+    if (msg == NULL) {
+        ALOGE("Could not allocate D-Bus message object!");
+        goto done;
+    }
+
+    /* append arguments */
+    if (!dbus_message_append_args_valist(msg, first_arg_type, args)) {
+        ALOGE("Could not append argument to method call!");
+        goto done;
+    }
+
+    /* Make the call. */
+    pending = (dbus_async_call_t *)malloc(sizeof(dbus_async_call_t));
+    if (pending) {
+        DBusPendingCall *call;
+
+        pending->env = env;
+        pending->user_cb = user_cb;
+        pending->user = user;
+        pending->nat = nat;
+        //pending->method = msg;
+
+        reply = dbus_connection_send_with_reply(conn, msg,
+                                                &call,
+                                                timeout_ms);
+        if (reply == TRUE) {
+            dbus_pending_call_set_notify(call,
+                                         dbus_func_args_async_callback,
+                                         pending,
+                                         NULL);
+        }
+    }
+
+done:
+    if (msg) dbus_message_unref(msg);
+    return reply;
+}
+
+dbus_bool_t dbus_func_args_async(JNIEnv *env,
+                                 DBusConnection *conn,
+                                 int timeout_ms,
+                                 void (*reply)(DBusMessage *, void *, void*),
+                                 void *user,
+                                 void *nat,
+                                 const char *path,
+                                 const char *ifc,
+                                 const char *func,
+                                 int first_arg_type,
+                                 ...) {
+    dbus_bool_t ret;
+    va_list lst;
+    if (!path || !func || !ifc) {
+        return FALSE;
+    }
+
+    va_start(lst, first_arg_type);
+    ret = dbus_func_args_async_valist(env, conn,
+                                      timeout_ms,
+                                      reply, user, nat,
+                                      path, ifc, func,
+                                      first_arg_type, lst);
+    va_end(lst);
+    return ret;
+}
+
+// If err is NULL, then any errors will be ALOGE'd, and free'd and the reply
+// will be NULL.
+// If err is not NULL, then it is assumed that dbus_error_init was already
+// called, and error's will be returned to the caller without logging. The
+// return value is NULL iff an error was set. The client must free the error if
+// set.
+DBusMessage * dbus_func_args_timeout_valist(JNIEnv *env,
+                                            DBusConnection *conn,
+                                            int timeout_ms,
+                                            DBusError *err,
+                                            const char *path,
+                                            const char *ifc,
+                                            const char *func,
+                                            int first_arg_type,
+                                            va_list args) {
+
+    DBusMessage *msg = NULL, *reply = NULL;
+    const char *name;
+    bool return_error = (err != NULL);
+
+    if (!path || !func || !ifc) {
+        return NULL;
+    }
+
+    if (!return_error) {
+        err = (DBusError*)malloc(sizeof(DBusError));
+        dbus_error_init(err);
+    }
+
+    /* Compose the command */
+    msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC, path, ifc, func);
+
+    if (msg == NULL) {
+        ALOGE("Could not allocate D-Bus message object!");
+        goto done;
+    }
+
+    /* append arguments */
+    if (!dbus_message_append_args_valist(msg, first_arg_type, args)) {
+        ALOGE("Could not append argument to method call!");
+        goto done;
+    }
+
+    /* Make the call. */
+    reply = dbus_connection_send_with_reply_and_block(conn, msg, timeout_ms, err);
+    if (!return_error && dbus_error_is_set(err)) {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(err, msg);
+    }
+
+done:
+    if (!return_error) {
+        free(err);
+    }
+    if (msg) dbus_message_unref(msg);
+    return reply;
+}
+
+/*
+ * This generic version of the function will take the service path
+ * as an argument and call the methods on the given service, path and
+ * interface.
+ * This can be used to call any interface on any services that are
+ * connected to D-Bus
+ */
+DBusMessage * dbus_func_args_generic_timeout_valist(JNIEnv *env,
+                                            DBusConnection *conn,
+                                            int timeout_ms,
+                                            DBusError *err,
+                                            const char *service,
+                                            const char *path,
+                                            const char *ifc,
+                                            const char *func,
+                                            int first_arg_type,
+                                            va_list args) {
+
+    DBusMessage *msg = NULL, *reply = NULL;
+    const char *name;
+    bool return_error = (err != NULL);
+
+    if (!path || !func || !ifc) {
+        return NULL;
+    }
+
+    if (!return_error) {
+        err = (DBusError*)malloc(sizeof(DBusError));
+        dbus_error_init(err);
+    }
+
+    /* Compose the command */
+    msg = dbus_message_new_method_call(service, path, ifc, func);
+
+    if (msg == NULL) {
+        ALOGE("Could not allocate D-Bus message object!");
+        goto done;
+    }
+
+    /* append arguments */
+    if (!dbus_message_append_args_valist(msg, first_arg_type, args)) {
+        ALOGE("Could not append argument to method call!");
+        goto done;
+    }
+
+    /* Make the call. */
+    reply = dbus_connection_send_with_reply_and_block(conn, msg, timeout_ms, err);
+    if (!return_error && dbus_error_is_set(err)) {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(err, msg);
+    }
+
+done:
+    if (!return_error) {
+        free(err);
+    }
+    if (msg) dbus_message_unref(msg);
+    return reply;
+}
+
+DBusMessage * dbus_func_args_timeout(JNIEnv *env,
+                                     DBusConnection *conn,
+                                     int timeout_ms,
+                                     const char *path,
+                                     const char *ifc,
+                                     const char *func,
+                                     int first_arg_type,
+                                     ...) {
+    DBusMessage *ret;
+    va_list lst;
+    if (!path || !func || !ifc) {
+        return NULL;
+    }
+
+    va_start(lst, first_arg_type);
+    ret = dbus_func_args_timeout_valist(env, conn, timeout_ms, NULL,
+                                        path, ifc, func,
+                                        first_arg_type, lst);
+    va_end(lst);
+    return ret;
+}
+
+/*
+ * This generic version of the function will take the service path
+ * as an argument and call the methods on the given service, path and
+ * interface.
+ * This can be used to call any interface on any services that are
+ * connected to D-Bus
+ */
+DBusMessage * dbus_func_args_generic(JNIEnv *env,
+                             DBusConnection *conn,
+                             const char *service,
+                             const char *path,
+                             const char *ifc,
+                             const char *func,
+                             int first_arg_type,
+                             ...) {
+    DBusMessage *ret;
+    va_list lst;
+    if (!path || !func || !ifc) {
+        return NULL;
+    }
+
+    va_start(lst, first_arg_type);
+    ret = dbus_func_args_generic_timeout_valist(env, conn, -1, NULL,
+                                        service, path, ifc, func,
+                                        first_arg_type, lst);
+    va_end(lst);
+    return ret;
+}
+
+DBusMessage * dbus_func_args(JNIEnv *env,
+                             DBusConnection *conn,
+                             const char *path,
+                             const char *ifc,
+                             const char *func,
+                             int first_arg_type,
+                             ...) {
+    DBusMessage *ret;
+    va_list lst;
+    if (!path || !func || !ifc) {
+        return NULL;
+    }
+
+    va_start(lst, first_arg_type);
+    ret = dbus_func_args_timeout_valist(env, conn, -1, NULL,
+                                        path, ifc, func,
+                                        first_arg_type, lst);
+    va_end(lst);
+    return ret;
+}
+
+DBusMessage * dbus_func_args_error(JNIEnv *env,
+                                   DBusConnection *conn,
+                                   DBusError *err,
+                                   const char *path,
+                                   const char *ifc,
+                                   const char *func,
+                                   int first_arg_type,
+                                   ...) {
+    DBusMessage *ret;
+    va_list lst;
+    if (!path || !func || !ifc) {
+        return NULL;
+    }
+
+    va_start(lst, first_arg_type);
+    ret = dbus_func_args_timeout_valist(env, conn, -1, err,
+                                        path, ifc, func,
+                                        first_arg_type, lst);
+    va_end(lst);
+    return ret;
+}
+
+jint dbus_returns_unixfd(JNIEnv *env, DBusMessage *reply) {
+
+    DBusError err;
+    jint ret = -1;
+
+    dbus_error_init(&err);
+    if (!dbus_message_get_args(reply, &err,
+                               DBUS_TYPE_UNIX_FD, &ret,
+                               DBUS_TYPE_INVALID)) {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+    dbus_message_unref(reply);
+    return ret;
+}
+
+
+jint dbus_returns_int32(JNIEnv *env, DBusMessage *reply) {
+
+    DBusError err;
+    jint ret = -1;
+
+    dbus_error_init(&err);
+    if (!dbus_message_get_args(reply, &err,
+                               DBUS_TYPE_INT32, &ret,
+                               DBUS_TYPE_INVALID)) {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+    dbus_message_unref(reply);
+    return ret;
+}
+
+jint dbus_returns_uint32(JNIEnv *env, DBusMessage *reply) {
+
+    DBusError err;
+    jint ret = -1;
+
+    dbus_error_init(&err);
+    if (!dbus_message_get_args(reply, &err,
+                               DBUS_TYPE_UINT32, &ret,
+                               DBUS_TYPE_INVALID)) {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+    dbus_message_unref(reply);
+    return ret;
+}
+
+jstring dbus_returns_string(JNIEnv *env, DBusMessage *reply) {
+
+    DBusError err;
+    jstring ret = NULL;
+    const char *name;
+
+    dbus_error_init(&err);
+    if (dbus_message_get_args(reply, &err,
+                               DBUS_TYPE_STRING, &name,
+                               DBUS_TYPE_INVALID)) {
+        ret = env->NewStringUTF(name);
+    } else {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+    dbus_message_unref(reply);
+
+    return ret;
+}
+
+jboolean dbus_returns_boolean(JNIEnv *env, DBusMessage *reply) {
+    DBusError err;
+    jboolean ret = JNI_FALSE;
+    dbus_bool_t val = FALSE;
+
+    dbus_error_init(&err);
+
+    /* Check the return value. */
+    if (dbus_message_get_args(reply, &err,
+                               DBUS_TYPE_BOOLEAN, &val,
+                               DBUS_TYPE_INVALID)) {
+        ret = val == TRUE ? JNI_TRUE : JNI_FALSE;
+    } else {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+
+    dbus_message_unref(reply);
+    return ret;
+}
+
+static void set_object_array_element(JNIEnv *env, jobjectArray strArray,
+                                     const char *value, int index) {
+    jstring obj;
+    obj = env->NewStringUTF(value);
+    env->SetObjectArrayElement(strArray, index, obj);
+    env->DeleteLocalRef(obj);
+}
+
+jobjectArray dbus_returns_array_of_object_path(JNIEnv *env,
+                                               DBusMessage *reply) {
+
+    DBusError err;
+    char **list;
+    int i, len;
+    jobjectArray strArray = NULL;
+
+    dbus_error_init(&err);
+    if (dbus_message_get_args (reply,
+                               &err,
+                               DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
+                               &list, &len,
+                               DBUS_TYPE_INVALID)) {
+        jclass stringClass;
+        jstring classNameStr;
+
+        stringClass = env->FindClass("java/lang/String");
+        strArray = env->NewObjectArray(len, stringClass, NULL);
+
+        for (i = 0; i < len; i++)
+            set_object_array_element(env, strArray, list[i], i);
+    } else {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+
+    dbus_message_unref(reply);
+    return strArray;
+}
+
+jobjectArray dbus_returns_array_of_strings(JNIEnv *env, DBusMessage *reply) {
+
+    DBusError err;
+    char **list;
+    int i, len;
+    jobjectArray strArray = NULL;
+
+    dbus_error_init(&err);
+    if (dbus_message_get_args (reply,
+                               &err,
+                               DBUS_TYPE_ARRAY, DBUS_TYPE_STRING,
+                               &list, &len,
+                               DBUS_TYPE_INVALID)) {
+        jclass stringClass;
+        jstring classNameStr;
+
+        //ALOGV("%s: there are %d elements in string array!", __FUNCTION__, len);
+
+        stringClass = env->FindClass("java/lang/String");
+        strArray = env->NewObjectArray(len, stringClass, NULL);
+
+        for (i = 0; i < len; i++)
+            set_object_array_element(env, strArray, list[i], i);
+    } else {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+
+    dbus_message_unref(reply);
+    return strArray;
+}
+
+jbyteArray dbus_returns_array_of_bytes(JNIEnv *env, DBusMessage *reply) {
+
+    DBusError err;
+    int i, len;
+    jbyte *list;
+    jbyteArray byteArray = NULL;
+
+    dbus_error_init(&err);
+    if (dbus_message_get_args(reply, &err,
+                              DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &list, &len,
+                              DBUS_TYPE_INVALID)) {
+        //ALOGV("%s: there are %d elements in byte array!", __FUNCTION__, len);
+        byteArray = env->NewByteArray(len);
+        if (byteArray)
+            env->SetByteArrayRegion(byteArray, 0, len, list);
+
+    } else {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+
+    dbus_message_unref(reply);
+    return byteArray;
+}
+
+void append_variant(DBusMessageIter *iter, int type, void *val)
+{
+    DBusMessageIter value_iter;
+    char var_type[2] = { type, '\0'};
+    dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT, var_type, &value_iter);
+    dbus_message_iter_append_basic(&value_iter, type, val);
+    dbus_message_iter_close_container(iter, &value_iter);
+}
+
+static void dict_append_entry(DBusMessageIter *dict,
+                        const char *key, int type, void *val)
+{
+        DBusMessageIter dict_entry;
+        dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+                                                        NULL, &dict_entry);
+
+        dbus_message_iter_append_basic(&dict_entry, DBUS_TYPE_STRING, &key);
+        append_variant(&dict_entry, type, val);
+        dbus_message_iter_close_container(dict, &dict_entry);
+}
+
+static void append_dict_valist(DBusMessageIter *iterator, const char *first_key,
+                                va_list var_args)
+{
+        DBusMessageIter dict;
+        int val_type;
+        const char *val_key;
+        void *val;
+
+        dbus_message_iter_open_container(iterator, DBUS_TYPE_ARRAY,
+                        DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                        DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+                        DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+        val_key = first_key;
+        while (val_key) {
+                val_type = va_arg(var_args, int);
+                val = va_arg(var_args, void *);
+                dict_append_entry(&dict, val_key, val_type, val);
+                val_key = va_arg(var_args, char *);
+        }
+
+        dbus_message_iter_close_container(iterator, &dict);
+}
+
+void append_dict_args(DBusMessage *reply, const char *first_key, ...)
+{
+        DBusMessageIter iter;
+        va_list var_args;
+
+        dbus_message_iter_init_append(reply, &iter);
+
+        va_start(var_args, first_key);
+        append_dict_valist(&iter, first_key, var_args);
+        va_end(var_args);
+}
+
+void append_array_variant(DBusMessageIter *iter, int type, void *val,
+                            int n_elements)
+{
+    DBusMessageIter variant, array;
+    char type_sig[2] = { type, '\0' };
+    char array_sig[3] = { DBUS_TYPE_ARRAY, type, '\0' };
+
+    dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT,
+                        array_sig, &variant);
+
+    dbus_message_iter_open_container(&variant, DBUS_TYPE_ARRAY,
+                        type_sig, &array);
+
+    if (type == DBUS_TYPE_BYTE) {
+        jbyte *v_ptr = (jbyte *) val;
+        for (int i = 0; i < n_elements; i++) {
+            dbus_message_iter_append_basic(&array, type, &(v_ptr[i]));
+        }
+    } else if (type == DBUS_TYPE_STRING || type == DBUS_TYPE_OBJECT_PATH) {
+        const char ***str_array = (const char ***)val;
+        int i;
+
+        for (i = 0; i < n_elements; i++)
+            dbus_message_iter_append_basic(&array, type,
+                            &((*str_array)[i]));
+    }
+
+    dbus_message_iter_close_container(&variant, &array);
+
+    dbus_message_iter_close_container(iter, &variant);
+}
+
+int get_property(DBusMessageIter iter, Properties *properties, int max_num_properties,
+                  int *prop_index, property_value *value, int *value_type, int *len) {
+    DBusMessageIter prop_val, array_val_iter;
+    char *property = NULL;
+    uint32_t array_type;
+    char *str_val;
+    int i, j, type, int_val;
+
+    if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
+        return -1;
+    dbus_message_iter_get_basic(&iter, &property);
+    if (!dbus_message_iter_next(&iter))
+        return -1;
+    if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_VARIANT)
+        return -1;
+    for (i = 0; i <  max_num_properties; i++) {
+        if (!strncmp(property, properties[i].name, strlen(property)))
+            break;
+    }
+    *prop_index = i;
+    if (i == max_num_properties)
+        return -1;
+
+    dbus_message_iter_recurse(&iter, &prop_val);
+    type = properties[*prop_index].type;
+    if (dbus_message_iter_get_arg_type(&prop_val) != type) {
+        ALOGE("Property type mismatch in get_property: %d, expected:%d, index:%d",
+             dbus_message_iter_get_arg_type(&prop_val), type, *prop_index);
+        return -1;
+    }
+
+    switch(type) {
+    case DBUS_TYPE_STRING:
+    case DBUS_TYPE_OBJECT_PATH:
+        dbus_message_iter_get_basic(&prop_val, &value->str_val);
+        *len = 1;
+        break;
+    case DBUS_TYPE_BYTE:
+        uint8_t uint8_val;
+        dbus_message_iter_get_basic(&prop_val, &uint8_val);
+        value->int_val = uint8_val;
+        *len = 1;
+        break;
+    case DBUS_TYPE_UINT16:
+        uint16_t uint16_val;
+        dbus_message_iter_get_basic(&prop_val, &uint16_val);
+        value->int_val = uint16_val;
+        *len = 1;
+        break;
+    case DBUS_TYPE_UINT32:
+    case DBUS_TYPE_INT16:
+    case DBUS_TYPE_BOOLEAN:
+        dbus_message_iter_get_basic(&prop_val, &int_val);
+        value->int_val = int_val;
+        *len = 1;
+        break;
+    case DBUS_TYPE_ARRAY:
+        dbus_message_iter_recurse(&prop_val, &array_val_iter);
+        array_type = dbus_message_iter_get_arg_type(&array_val_iter);
+        *len = 0;
+        value->array_val = NULL;
+        *value_type = array_type;
+        if (array_type == DBUS_TYPE_OBJECT_PATH ||
+            array_type == DBUS_TYPE_STRING){
+            j = 0;
+            do {
+               j ++;
+            } while(dbus_message_iter_next(&array_val_iter));
+            dbus_message_iter_recurse(&prop_val, &array_val_iter);
+            // Allocate  an array of char *
+            *len = j;
+            char **tmp = (char **)malloc(sizeof(char *) * *len);
+            if (!tmp)
+                return -1;
+            j = 0;
+            do {
+               dbus_message_iter_get_basic(&array_val_iter, &tmp[j]);
+               j ++;
+            } while(dbus_message_iter_next(&array_val_iter));
+            value->array_val = tmp;
+        } else if (array_type == DBUS_TYPE_BYTE) {
+            char * tempPtr;
+            char * tmpValueArray;
+            int size = 0;
+            dbus_message_iter_get_fixed_array(&array_val_iter, &tempPtr, &size);
+
+            tmpValueArray = (char *) malloc(sizeof(char) * ( (2*size) + 1 ));
+            if (!tmpValueArray) {
+                return -1;
+            }
+
+            char *tmpPos = tmpValueArray;
+
+            for ( j=0; j<size; j++) {
+                sprintf(tmpPos, "%02x", tempPtr[j]);
+                tmpPos+=2;
+            }
+            tmpValueArray[2*size] = '\0';
+            value->str_val = tmpValueArray;
+            *len = 1;
+        }
+        break;
+    default:
+        return -1;
+    }
+    return 0;
+}
+
+void create_prop_array(JNIEnv *env, jobjectArray strArray, Properties *property,
+                       property_value *value, int value_type, int len,
+                       int *array_index ) {
+    char **prop_val = NULL;
+    char buf[32] = {'\0'}, buf1[32] = {'\0'};
+    int i;
+
+    char *name = property->name;
+    int prop_type = property->type;
+
+    set_object_array_element(env, strArray, name, *array_index);
+    *array_index += 1;
+
+    if (prop_type == DBUS_TYPE_UINT32 || prop_type == DBUS_TYPE_INT16 ||
+        prop_type == DBUS_TYPE_UINT16 || prop_type == DBUS_TYPE_BYTE) {
+        sprintf(buf, "%d", value->int_val);
+        set_object_array_element(env, strArray, buf, *array_index);
+        *array_index += 1;
+    } else if (prop_type == DBUS_TYPE_BOOLEAN) {
+        sprintf(buf, "%s", value->int_val ? "true" : "false");
+
+        set_object_array_element(env, strArray, buf, *array_index);
+        *array_index += 1;
+    } else if (prop_type == DBUS_TYPE_ARRAY) {
+        if (value_type == DBUS_TYPE_BYTE) {
+            set_object_array_element(env, strArray, (const char *) value->str_val,
+                                     *array_index);
+            *array_index += 1;
+        } else {
+            // Write the length first
+            sprintf(buf1, "%d", len);
+            set_object_array_element(env, strArray, buf1, *array_index);
+            *array_index += 1;
+
+            prop_val = value->array_val;
+            for (i = 0; i < len; i++) {
+                set_object_array_element(env, strArray, prop_val[i], *array_index);
+                *array_index += 1;
+            }
+        }
+    } else {
+        set_object_array_element(env, strArray, (const char *) value->str_val, *array_index);
+        *array_index += 1;
+    }
+}
+
+jobjectArray parse_properties(JNIEnv *env, DBusMessageIter *iter, Properties *properties,
+                              const int max_num_properties) {
+    DBusMessageIter dict_entry, dict;
+    jobjectArray strArray = NULL;
+    property_value value;
+    int i, size = 0,array_index = 0, value_type;
+    int len = 0, prop_type = DBUS_TYPE_INVALID, prop_index = -1, type;
+    struct {
+        property_value value;
+        int value_type;
+        int len;
+        bool used;
+    } values[max_num_properties];
+    int t, j;
+
+    jclass stringClass = env->FindClass("java/lang/String");
+    DBusError err;
+    dbus_error_init(&err);
+
+    for (i = 0; i < max_num_properties; i++) {
+        values[i].used = false;
+    }
+
+    if(dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_ARRAY)
+        goto failure;
+    dbus_message_iter_recurse(iter, &dict);
+    do {
+        len = 0;
+        value_type = 0;
+        if (dbus_message_iter_get_arg_type(&dict) != DBUS_TYPE_DICT_ENTRY)
+            goto failure;
+        dbus_message_iter_recurse(&dict, &dict_entry);
+
+        if (!get_property(dict_entry, properties, max_num_properties, &prop_index,
+                          &value, &value_type, &len)) {
+            size += 2;
+            if (properties[prop_index].type == DBUS_TYPE_ARRAY &&
+                value_type != DBUS_TYPE_BYTE)
+                size += len;
+            values[prop_index].value = value;
+            values[prop_index].value_type = value_type;
+            values[prop_index].len = len;
+            values[prop_index].used = true;
+        } else {
+            goto failure;
+        }
+    } while(dbus_message_iter_next(&dict));
+
+    strArray = env->NewObjectArray(size, stringClass, NULL);
+
+    for (i = 0; i < max_num_properties; i++) {
+        if (values[i].used) {
+            create_prop_array(env, strArray, &properties[i], &values[i].value,
+                              values[i].value_type, values[i].len, &array_index);
+
+            if (properties[i].type == DBUS_TYPE_ARRAY && values[i].used) {
+                if (values[i].value_type == DBUS_TYPE_BYTE &&
+                    values[i].value.str_val != NULL) {
+                    free(values[i].value.str_val);
+                } else if (values[i].value.array_val != NULL) {
+                    free(values[i].value.array_val);
+                }
+            }
+        }
+    }
+    return strArray;
+
+failure:
+    if (dbus_error_is_set(&err))
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    for (i = 0; i < max_num_properties; i++)
+        if (properties[i].type == DBUS_TYPE_ARRAY && values[i].used == true
+                                        && values[i].value.array_val != NULL)
+            free(values[i].value.array_val);
+    return NULL;
+}
+
+jobjectArray parse_property_change(JNIEnv *env, DBusMessage *msg,
+                           Properties *properties, int max_num_properties) {
+    DBusMessageIter iter;
+    DBusError err;
+    jobjectArray strArray = NULL;
+    jclass stringClass= env->FindClass("java/lang/String");
+    int i, len = 0, prop_index = -1;
+    int array_index = 0, size = 0, value_type = 0;
+    property_value value;
+
+    dbus_error_init(&err);
+    if (!dbus_message_iter_init(msg, &iter))
+        goto failure;
+
+    if (!get_property(iter, properties, max_num_properties,
+                      &prop_index, &value, &value_type, &len)) {
+        size += 2;
+        if (properties[prop_index].type == DBUS_TYPE_ARRAY &&
+            value_type != DBUS_TYPE_BYTE) {
+            size += len;
+        }
+
+        strArray = env->NewObjectArray(size, stringClass, NULL);
+
+        create_prop_array(env, strArray, &properties[prop_index],
+                          &value, value_type, len, &array_index);
+
+        if (properties[prop_index].type == DBUS_TYPE_ARRAY) {
+            if (value_type == DBUS_TYPE_BYTE &&
+                value.str_val != NULL) {
+                free(value.str_val);
+            } else if (value.array_val != NULL) {
+                free(value.array_val);
+            }
+        }
+        return strArray;
+    }
+failure:
+    LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+    return NULL;
+}
+
+jobjectArray parse_adapter_property_change(JNIEnv *env, DBusMessage *msg) {
+    return parse_property_change(env, msg, (Properties *) &adapter_properties,
+                    sizeof(adapter_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_remote_device_property_change(JNIEnv *env, DBusMessage *msg) {
+    return parse_property_change(env, msg, (Properties *) &remote_device_properties,
+                    sizeof(remote_device_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_input_property_change(JNIEnv *env, DBusMessage *msg) {
+    return parse_property_change(env, msg, (Properties *) &input_properties,
+                    sizeof(input_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_pan_property_change(JNIEnv *env, DBusMessage *msg) {
+    return parse_property_change(env, msg, (Properties *) &pan_properties,
+                    sizeof(pan_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_adapter_properties(JNIEnv *env, DBusMessageIter *iter) {
+    return parse_properties(env, iter, (Properties *) &adapter_properties,
+                            sizeof(adapter_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_remote_device_properties(JNIEnv *env, DBusMessageIter *iter) {
+    return parse_properties(env, iter, (Properties *) &remote_device_properties,
+                          sizeof(remote_device_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_input_properties(JNIEnv *env, DBusMessageIter *iter) {
+    return parse_properties(env, iter, (Properties *) &input_properties,
+                          sizeof(input_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_health_device_properties(JNIEnv *env, DBusMessageIter *iter) {
+    return parse_properties(env, iter, (Properties *) &health_device_properties,
+                          sizeof(health_device_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_health_device_property_change(JNIEnv *env, DBusMessage *msg) {
+    return parse_property_change(env, msg, (Properties *) &health_device_properties,
+                    sizeof(health_device_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_health_channel_properties(JNIEnv *env, DBusMessageIter *iter) {
+    return parse_properties(env, iter, (Properties *) &health_channel_properties,
+                          sizeof(health_channel_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_gatt_service_properties(JNIEnv *env, DBusMessageIter *iter) {
+    return parse_properties(env, iter, (Properties *) &gatt_service_properties,
+                          sizeof(gatt_service_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_gatt_characteristic_properties(JNIEnv *env, DBusMessageIter *iter) {
+    return parse_properties(env, iter, (Properties *) &gatt_characteristic_properties,
+                            sizeof(gatt_characteristic_properties) / sizeof(Properties));
+}
+
+int get_bdaddr(const char *str, bdaddr_t *ba) {
+    char *d = ((char *)ba) + 5, *endp;
+    int i;
+    for(i = 0; i < 6; i++) {
+        *d-- = strtol(str, &endp, 16);
+        if (*endp != ':' && i != 5) {
+            memset(ba, 0, sizeof(bdaddr_t));
+            return -1;
+        }
+        str = endp + 1;
+    }
+    return 0;
+}
+
+void get_bdaddr_as_string(const bdaddr_t *ba, char *str) {
+    const uint8_t *b = (const uint8_t *)ba;
+    sprintf(str, "%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
+            b[5], b[4], b[3], b[2], b[1], b[0]);
+}
+
+bool debug_no_encrypt() {
+    return false;
+#if 0
+    char value[PROPERTY_VALUE_MAX] = "";
+
+    property_get("debug.bt.no_encrypt", value, "");
+    if (!strncmp("true", value, PROPERTY_VALUE_MAX) ||
+        !strncmp("1", value, PROPERTY_VALUE_MAX)) {
+        ALOGD("mandatory bluetooth encryption disabled");
+        return true;
+    } else {
+        return false;
+    }
+#endif
+}
+#endif
+
+} /* namespace android */
diff --git a/core/jni/bluetoothmsm/android_bluetooth_common.h b/core/jni/bluetoothmsm/android_bluetooth_common.h
new file mode 100644
index 0000000..a6cff4d
--- /dev/null
+++ b/core/jni/bluetoothmsm/android_bluetooth_common.h
@@ -0,0 +1,263 @@
+/*
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifndef ANDROID_BLUETOOTH_COMMON_H
+#define ANDROID_BLUETOOTH_COMMON_H
+
+// Set to 0 to enable verbose bluetooth logging
+//#define LOG_NDEBUG 1
+
+
+//#undef NDEBUG
+
+//#define LOG_NIDEBUG 0
+//#define LOG_NDEBUG 0
+//#define LOG_NDDEBUG 0
+
+#include "jni.h"
+#include "utils/Log.h"
+
+#include <errno.h>
+#include <pthread.h>
+#include <stdint.h>
+#include <sys/poll.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <dbus/dbus.h>
+#include <bluetooth/bluetooth.h>
+#endif
+
+namespace android {
+
+#ifdef HAVE_BLUETOOTH
+#define BLUEZ_DBUS_BASE_PATH      "/org/bluez"
+#define BLUEZ_DBUS_BASE_IFC       "org.bluez"
+#define BLUEZ_ERROR_IFC           "org.bluez.Error"
+#define FRAMEWORKS_BASE_IFC       "android.frameworks"
+
+// It would be nicer to retrieve this from bluez using GetDefaultAdapter,
+// but this is only possible when the adapter is up (and hcid is running).
+// It is much easier just to hardcode bluetooth adapter to hci0
+#define BLUETOOTH_ADAPTER_HCI_NUM 0
+#define BLUEZ_ADAPTER_OBJECT_NAME BLUEZ_DBUS_BASE_PATH "/hci0"
+
+#define BTADDR_SIZE 18   // size of BT address character array (including null)
+
+// size of the dbus event loops pollfd structure, hopefully never to be grown
+#define DEFAULT_INITIAL_POLLFD_COUNT 8
+
+jfieldID get_field(JNIEnv *env,
+                   jclass clazz,
+                   const char *member,
+                   const char *mtype);
+
+// ALOGE and free a D-Bus error
+// Using #define so that __FUNCTION__ resolves usefully
+#define LOG_AND_FREE_DBUS_ERROR_WITH_MSG(err, msg) \
+    {   ALOGE("%s: D-Bus error in %s: %s (%s)", __FUNCTION__, \
+        dbus_message_get_member((msg)), (err)->name, (err)->message); \
+         dbus_error_free((err)); }
+#define LOG_AND_FREE_DBUS_ERROR(err) \
+    {   ALOGE("%s: D-Bus error: %s (%s)", __FUNCTION__, \
+        (err)->name, (err)->message); \
+        dbus_error_free((err)); }
+
+struct event_loop_native_data_t {
+    DBusConnection *conn;
+    const char *adapter;
+
+    /* protects the thread */
+    pthread_mutex_t thread_mutex;
+    pthread_t thread;
+    /* our comms socket */
+    /* mem for the list of sockets to listen to */
+    struct pollfd *pollData;
+    int pollMemberCount;
+    int pollDataSize;
+    /* mem for matching set of dbus watch ptrs */
+    DBusWatch **watchData;
+    /* pair of sockets for event loop control, Reader and Writer */
+    int controlFdR;
+    int controlFdW;
+    /* our vm and env Version for future env generation */
+    JavaVM *vm;
+    int envVer;
+    /* reference to our java self */
+    jobject me;
+    /* flag to indicate if the event loop thread is running */
+    bool running;
+};
+
+struct _Properties {
+    char name[32];
+    int type;
+};
+typedef struct _Properties Properties;
+
+typedef struct {
+    void (*user_cb)(DBusMessage *, void *, void *);
+    void *user;
+    void *nat;
+    JNIEnv *env;
+} dbus_async_call_t;
+
+struct set_characteristic_property_t {
+    char * path;
+    char * property;
+};
+
+struct set_indicate_info_t {
+    char *path;
+};
+
+dbus_bool_t dbus_func_args_async(JNIEnv *env,
+                                 DBusConnection *conn,
+                                 int timeout_ms,
+                                 void (*reply)(DBusMessage *, void *, void *),
+                                 void *user,
+                                 void *nat,
+                                 const char *path,
+                                 const char *ifc,
+                                 const char *func,
+                                 int first_arg_type,
+                                 ...);
+
+DBusMessage * dbus_func_args(JNIEnv *env,
+                             DBusConnection *conn,
+                             const char *path,
+                             const char *ifc,
+                             const char *func,
+                             int first_arg_type,
+                             ...);
+
+DBusMessage * dbus_func_args_generic(JNIEnv *env,
+                             DBusConnection *conn,
+                             const char *service,
+                             const char *path,
+                             const char *ifc,
+                             const char *func,
+                             int first_arg_type,
+                             ...);
+
+DBusMessage * dbus_func_args_error(JNIEnv *env,
+                                   DBusConnection *conn,
+                                   DBusError *err,
+                                   const char *path,
+                                   const char *ifc,
+                                   const char *func,
+                                   int first_arg_type,
+                                   ...);
+
+DBusMessage * dbus_func_args_timeout(JNIEnv *env,
+                                     DBusConnection *conn,
+                                     int timeout_ms,
+                                     const char *path,
+                                     const char *ifc,
+                                     const char *func,
+                                     int first_arg_type,
+                                     ...);
+
+DBusMessage * dbus_func_args_timeout_valist(JNIEnv *env,
+                                            DBusConnection *conn,
+                                            int timeout_ms,
+                                            DBusError *err,
+                                            const char *path,
+                                            const char *ifc,
+                                            const char *func,
+                                            int first_arg_type,
+                                            va_list args);
+
+void dbus_func_args_async_callback(DBusPendingCall *call, void *data);
+
+jint dbus_returns_int32(JNIEnv *env, DBusMessage *reply);
+jint dbus_returns_uint32(JNIEnv *env, DBusMessage *reply);
+jint dbus_returns_unixfd(JNIEnv *env, DBusMessage *reply);
+jstring dbus_returns_string(JNIEnv *env, DBusMessage *reply);
+jboolean dbus_returns_boolean(JNIEnv *env, DBusMessage *reply);
+jobjectArray dbus_returns_array_of_strings(JNIEnv *env, DBusMessage *reply);
+jobjectArray dbus_returns_array_of_object_path(JNIEnv *env, DBusMessage *reply);
+jbyteArray dbus_returns_array_of_bytes(JNIEnv *env, DBusMessage *reply);
+
+jobjectArray parse_properties(JNIEnv *env, DBusMessageIter *iter, Properties *properties,
+                              const int max_num_properties);
+jobjectArray parse_property_change(JNIEnv *env, DBusMessage *msg,
+                                   Properties *properties, int max_num_properties);
+jobjectArray parse_adapter_properties(JNIEnv *env, DBusMessageIter *iter);
+jobjectArray parse_remote_device_properties(JNIEnv *env, DBusMessageIter *iter);
+jobjectArray parse_gatt_service_properties(JNIEnv *env, DBusMessageIter *iter);
+jobjectArray parse_gatt_characteristic_properties(JNIEnv *env, DBusMessageIter *iter);
+jobjectArray parse_remote_device_property_change(JNIEnv *env, DBusMessage *msg);
+jobjectArray parse_adapter_property_change(JNIEnv *env, DBusMessage *msg);
+jobjectArray parse_input_properties(JNIEnv *env, DBusMessageIter *iter);
+jobjectArray parse_health_device_properties(JNIEnv *env, DBusMessageIter *iter);
+jobjectArray parse_health_channel_properties(JNIEnv *env, DBusMessageIter *iter);
+jobjectArray parse_input_property_change(JNIEnv *env, DBusMessage *msg);
+jobjectArray parse_pan_property_change(JNIEnv *env, DBusMessage *msg);
+jobjectArray parse_health_device_property_change(JNIEnv *env, DBusMessage *msg);
+
+void append_dict_args(DBusMessage *reply, const char *first_key, ...);
+void append_variant(DBusMessageIter *iter, int type, void *val);
+void append_array_variant(DBusMessageIter *iter, int type, void *val, int n_elements);
+int get_bdaddr(const char *str, bdaddr_t *ba);
+void get_bdaddr_as_string(const bdaddr_t *ba, char *str);
+
+bool debug_no_encrypt();
+
+int register_gatt_path(event_loop_native_data_t *nat, const char *gatt_path);
+int unregister_gatt_path(event_loop_native_data_t *nat, const char *gatt_path);
+
+// Result codes from Bluez DBus calls
+#define BOND_RESULT_ERROR                      -1
+#define BOND_RESULT_SUCCESS                     0
+#define BOND_RESULT_AUTH_FAILED                 1
+#define BOND_RESULT_AUTH_REJECTED               2
+#define BOND_RESULT_AUTH_CANCELED               3
+#define BOND_RESULT_REMOTE_DEVICE_DOWN          4
+#define BOND_RESULT_DISCOVERY_IN_PROGRESS       5
+#define BOND_RESULT_AUTH_TIMEOUT                6
+#define BOND_RESULT_REPEATED_ATTEMPTS           7
+
+#define PAN_DISCONNECT_FAILED_NOT_CONNECTED  1000
+#define PAN_CONNECT_FAILED_ALREADY_CONNECTED 1001
+#define PAN_CONNECT_FAILED_ATTEMPT_FAILED    1002
+#define PAN_OPERATION_GENERIC_FAILURE        1003
+#define PAN_OPERATION_SUCCESS                1004
+
+#define INPUT_DISCONNECT_FAILED_NOT_CONNECTED  5000
+#define INPUT_CONNECT_FAILED_ALREADY_CONNECTED 5001
+#define INPUT_CONNECT_FAILED_ATTEMPT_FAILED    5002
+#define INPUT_OPERATION_GENERIC_FAILURE        5003
+#define INPUT_OPERATION_SUCCESS                5004
+
+#define HEALTH_OPERATION_SUCCESS               6000
+#define HEALTH_OPERATION_ERROR                 6001
+#define HEALTH_OPERATION_INVALID_ARGS          6002
+#define HEALTH_OPERATION_GENERIC_FAILURE       6003
+#define HEALTH_OPERATION_NOT_FOUND             6004
+#define HEALTH_OPERATION_NOT_ALLOWED           6005
+
+#define GATT_OPERATION_SUCCESS               0
+#define GATT_OPERATION_TIMEOUT                1
+#define GATT_OPERATION_GENERIC_FAILURE   2
+#define GATT_OPERATION_BUSY                     3
+#define GATT_OPERATION_NOT_CONNECTED   4
+#define GATT_ALREADY_CONNECTED              5
+#define GATT_OPERATION_NOT_SUPPORTED   6
+
+#endif
+} /* namespace android */
+
+#endif/*ANDROID_BLUETOOTH_COMMON_H*/
diff --git a/core/jni/bluetoothmsm/android_server_BluetoothA2dpService.cpp b/core/jni/bluetoothmsm/android_server_BluetoothA2dpService.cpp
new file mode 100644
index 0000000..e4a9c64
--- /dev/null
+++ b/core/jni/bluetoothmsm/android_server_BluetoothA2dpService.cpp
@@ -0,0 +1,671 @@
+/*
+** Copyright 2008, The Android Open Source Project
+** Copyright (c) 2009-2010, The Linux Foundation, Inc. All rights reserved.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "BluetoothA2dpService.cpp"
+
+#include "android_bluetooth_common.h"
+#include "android_runtime/AndroidRuntime.h"
+#include "JNIHelp.h"
+#include "jni.h"
+#include "utils/Log.h"
+#include "utils/misc.h"
+
+#include <ctype.h>
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <dbus/dbus.h>
+#endif
+
+namespace android {
+
+#ifdef HAVE_BLUETOOTH
+static jmethodID method_onSinkPropertyChanged;
+static jmethodID method_onConnectSinkResult;
+static jmethodID method_onGetPlayStatusRequest;
+static jmethodID method_onListPlayerAttributeRequest;
+static jmethodID method_onListPlayerAttributeValues;
+static jmethodID method_onGetPlayerAttributeValues;
+static jmethodID method_onSetPlayerAttributeValues;
+static jmethodID method_onListPlayerAttributesText;
+static jmethodID method_onListAttributeValuesText;
+static jfieldID field_mTrackName;
+static jfieldID field_mArtistName;
+static jfieldID field_mAlbumName;
+static jfieldID field_mMediaNumber;
+static jfieldID field_mMediaCount;
+static jfieldID field_mDuration;
+static jfieldID field_mGenre;
+
+typedef struct {
+    JavaVM *vm;
+    int envVer;
+    DBusConnection *conn;
+    jobject me;  // for callbacks to java
+} native_data_t;
+
+static native_data_t *nat = NULL;  // global native data
+static void onConnectSinkResult(DBusMessage *msg, void *user, void *n);
+static void onStatusReply(DBusMessage *msg, void *user, void *n);
+
+static Properties sink_properties[] = {
+        {"State", DBUS_TYPE_STRING},
+        {"Connected", DBUS_TYPE_BOOLEAN},
+        {"Playing", DBUS_TYPE_BOOLEAN},
+        {"Protected", DBUS_TYPE_BOOLEAN},
+      };
+#endif
+
+/* Returns true on success (even if adapter is present but disabled).
+ * Return false if dbus is down, or another serious error (out of memory)
+*/
+static bool initNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    nat = (native_data_t *)calloc(1, sizeof(native_data_t));
+    if (NULL == nat) {
+        ALOGE("%s: out of memory!", __FUNCTION__);
+        return false;
+    }
+    env->GetJavaVM( &(nat->vm) );
+    nat->envVer = env->GetVersion();
+    nat->me = env->NewGlobalRef(object);
+
+    DBusError err;
+    dbus_error_init(&err);
+    dbus_threads_init_default();
+    nat->conn = dbus_bus_get(DBUS_BUS_SYSTEM, &err);
+    if (dbus_error_is_set(&err)) {
+        ALOGE("Could not get onto the system bus: %s", err.message);
+        dbus_error_free(&err);
+        return false;
+    }
+    dbus_connection_set_exit_on_disconnect(nat->conn, FALSE);
+#endif  /*HAVE_BLUETOOTH*/
+    return true;
+}
+
+static void cleanupNative(JNIEnv* env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        dbus_connection_close(nat->conn);
+        env->DeleteGlobalRef(nat->me);
+        free(nat);
+        nat = NULL;
+    }
+#endif
+}
+
+static jobjectArray getSinkPropertiesNative(JNIEnv *env, jobject object,
+                                            jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        reply = dbus_func_args_timeout(env,
+                                   nat->conn, -1, c_path,
+                                   "org.bluez.AudioSink", "GetProperties",
+                                   DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        if (!reply && dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+            return NULL;
+        } else if (!reply) {
+            ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return NULL;
+        }
+        DBusMessageIter iter;
+        if (dbus_message_iter_init(reply, &iter))
+            return parse_properties(env, &iter, (Properties *)&sink_properties,
+                                 sizeof(sink_properties) / sizeof(Properties));
+    }
+#endif
+    return NULL;
+}
+
+
+static jboolean connectSinkNative(JNIEnv *env, jobject object, jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onConnectSinkResult, context_path,
+                                    nat, c_path, "org.bluez.AudioSink", "Connect",
+                                    DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean disconnectSinkNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, NULL, NULL, nat,
+                                    c_path, "org.bluez.AudioSink", "Disconnect",
+                                    DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean suspendSinkNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1, NULL, NULL, nat,
+                           c_path, "org.bluez.AudioSink", "Suspend",
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean resumeSinkNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1, NULL, NULL, nat,
+                           c_path, "org.bluez.AudioSink", "Resume",
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean avrcpVolumeUpNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1, NULL, NULL, nat,
+                           c_path, "org.bluez.Control", "VolumeUp",
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean sendMetaDataNative(JNIEnv *env, jobject obj,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        jstring title, artist, album, media_number, total_media_count, playing_time;
+        jstring genre;
+        const char *c_title, *c_artist, *c_album, *c_media_number, *c_genre;
+        const char *c_total_media_count, *c_playing_time;
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        title = (jstring) env->GetObjectField(obj, field_mTrackName);
+        artist = (jstring) env->GetObjectField(obj, field_mArtistName);
+        album = (jstring) env->GetObjectField(obj, field_mAlbumName);
+        media_number = (jstring) env->GetObjectField(obj, field_mMediaNumber);
+        total_media_count = (jstring) env->GetObjectField(obj, field_mMediaCount);
+        playing_time = (jstring) env->GetObjectField(obj, field_mDuration);
+        genre = (jstring) env->GetObjectField(obj, field_mGenre);
+
+        c_title = env->GetStringUTFChars(title, NULL);
+        c_artist = env->GetStringUTFChars(artist, NULL);
+        c_album = env->GetStringUTFChars(album, NULL);
+        c_media_number = env->GetStringUTFChars(media_number, NULL);
+        c_total_media_count = env->GetStringUTFChars(total_media_count, NULL);
+        c_playing_time = env->GetStringUTFChars(playing_time, NULL);
+        c_genre = env->GetStringUTFChars(genre, NULL);
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onStatusReply, NULL, nat,
+                           c_path, "org.bluez.Control", "UpdateMetaData",
+                           DBUS_TYPE_STRING, &c_title,
+                           DBUS_TYPE_STRING, &c_artist,
+                           DBUS_TYPE_STRING, &c_album,
+                           DBUS_TYPE_STRING, &c_media_number,
+                           DBUS_TYPE_STRING, &c_total_media_count,
+                           DBUS_TYPE_STRING, &c_playing_time,
+                           DBUS_TYPE_STRING, &c_genre,
+                           DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(title, c_title);
+        env->ReleaseStringUTFChars(artist, c_artist);
+        env->ReleaseStringUTFChars(album, c_album);
+        env->ReleaseStringUTFChars(media_number, c_media_number);
+        env->ReleaseStringUTFChars(total_media_count, c_total_media_count);
+        env->ReleaseStringUTFChars(playing_time, c_playing_time);
+        env->ReleaseStringUTFChars(genre, c_genre);
+
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+
+static jboolean sendPlayStatusNative(JNIEnv *env, jobject object, jstring path,
+                                        jint duration, jint position, jint play_status) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onStatusReply, NULL, nat,
+                           c_path, "org.bluez.Control", "UpdatePlayStatus",
+                           DBUS_TYPE_UINT32, &duration,
+                           DBUS_TYPE_UINT32, &position,
+                           DBUS_TYPE_UINT32, &play_status,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean sendPlayerSettingsNative(JNIEnv *env, jobject object, jstring path,
+                          jstring response, jint len, jbyteArray values) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        const char *c_response = env->GetStringUTFChars(response, NULL);
+        jbyte *u_values = env->GetByteArrayElements(values, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onStatusReply, NULL, nat,
+                           c_path, "org.bluez.Control", c_response,
+                           DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &u_values, len,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(response, c_response);
+        env->ReleaseByteArrayElements(values, u_values, 0);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean sendSettingsTextNative(JNIEnv *env, jobject object, jstring path,
+                   jstring response, jint len, jbyteArray values, jobjectArray strings) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        const char *c_response = env->GetStringUTFChars(response, NULL);
+        jbyte *u_values = env->GetByteArrayElements(values, NULL);
+        char const** c_strings = (char const**)malloc(sizeof(char*)*len);
+        for (int i = 0; i < len; i++) {
+            c_strings[i] = env->GetStringUTFChars(
+                            (jstring)env->GetObjectArrayElement(strings, i),
+                             NULL);
+        }
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onStatusReply, NULL, nat,
+                           c_path, "org.bluez.Control", c_response,
+                           DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &u_values, len,
+                           DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &c_strings, len,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(response, c_response);
+        env->ReleaseByteArrayElements(values, u_values, 0);
+        for (int i = 0; i < len; i++) {
+            env->ReleaseStringUTFChars((jstring)env->GetObjectArrayElement(strings, i), c_strings[i]);
+        }
+
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean sendEventNative(JNIEnv *env, jobject object,
+                                     jstring path, jint event_id, jlong data) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onStatusReply, NULL, nat,
+                           c_path, "org.bluez.Control", "UpdateNotification",
+                           DBUS_TYPE_UINT16, &event_id,
+                           DBUS_TYPE_UINT64, &data,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean avrcpVolumeDownNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1, NULL, NULL, nat,
+                           c_path, "org.bluez.Control", "VolumeDown",
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+#ifdef HAVE_BLUETOOTH
+DBusHandlerResult a2dp_event_filter(DBusMessage *msg, JNIEnv *env) {
+    DBusError err;
+
+    if (!nat) {
+        ALOGV("... skipping %s\n", __FUNCTION__);
+        ALOGV("... ignored\n");
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    }
+
+    dbus_error_init(&err);
+
+    if (dbus_message_get_type(msg) != DBUS_MESSAGE_TYPE_SIGNAL) {
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    }
+
+    DBusHandlerResult result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    if (dbus_message_is_signal(msg, "org.bluez.AudioSink",
+                                      "PropertyChanged")) {
+        jobjectArray str_array =
+                    parse_property_change(env, msg, (Properties *)&sink_properties,
+                                sizeof(sink_properties) / sizeof(Properties));
+        const char *c_path = dbus_message_get_path(msg);
+        jstring path = env->NewStringUTF(c_path);
+        env->CallVoidMethod(nat->me,
+                            method_onSinkPropertyChanged,
+                            path,
+                            str_array);
+        env->DeleteLocalRef(path);
+        result = DBUS_HANDLER_RESULT_HANDLED;
+        return result;
+    } else if (dbus_message_is_signal(msg, "org.bluez.Control",
+                                      "GetPlayStatus")) {
+        const char *c_path = dbus_message_get_path(msg);
+        jstring path = env->NewStringUTF(c_path);
+
+        env->CallVoidMethod(nat->me, method_onGetPlayStatusRequest, path);
+        env->DeleteLocalRef(path);
+        result = DBUS_HANDLER_RESULT_HANDLED;
+        return result;
+    } else if (dbus_message_is_signal(msg, "org.bluez.Control",
+                                      "ListPlayerAttributes")) {
+        const char *c_path = dbus_message_get_path(msg);
+        jstring path = env->NewStringUTF(c_path);
+
+        env->CallVoidMethod(nat->me, method_onListPlayerAttributeRequest, path);
+        env->DeleteLocalRef(path);
+        result = DBUS_HANDLER_RESULT_HANDLED;
+        return result;
+    } else if (dbus_message_is_signal(msg, "org.bluez.Control",
+                                      "ListAttributeValues")) {
+        const char *c_path = dbus_message_get_path(msg);
+        jstring path = env->NewStringUTF(c_path);
+        jbyte attrib;
+        if (dbus_message_get_args(msg, &err,
+                                DBUS_TYPE_BYTE, &attrib,
+                                DBUS_TYPE_INVALID)) {
+            env->CallVoidMethod(nat->me,
+                                method_onListPlayerAttributeValues,
+                                path,
+                                attrib);
+        }
+        env->DeleteLocalRef(path);
+        result = DBUS_HANDLER_RESULT_HANDLED;
+        return result;
+    } else if (dbus_message_is_signal(msg, "org.bluez.Control",
+                                      "GetAttributeValues")) {
+        const char *c_path = dbus_message_get_path(msg);
+        jstring path = env->NewStringUTF(c_path);
+        uint8_t *attribArray;
+        int len;
+        jbyteArray jAttribs;
+        if (dbus_message_get_args(msg, &err,
+                                DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE,
+                                &attribArray, &len,
+                                DBUS_TYPE_INVALID)) {
+            jAttribs = env->NewByteArray(len);
+            env->SetByteArrayRegion(jAttribs, 0, len,(jbyte *)attribArray);
+
+            env->CallVoidMethod(nat->me,
+                                method_onGetPlayerAttributeValues,
+                                path,
+                                jAttribs);
+            env->DeleteLocalRef(jAttribs);
+        }
+        env->DeleteLocalRef(path);
+        result = DBUS_HANDLER_RESULT_HANDLED;
+        return result;
+    } else if (dbus_message_is_signal(msg, "org.bluez.Control",
+                                      "SetAttributeValues")) {
+        const char *c_path = dbus_message_get_path(msg);
+        jstring path = env->NewStringUTF(c_path);
+        jbyte* attribArray;
+        int len;
+        jbyteArray jAttribs;
+        if (dbus_message_get_args(msg, &err,
+                                DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE,
+                                &attribArray, &len,
+                                DBUS_TYPE_INVALID)) {
+            jAttribs = env->NewByteArray(len);
+            env->SetByteArrayRegion(jAttribs, 0, len,(jbyte *)attribArray);
+            env->CallVoidMethod(nat->me,
+                                method_onSetPlayerAttributeValues,
+                                path,
+                                jAttribs);
+            env->DeleteLocalRef(jAttribs);
+        }
+        env->DeleteLocalRef(path);
+        result = DBUS_HANDLER_RESULT_HANDLED;
+        return result;
+    } else if (dbus_message_is_signal(msg, "org.bluez.Control",
+                                      "ListPlayerAttributesText")) {
+        const char *c_path = dbus_message_get_path(msg);
+        jstring path = env->NewStringUTF(c_path);
+        uint8_t *attribArray;
+        int len;
+        jbyteArray jAttribs;
+        if (dbus_message_get_args(msg, &err,
+                                DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE,
+                                &attribArray, &len,
+                                DBUS_TYPE_INVALID)) {
+            jAttribs = env->NewByteArray(len);
+            env->SetByteArrayRegion(jAttribs, 0, len,(jbyte *)attribArray);
+
+            env->CallVoidMethod(nat->me,
+                                method_onListPlayerAttributesText,
+                                path,
+                                jAttribs);
+            env->DeleteLocalRef(jAttribs);
+        }
+        env->DeleteLocalRef(path);
+        result = DBUS_HANDLER_RESULT_HANDLED;
+        return result;
+    } else if (dbus_message_is_signal(msg, "org.bluez.Control",
+                                      "ListAttributeValuesText")) {
+        const char *c_path = dbus_message_get_path(msg);
+        jstring path = env->NewStringUTF(c_path);
+        uint8_t *valueArray;
+        int len;
+        jbyteArray jValues;
+        jbyte attrib;
+        if (dbus_message_get_args(msg, &err,
+                                DBUS_TYPE_BYTE, &attrib,
+                                DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE,
+                                &valueArray, &len,
+                                DBUS_TYPE_INVALID)) {
+            jValues = env->NewByteArray(len);
+            env->SetByteArrayRegion(jValues, 0, len,(jbyte *)valueArray);
+
+            env->CallVoidMethod(nat->me,
+                                method_onListAttributeValuesText,
+                                path,
+                                attrib,
+                                jValues);
+            env->DeleteLocalRef(jValues);
+        }
+        env->DeleteLocalRef(path);
+        result = DBUS_HANDLER_RESULT_HANDLED;
+        return result;
+    }else {
+        ALOGV("... ignored");
+    }
+    if (env->ExceptionCheck()) {
+        ALOGE("VM Exception occurred while handling %s.%s (%s) in %s,"
+             " leaving for VM",
+             dbus_message_get_interface(msg), dbus_message_get_member(msg),
+             dbus_message_get_path(msg), __FUNCTION__);
+        env->ExceptionDescribe();
+    }
+
+    return result;
+}
+
+void onConnectSinkResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *path = (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+
+    bool result = JNI_TRUE;
+    if (dbus_set_error_from_message(&err, msg)) {
+        LOG_AND_FREE_DBUS_ERROR(&err);
+        result = JNI_FALSE;
+    }
+    ALOGV("... Device Path = %s, result = %d", path, result);
+
+    jstring jPath = env->NewStringUTF(path);
+    env->CallVoidMethod(nat->me,
+                        method_onConnectSinkResult,
+                        jPath,
+                        result);
+    env->DeleteLocalRef(jPath);
+    free(user);
+}
+
+void onStatusReply(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    DBusError err;
+    dbus_error_init(&err);
+    if (dbus_set_error_from_message(&err, msg)) {
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+}
+
+
+#endif
+
+
+static JNINativeMethod sMethods[] = {
+    {"initNative", "()Z", (void *)initNative},
+    {"cleanupNative", "()V", (void *)cleanupNative},
+
+    /* Bluez audio 4.47 API */
+    {"connectSinkNative", "(Ljava/lang/String;)Z", (void *)connectSinkNative},
+    {"disconnectSinkNative", "(Ljava/lang/String;)Z", (void *)disconnectSinkNative},
+    {"suspendSinkNative", "(Ljava/lang/String;)Z", (void*)suspendSinkNative},
+    {"resumeSinkNative", "(Ljava/lang/String;)Z", (void*)resumeSinkNative},
+    {"getSinkPropertiesNative", "(Ljava/lang/String;)[Ljava/lang/Object;",
+                                    (void *)getSinkPropertiesNative},
+    {"avrcpVolumeUpNative", "(Ljava/lang/String;)Z", (void*)avrcpVolumeUpNative},
+    {"avrcpVolumeDownNative", "(Ljava/lang/String;)Z", (void*)avrcpVolumeDownNative},
+    {"sendMetaDataNative", "(Ljava/lang/String;)Z", (void*)sendMetaDataNative},
+    {"sendEventNative", "(Ljava/lang/String;IJ)Z", (void*)sendEventNative},
+    {"sendPlayStatusNative", "(Ljava/lang/String;III)Z", (void*)sendPlayStatusNative},
+    {"sendPlayerSettingsNative", "(Ljava/lang/String;Ljava/lang/String;I[B)Z", (void*)sendPlayerSettingsNative},
+    {"sendSettingsTextNative", "(Ljava/lang/String;Ljava/lang/String;I[B[Ljava/lang/String;)Z", (void*)sendSettingsTextNative},
+};
+
+int register_android_server_BluetoothA2dpService(JNIEnv *env) {
+    jclass clazz = env->FindClass("android/server/BluetoothA2dpService");
+    if (clazz == NULL) {
+        ALOGE("Can't find android/server/BluetoothA2dpService");
+        return -1;
+    }
+
+#ifdef HAVE_BLUETOOTH
+    method_onSinkPropertyChanged = env->GetMethodID(clazz, "onSinkPropertyChanged",
+                                          "(Ljava/lang/String;[Ljava/lang/String;)V");
+    method_onConnectSinkResult = env->GetMethodID(clazz, "onConnectSinkResult",
+                                                         "(Ljava/lang/String;Z)V");
+    method_onGetPlayStatusRequest = env->GetMethodID(clazz, "onGetPlayStatusRequest",
+                                          "(Ljava/lang/String;)V");
+    method_onListPlayerAttributeRequest = env->GetMethodID(clazz, "onListPlayerAttributeRequest",
+                                          "(Ljava/lang/String;)V");
+    method_onListPlayerAttributeValues = env->GetMethodID(clazz, "onListPlayerAttributeValues",
+                                          "(Ljava/lang/String;B)V");
+    method_onGetPlayerAttributeValues = env->GetMethodID(clazz, "onGetPlayerAttributeValues",
+                                          "(Ljava/lang/String;[B)V");
+    method_onSetPlayerAttributeValues = env->GetMethodID(clazz, "onSetPlayerAttributeValues",
+                                          "(Ljava/lang/String;[B)V");
+    method_onListPlayerAttributesText = env->GetMethodID(clazz, "onListPlayerAttributesText",
+                                          "(Ljava/lang/String;[B)V");
+    method_onListAttributeValuesText = env->GetMethodID(clazz, "onListAttributeValuesText",
+                                          "(Ljava/lang/String;B[B)V");
+    field_mTrackName = env->GetFieldID(clazz, "mTrackName", "Ljava/lang/String;");
+    field_mArtistName = env->GetFieldID(clazz, "mArtistName", "Ljava/lang/String;");
+    field_mAlbumName = env->GetFieldID(clazz, "mAlbumName", "Ljava/lang/String;");
+    field_mMediaNumber = env->GetFieldID(clazz, "mMediaNumber", "Ljava/lang/String;");
+    field_mMediaCount = env->GetFieldID(clazz, "mMediaCount", "Ljava/lang/String;");
+    field_mDuration = env->GetFieldID(clazz, "mDuration", "Ljava/lang/String;");
+    field_mGenre = env->GetFieldID(clazz, "mGenre", "Ljava/lang/String;");
+#endif
+
+    return AndroidRuntime::registerNativeMethods(env,
+                "android/server/BluetoothA2dpService", sMethods, NELEM(sMethods));
+}
+
+} /* namespace android */
diff --git a/core/jni/bluetoothmsm/android_server_BluetoothEventLoop.cpp b/core/jni/bluetoothmsm/android_server_BluetoothEventLoop.cpp
new file mode 100644
index 0000000..e12c7bf
--- /dev/null
+++ b/core/jni/bluetoothmsm/android_server_BluetoothEventLoop.cpp
@@ -0,0 +1,2532 @@
+/*
+** Copyright 2008, The Android Open Source Project
+** Copyright (C) 2011 The Linux Foundation. All rights reserved.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "BluetoothEventLoop.cpp"
+
+#include "android_bluetooth_common.h"
+#include "android_runtime/AndroidRuntime.h"
+#include "cutils/sockets.h"
+#include "JNIHelp.h"
+#include "jni.h"
+#include "utils/Log.h"
+#include "utils/misc.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <cutils/properties.h>
+#ifdef HAVE_BLUETOOTH
+#include <dbus/dbus.h>
+#endif
+
+namespace android {
+
+#define CREATE_DEVICE_ALREADY_EXISTS 1
+#define CREATE_DEVICE_SUCCESS 0
+#define CREATE_DEVICE_FAILED -1
+#define SAP_UUID "0000112D-0000-1000-8000-00805F9B34FB"
+#define DUN_UUID "00001103-0000-1000-8000-00805F9B34FB"
+
+/* Following macro definition is aligned with that defined in BlueZ */
+#define MAX_PATH_LENGTH 64
+
+#ifdef HAVE_BLUETOOTH
+static jfieldID field_mNativeData;
+
+static jmethodID method_onPropertyChanged;
+static jmethodID method_onDevicePropertyChanged;
+static jmethodID method_onDeviceFound;
+static jmethodID method_onDeviceDisappeared;
+static jmethodID method_onDeviceCreated;
+static jmethodID method_onDeviceRemoved;
+static jmethodID method_onDeviceDisconnectRequested;
+static jmethodID method_onNetworkDeviceDisconnected;
+static jmethodID method_onNetworkDeviceConnected;
+
+static jmethodID method_onCreatePairedDeviceResult;
+static jmethodID method_onCreateDeviceResult;
+
+static jmethodID method_onAddToPreferredDeviceListResult;
+static jmethodID method_onRemoveFromPreferredDeviceListResult;
+static jmethodID method_onClearPreferredDeviceListResult;
+static jmethodID method_onGattConnectToPreferredDeviceListResult;
+static jmethodID method_onGattCancelConnectToPreferredDeviceListResult;
+
+static jmethodID method_onDiscoverServicesResult;
+static jmethodID method_onGetDeviceServiceChannelResult;
+
+static jmethodID method_onDiscoverCharacteristicsResult;
+static jmethodID method_onSetCharacteristicPropertyResult;
+static jmethodID method_onUpdateCharacteristicValueResult;
+static jmethodID method_onWatcherValueChanged;
+static jmethodID method_onGattDiscoverPrimaryRequest;
+static jmethodID method_onGattDiscoverPrimaryByUuidRequest;
+static jmethodID method_onGattDiscoverIncludedRequest;
+static jmethodID method_onGattDiscoverCharacteristicsRequest;
+static jmethodID method_onGattFindInfoRequest;
+static jmethodID method_onGattReadByTypeRequest;
+static jmethodID method_onGattReadRequest;
+static jmethodID method_onGattWriteCommand;
+static jmethodID method_onGattWriteRequest;
+static jmethodID method_onGattSetClientConfigDescriptor;
+static jmethodID method_onIndicateResponse;
+
+static jmethodID method_onRequestPinCode;
+static jmethodID method_onRequestPasskey;
+static jmethodID method_onRequestPasskeyConfirmation;
+static jmethodID method_onRequestPairingConsent;
+static jmethodID method_onDisplayPasskey;
+static jmethodID method_onRequestOobData;
+static jmethodID method_onAgentOutOfBandDataAvailable;
+static jmethodID method_onAgentAuthorize;
+static jmethodID method_onAgentCancel;
+static jmethodID method_onSapAuthorize;
+static jmethodID method_onSapStateChanged;
+static jmethodID method_onDUNAuthorize;
+static jmethodID method_onDUNStateChanged;
+
+
+static jmethodID method_onInputDevicePropertyChanged;
+static jmethodID method_onInputDeviceConnectionResult;
+static jmethodID method_onPanDevicePropertyChanged;
+static jmethodID method_onPanDeviceConnectionResult;
+static jmethodID method_onHealthDevicePropertyChanged;
+static jmethodID method_onHealthDeviceChannelChanged;
+static jmethodID method_onHealthDeviceConnectionResult;
+
+typedef event_loop_native_data_t native_data_t;
+
+#define EVENT_LOOP_REFS 10
+
+static inline native_data_t * get_native_data(JNIEnv *env, jobject object) {
+    return (native_data_t *)(env->GetIntField(object,
+                                                 field_mNativeData));
+}
+
+native_data_t *get_EventLoop_native_data(JNIEnv *env, jobject object) {
+    return get_native_data(env, object);
+}
+
+#endif
+static void classInitNative(JNIEnv* env, jclass clazz) {
+    ALOGV("%s", __FUNCTION__);
+
+#ifdef HAVE_BLUETOOTH
+    method_onPropertyChanged = env->GetMethodID(clazz, "onPropertyChanged",
+                                                "([Ljava/lang/String;)V");
+    method_onDevicePropertyChanged = env->GetMethodID(clazz,
+                                                      "onDevicePropertyChanged",
+                                                      "(Ljava/lang/String;[Ljava/lang/String;)V");
+    method_onDeviceFound = env->GetMethodID(clazz, "onDeviceFound",
+                                            "(Ljava/lang/String;[Ljava/lang/String;)V");
+    method_onDeviceDisappeared = env->GetMethodID(clazz, "onDeviceDisappeared",
+                                                  "(Ljava/lang/String;)V");
+    method_onDeviceCreated = env->GetMethodID(clazz, "onDeviceCreated", "(Ljava/lang/String;)V");
+    method_onDeviceRemoved = env->GetMethodID(clazz, "onDeviceRemoved", "(Ljava/lang/String;)V");
+    method_onDeviceDisconnectRequested = env->GetMethodID(clazz, "onDeviceDisconnectRequested",
+                                                        "(Ljava/lang/String;)V");
+    method_onNetworkDeviceConnected = env->GetMethodID(clazz, "onNetworkDeviceConnected",
+                                                     "(Ljava/lang/String;Ljava/lang/String;I)V");
+    method_onNetworkDeviceDisconnected = env->GetMethodID(clazz, "onNetworkDeviceDisconnected",
+                                                              "(Ljava/lang/String;)V");
+
+    method_onCreatePairedDeviceResult = env->GetMethodID(clazz, "onCreatePairedDeviceResult",
+                                                         "(Ljava/lang/String;I)V");
+    method_onCreateDeviceResult = env->GetMethodID(clazz, "onCreateDeviceResult",
+                                                         "(Ljava/lang/String;I)V");
+
+    method_onAddToPreferredDeviceListResult = env->GetMethodID(clazz, "onAddToPreferredDeviceListResult",
+                                                             "(I)V");
+    method_onRemoveFromPreferredDeviceListResult = env->GetMethodID(clazz, "onRemoveFromPreferredDeviceListResult",
+                                                                 "(I)V");
+    method_onClearPreferredDeviceListResult = env->GetMethodID(clazz, "onClearPreferredDeviceListResult",
+                                                                 "(I)V");
+    method_onGattConnectToPreferredDeviceListResult = env->GetMethodID(clazz, "onGattConnectToPreferredDeviceListResult",
+                                                                 "(I)V");
+    method_onGattCancelConnectToPreferredDeviceListResult = env->GetMethodID(clazz,
+                                                                 "onGattCancelConnectToPreferredDeviceListResult",
+                                                                 "(I)V");
+
+    method_onDiscoverServicesResult = env->GetMethodID(clazz, "onDiscoverServicesResult",
+                                                         "(Ljava/lang/String;Z)V");
+
+    method_onDiscoverCharacteristicsResult = env->GetMethodID(clazz, "onDiscoverCharacteristicsResult",
+                                                         "(Ljava/lang/String;Z)V");
+    method_onSetCharacteristicPropertyResult = env->GetMethodID(clazz, "onSetCharacteristicPropertyResult",
+                                                         "(Ljava/lang/String;Ljava/lang/String;Z)V");
+    method_onUpdateCharacteristicValueResult = env->GetMethodID(clazz, "onUpdateCharacteristicValueResult",
+                                                         "(Ljava/lang/String;Z)V");
+    method_onIndicateResponse = env->GetMethodID(clazz, "onIndicateResponse",
+                                                         "(Ljava/lang/String;Z)V");
+
+    method_onWatcherValueChanged = env->GetMethodID(clazz, "onWatcherValueChanged",
+                                                         "(Ljava/lang/String;Ljava/lang/String;)V");
+
+    method_onGattDiscoverPrimaryRequest = env->GetMethodID(clazz, "onGattDiscoverPrimaryRequest",
+                                                         "(Ljava/lang/String;III)V");
+    method_onGattDiscoverPrimaryByUuidRequest = env->GetMethodID(clazz, "onGattDiscoverPrimaryByUuidRequest",
+                                                         "(Ljava/lang/String;Ljava/lang/String;III)V");
+    method_onGattDiscoverIncludedRequest = env->GetMethodID(clazz, "onGattDiscoverIncludedRequest",
+                                                         "(Ljava/lang/String;III)V");
+    method_onGattDiscoverCharacteristicsRequest = env->GetMethodID(clazz, "onGattDiscoverCharacteristicsRequest",
+                                                         "(Ljava/lang/String;III)V");
+    method_onGattFindInfoRequest = env->GetMethodID(clazz, "onGattFindInfoRequest",
+                                                         "(Ljava/lang/String;III)V");
+    method_onGattReadByTypeRequest = env->GetMethodID(clazz, "onGattReadByTypeRequest",
+                                                         "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;III)V");
+    method_onGattReadRequest = env->GetMethodID(clazz, "onGattReadRequest",
+                                                         "(Ljava/lang/String;Ljava/lang/String;II)V");
+    method_onGattWriteCommand = env->GetMethodID(clazz, "onGattWriteCommand",
+                                                         "(Ljava/lang/String;Ljava/lang/String;I[B)V");
+    method_onGattWriteRequest = env->GetMethodID(clazz, "onGattWriteRequest",
+                                                         "(Ljava/lang/String;Ljava/lang/String;I[BII)V");
+    method_onGattSetClientConfigDescriptor = env->GetMethodID(clazz, "onGattSetClientConfigDescriptor",
+                                                         "(Ljava/lang/String;II[B)V");
+    method_onAgentAuthorize = env->GetMethodID(clazz, "onAgentAuthorize",
+                                               "(Ljava/lang/String;Ljava/lang/String;I)V");
+    method_onSapAuthorize = env->GetMethodID(clazz, "onSapAuthorize",
+                                               "(Ljava/lang/String;Ljava/lang/String;I)V");
+    method_onSapStateChanged = env->GetMethodID(clazz, "onSapStateChanged",
+                                               "(Ljava/lang/String;Ljava/lang/String;I)V");
+    method_onDUNAuthorize = env->GetMethodID(clazz, "onDUNAuthorize",
+                                               "(Ljava/lang/String;Ljava/lang/String;I)V");
+    method_onDUNStateChanged = env->GetMethodID(clazz, "onDUNStateChanged",
+                                               "(Ljava/lang/String;Ljava/lang/String;I)V");
+    method_onAgentOutOfBandDataAvailable = env->GetMethodID(clazz, "onAgentOutOfBandDataAvailable",
+                                               "(Ljava/lang/String;)Z");
+    method_onAgentCancel = env->GetMethodID(clazz, "onAgentCancel", "()V");
+    method_onRequestPinCode = env->GetMethodID(clazz, "onRequestPinCode",
+                                               "(Ljava/lang/String;IZ)V");
+    method_onRequestPasskey = env->GetMethodID(clazz, "onRequestPasskey",
+                                               "(Ljava/lang/String;I)V");
+    method_onRequestPasskeyConfirmation = env->GetMethodID(clazz, "onRequestPasskeyConfirmation",
+                                               "(Ljava/lang/String;II)V");
+    method_onRequestPairingConsent = env->GetMethodID(clazz, "onRequestPairingConsent",
+                                               "(Ljava/lang/String;I)V");
+    method_onDisplayPasskey = env->GetMethodID(clazz, "onDisplayPasskey",
+                                               "(Ljava/lang/String;II)V");
+    method_onInputDevicePropertyChanged = env->GetMethodID(clazz, "onInputDevicePropertyChanged",
+                                               "(Ljava/lang/String;[Ljava/lang/String;)V");
+    method_onInputDeviceConnectionResult = env->GetMethodID(clazz, "onInputDeviceConnectionResult",
+                                               "(Ljava/lang/String;I)V");
+    method_onPanDevicePropertyChanged = env->GetMethodID(clazz, "onPanDevicePropertyChanged",
+                                               "(Ljava/lang/String;[Ljava/lang/String;)V");
+    method_onPanDeviceConnectionResult = env->GetMethodID(clazz, "onPanDeviceConnectionResult",
+                                               "(Ljava/lang/String;I)V");
+    method_onHealthDeviceConnectionResult = env->GetMethodID(clazz,
+                                                             "onHealthDeviceConnectionResult",
+                                                             "(II)V");
+    method_onHealthDevicePropertyChanged = env->GetMethodID(clazz, "onHealthDevicePropertyChanged",
+                                               "(Ljava/lang/String;[Ljava/lang/String;)V");
+    method_onHealthDeviceChannelChanged = env->GetMethodID(clazz, "onHealthDeviceChannelChanged",
+                                               "(Ljava/lang/String;Ljava/lang/String;Z)V");
+    method_onRequestOobData = env->GetMethodID(clazz, "onRequestOobData",
+                                               "(Ljava/lang/String;I)V");
+
+    field_mNativeData = env->GetFieldID(clazz, "mNativeData", "I");
+#endif
+}
+
+static void initializeNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = (native_data_t *)calloc(1, sizeof(native_data_t));
+    if (NULL == nat) {
+        ALOGE("%s: out of memory!", __FUNCTION__);
+        return;
+    }
+
+    pthread_mutex_init(&(nat->thread_mutex), NULL);
+
+    env->SetIntField(object, field_mNativeData, (jint)nat);
+
+    {
+        DBusError err;
+        dbus_error_init(&err);
+        dbus_threads_init_default();
+        nat->conn = dbus_bus_get(DBUS_BUS_SYSTEM, &err);
+        if (dbus_error_is_set(&err)) {
+            ALOGE("%s: Could not get onto the system bus!", __FUNCTION__);
+            dbus_error_free(&err);
+            return;
+        }
+        dbus_bus_request_name(nat->conn, FRAMEWORKS_BASE_IFC,
+                    DBUS_NAME_FLAG_DO_NOT_QUEUE, &err);
+        if (dbus_error_is_set(&err)) {
+            ALOGE("%s: Could not get requested name", __FUNCTION__);
+            dbus_error_free(&err);
+        }
+        dbus_connection_set_exit_on_disconnect(nat->conn, FALSE);
+    }
+#endif
+}
+
+static void cleanupNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat =
+            (native_data_t *)env->GetIntField(object, field_mNativeData);
+
+    pthread_mutex_destroy(&(nat->thread_mutex));
+
+    if (nat) {
+        free(nat);
+    }
+#endif
+}
+
+#ifdef HAVE_BLUETOOTH
+static DBusHandlerResult event_filter(DBusConnection *conn, DBusMessage *msg,
+                                      void *data);
+DBusHandlerResult agent_event_filter(DBusConnection *conn,
+                                     DBusMessage *msg,
+                                     void *data);
+DBusHandlerResult watcher_event_filter(DBusConnection *conn,
+                                     DBusMessage *msg,
+                                     void *data);
+DBusHandlerResult gatt_event_filter(DBusConnection *conn,
+                                     DBusMessage *msg,
+                                     void *data);
+static int register_agent(native_data_t *nat,
+                          const char *agent_path, const char *capabilities);
+static int register_watcher_path(native_data_t *nat, const char *watcher_path);
+
+static const DBusObjectPathVTable agent_vtable = {
+    NULL, agent_event_filter, NULL, NULL, NULL, NULL
+};
+
+static const DBusObjectPathVTable watcher_vtable = {
+    NULL, watcher_event_filter, NULL, NULL, NULL, NULL
+};
+
+static const DBusObjectPathVTable gatt_vtable = {
+    NULL, gatt_event_filter, NULL, NULL, NULL, NULL
+};
+
+static unsigned int unix_events_to_dbus_flags(short events) {
+    return (events & DBUS_WATCH_READABLE ? POLLIN : 0) |
+           (events & DBUS_WATCH_WRITABLE ? POLLOUT : 0) |
+           (events & DBUS_WATCH_ERROR ? POLLERR : 0) |
+           (events & DBUS_WATCH_HANGUP ? POLLHUP : 0);
+}
+
+static short dbus_flags_to_unix_events(unsigned int flags) {
+    return (flags & POLLIN ? DBUS_WATCH_READABLE : 0) |
+           (flags & POLLOUT ? DBUS_WATCH_WRITABLE : 0) |
+           (flags & POLLERR ? DBUS_WATCH_ERROR : 0) |
+           (flags & POLLHUP ? DBUS_WATCH_HANGUP : 0);
+}
+
+static jboolean setUpEventLoop(native_data_t *nat) {
+    ALOGV("%s", __FUNCTION__);
+
+    if (nat != NULL && nat->conn != NULL) {
+        dbus_threads_init_default();
+        DBusError err;
+        dbus_error_init(&err);
+
+        const char *agent_path = "/android/bluetooth/agent";
+        const char *capabilities = "KeyboardDisplay";
+        if (register_agent(nat, agent_path, capabilities) < 0) {
+            dbus_connection_unregister_object_path (nat->conn, agent_path);
+            return JNI_FALSE;
+        }
+
+        // Add a filter for all incoming messages
+        if (!dbus_connection_add_filter(nat->conn, event_filter, nat, NULL)){
+            return JNI_FALSE;
+        }
+
+        // Set which messages will be processed by this dbus connection
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='org.freedesktop.DBus'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Adapter'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Device'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Input'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Network'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".NetworkServer'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Control'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='org.qcom.sap'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            ALOGE("Not able to register to get the org.qcom.sap");
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+
+        dbus_bus_add_match(nat->conn,
+              "type='signal',interface='org.qcom.bluetooth.dun'",
+              &err);
+        if (dbus_error_is_set(&err)) {
+            ALOGE("Not able to register to get the org.qcom.bluetooth.dun");
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".HealthDevice'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='org.bluez.AudioSink'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+
+        const char *watcher_path = "/android/bluetooth/watcher";
+        if (register_watcher_path(nat, watcher_path) < 0) {
+            dbus_connection_unregister_object_path (nat->conn, watcher_path);
+            return JNI_FALSE;
+        }
+        return JNI_TRUE;
+
+    }
+    return JNI_FALSE;
+}
+
+
+const char * get_adapter_path(DBusConnection *conn) {
+    DBusMessage *msg = NULL, *reply = NULL;
+    DBusError err;
+    const char *device_path = NULL;
+    static char device_path_cp[MAX_PATH_LENGTH];
+    int attempt = 0;
+
+    for (attempt = 0; attempt < 1000 && reply == NULL; attempt ++) {
+        msg = dbus_message_new_method_call("org.bluez", "/",
+              "org.bluez.Manager", "DefaultAdapter");
+        if (!msg) {
+            ALOGE("%s: Can't allocate new method call for get_adapter_path!",
+                  __FUNCTION__);
+            return NULL;
+        }
+        dbus_message_append_args(msg, DBUS_TYPE_INVALID);
+        dbus_error_init(&err);
+        reply = dbus_connection_send_with_reply_and_block(conn, msg, -1, &err);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                if (dbus_error_has_name(&err,
+                    "org.freedesktop.DBus.Error.ServiceUnknown")) {
+                    // bluetoothd is still down, retry
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                    usleep(10000);  // 10 ms
+                    continue;
+                } else {
+                    // Some other error we weren't expecting
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                }
+            }
+            goto failed;
+        }
+    }
+    if (attempt == 1000) {
+        ALOGE("Time out while trying to get Adapter path, is bluetoothd up ?");
+        goto failed;
+    }
+
+    if (!dbus_message_get_args(reply, &err, DBUS_TYPE_OBJECT_PATH,
+                               &device_path, DBUS_TYPE_INVALID)
+                               || !device_path){
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        goto failed;
+    }
+    strncpy(device_path_cp, device_path, sizeof(device_path_cp));
+    dbus_message_unref(msg);
+    dbus_message_unref(reply);
+    return device_path_cp;
+
+failed:
+    dbus_message_unref(msg);
+    if (reply)
+       dbus_message_unref(reply);
+    return NULL;
+}
+
+static int register_agent(native_data_t *nat,
+                          const char * agent_path, const char * capabilities)
+{
+    DBusMessage *msg, *reply;
+    DBusError err;
+    dbus_bool_t oob = TRUE;
+    const char *sender = NULL;
+    char sender_conn[PROPERTY_VALUE_MAX];
+    char value[PROPERTY_VALUE_MAX];
+
+    if (!dbus_connection_register_object_path(nat->conn, agent_path,
+            &agent_vtable, nat)) {
+        ALOGE("%s: Can't register object path %s for agent!",
+              __FUNCTION__, agent_path);
+        return -1;
+    }
+
+    nat->adapter = get_adapter_path(nat->conn);
+    if (nat->adapter == NULL) {
+        return -1;
+    }
+    msg = dbus_message_new_method_call("org.bluez", nat->adapter,
+          "org.bluez.Adapter", "RegisterAgent");
+    if (!msg) {
+        ALOGE("%s: Can't allocate new method call for agent!",
+              __FUNCTION__);
+        return -1;
+    }
+    dbus_message_append_args(msg, DBUS_TYPE_OBJECT_PATH, &agent_path,
+                             DBUS_TYPE_STRING, &capabilities,
+                             DBUS_TYPE_INVALID);
+
+    dbus_error_init(&err);
+    reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+    dbus_message_unref(msg);
+    sender = dbus_bus_get_unique_name(nat->conn);
+    ALOGV("Sender is %s", sender);
+    if ((sender != NULL) && (strlen(sender) < PROPERTY_VALUE_MAX)) {
+
+               strcpy(sender_conn, sender);
+               sender_conn[strlen(sender)]='\0';
+               ALOGV("Sender conn is %s", sender_conn);
+               int ret = property_set("bluetooth.eventloop.dbus", sender_conn);
+               ALOGV("Ret is %d", ret);
+    }
+    if (!reply) {
+        ALOGE("%s: Can't register agent!", __FUNCTION__);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        return -1;
+    }
+
+    dbus_message_unref(reply);
+    dbus_connection_flush(nat->conn);
+
+    return 0;
+}
+
+static int register_watcher_path(native_data_t *nat, const char * watcher_path)
+{
+    DBusMessage *msg, *reply;
+    DBusError err;
+    bool oob = TRUE;
+
+    if (!dbus_connection_register_object_path(nat->conn, watcher_path,
+            &watcher_vtable, nat)) {
+        ALOGE("%s: Can't register object path %s for watcher!",
+              __FUNCTION__, watcher_path);
+        return -1;
+    }
+    return 0;
+}
+
+int register_gatt_path(native_data_t *nat, const char * gatt_path)
+{
+    DBusMessage *msg, *reply;
+    DBusError err;
+    dbus_error_init(&err);
+    dbus_bool_t result = FALSE;
+    const char *name = NULL;
+
+    ALOGE("%s: Inside register_gatt_path ",__FUNCTION__);
+
+    if(!nat) {
+        ALOGE("%s: Can't register object path nat is null!",
+              __FUNCTION__);
+        return -1;
+    }
+
+    if (!dbus_connection_try_register_object_path(nat->conn, gatt_path,
+                                                  &gatt_vtable, nat, &err)) {
+        ALOGE("%s: Can't register object path %s for Gatt!",
+              __FUNCTION__, gatt_path);
+
+        ALOGE("DBus error name: %s message: %s", err.name, err.message);
+        if (strcmp(err.name, DBUS_ERROR_OBJECT_PATH_IN_USE) != 0)
+            return -1;
+    }
+
+    name = dbus_bus_get_unique_name(nat->conn);
+    ALOGE("!!! Gatt connection name : %s", name);
+
+    return 0;
+}
+
+int unregister_gatt_path(native_data_t *nat, const char *gatt_path)
+{
+    if(!nat) {
+        ALOGE("%s: Can't unregister object path nat is null!",
+              __FUNCTION__);
+        return -1;
+    }
+
+    if (!dbus_connection_unregister_object_path(nat->conn, gatt_path)) {
+        ALOGE("%s: Can't unregister object path %s for Gatt!",
+              __FUNCTION__, gatt_path);
+        return -1;
+    }
+    return 0;
+}
+
+static void tearDownEventLoop(native_data_t *nat) {
+    ALOGV("%s", __FUNCTION__);
+    if (nat != NULL && nat->conn != NULL) {
+
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+        const char * agent_path = "/android/bluetooth/agent";
+        const char * watcher_path = "/android/bluetooth/watcher";
+
+        msg = dbus_message_new_method_call("org.bluez",
+                                           nat->adapter,
+                                           "org.bluez.Adapter",
+                                           "UnregisterAgent");
+        if (msg != NULL) {
+            dbus_message_append_args(msg, DBUS_TYPE_OBJECT_PATH, &agent_path,
+                                     DBUS_TYPE_INVALID);
+            reply = dbus_connection_send_with_reply_and_block(nat->conn,
+                                                              msg, -1, &err);
+
+            if (!reply) {
+                if (dbus_error_is_set(&err)) {
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                    dbus_error_free(&err);
+                }
+            } else {
+                dbus_message_unref(reply);
+            }
+            dbus_message_unref(msg);
+        } else {
+             ALOGE("%s: Can't create new method call!", __FUNCTION__);
+        }
+
+        dbus_connection_flush(nat->conn);
+        dbus_connection_unregister_object_path(nat->conn, agent_path);
+        dbus_connection_unregister_object_path(nat->conn, watcher_path);
+
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Control'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='org.qcom.sap'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+
+        dbus_bus_remove_match(nat->conn,
+             "type='signal',interface='org.qcom.bluetooth.dun'",
+             &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".AudioSink'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Device'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Input'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Network'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".NetworkServer'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".HealthDevice'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='org.bluez.audio.Manager'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Adapter'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='org.freedesktop.DBus'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+
+        dbus_connection_remove_filter(nat->conn, event_filter, nat);
+    }
+}
+
+
+#define EVENT_LOOP_EXIT 1
+#define EVENT_LOOP_ADD  2
+#define EVENT_LOOP_REMOVE 3
+#define EVENT_LOOP_WAKEUP 4
+
+dbus_bool_t dbusAddWatch(DBusWatch *watch, void *data) {
+    native_data_t *nat = (native_data_t *)data;
+
+    if (dbus_watch_get_enabled(watch)) {
+        // note that we can't just send the watch and inspect it later
+        // because we may get a removeWatch call before this data is reacted
+        // to by our eventloop and remove this watch..  reading the add first
+        // and then inspecting the recently deceased watch would be bad.
+        char control = EVENT_LOOP_ADD;
+        write(nat->controlFdW, &control, sizeof(char));
+
+        int fd = dbus_watch_get_fd(watch);
+        write(nat->controlFdW, &fd, sizeof(int));
+
+        unsigned int flags = dbus_watch_get_flags(watch);
+        write(nat->controlFdW, &flags, sizeof(unsigned int));
+
+        write(nat->controlFdW, &watch, sizeof(DBusWatch*));
+    }
+    return true;
+}
+
+void dbusRemoveWatch(DBusWatch *watch, void *data) {
+    native_data_t *nat = (native_data_t *)data;
+
+    char control = EVENT_LOOP_REMOVE;
+    write(nat->controlFdW, &control, sizeof(char));
+
+    int fd = dbus_watch_get_fd(watch);
+    write(nat->controlFdW, &fd, sizeof(int));
+
+    unsigned int flags = dbus_watch_get_flags(watch);
+    write(nat->controlFdW, &flags, sizeof(unsigned int));
+}
+
+void dbusToggleWatch(DBusWatch *watch, void *data) {
+    if (dbus_watch_get_enabled(watch)) {
+        dbusAddWatch(watch, data);
+    } else {
+        dbusRemoveWatch(watch, data);
+    }
+}
+
+void dbusWakeup(void *data) {
+    native_data_t *nat = (native_data_t *)data;
+
+    char control = EVENT_LOOP_WAKEUP;
+    write(nat->controlFdW, &control, sizeof(char));
+}
+
+static void handleWatchAdd(native_data_t *nat) {
+    DBusWatch *watch;
+    int newFD;
+    unsigned int flags;
+
+    read(nat->controlFdR, &newFD, sizeof(int));
+    read(nat->controlFdR, &flags, sizeof(unsigned int));
+    read(nat->controlFdR, &watch, sizeof(DBusWatch *));
+    short events = dbus_flags_to_unix_events(flags);
+
+    for (int y = 0; y<nat->pollMemberCount; y++) {
+        if ((nat->pollData[y].fd == newFD) &&
+                (nat->pollData[y].events == events)) {
+            ALOGV("DBusWatch duplicate add");
+            return;
+        }
+    }
+    if (nat->pollMemberCount == nat->pollDataSize) {
+        ALOGV("Bluetooth EventLoop poll struct growing");
+        struct pollfd *temp = (struct pollfd *)malloc(
+                sizeof(struct pollfd) * (nat->pollMemberCount+1));
+        if (!temp) {
+            return;
+        }
+        memcpy(temp, nat->pollData, sizeof(struct pollfd) *
+                nat->pollMemberCount);
+        free(nat->pollData);
+        nat->pollData = temp;
+        DBusWatch **temp2 = (DBusWatch **)malloc(sizeof(DBusWatch *) *
+                (nat->pollMemberCount+1));
+        if (!temp2) {
+            return;
+        }
+        memcpy(temp2, nat->watchData, sizeof(DBusWatch *) *
+                nat->pollMemberCount);
+        free(nat->watchData);
+        nat->watchData = temp2;
+        nat->pollDataSize++;
+    }
+    nat->pollData[nat->pollMemberCount].fd = newFD;
+    nat->pollData[nat->pollMemberCount].revents = 0;
+    nat->pollData[nat->pollMemberCount].events = events;
+    nat->watchData[nat->pollMemberCount] = watch;
+    nat->pollMemberCount++;
+}
+
+static void handleWatchRemove(native_data_t *nat) {
+    int removeFD;
+    unsigned int flags;
+
+    read(nat->controlFdR, &removeFD, sizeof(int));
+    read(nat->controlFdR, &flags, sizeof(unsigned int));
+    short events = dbus_flags_to_unix_events(flags);
+
+    for (int y = 0; y < nat->pollMemberCount; y++) {
+        if ((nat->pollData[y].fd == removeFD) &&
+                (nat->pollData[y].events == events)) {
+            int newCount = --nat->pollMemberCount;
+            // copy the last live member over this one
+            nat->pollData[y].fd = nat->pollData[newCount].fd;
+            nat->pollData[y].events = nat->pollData[newCount].events;
+            nat->pollData[y].revents = nat->pollData[newCount].revents;
+            nat->watchData[y] = nat->watchData[newCount];
+            return;
+        }
+    }
+    ALOGW("WatchRemove given with unknown watch");
+}
+
+static void *eventLoopMain(void *ptr) {
+    native_data_t *nat = (native_data_t *)ptr;
+    JNIEnv *env;
+
+    JavaVMAttachArgs args;
+    char name[] = "BT EventLoop";
+    args.version = nat->envVer;
+    args.name = name;
+    args.group = NULL;
+
+    nat->vm->AttachCurrentThread(&env, &args);
+
+    dbus_connection_set_watch_functions(nat->conn, dbusAddWatch,
+            dbusRemoveWatch, dbusToggleWatch, ptr, NULL);
+    dbus_connection_set_wakeup_main_function(nat->conn, dbusWakeup, ptr, NULL);
+
+    nat->running = true;
+
+    while (1) {
+        for (int i = 0; i < nat->pollMemberCount; i++) {
+            if (!nat->pollData[i].revents) {
+                continue;
+            }
+            if (nat->pollData[i].fd == nat->controlFdR) {
+                char data;
+                while (recv(nat->controlFdR, &data, sizeof(char), MSG_DONTWAIT)
+                        != -1) {
+                    switch (data) {
+                    case EVENT_LOOP_EXIT:
+                    {
+                        dbus_connection_set_watch_functions(nat->conn,
+                                NULL, NULL, NULL, NULL, NULL);
+                        tearDownEventLoop(nat);
+                        nat->vm->DetachCurrentThread();
+
+                        int fd = nat->controlFdR;
+                        nat->controlFdR = 0;
+                        close(fd);
+                        return NULL;
+                    }
+                    case EVENT_LOOP_ADD:
+                    {
+                        handleWatchAdd(nat);
+                        break;
+                    }
+                    case EVENT_LOOP_REMOVE:
+                    {
+                        handleWatchRemove(nat);
+                        break;
+                    }
+                    case EVENT_LOOP_WAKEUP:
+                    {
+                        // noop
+                        break;
+                    }
+                    }
+                }
+            } else {
+                short events = nat->pollData[i].revents;
+                unsigned int flags = unix_events_to_dbus_flags(events);
+                dbus_watch_handle(nat->watchData[i], flags);
+                nat->pollData[i].revents = 0;
+                // can only do one - it may have caused a 'remove'
+                break;
+            }
+        }
+        while (dbus_connection_dispatch(nat->conn) ==
+                DBUS_DISPATCH_DATA_REMAINS) {
+        }
+
+        poll(nat->pollData, nat->pollMemberCount, -1);
+    }
+}
+#endif // HAVE_BLUETOOTH
+
+static jboolean startEventLoopNative(JNIEnv *env, jobject object) {
+    jboolean result = JNI_FALSE;
+#ifdef HAVE_BLUETOOTH
+    event_loop_native_data_t *nat = get_native_data(env, object);
+
+    pthread_mutex_lock(&(nat->thread_mutex));
+
+    nat->running = false;
+
+    if (nat->pollData) {
+        ALOGW("trying to start EventLoop a second time!");
+        pthread_mutex_unlock( &(nat->thread_mutex) );
+        return JNI_FALSE;
+    }
+
+    nat->pollData = (struct pollfd *)calloc(
+            DEFAULT_INITIAL_POLLFD_COUNT, sizeof(struct pollfd));
+    if (!nat->pollData) {
+        ALOGE("out of memory error starting EventLoop!");
+        goto done;
+    }
+
+    nat->watchData = (DBusWatch **)calloc(
+            DEFAULT_INITIAL_POLLFD_COUNT, sizeof(DBusWatch *));
+    if (!nat->watchData) {
+        ALOGE("out of memory error starting EventLoop!");
+        goto done;
+    }
+
+    nat->pollDataSize = DEFAULT_INITIAL_POLLFD_COUNT;
+    nat->pollMemberCount = 1;
+
+    if (socketpair(AF_LOCAL, SOCK_STREAM, 0, &(nat->controlFdR))) {
+        ALOGE("Error getting BT control socket");
+        goto done;
+    }
+    nat->pollData[0].fd = nat->controlFdR;
+    nat->pollData[0].events = POLLIN;
+
+    env->GetJavaVM( &(nat->vm) );
+    nat->envVer = env->GetVersion();
+
+    nat->me = env->NewGlobalRef(object);
+
+    if (setUpEventLoop(nat) != JNI_TRUE) {
+        ALOGE("failure setting up Event Loop!");
+        goto done;
+    }
+
+    pthread_create(&(nat->thread), NULL, eventLoopMain, nat);
+    result = JNI_TRUE;
+
+done:
+    if (JNI_FALSE == result) {
+        if (nat->controlFdW) {
+            close(nat->controlFdW);
+            nat->controlFdW = 0;
+        }
+        if (nat->controlFdR) {
+            close(nat->controlFdR);
+            nat->controlFdR = 0;
+        }
+        if (nat->me) env->DeleteGlobalRef(nat->me);
+        nat->me = NULL;
+        if (nat->pollData) free(nat->pollData);
+        nat->pollData = NULL;
+        if (nat->watchData) free(nat->watchData);
+        nat->watchData = NULL;
+        nat->pollDataSize = 0;
+        nat->pollMemberCount = 0;
+    }
+
+    pthread_mutex_unlock(&(nat->thread_mutex));
+#endif // HAVE_BLUETOOTH
+    return result;
+}
+
+static void stopEventLoopNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+
+    pthread_mutex_lock(&(nat->thread_mutex));
+    if (nat->pollData) {
+        char data = EVENT_LOOP_EXIT;
+        ssize_t t = write(nat->controlFdW, &data, sizeof(char));
+        void *ret;
+        pthread_join(nat->thread, &ret);
+
+        env->DeleteGlobalRef(nat->me);
+        nat->me = NULL;
+        free(nat->pollData);
+        nat->pollData = NULL;
+        free(nat->watchData);
+        nat->watchData = NULL;
+        nat->pollDataSize = 0;
+        nat->pollMemberCount = 0;
+
+        int fd = nat->controlFdW;
+        nat->controlFdW = 0;
+        close(fd);
+    }
+    nat->running = false;
+    pthread_mutex_unlock(&(nat->thread_mutex));
+#endif // HAVE_BLUETOOTH
+}
+
+static jboolean isEventLoopRunningNative(JNIEnv *env, jobject object) {
+    jboolean result = JNI_FALSE;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+
+    pthread_mutex_lock(&(nat->thread_mutex));
+    if (nat->running) {
+        result = JNI_TRUE;
+    }
+    pthread_mutex_unlock(&(nat->thread_mutex));
+
+#endif // HAVE_BLUETOOTH
+    return result;
+}
+
+#ifdef HAVE_BLUETOOTH
+extern DBusHandlerResult a2dp_event_filter(DBusMessage *msg, JNIEnv *env);
+
+// Called by dbus during WaitForAndDispatchEventNative()
+static DBusHandlerResult event_filter(DBusConnection *conn, DBusMessage *msg,
+                                      void *data) {
+    native_data_t *nat;
+    JNIEnv *env;
+    DBusError err;
+    DBusHandlerResult ret;
+
+    dbus_error_init(&err);
+
+    nat = (native_data_t *)data;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+    if (dbus_message_get_type(msg) != DBUS_MESSAGE_TYPE_SIGNAL) {
+        ALOGV("%s: not interested (not a signal).", __FUNCTION__);
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    }
+
+    ALOGV("%s: Received signal %s:%s from %s", __FUNCTION__,
+        dbus_message_get_interface(msg), dbus_message_get_member(msg),
+        dbus_message_get_path(msg));
+
+    env->PushLocalFrame(EVENT_LOOP_REFS);
+    if (dbus_message_is_signal(msg,
+                               "org.bluez.Adapter",
+                               "DeviceFound")) {
+        char *c_address;
+        DBusMessageIter iter;
+        jobjectArray str_array = NULL;
+        if (dbus_message_iter_init(msg, &iter)) {
+            dbus_message_iter_get_basic(&iter, &c_address);
+            if (dbus_message_iter_next(&iter))
+                str_array =
+                    parse_remote_device_properties(env, &iter);
+        }
+        if (str_array != NULL) {
+            env->CallVoidMethod(nat->me,
+                                method_onDeviceFound,
+                                env->NewStringUTF(c_address),
+                                str_array);
+        } else
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.Adapter",
+                                     "DeviceDisappeared")) {
+        char *c_address;
+        if (dbus_message_get_args(msg, &err,
+                                  DBUS_TYPE_STRING, &c_address,
+                                  DBUS_TYPE_INVALID)) {
+            ALOGV("... address = %s", c_address);
+            env->CallVoidMethod(nat->me, method_onDeviceDisappeared,
+                                env->NewStringUTF(c_address));
+        } else LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.Adapter",
+                                     "DeviceCreated")) {
+        char *c_object_path;
+        if (dbus_message_get_args(msg, &err,
+                                  DBUS_TYPE_OBJECT_PATH, &c_object_path,
+                                  DBUS_TYPE_INVALID)) {
+            ALOGV("... address = %s", c_object_path);
+            env->CallVoidMethod(nat->me,
+                                method_onDeviceCreated,
+                                env->NewStringUTF(c_object_path));
+        } else LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.Adapter",
+                                     "DeviceRemoved")) {
+        char *c_object_path;
+        if (dbus_message_get_args(msg, &err,
+                                 DBUS_TYPE_OBJECT_PATH, &c_object_path,
+                                 DBUS_TYPE_INVALID)) {
+           ALOGV("... Object Path = %s", c_object_path);
+           env->CallVoidMethod(nat->me,
+                               method_onDeviceRemoved,
+                               env->NewStringUTF(c_object_path));
+        } else LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                      "org.bluez.Adapter",
+                                      "PropertyChanged")) {
+        jobjectArray str_array = parse_adapter_property_change(env, msg);
+        if (str_array != NULL) {
+            /* Check if bluetoothd has (re)started, if so update the path. */
+            jstring property =(jstring) env->GetObjectArrayElement(str_array, 0);
+            const char *c_property = env->GetStringUTFChars(property, NULL);
+            if (!strncmp(c_property, "Powered", strlen("Powered"))) {
+                jstring value =
+                    (jstring) env->GetObjectArrayElement(str_array, 1);
+                const char *c_value = env->GetStringUTFChars(value, NULL);
+                if (!strncmp(c_value, "true", strlen("true")))
+                    nat->adapter = get_adapter_path(nat->conn);
+                env->ReleaseStringUTFChars(value, c_value);
+            }
+            env->ReleaseStringUTFChars(property, c_property);
+
+            env->CallVoidMethod(nat->me,
+                              method_onPropertyChanged,
+                              str_array);
+        } else LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                      "org.bluez.Device",
+                                      "PropertyChanged")) {
+        jobjectArray str_array = parse_remote_device_property_change(env, msg);
+        if (str_array != NULL) {
+            const char *remote_device_path = dbus_message_get_path(msg);
+            env->CallVoidMethod(nat->me,
+                            method_onDevicePropertyChanged,
+                            env->NewStringUTF(remote_device_path),
+                            str_array);
+        } else LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                      "org.bluez.Device",
+                                      "DisconnectRequested")) {
+        const char *remote_device_path = dbus_message_get_path(msg);
+        env->CallVoidMethod(nat->me,
+                            method_onDeviceDisconnectRequested,
+                            env->NewStringUTF(remote_device_path));
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                      "org.bluez.Input",
+                                      "PropertyChanged")) {
+
+        jobjectArray str_array =
+                    parse_input_property_change(env, msg);
+        if (str_array != NULL) {
+            const char *c_path = dbus_message_get_path(msg);
+            env->CallVoidMethod(nat->me,
+                                method_onInputDevicePropertyChanged,
+                                env->NewStringUTF(c_path),
+                                str_array);
+        } else {
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        }
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.Network",
+                                     "PropertyChanged")) {
+
+       jobjectArray str_array =
+                   parse_pan_property_change(env, msg);
+       if (str_array != NULL) {
+           const char *c_path = dbus_message_get_path(msg);
+           env->CallVoidMethod(nat->me,
+                               method_onPanDevicePropertyChanged,
+                               env->NewStringUTF(c_path),
+                               str_array);
+       } else {
+           LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+       }
+       goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.NetworkServer",
+                                     "DeviceDisconnected")) {
+       char *c_address;
+       if (dbus_message_get_args(msg, &err,
+                                  DBUS_TYPE_STRING, &c_address,
+                                  DBUS_TYPE_INVALID)) {
+           env->CallVoidMethod(nat->me,
+                               method_onNetworkDeviceDisconnected,
+                               env->NewStringUTF(c_address));
+       } else {
+           LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+       }
+       goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.NetworkServer",
+                                     "DeviceConnected")) {
+       char *c_address;
+       char *c_iface;
+       uint16_t uuid;
+
+       if (dbus_message_get_args(msg, &err,
+                                  DBUS_TYPE_STRING, &c_address,
+                                  DBUS_TYPE_STRING, &c_iface,
+                                  DBUS_TYPE_UINT16, &uuid,
+                                  DBUS_TYPE_INVALID)) {
+           env->CallVoidMethod(nat->me,
+                               method_onNetworkDeviceConnected,
+                               env->NewStringUTF(c_address),
+                               env->NewStringUTF(c_iface),
+                               uuid);
+       } else {
+           LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+       }
+       goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.HealthDevice",
+                                     "ChannelConnected")) {
+       const char *c_path = dbus_message_get_path(msg);
+       const char *c_channel_path;
+       jboolean exists = JNI_TRUE;
+       if (dbus_message_get_args(msg, &err,
+                                  DBUS_TYPE_OBJECT_PATH, &c_channel_path,
+                                  DBUS_TYPE_INVALID)) {
+           env->CallVoidMethod(nat->me,
+                               method_onHealthDeviceChannelChanged,
+                               env->NewStringUTF(c_path),
+                               env->NewStringUTF(c_channel_path),
+                               exists);
+       } else {
+           LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+       }
+       goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.HealthDevice",
+                                     "ChannelDeleted")) {
+
+       const char *c_path = dbus_message_get_path(msg);
+       const char *c_channel_path;
+       jboolean exists = JNI_FALSE;
+       if (dbus_message_get_args(msg, &err,
+                                  DBUS_TYPE_OBJECT_PATH, &c_channel_path,
+                                  DBUS_TYPE_INVALID)) {
+           env->CallVoidMethod(nat->me,
+                               method_onHealthDeviceChannelChanged,
+                               env->NewStringUTF(c_path),
+                               env->NewStringUTF(c_channel_path),
+                               exists);
+       } else {
+           LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+       }
+       goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.HealthDevice",
+                                     "PropertyChanged")) {
+        jobjectArray str_array =
+                    parse_health_device_property_change(env, msg);
+        if (str_array != NULL) {
+            const char *c_path = dbus_message_get_path(msg);
+            env->CallVoidMethod(nat->me,
+                                method_onHealthDevicePropertyChanged,
+                                env->NewStringUTF(c_path),
+                                str_array);
+       } else {
+           LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+       }
+       goto success;
+    }  else if (dbus_message_is_signal(msg,
+                                      "org.qcom.sap",
+                                      "SapStateChanged")) {
+        const char *remote_device_path = dbus_message_get_path(msg);
+        const char *state;
+        ALOGV("Got the SAP state changed :dev: %s \n", remote_device_path );
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &remote_device_path,
+                                   DBUS_TYPE_STRING, &state,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for SapStateChanged() method", __FUNCTION__);
+        }
+        ALOGV("<SAP>SapState: %s\n", state);
+        env->CallVoidMethod(nat->me, method_onSapStateChanged,
+                                       env->NewStringUTF(remote_device_path),
+                                       env->NewStringUTF(state),
+                                       int(msg));
+        goto success;
+    }  else if (dbus_message_is_signal(msg,
+                                      "org.qcom.bluetooth.dun",
+                                      "DunStateChanged")) {
+        const char *remote_device_path = dbus_message_get_path(msg);
+        const char *state;
+        ALOGV("Got the DUN state changed :dev: %s \n", remote_device_path );
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &remote_device_path,
+                                   DBUS_TYPE_STRING, &state,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for DUNStateChanged() method", __FUNCTION__);
+        }
+        env->CallVoidMethod(nat->me, method_onDUNStateChanged,
+                                       env->NewStringUTF(remote_device_path),
+                                       env->NewStringUTF(state),
+                                       int(msg));
+        goto success;
+    }
+
+    ret = a2dp_event_filter(msg, env);
+    env->PopLocalFrame(NULL);
+    return ret;
+
+success:
+    env->PopLocalFrame(NULL);
+    return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+// Called by dbus during WaitForAndDispatchEventNative()
+DBusHandlerResult agent_event_filter(DBusConnection *conn,
+                                     DBusMessage *msg, void *data) {
+    native_data_t *nat = (native_data_t *)data;
+    JNIEnv *env;
+    if (dbus_message_get_type(msg) != DBUS_MESSAGE_TYPE_METHOD_CALL) {
+        ALOGV("%s: not interested (not a method call).", __FUNCTION__);
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    }
+    ALOGI("%s: Received method %s:%s", __FUNCTION__,
+         dbus_message_get_interface(msg), dbus_message_get_member(msg));
+
+    if (nat == NULL) return DBUS_HANDLER_RESULT_HANDLED;
+
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+    env->PushLocalFrame(EVENT_LOOP_REFS);
+
+    if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "Cancel")) {
+        env->CallVoidMethod(nat->me, method_onAgentCancel);
+        // reply
+        DBusMessage *reply = dbus_message_new_method_return(msg);
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply\n", __FUNCTION__);
+            goto failure;
+        }
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(reply);
+        goto success;
+
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "Authorize")) {
+        char *object_path;
+        const char *uuid;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_STRING, &uuid,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for Authorize() method", __FUNCTION__);
+            goto failure;
+        }
+
+        ALOGV("... object_path = %s", object_path);
+        ALOGV("... uuid = %s", uuid);
+        if (!strcmp(uuid, SAP_UUID)) {
+            ALOGV("Received SAP authorization request");
+            dbus_message_ref(msg);  // increment refcount because we pass to java
+            env->CallVoidMethod(nat->me, method_onSapAuthorize,
+                                       env->NewStringUTF(object_path),
+                                       env->NewStringUTF(uuid),
+                                       int(msg));
+            goto success;
+        }
+
+        if (!strcmp(uuid, DUN_UUID)) {
+            ALOGV("Received DUN authorization request");
+            dbus_message_ref(msg);  // increment refcount because we pass to java
+            env->CallVoidMethod(nat->me, method_onDUNAuthorize,
+                                       env->NewStringUTF(object_path),
+                                       env->NewStringUTF(uuid),
+                                       int(msg));
+            goto success;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onAgentAuthorize,
+                env->NewStringUTF(object_path), env->NewStringUTF(uuid),
+                int(msg));
+
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "OutOfBandAvailable")) {
+        char *object_path;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for OutOfBandData available() method", __FUNCTION__);
+            goto failure;
+        }
+
+        ALOGV("... object_path = %s", object_path);
+
+        bool available =
+            env->CallBooleanMethod(nat->me, method_onAgentOutOfBandDataAvailable,
+                env->NewStringUTF(object_path));
+
+
+        // reply
+        if (available) {
+            DBusMessage *reply = dbus_message_new_method_return(msg);
+            if (!reply) {
+                ALOGE("%s: Cannot create message reply\n", __FUNCTION__);
+                goto failure;
+            }
+            dbus_connection_send(nat->conn, reply, NULL);
+            dbus_message_unref(reply);
+        } else {
+            DBusMessage *reply = dbus_message_new_error(msg,
+                    "org.bluez.Error.DoesNotExist", "OutofBand data not available");
+            if (!reply) {
+                ALOGE("%s: Cannot create message reply\n", __FUNCTION__);
+                goto failure;
+            }
+            dbus_connection_send(nat->conn, reply, NULL);
+            dbus_message_unref(reply);
+        }
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "RequestPinCode")) {
+        char *object_path;
+        dbus_bool_t secure;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_BOOLEAN, &secure,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for RequestPinCode() method", __FUNCTION__);
+            goto failure;
+        }
+        ALOGV("Secure Pairing %d", secure);
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onRequestPinCode,
+                                       env->NewStringUTF(object_path),
+                                       int(msg), secure);
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "RequestPasskey")) {
+        char *object_path;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for RequestPasskey() method", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onRequestPasskey,
+                                       env->NewStringUTF(object_path),
+                                       int(msg));
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "RequestOobData")) {
+        char *object_path;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for RequestOobData() method", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onRequestOobData,
+                                       env->NewStringUTF(object_path),
+                                       int(msg));
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "DisplayPasskey")) {
+        char *object_path;
+        uint32_t passkey;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_UINT32, &passkey,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for RequestPasskey() method", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onDisplayPasskey,
+                                       env->NewStringUTF(object_path),
+                                       passkey,
+                                       int(msg));
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "RequestConfirmation")) {
+        char *object_path;
+        uint32_t passkey;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_UINT32, &passkey,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for RequestConfirmation() method", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onRequestPasskeyConfirmation,
+                                       env->NewStringUTF(object_path),
+                                       passkey,
+                                       int(msg));
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "RequestPairingConsent")) {
+        char *object_path;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for RequestPairingConsent() method", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onRequestPairingConsent,
+                                       env->NewStringUTF(object_path),
+                                       int(msg));
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+                  "org.bluez.Agent", "Release")) {
+        // reply
+        DBusMessage *reply = dbus_message_new_method_return(msg);
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply\n", __FUNCTION__);
+            goto failure;
+        }
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(reply);
+        goto success;
+    } else {
+        ALOGV("%s:%s is ignored", dbus_message_get_interface(msg), dbus_message_get_member(msg));
+    }
+
+failure:
+    env->PopLocalFrame(NULL);
+    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+success:
+    env->PopLocalFrame(NULL);
+    return DBUS_HANDLER_RESULT_HANDLED;
+
+}
+
+// Called by dbus during WaitForAndDispatchEventNative()
+DBusHandlerResult watcher_event_filter(DBusConnection *conn,
+                                     DBusMessage *msg, void *data) {
+    native_data_t *nat = (native_data_t *)data;
+    JNIEnv *env;
+    if (dbus_message_get_type(msg) != DBUS_MESSAGE_TYPE_METHOD_CALL) {
+        ALOGV("%s: not interested (not a method call).", __FUNCTION__);
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    }
+    ALOGE("%s: WatcherEventFilter Received method %s:%s", __FUNCTION__,
+         dbus_message_get_interface(msg), dbus_message_get_member(msg));
+
+    if (nat == NULL) return DBUS_HANDLER_RESULT_HANDLED;
+
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+    env->PushLocalFrame(EVENT_LOOP_REFS);
+
+    if (dbus_message_is_method_call(msg,
+            "org.bluez.Watcher", "ValueChanged")) {
+        char *object_path;
+        uint8_t *value;
+        int vlen;
+
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &value, &vlen,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for ValueChanged() method", __FUNCTION__);
+            goto failure;
+        }
+
+        char *tmpValueArray = (char *) malloc(sizeof(char) * ( (2*vlen) + 1 ));
+        char *tmpPos = tmpValueArray;
+        for (int j=0; j<vlen; j++) {
+            sprintf(tmpPos, "%02x", value[j]);
+            tmpPos+=2;
+        }
+        tmpValueArray[2*vlen] = '\0';
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+
+        env->CallVoidMethod(nat->me, method_onWatcherValueChanged,
+                                       env->NewStringUTF(object_path),
+                                       env->NewStringUTF(tmpValueArray)
+                                       );
+        free(tmpValueArray);
+
+        goto success;
+    } else {
+        ALOGV("%s:%s is ignored", dbus_message_get_interface(msg), dbus_message_get_member(msg));
+    }
+
+failure:
+    env->PopLocalFrame(NULL);
+    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+success:
+    env->PopLocalFrame(NULL);
+    return DBUS_HANDLER_RESULT_HANDLED;
+
+}
+// Called by dbus during WaitForAndDispatchEventNative()
+DBusHandlerResult gatt_event_filter(DBusConnection *conn,
+                                     DBusMessage *msg, void *data) {
+    native_data_t *nat = (native_data_t *)data;
+    JNIEnv *env;
+    if (dbus_message_get_type(msg) != DBUS_MESSAGE_TYPE_METHOD_CALL) {
+        ALOGV("%s: not interested (not a method call).", __FUNCTION__);
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    }
+    ALOGE("%s: gatt_event_filter Received method %s:%s", __FUNCTION__,
+         dbus_message_get_interface(msg), dbus_message_get_member(msg));
+
+    if (nat == NULL) return DBUS_HANDLER_RESULT_HANDLED;
+
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+    env->PushLocalFrame(EVENT_LOOP_REFS);
+
+    if (dbus_message_is_method_call(msg,
+            "org.bluez.GattServer", "ReadByGroup")) {
+        const char *uuid_str, *objPath;
+        uint16_t start;
+        uint16_t end;
+
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_UINT16, &start,
+                                   DBUS_TYPE_UINT16, &end,
+                                   DBUS_TYPE_STRING, &uuid_str,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for ReadByGroup() method", __FUNCTION__);
+            goto failure;
+        }
+
+        objPath = dbus_message_get_path(msg);
+        if(objPath == NULL) {
+            ALOGE("%s: Gatt object path is null", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+
+        env->CallVoidMethod(nat->me, method_onGattDiscoverPrimaryRequest,
+                            env->NewStringUTF(objPath),
+                            start, end,
+                            int(msg)
+                            );
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.GattServer", "FindByPrim")) {
+        const char *uuid_str, *objPath;
+        uint16_t start;
+        uint16_t end;
+
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_UINT16, &start,
+                                   DBUS_TYPE_UINT16, &end,
+                                   DBUS_TYPE_STRING, &uuid_str,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for FindByType() method", __FUNCTION__);
+            goto failure;
+        }
+
+        objPath = dbus_message_get_path(msg);
+        if(objPath == NULL) {
+            ALOGE("%s: Gatt object path is null", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+
+        env->CallVoidMethod(nat->me, method_onGattDiscoverPrimaryByUuidRequest,
+                            env->NewStringUTF(objPath),
+                            env->NewStringUTF(uuid_str),
+                            start, end,
+                            int(msg)
+                            );
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.GattServer", "ReadByInc")) {
+        const char *objPath;
+        uint16_t start;
+        uint16_t end;
+
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_UINT16, &start,
+                                   DBUS_TYPE_UINT16, &end,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for ReadByInc() method", __FUNCTION__);
+            goto failure;
+        }
+
+        objPath = dbus_message_get_path(msg);
+        if(objPath == NULL) {
+            ALOGE("%s: Gatt object path is null", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+
+        env->CallVoidMethod(nat->me, method_onGattDiscoverIncludedRequest,
+                            env->NewStringUTF(objPath),
+                            start, end,
+                            int(msg)
+                            );
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.GattServer", "ReadByChar")) {
+        const char *objPath;
+        uint16_t start;
+        uint16_t end;
+
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_UINT16, &start,
+                                   DBUS_TYPE_UINT16, &end,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for ReadByChar() method", __FUNCTION__);
+            goto failure;
+        }
+
+        objPath = dbus_message_get_path(msg);
+        if(objPath == NULL) {
+            ALOGE("%s: Gatt object path is null", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+
+        env->CallVoidMethod(nat->me, method_onGattDiscoverCharacteristicsRequest,
+                            env->NewStringUTF(objPath),
+                            start, end,
+                            int(msg)
+                            );
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.GattServer", "ReadByType")) {
+        const char *uuid_str, *objPath, *auth;
+        uint16_t start;
+        uint16_t end;
+
+
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_UINT16, &start,
+                                   DBUS_TYPE_UINT16, &end,
+                                   DBUS_TYPE_STRING, &uuid_str,
+                                   DBUS_TYPE_STRING, &auth,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for FindByType() method", __FUNCTION__);
+            goto failure;
+        }
+
+        objPath = dbus_message_get_path(msg);
+        if(objPath == NULL) {
+            ALOGE("%s: Gatt object path is null", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+
+        env->CallVoidMethod(nat->me, method_onGattReadByTypeRequest,
+                            env->NewStringUTF(objPath),
+                            env->NewStringUTF(uuid_str),
+                            env->NewStringUTF(auth),
+                            start, end,
+                            int(msg)
+                            );
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.GattServer", "FindInfo")) {
+        const char *objPath;
+        uint16_t start;
+        uint16_t end;
+
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_UINT16, &start,
+                                   DBUS_TYPE_UINT16, &end,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for FindInfo() method", __FUNCTION__);
+            goto failure;
+        }
+
+        objPath = dbus_message_get_path(msg);
+        if(objPath == NULL) {
+            ALOGE("%s: Gatt object path is null", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+
+        env->CallVoidMethod(nat->me, method_onGattFindInfoRequest,
+                            env->NewStringUTF(objPath),
+                            start, end,
+                            int(msg)
+                            );
+        goto success;
+    }  else if (dbus_message_is_method_call(msg,
+            "org.bluez.GattServer", "Read")) {
+        const char *objPath, *auth;
+        uint16_t handle;
+
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_UINT16, &handle,
+                                   DBUS_TYPE_STRING, &auth,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for FindByType() method", __FUNCTION__);
+            goto failure;
+        }
+
+        objPath = dbus_message_get_path(msg);
+        if(objPath == NULL) {
+            ALOGE("%s: Gatt object path is null", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+
+        env->CallVoidMethod(nat->me, method_onGattReadRequest,
+                            env->NewStringUTF(objPath),
+                            env->NewStringUTF(auth),
+                            handle,
+                            int(msg)
+                            );
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.GattServer", "Write")) {
+        const char *objPath, *auth;
+        int sessionHandle;
+        uint16_t handle;
+        jbyte *value;
+        int vlen;
+        jbyteArray byteArray = NULL;
+
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_UINT32, &sessionHandle,
+                                   DBUS_TYPE_UINT16, &handle,
+                                   DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &value, &vlen,
+                                   DBUS_TYPE_STRING, &auth,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for Write() method", __FUNCTION__);
+            goto failure;
+        }
+
+        objPath = dbus_message_get_path(msg);
+        if(objPath == NULL) {
+            ALOGE("%s: Gatt object path is null", __FUNCTION__);
+            goto failure;
+        }
+
+        if (vlen != 0) {
+            byteArray = env->NewByteArray(vlen);
+            if (byteArray)
+                env->SetByteArrayRegion(byteArray, 0, vlen, value);
+            else
+                goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+
+        env->CallVoidMethod(nat->me, method_onGattWriteRequest,
+                            env->NewStringUTF(objPath),
+                            env->NewStringUTF(auth),
+                            handle,
+                            byteArray,
+                            sessionHandle,
+                            int(msg)
+                            );
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.GattServer", "WriteCmd")) {
+        const char *objPath, *auth;
+        uint16_t handle;
+        jbyte *value;
+        int vlen;
+        jbyteArray byteArray = NULL;
+
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_UINT16, &handle,
+                                   DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &value, &vlen,
+                                   DBUS_TYPE_STRING, &auth,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for Write() method", __FUNCTION__);
+            goto failure;
+        }
+
+        objPath = dbus_message_get_path(msg);
+        if(objPath == NULL) {
+            ALOGE("%s: Gatt object path is null", __FUNCTION__);
+            goto failure;
+        }
+
+        if (vlen != 0) {
+            byteArray = env->NewByteArray(vlen);
+        }
+        if (byteArray) {
+            env->SetByteArrayRegion(byteArray, 0, vlen, value);
+        } else
+            goto failure;
+
+        env->CallVoidMethod(nat->me, method_onGattWriteCommand,
+                            env->NewStringUTF(objPath),
+                            env->NewStringUTF(auth),
+                            handle,
+                            byteArray);
+        goto success;
+
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.GattServer", "UpdateClientConfig")) {
+        const char *objPath;
+        int sessionHandle;
+        uint16_t handle;
+        jbyte *value;
+        int vlen;
+        jbyteArray byteArray = NULL;
+
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_UINT32, &sessionHandle,
+                                   DBUS_TYPE_UINT16, &handle,
+                                   DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &value, &vlen,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for UpdateClientConfig() method", __FUNCTION__);
+            goto failure;
+        }
+
+        objPath = dbus_message_get_path(msg);
+        if(objPath == NULL) {
+            ALOGE("%s: Gatt object path is null", __FUNCTION__);
+            goto failure;
+        }
+
+        if (vlen != 0) {
+            byteArray = env->NewByteArray(vlen);
+        }
+        if (byteArray) {
+            env->SetByteArrayRegion(byteArray, 0, vlen, value);
+        } else
+            goto failure;
+
+        env->CallVoidMethod(nat->me, method_onGattSetClientConfigDescriptor,
+                            env->NewStringUTF(objPath),
+                            sessionHandle,
+                            handle,
+                            byteArray
+                            );
+        goto success;
+    } else {
+        ALOGV("%s:%s is ignored", dbus_message_get_interface(msg), dbus_message_get_member(msg));
+    }
+
+failure:
+    env->PopLocalFrame(NULL);
+    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+success:
+    env->PopLocalFrame(NULL);
+    return DBUS_HANDLER_RESULT_HANDLED;
+
+}
+#endif
+
+
+#ifdef HAVE_BLUETOOTH
+
+void onCreatePairedDeviceResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *address = (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    jstring addr;
+
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    ALOGV("... address = %s", address);
+
+    jint result = BOND_RESULT_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.AuthenticationFailed")) {
+            // Pins did not match, or remote device did not respond to pin
+            // request in time
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_AUTH_FAILED;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.AuthenticationRejected")) {
+            // We rejected pairing, or the remote side rejected pairing. This
+            // happens if either side presses 'cancel' at the pairing dialog.
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_AUTH_REJECTED;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.AuthenticationCanceled")) {
+            // Not sure if this happens
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_AUTH_CANCELED;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.ConnectionAttemptFailed")) {
+            // Other device is not responding at all
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_REMOTE_DEVICE_DOWN;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.AlreadyExists")) {
+            // already bonded
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_SUCCESS;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.InProgress") &&
+                   !strcmp(err.message, "Bonding in progress")) {
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            goto done;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.InProgress") &&
+                   !strcmp(err.message, "Discover in progress")) {
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_DISCOVERY_IN_PROGRESS;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.RepeatedAttempts")) {
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_REPEATED_ATTEMPTS;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.AuthenticationTimeout")) {
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_AUTH_TIMEOUT;
+        } else {
+            ALOGE("%s: D-Bus error: %s (%s)\n", __FUNCTION__, err.name, err.message);
+            result = BOND_RESULT_ERROR;
+        }
+    }
+
+    addr = env->NewStringUTF(address);
+    env->CallVoidMethod(nat->me,
+                        method_onCreatePairedDeviceResult,
+                        addr,
+                        result);
+    env->DeleteLocalRef(addr);
+done:
+    dbus_error_free(&err);
+    free(user);
+}
+
+void onCreateDeviceResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *address= (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    ALOGV("... Address = %s", address);
+
+    jint result = CREATE_DEVICE_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (dbus_error_has_name(&err, "org.bluez.Error.AlreadyExists")) {
+            result = CREATE_DEVICE_ALREADY_EXISTS;
+        } else {
+            result = CREATE_DEVICE_FAILED;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+    jstring addr = env->NewStringUTF(address);
+    env->CallVoidMethod(nat->me,
+                        method_onCreateDeviceResult,
+                        addr,
+                        result);
+    env->DeleteLocalRef(addr);
+    free(user);
+}
+
+void onAddToPreferredDeviceListResult(DBusMessage *msg, void *user, void *n) {
+    native_data_t *nat = (native_data_t *)n;
+    const char *address= (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    jint result = CREATE_DEVICE_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (dbus_error_has_name(&err, "org.bluez.Error.AlreadyExists")) {
+            result = CREATE_DEVICE_ALREADY_EXISTS;
+        } else {
+            result = CREATE_DEVICE_FAILED;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+
+    env->CallVoidMethod(nat->me,
+                        method_onAddToPreferredDeviceListResult,
+                        result);
+    free(user);
+}
+void onRemoveFromPreferredDeviceListResult(DBusMessage *msg, void *user, void *n) {
+    native_data_t *nat = (native_data_t *)n;
+    const char *address= (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    jint result = CREATE_DEVICE_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (dbus_error_has_name(&err, "org.bluez.Error.AlreadyExists")) {
+            result = CREATE_DEVICE_ALREADY_EXISTS;
+        } else {
+            result = CREATE_DEVICE_FAILED;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+    env->CallVoidMethod(nat->me,
+                        method_onRemoveFromPreferredDeviceListResult,
+                        result);
+    free(user);
+}
+void onClearPreferredDeviceListResult(DBusMessage *msg, void *user, void *n) {
+    native_data_t *nat = (native_data_t *)n;
+    const char *address= (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    jint result = CREATE_DEVICE_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (dbus_error_has_name(&err, "org.bluez.Error.AlreadyExists")) {
+            result = CREATE_DEVICE_ALREADY_EXISTS;
+        } else {
+            result = CREATE_DEVICE_FAILED;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+
+    env->CallVoidMethod(nat->me,
+                        method_onClearPreferredDeviceListResult,
+                        result);
+    free(user);
+}
+void onGattConnectToPreferredDeviceListResult(DBusMessage *msg, void *user, void *n) {
+    native_data_t *nat = (native_data_t *)n;
+    const char *address= (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    jint result = CREATE_DEVICE_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (dbus_error_has_name(&err, "org.bluez.Error.AlreadyExists")) {
+            result = CREATE_DEVICE_ALREADY_EXISTS;
+        } else {
+            result = CREATE_DEVICE_FAILED;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+    env->CallVoidMethod(nat->me,
+                        method_onGattConnectToPreferredDeviceListResult,
+                        result);
+    free(user);
+}
+void onGattCancelConnectToPreferredDeviceListResult(DBusMessage *msg, void *user, void *n) {
+    native_data_t *nat = (native_data_t *)n;
+    const char *address= (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+    jint result = CREATE_DEVICE_SUCCESS;
+
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (dbus_error_has_name(&err, "org.bluez.Error.AlreadyExists")) {
+            result = CREATE_DEVICE_ALREADY_EXISTS;
+        } else {
+            result = CREATE_DEVICE_FAILED;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+    env->CallVoidMethod(nat->me,
+                        method_onGattCancelConnectToPreferredDeviceListResult,
+                        result);
+    free(user);
+}
+
+void onDiscoverServicesResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *path = (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    ALOGV("... Device Path = %s", path);
+
+    bool result = JNI_TRUE;
+    if (dbus_set_error_from_message(&err, msg)) {
+        LOG_AND_FREE_DBUS_ERROR(&err);
+        result = JNI_FALSE;
+    }
+    jstring jPath = env->NewStringUTF(path);
+    env->CallVoidMethod(nat->me,
+                        method_onDiscoverServicesResult,
+                        jPath,
+                        result);
+    env->DeleteLocalRef(jPath);
+    free(user);
+}
+
+void onGetDeviceServiceChannelResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    const char *address = (const char *) user;
+    native_data_t *nat = (native_data_t *) n;
+
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    jint channel = -2;
+
+    ALOGV("... address = %s", address);
+
+    if (dbus_set_error_from_message(&err, msg) ||
+        !dbus_message_get_args(msg, &err,
+                               DBUS_TYPE_INT32, &channel,
+                               DBUS_TYPE_INVALID)) {
+        ALOGE("%s: D-Bus error: %s (%s)\n", __FUNCTION__, err.name, err.message);
+        dbus_error_free(&err);
+    }
+
+done:
+    jstring addr = env->NewStringUTF(address);
+    env->CallVoidMethod(nat->me,
+                        method_onGetDeviceServiceChannelResult,
+                        addr,
+                        channel);
+    env->DeleteLocalRef(addr);
+    free(user);
+}
+
+void onInputDeviceConnectionResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *path = (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    jint result = INPUT_OPERATION_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (!strcmp(err.name, BLUEZ_ERROR_IFC ".ConnectionAttemptFailed")) {
+            result = INPUT_CONNECT_FAILED_ATTEMPT_FAILED;
+        } else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".AlreadyConnected")) {
+            result = INPUT_CONNECT_FAILED_ALREADY_CONNECTED;
+        } else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".Failed")) {
+            // TODO():This is flaky, need to change Bluez to add new error codes
+            if (!strcmp(err.message, "Transport endpoint is not connected")) {
+              result = INPUT_DISCONNECT_FAILED_NOT_CONNECTED;
+            } else {
+              result = INPUT_OPERATION_GENERIC_FAILURE;
+            }
+        } else {
+            result = INPUT_OPERATION_GENERIC_FAILURE;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+
+    ALOGV("... Device Path = %s, result = %d", path, result);
+    jstring jPath = env->NewStringUTF(path);
+    env->CallVoidMethod(nat->me,
+                        method_onInputDeviceConnectionResult,
+                        jPath,
+                        result);
+    env->DeleteLocalRef(jPath);
+    free(user);
+}
+
+void onDiscoverCharacteristicsResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *path = (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    ALOGV("... GATT Service Path = %s", path);
+
+    bool result = JNI_TRUE;
+    if (dbus_set_error_from_message(&err, msg)) {
+        LOG_AND_FREE_DBUS_ERROR(&err);
+        result = JNI_FALSE;
+    }
+    jstring jPath = env->NewStringUTF(path);
+    env->CallVoidMethod(nat->me,
+                        method_onDiscoverCharacteristicsResult,
+                        jPath,
+                        result);
+    env->DeleteLocalRef(jPath);
+    free(user);
+}
+
+void onPanDeviceConnectionResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *path = (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    jint result = PAN_OPERATION_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (!strcmp(err.name, BLUEZ_ERROR_IFC ".ConnectionAttemptFailed")) {
+            result = PAN_CONNECT_FAILED_ATTEMPT_FAILED;
+        } else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".Failed")) {
+            // TODO():This is flaky, need to change Bluez to add new error codes
+            if (!strcmp(err.message, "Device already connected")) {
+                result = PAN_CONNECT_FAILED_ALREADY_CONNECTED;
+            } else if (!strcmp(err.message, "Device not connected")) {
+                result = PAN_DISCONNECT_FAILED_NOT_CONNECTED;
+            } else {
+                result = PAN_OPERATION_GENERIC_FAILURE;
+            }
+        } else {
+            result = PAN_OPERATION_GENERIC_FAILURE;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+
+    ALOGV("... Pan Device Path = %s, result = %d", path, result);
+    jstring jPath = env->NewStringUTF(path);
+    env->CallVoidMethod(nat->me,
+                        method_onPanDeviceConnectionResult,
+                        jPath,
+                        result);
+    env->DeleteLocalRef(jPath);
+    free(user);
+}
+
+void onHealthDeviceConnectionResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    jint result = HEALTH_OPERATION_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (!strcmp(err.name, BLUEZ_ERROR_IFC ".InvalidArgs")) {
+            result = HEALTH_OPERATION_INVALID_ARGS;
+        } else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".HealthError")) {
+            result = HEALTH_OPERATION_ERROR;
+        } else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".NotFound")) {
+            result = HEALTH_OPERATION_NOT_FOUND;
+        } else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".NotAllowed")) {
+            result = HEALTH_OPERATION_NOT_ALLOWED;
+        } else {
+            result = HEALTH_OPERATION_GENERIC_FAILURE;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+
+    jint code = *(int *) user;
+    ALOGV("... Health Device Code = %d, result = %d", code, result);
+    env->CallVoidMethod(nat->me,
+                        method_onHealthDeviceConnectionResult,
+                        code,
+                        result);
+    free(user);
+}
+
+void onSetCharacteristicPropertyResult(DBusMessage *msg, void *user, void *n) {
+    native_data_t *nat = (native_data_t *)n;
+    DBusError err;
+    uint8_t status;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    struct set_characteristic_property_t *prop = (set_characteristic_property_t *)user;
+
+    char *c_object_path;
+    bool result = JNI_TRUE;
+    if (dbus_set_error_from_message(&err, msg)) {
+        LOG_AND_FREE_DBUS_ERROR(&err);
+        result = JNI_FALSE;
+    }
+
+    jstring jPath = env->NewStringUTF(prop->path);
+    jstring jProperty = env->NewStringUTF(prop->property);
+    env->CallVoidMethod(nat->me,
+                        method_onSetCharacteristicPropertyResult,
+                        jPath,
+                        jProperty,
+                        result);
+    env->DeleteLocalRef(jPath);
+    env->DeleteLocalRef(jProperty);
+
+    free(prop->path);
+    free(prop->property);
+    free(user);
+}
+
+void onIndicateResponse(DBusMessage *msg, void *user, void *n) {
+    native_data_t *nat = (native_data_t *)n;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+    ALOGE("%s", __FUNCTION__);
+
+    struct set_indicate_info_t *prop = (set_indicate_info_t *)user;
+    bool result = JNI_TRUE;
+    if (dbus_set_error_from_message(&err, msg)) {
+        LOG_AND_FREE_DBUS_ERROR(&err);
+        result = JNI_FALSE;
+    }
+
+    jstring jPath = env->NewStringUTF(prop->path);
+    env->CallVoidMethod(nat->me,
+                        method_onIndicateResponse,
+                        jPath,
+                        result);
+    env->DeleteLocalRef(jPath);
+
+    free(prop->path);
+    free(user);
+}
+
+void onUpdateCharacteristicValueResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *path = (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    jbyte *char_val;
+    int char_vlen;
+    bool result = JNI_TRUE;
+
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    ALOGV("... GATT Characteristic Path = %s", path);
+
+    if (dbus_set_error_from_message(&err, msg)){
+        ALOGE("%s: D-Bus error: %s (%s)\n", __FUNCTION__, err.name, err.message);
+
+        LOG_AND_FREE_DBUS_ERROR(&err);
+        result = JNI_FALSE;
+    }
+
+    jstring jPath = env->NewStringUTF(path);
+    env->CallVoidMethod(nat->me,
+                        method_onUpdateCharacteristicValueResult,
+                        jPath,
+                        result);
+    env->DeleteLocalRef(jPath);
+    free(user);
+ }
+
+#endif
+
+static JNINativeMethod sMethods[] = {
+     /* name, signature, funcPtr */
+    {"classInitNative", "()V", (void *)classInitNative},
+    {"initializeNativeDataNative", "()V", (void *)initializeNativeDataNative},
+    {"cleanupNativeDataNative", "()V", (void *)cleanupNativeDataNative},
+    {"startEventLoopNative", "()V", (void *)startEventLoopNative},
+    {"stopEventLoopNative", "()V", (void *)stopEventLoopNative},
+    {"isEventLoopRunningNative", "()Z", (void *)isEventLoopRunningNative}
+};
+
+int register_android_server_BluetoothEventLoop(JNIEnv *env) {
+    return AndroidRuntime::registerNativeMethods(env,
+            "android/server/BluetoothEventLoop", sMethods, NELEM(sMethods));
+}
+
+} /* namespace android */
diff --git a/core/jni/bluetoothmsm/android_server_BluetoothService.cpp b/core/jni/bluetoothmsm/android_server_BluetoothService.cpp
new file mode 100644
index 0000000..7b7504e
--- /dev/null
+++ b/core/jni/bluetoothmsm/android_server_BluetoothService.cpp
@@ -0,0 +1,3812 @@
+/*
+** Copyright 2006, The Android Open Source Project
+** Copyright (c) 2012, The Linux Foundation. All rights reserved
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define DBUS_ADAPTER_IFACE BLUEZ_DBUS_BASE_IFC ".Adapter"
+#define DBUS_DEVICE_IFACE BLUEZ_DBUS_BASE_IFC ".Device"
+#define DBUS_INPUT_IFACE BLUEZ_DBUS_BASE_IFC ".Input"
+#define DBUS_NETWORK_IFACE BLUEZ_DBUS_BASE_IFC ".Network"
+#define DBUS_NETWORKSERVER_IFACE BLUEZ_DBUS_BASE_IFC ".NetworkServer"
+#define DBUS_HEALTH_MANAGER_PATH "/org/bluez"
+#define DBUS_HEALTH_MANAGER_IFACE BLUEZ_DBUS_BASE_IFC ".HealthManager"
+#define DBUS_HEALTH_DEVICE_IFACE BLUEZ_DBUS_BASE_IFC ".HealthDevice"
+#define DBUS_HEALTH_CHANNEL_IFACE BLUEZ_DBUS_BASE_IFC ".HealthChannel"
+#define DBUS_CHARACTERISTIC_IFACE BLUEZ_DBUS_BASE_IFC ".Characteristic"
+#define DBUS_GATT_SERVER_INTERFACE  BLUEZ_DBUS_BASE_IFC ".GattServer"
+
+#define LOG_TAG "BluetoothService.cpp"
+
+#include "android_bluetooth_common.h"
+#include "android_runtime/AndroidRuntime.h"
+#include "android_util_Binder.h"
+#include "JNIHelp.h"
+#include "jni.h"
+
+
+//#undef NDEBUG
+
+//#define LOG_NIDEBUG 0
+//#define LOG_NDEBUG 0
+//#define LOG_NDDEBUG 0
+
+#include "utils/Log.h"
+#include "utils/misc.h"
+
+#include <ctype.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <dbus/dbus.h>
+#include <bluedroid/bluetooth.h>
+#endif
+
+#include <cutils/properties.h>
+
+namespace android {
+
+#define BLUETOOTH_CLASS_ERROR 0xFF000000
+#define PROPERTIES_NREFS 10
+
+#ifdef HAVE_BLUETOOTH
+// We initialize these variables when we load class
+// android.server.BluetoothService
+static jfieldID field_mNativeData;
+static jfieldID field_mEventLoop;
+
+typedef struct {
+    JNIEnv *env;
+    DBusConnection *conn;
+    const char *adapter;  // dbus object name of the local adapter
+} native_data_t;
+
+extern event_loop_native_data_t *get_EventLoop_native_data(JNIEnv *,
+                                                           jobject);
+extern DBusHandlerResult agent_event_filter(DBusConnection *conn,
+                                            DBusMessage *msg,
+                                            void *data);
+void onCreatePairedDeviceResult(DBusMessage *msg, void *user, void *nat);
+void onDiscoverServicesResult(DBusMessage *msg, void *user, void *nat);
+void onCreateDeviceResult(DBusMessage *msg, void *user, void *nat);
+void onInputDeviceConnectionResult(DBusMessage *msg, void *user, void *nat);
+void onPanDeviceConnectionResult(DBusMessage *msg, void *user, void *nat);
+void onHealthDeviceConnectionResult(DBusMessage *msg, void *user, void *nat);
+void onDiscoverCharacteristicsResult(DBusMessage *msg, void *user, void *nat);
+void onSetCharacteristicPropertyResult(DBusMessage *msg, void *user, void *nat);
+void onUpdateCharacteristicValueResult(DBusMessage *msg, void *user, void *nat);
+void onIndicateResponse(DBusMessage *msg, void *user, void *nat);
+
+void onAddToPreferredDeviceListResult(DBusMessage *msg, void *user, void *nat);
+void onRemoveFromPreferredDeviceListResult(DBusMessage *msg, void *user, void *nat);
+void onClearPreferredDeviceListResult(DBusMessage *msg, void *user, void *nat);
+void onGattConnectToPreferredDeviceListResult(DBusMessage *msg, void *user, void *nat);
+void onGattCancelConnectToPreferredDeviceListResult(DBusMessage *msg, void *user, void *nat);
+
+
+/** Get native data stored in the opaque (Java code maintained) pointer mNativeData
+ *  Perform quick sanity check, if there are any problems return NULL
+ */
+static inline native_data_t * get_native_data(JNIEnv *env, jobject object) {
+    native_data_t *nat =
+            (native_data_t *)(env->GetIntField(object, field_mNativeData));
+    if (nat == NULL || nat->conn == NULL) {
+        ALOGE("Uninitialized native data\n");
+        return NULL;
+    }
+    return nat;
+}
+#endif
+
+static void classInitNative(JNIEnv* env, jclass clazz) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    field_mNativeData = get_field(env, clazz, "mNativeData", "I");
+    field_mEventLoop = get_field(env, clazz, "mEventLoop",
+            "Landroid/server/BluetoothEventLoop;");
+#endif
+}
+
+/* Returns true on success (even if adapter is present but disabled).
+ * Return false if dbus is down, or another serious error (out of memory)
+*/
+static bool initializeNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = (native_data_t *)calloc(1, sizeof(native_data_t));
+    if (NULL == nat) {
+        ALOGE("%s: out of memory!", __FUNCTION__);
+        return false;
+    }
+    nat->env = env;
+
+    env->SetIntField(object, field_mNativeData, (jint)nat);
+    DBusError err;
+    dbus_error_init(&err);
+    dbus_threads_init_default();
+    nat->conn = dbus_bus_get(DBUS_BUS_SYSTEM, &err);
+    if (dbus_error_is_set(&err)) {
+        ALOGE("Could not get onto the system bus: %s", err.message);
+        dbus_error_free(&err);
+        return false;
+    }
+    dbus_connection_set_exit_on_disconnect(nat->conn, FALSE);
+#endif  /*HAVE_BLUETOOTH*/
+    return true;
+}
+
+static const char *get_adapter_path(JNIEnv* env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    event_loop_native_data_t *event_nat =
+        get_EventLoop_native_data(env, env->GetObjectField(object,
+                                                           field_mEventLoop));
+    if (event_nat == NULL)
+        return NULL;
+    return event_nat->adapter;
+#else
+    return NULL;
+#endif
+}
+
+// This function is called when the adapter is enabled.
+static jboolean setupNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat =
+        (native_data_t *)env->GetIntField(object, field_mNativeData);
+    event_loop_native_data_t *event_nat =
+        get_EventLoop_native_data(env, env->GetObjectField(object,
+                                                           field_mEventLoop));
+    // Register agent for remote devices.
+    const char *device_agent_path = "/android/bluetooth/remote_device_agent";
+    static const DBusObjectPathVTable agent_vtable = {
+                 NULL, agent_event_filter, NULL, NULL, NULL, NULL };
+
+    if (!dbus_connection_register_object_path(nat->conn, device_agent_path,
+                                              &agent_vtable, event_nat)) {
+        ALOGE("%s: Can't register object path %s for remote device agent!",
+                               __FUNCTION__, device_agent_path);
+        return JNI_FALSE;
+    }
+#endif /*HAVE_BLUETOOTH*/
+    return JNI_TRUE;
+}
+
+static jboolean tearDownNativeDataNative(JNIEnv *env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat =
+               (native_data_t *)env->GetIntField(object, field_mNativeData);
+    if (nat != NULL) {
+        const char *device_agent_path =
+            "/android/bluetooth/remote_device_agent";
+        dbus_connection_unregister_object_path (nat->conn, device_agent_path);
+    }
+#endif /*HAVE_BLUETOOTH*/
+    return JNI_TRUE;
+}
+
+static void cleanupNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat =
+        (native_data_t *)env->GetIntField(object, field_mNativeData);
+    if (nat) {
+        free(nat);
+        nat = NULL;
+    }
+#endif
+}
+
+static jstring getAdapterPathNative(JNIEnv *env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        return (env->NewStringUTF(get_adapter_path(env, object)));
+    }
+#endif
+    return NULL;
+}
+
+
+static jboolean startDiscoveryNative(JNIEnv *env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+
+#ifdef HAVE_BLUETOOTH
+    DBusMessage *msg = NULL;
+    DBusMessage *reply = NULL;
+    DBusError err;
+    const char *name;
+    jboolean ret = JNI_FALSE;
+
+    native_data_t *nat = get_native_data(env, object);
+    if (nat == NULL) {
+        goto done;
+    }
+
+    dbus_error_init(&err);
+
+    /* Compose the command */
+    msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                       get_adapter_path(env, object),
+                                       DBUS_ADAPTER_IFACE, "StartDiscovery");
+
+    if (msg == NULL) {
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        }
+        goto done;
+    }
+
+    /* Send the command. */
+    reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+    if (dbus_error_is_set(&err)) {
+         LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+         ret = JNI_FALSE;
+         goto done;
+    }
+
+    ret = JNI_TRUE;
+done:
+    if (reply) dbus_message_unref(reply);
+    if (msg) dbus_message_unref(msg);
+    return ret;
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean stopDiscoveryNative(JNIEnv *env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    DBusMessage *msg = NULL;
+    DBusMessage *reply = NULL;
+    DBusError err;
+    const char *name;
+    native_data_t *nat;
+    jboolean ret = JNI_FALSE;
+
+    dbus_error_init(&err);
+
+    nat = get_native_data(env, object);
+    if (nat == NULL) {
+        goto done;
+    }
+
+    /* Compose the command */
+    msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                       get_adapter_path(env, object),
+                                       DBUS_ADAPTER_IFACE, "StopDiscovery");
+    if (msg == NULL) {
+        if (dbus_error_is_set(&err))
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto done;
+    }
+
+    /* Send the command. */
+    reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+    if (dbus_error_is_set(&err)) {
+        if(strncmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.NotAuthorized",
+                   strlen(BLUEZ_DBUS_BASE_IFC ".Error.NotAuthorized")) == 0) {
+            // hcid sends this if there is no active discovery to cancel
+            ALOGV("%s: There was no active discovery to cancel", __FUNCTION__);
+            dbus_error_free(&err);
+        } else {
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        }
+        goto done;
+    }
+
+    ret = JNI_TRUE;
+done:
+    if (msg) dbus_message_unref(msg);
+    if (reply) dbus_message_unref(reply);
+    return ret;
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jbyteArray readAdapterOutOfBandDataNative(JNIEnv *env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    DBusError err;
+    jbyte *hash, *randomizer;
+    jbyteArray byteArray = NULL;
+    int hash_len, r_len;
+    if (nat) {
+       DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           get_adapter_path(env, object),
+                           DBUS_ADAPTER_IFACE, "ReadLocalOutOfBandData",
+                           DBUS_TYPE_INVALID);
+       if (!reply) return NULL;
+
+       dbus_error_init(&err);
+       if (dbus_message_get_args(reply, &err,
+                                DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &hash, &hash_len,
+                                DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &randomizer, &r_len,
+                                DBUS_TYPE_INVALID)) {
+          if (hash_len == 16 && r_len == 16) {
+               byteArray = env->NewByteArray(32);
+               if (byteArray) {
+                   env->SetByteArrayRegion(byteArray, 0, 16, hash);
+                   env->SetByteArrayRegion(byteArray, 16, 16, randomizer);
+               }
+           } else {
+               ALOGE("readAdapterOutOfBandDataNative: Hash len = %d, R len = %d",
+                                                                  hash_len, r_len);
+           }
+       } else {
+          LOG_AND_FREE_DBUS_ERROR(&err);
+       }
+       dbus_message_unref(reply);
+       return byteArray;
+    }
+#endif
+    return NULL;
+}
+
+static jboolean createPairedDeviceNative(JNIEnv *env, jobject object,
+                                         jstring address, jint timeout_ms) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_address = env->GetStringUTFChars(address, NULL);
+        ALOGV("... address = %s", c_address);
+        char *context_address = (char *)calloc(BTADDR_SIZE, sizeof(char));
+        const char *capabilities = "KeyboardDisplay";
+        const char *agent_path = "/android/bluetooth/remote_device_agent";
+
+        strlcpy(context_address, c_address, BTADDR_SIZE);  // for callback
+        bool ret = dbus_func_args_async(env, nat->conn, (int)timeout_ms,
+                                        onCreatePairedDeviceResult, // callback
+                                        context_address,
+                                        eventLoopNat,
+                                        get_adapter_path(env, object),
+                                        DBUS_ADAPTER_IFACE,
+                                        "CreatePairedDevice",
+                                        DBUS_TYPE_STRING, &c_address,
+                                        DBUS_TYPE_OBJECT_PATH, &agent_path,
+                                        DBUS_TYPE_STRING, &capabilities,
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(address, c_address);
+        return ret ? JNI_TRUE : JNI_FALSE;
+
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean createPairedDeviceOutOfBandNative(JNIEnv *env, jobject object,
+                                                jstring address, jint timeout_ms) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_address = env->GetStringUTFChars(address, NULL);
+        ALOGV("... address = %s", c_address);
+        char *context_address = (char *)calloc(BTADDR_SIZE, sizeof(char));
+        const char *capabilities = "KeyboardDisplay";
+        const char *agent_path = "/android/bluetooth/remote_device_agent";
+
+        strlcpy(context_address, c_address, BTADDR_SIZE);  // for callback
+        bool ret = dbus_func_args_async(env, nat->conn, (int)timeout_ms,
+                                        onCreatePairedDeviceResult, // callback
+                                        context_address,
+                                        eventLoopNat,
+                                        get_adapter_path(env, object),
+                                        DBUS_ADAPTER_IFACE,
+                                        "CreatePairedDeviceOutOfBand",
+                                        DBUS_TYPE_STRING, &c_address,
+                                        DBUS_TYPE_OBJECT_PATH, &agent_path,
+                                        DBUS_TYPE_STRING, &capabilities,
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(address, c_address);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jint getDeviceServiceChannelNative(JNIEnv *env, jobject object,
+                                          jstring path,
+                                          jstring pattern, jint attr_id) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+    if (nat && eventLoopNat) {
+        const char *c_pattern = env->GetStringUTFChars(pattern, NULL);
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        ALOGV("... pattern = %s", c_pattern);
+        ALOGV("... attr_id = %#X", attr_id);
+        DBusMessage *reply =
+            dbus_func_args(env, nat->conn, c_path,
+                           DBUS_DEVICE_IFACE, "GetServiceAttributeValue",
+                           DBUS_TYPE_STRING, &c_pattern,
+                           DBUS_TYPE_UINT16, &attr_id,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(pattern, c_pattern);
+        env->ReleaseStringUTFChars(path, c_path);
+        return reply ? dbus_returns_int32(env, reply) : -1;
+    }
+#endif
+    return -1;
+}
+
+static jstring getDeviceStringAttrValue(JNIEnv *env, jobject object,
+                                          jstring path,
+                                          jstring pattern, jint attr_id) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s",__FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+    if (nat && eventLoopNat) {
+        const char *c_pattern = env->GetStringUTFChars(pattern, NULL);
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        ALOGV("... pattern = %s", c_pattern);
+        ALOGV("... attr_id = %#X", attr_id);
+        DBusMessage *reply =
+            dbus_func_args(env, nat->conn, c_path,
+                           DBUS_DEVICE_IFACE, "GetServiceAttributeValue",
+                           DBUS_TYPE_STRING, &c_pattern,
+                           DBUS_TYPE_UINT16, &attr_id,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(pattern, c_pattern);
+        env->ReleaseStringUTFChars(path, c_path);
+        return reply ? dbus_returns_string(env, reply) : NULL;
+    }
+#endif
+    return NULL;
+}
+
+static jboolean cancelDeviceCreationNative(JNIEnv *env, jobject object,
+                                           jstring address) {
+    ALOGV("%s", __FUNCTION__);
+    jboolean result = JNI_FALSE;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_address = env->GetStringUTFChars(address, NULL);
+        DBusError err;
+        dbus_error_init(&err);
+        ALOGV("... address = %s", c_address);
+        DBusMessage *reply =
+            dbus_func_args_timeout(env, nat->conn, -1,
+                                   get_adapter_path(env, object),
+                                   DBUS_ADAPTER_IFACE, "CancelDeviceCreation",
+                                   DBUS_TYPE_STRING, &c_address,
+                                   DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(address, c_address);
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else
+                ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return JNI_FALSE;
+        } else {
+            result = JNI_TRUE;
+        }
+        dbus_message_unref(reply);
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean removeDeviceNative(JNIEnv *env, jobject object, jstring object_path) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_object_path = env->GetStringUTFChars(object_path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        NULL,
+                                        NULL,
+                                        NULL,
+                                        get_adapter_path(env, object),
+                                        DBUS_ADAPTER_IFACE,
+                                        "RemoveDevice",
+                                        DBUS_TYPE_OBJECT_PATH, &c_object_path,
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(object_path, c_object_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jint enableNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    return bt_enable();
+#endif
+    return -1;
+}
+
+static jint disableNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    return bt_disable();
+#endif
+    return -1;
+}
+
+static jint isEnabledNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    return bt_is_enabled();
+#endif
+    return -1;
+}
+
+static jboolean setPairingConfirmationNative(JNIEnv *env, jobject object,
+                                             jstring address, bool confirm,
+                                             int nativeData) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        if (confirm) {
+            reply = dbus_message_new_method_return(msg);
+        } else {
+            reply = dbus_message_new_error(msg,
+                "org.bluez.Error.Rejected", "User rejected confirmation");
+        }
+
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply to RequestPasskeyConfirmation or"
+                  "RequestPairingConsent to D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setPasskeyNative(JNIEnv *env, jobject object, jstring address,
+                         int passkey, int nativeData) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply = dbus_message_new_method_return(msg);
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply to return Passkey code to "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_message_append_args(reply, DBUS_TYPE_UINT32, (uint32_t *)&passkey,
+                                 DBUS_TYPE_INVALID);
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setRemoteOutOfBandDataNative(JNIEnv *env, jobject object, jstring address,
+                         jbyteArray hash, jbyteArray randomizer, int nativeData) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply = dbus_message_new_method_return(msg);
+        jbyte *h_ptr = env->GetByteArrayElements(hash, NULL);
+        jbyte *r_ptr = env->GetByteArrayElements(randomizer, NULL);
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply to return remote OOB data to "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_message_append_args(reply,
+                                DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &h_ptr, 16,
+                                DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &r_ptr, 16,
+                                DBUS_TYPE_INVALID);
+
+        env->ReleaseByteArrayElements(hash, h_ptr, 0);
+        env->ReleaseByteArrayElements(randomizer, r_ptr, 0);
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setAuthorizationNative(JNIEnv *env, jobject object, jstring address,
+                         jboolean val, int nativeData) {
+#ifdef HAVE_BLUETOOTH
+  ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        if (val) {
+            reply = dbus_message_new_method_return(msg);
+        } else {
+            reply = dbus_message_new_error(msg,
+                    "org.bluez.Error.Rejected", "Authorization rejected");
+        }
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setPinNative(JNIEnv *env, jobject object, jstring address,
+                         jstring pin, int nativeData) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply = dbus_message_new_method_return(msg);
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply to return PIN code to "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        const char *c_pin = env->GetStringUTFChars(pin, NULL);
+
+        dbus_message_append_args(reply, DBUS_TYPE_STRING, &c_pin,
+                                 DBUS_TYPE_INVALID);
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        env->ReleaseStringUTFChars(pin, c_pin);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean sapAuthorizeNative(JNIEnv *env, jobject object, jstring address,
+                         jboolean access, int nativeData) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("sapAuthorizeNative %s %d", (char*)address, access);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        if (access) {
+            reply = dbus_message_new_method_return(msg);
+            if (!reply) {
+               ALOGE("%s: Cannot create message reply to authorize sap "
+                     "D-Bus\n", __FUNCTION__);
+                dbus_message_unref(msg);
+                return JNI_FALSE;
+            }
+        } else {
+            reply = dbus_message_new_error(msg,
+                    "org.bluez.Error.Rejected", "Authorization rejected");
+            if (!reply) {
+               ALOGE("%s: Cannot create message reply\n", __FUNCTION__);
+                return JNI_FALSE;
+            }
+
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean DUNAuthorizeNative(JNIEnv *env, jobject object, jstring address,
+                         jboolean access, int nativeData) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("DUNAuthorizeNative %s %d", (char*)address, access);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        if (access) {
+            reply = dbus_message_new_method_return(msg);
+            if (!reply) {
+                ALOGE("%s: Cannot create message reply to authorize DUN "
+                     "D-Bus\n", __FUNCTION__);
+                dbus_message_unref(msg);
+                return JNI_FALSE;
+            }
+        } else {
+            reply = dbus_message_new_error(msg,
+                    "org.bluez.Error.Rejected", "Authorization rejected");
+            if (!reply) {
+                ALOGE("%s: Cannot create message reply\n", __FUNCTION__);
+                return JNI_FALSE;
+            }
+
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+
+
+static jboolean cancelPairingUserInputNative(JNIEnv *env, jobject object,
+                                            jstring address, int nativeData) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply = dbus_message_new_error(msg,
+                "org.bluez.Error.Canceled", "Pairing User Input was canceled");
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply to return cancelUserInput to"
+                 "D-BUS\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jobjectArray getDevicePropertiesNative(JNIEnv *env, jobject object,
+                                                    jstring path)
+{
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        reply = dbus_func_args_timeout(env,
+                                   nat->conn, -1, c_path,
+                                   DBUS_DEVICE_IFACE, "GetProperties",
+                                   DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else
+                ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return NULL;
+        }
+        env->PushLocalFrame(PROPERTIES_NREFS);
+
+        DBusMessageIter iter;
+        jobjectArray str_array = NULL;
+        if (dbus_message_iter_init(reply, &iter))
+           str_array =  parse_remote_device_properties(env, &iter);
+        dbus_message_unref(reply);
+
+        return (jobjectArray) env->PopLocalFrame(str_array);
+    }
+#endif
+    return NULL;
+}
+
+static jobjectArray getAdapterPropertiesNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        reply = dbus_func_args_timeout(env,
+                                   nat->conn, -1, get_adapter_path(env, object),
+                                   DBUS_ADAPTER_IFACE, "GetProperties",
+                                   DBUS_TYPE_INVALID);
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else
+                ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return NULL;
+        }
+        env->PushLocalFrame(PROPERTIES_NREFS);
+
+        DBusMessageIter iter;
+        jobjectArray str_array = NULL;
+        if (dbus_message_iter_init(reply, &iter))
+            str_array = parse_adapter_properties(env, &iter);
+        dbus_message_unref(reply);
+
+        return (jobjectArray) env->PopLocalFrame(str_array);
+    }
+#endif
+    return NULL;
+}
+
+static jboolean setAdapterPropertyNative(JNIEnv *env, jobject object, jstring key,
+                                         void *value, jint type) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg;
+        DBusMessageIter iter;
+        dbus_bool_t reply = JNI_FALSE;
+        const char *c_key = env->GetStringUTFChars(key, NULL);
+
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                           get_adapter_path(env, object),
+                                           DBUS_ADAPTER_IFACE, "SetProperty");
+        if (!msg) {
+            ALOGE("%s: Can't allocate new method call for GetProperties!",
+                  __FUNCTION__);
+            env->ReleaseStringUTFChars(key, c_key);
+            return JNI_FALSE;
+        }
+
+        dbus_message_append_args(msg, DBUS_TYPE_STRING, &c_key, DBUS_TYPE_INVALID);
+        dbus_message_iter_init_append(msg, &iter);
+        append_variant(&iter, type, value);
+
+        // Asynchronous call - the callbacks come via propertyChange
+        reply = dbus_connection_send_with_reply(nat->conn, msg, NULL, -1);
+        dbus_message_unref(msg);
+
+        env->ReleaseStringUTFChars(key, c_key);
+        return reply ? JNI_TRUE : JNI_FALSE;
+
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setAdapterPropertyStringNative(JNIEnv *env, jobject object, jstring key,
+                                               jstring value) {
+#ifdef HAVE_BLUETOOTH
+    const char *c_value = env->GetStringUTFChars(value, NULL);
+    jboolean ret =  setAdapterPropertyNative(env, object, key, (void *)&c_value, DBUS_TYPE_STRING);
+    env->ReleaseStringUTFChars(value, (char *)c_value);
+    return ret;
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean setAdapterPropertyIntegerNative(JNIEnv *env, jobject object, jstring key,
+                                               jint value) {
+#ifdef HAVE_BLUETOOTH
+    return setAdapterPropertyNative(env, object, key, (void *)&value, DBUS_TYPE_UINT32);
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean setAdapterPropertyBooleanNative(JNIEnv *env, jobject object, jstring key,
+                                               jint value) {
+#ifdef HAVE_BLUETOOTH
+    return setAdapterPropertyNative(env, object, key, (void *)&value, DBUS_TYPE_BOOLEAN);
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean setDevicePropertyNative(JNIEnv *env, jobject object, jstring path,
+                                               jstring key, void *value, jint type) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg;
+        DBusMessageIter iter;
+        dbus_bool_t reply = JNI_FALSE;
+
+        const char *c_key = env->GetStringUTFChars(key, NULL);
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                          c_path, DBUS_DEVICE_IFACE, "SetProperty");
+        if (!msg) {
+            ALOGE("%s: Can't allocate new method call for device SetProperty!", __FUNCTION__);
+            env->ReleaseStringUTFChars(key, c_key);
+            env->ReleaseStringUTFChars(path, c_path);
+            return JNI_FALSE;
+        }
+
+        dbus_message_append_args(msg, DBUS_TYPE_STRING, &c_key, DBUS_TYPE_INVALID);
+        dbus_message_iter_init_append(msg, &iter);
+        append_variant(&iter, type, value);
+
+        // Asynchronous call - the callbacks come via Device propertyChange
+        reply = dbus_connection_send_with_reply(nat->conn, msg, NULL, -1);
+        dbus_message_unref(msg);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(key, c_key);
+
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setDevicePropertyBooleanNative(JNIEnv *env, jobject object,
+                                                     jstring path, jstring key, jint value) {
+#ifdef HAVE_BLUETOOTH
+    return setDevicePropertyNative(env, object, path, key,
+                                        (void *)&value, DBUS_TYPE_BOOLEAN);
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean setDevicePropertyStringNative(JNIEnv *env, jobject object,
+                                              jstring path, jstring key, jstring value) {
+#ifdef HAVE_BLUETOOTH
+    const char *c_value = env->GetStringUTFChars(value, NULL);
+    jboolean ret = setDevicePropertyNative(env, object, path, key,
+                                           (void *)&c_value, DBUS_TYPE_STRING);
+    env->ReleaseStringUTFChars(value, (char *)c_value);
+    return ret;
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean setDevicePropertyIntegerNative(JNIEnv *env, jobject object,
+                                                     jstring path, jstring key, jint value) {
+#ifdef HAVE_BLUETOOTH
+    return setDevicePropertyNative(env, object, path, key,
+                                        (void *)&value, DBUS_TYPE_UINT32);
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean updateLEConnectionParametersNative(JNIEnv *env, jobject object,
+                                              jstring path,
+                                              jint prohibitRemoteChg,
+                                              jint intervalMin,
+                                              jint interValMax,
+                                              jint slaveLatency,
+                                              jint supervisionTimeout) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply, *msg;
+        DBusMessageIter iter;
+        DBusError err;
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        dbus_error_init(&err);
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                          c_path, DBUS_DEVICE_IFACE, "UpdateLEConnectionParams");
+        if (!msg) {
+           ALOGE("%s: Can't allocate new method call for device UpdateLEConnectionParams!", __FUNCTION__);
+            env->ReleaseStringUTFChars(path, c_path);
+            return JNI_FALSE;
+        }
+
+        dbus_message_append_args(msg,
+                                 DBUS_TYPE_BYTE, &prohibitRemoteChg,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&intervalMin,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&interValMax,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&slaveLatency,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&supervisionTimeout,
+                                 DBUS_TYPE_INVALID);
+        dbus_message_iter_init_append(msg, &iter);
+
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+        dbus_message_unref(msg);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else
+           ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return JNI_FALSE;
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setLEConnectionParamNative(JNIEnv *env, jobject object,
+                                           jstring path,
+                                           jint prohibitRemoteChg,
+                                           jint filterPolicy,
+                                           jint scanInterval,
+                                           jint scanWindow,
+                                           jint intervalMin,
+                                           jint intervalMax,
+                                           jint latency,
+                                           jint superVisionTimeout,
+                                           jint minCeLen,
+                                           jint maxCeLen,
+                                           jint connTimeout) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply, *msg;
+        DBusMessageIter iter;
+        DBusError err;
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+       ALOGE("the dbus object path: %s", c_path);
+
+        dbus_error_init(&err);
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                          c_path, DBUS_DEVICE_IFACE, "SetLEConnectParams");
+        if (!msg) {
+           ALOGE("%s: Can't allocate new method call for device SetConnectionParams!", __FUNCTION__);
+            env->ReleaseStringUTFChars(path, c_path);
+            return JNI_FALSE;
+        }
+
+        dbus_message_append_args(msg,
+                                 DBUS_TYPE_BYTE, &prohibitRemoteChg,
+                                 DBUS_TYPE_BYTE, &filterPolicy,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&scanInterval,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&scanWindow,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&intervalMin,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&intervalMax,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&latency,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&superVisionTimeout,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&minCeLen,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&maxCeLen,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&connTimeout,
+                                 DBUS_TYPE_INVALID);
+        dbus_message_iter_init_append(msg, &iter);
+
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+        dbus_message_unref(msg);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else
+           ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return JNI_FALSE;
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean registerRssiUpdateWatcherNative(JNIEnv *env, jobject object,
+                                              jstring path,
+                                              jint rssiThreshold,
+                                              jint interval,
+                                              jboolean updateOnThreshExceed) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply, *msg;
+        DBusMessageIter iter;
+        DBusError err;
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        dbus_error_init(&err);
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                           c_path, DBUS_DEVICE_IFACE,
+                                           "RegisterRssiUpdateWatcher");
+        if (!msg) {
+           ALOGE("%s: Can't allocate new method call", __FUNCTION__);
+            env->ReleaseStringUTFChars(path, c_path);
+            return JNI_FALSE;
+        }
+
+        dbus_message_append_args(msg, DBUS_TYPE_INT16, (int16_t *)&rssiThreshold,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&interval,
+                                 DBUS_TYPE_BOOLEAN, &updateOnThreshExceed,
+                                 DBUS_TYPE_INVALID);
+        dbus_message_iter_init_append(msg, &iter);
+
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+        dbus_message_unref(msg);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else
+           ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return JNI_FALSE;
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean unregisterRssiUpdateWatcherNative(JNIEnv *env, jobject object,
+                                              jstring path) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply, *msg;
+        DBusMessageIter iter;
+        DBusError err;
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        dbus_error_init(&err);
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                          c_path, DBUS_DEVICE_IFACE,
+                                          "UnregisterRssiUpdateWatcher");
+        if (!msg) {
+           ALOGE("%s: Can't allocate new method call", __FUNCTION__);
+            env->ReleaseStringUTFChars(path, c_path);
+            return JNI_FALSE;
+        }
+
+        dbus_message_iter_init_append(msg, &iter);
+
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+        dbus_message_unref(msg);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else
+           ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return JNI_FALSE;
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean createDeviceNative(JNIEnv *env, jobject object,
+                                                jstring address) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_address = env->GetStringUTFChars(address, NULL);
+        ALOGV("... address = %s", c_address);
+        char *context_address = (char *)calloc(BTADDR_SIZE, sizeof(char));
+        strlcpy(context_address, c_address, BTADDR_SIZE);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onCreateDeviceResult,
+                                        context_address,
+                                        eventLoopNat,
+                                        get_adapter_path(env, object),
+                                        DBUS_ADAPTER_IFACE,
+                                        "CreateDevice",
+                                        DBUS_TYPE_STRING, &c_address,
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(address, c_address);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean addToPreferredDeviceListNative(JNIEnv *env, jobject object,
+                                                jstring path) {
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        void *c_var;
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        if (context_path != NULL) {
+            strlcpy(context_path, c_path, len);  // for callback
+        } else {
+            return JNI_FALSE;
+        }
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onAddToPreferredDeviceListResult,
+                                        context_path,
+                                        eventLoopNat,
+                                        c_path,
+                                        DBUS_DEVICE_IFACE,
+                                        "AddToWhiteList",
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean removeFromPreferredDeviceListNative(JNIEnv *env, jobject object,
+                                                jstring path) {
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        void *c_var;
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        if (context_path != NULL) {
+            strlcpy(context_path, c_path, len);  // for callback
+        } else {
+            return JNI_FALSE;
+        }
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onRemoveFromPreferredDeviceListResult,
+                                        context_path,
+                                        eventLoopNat,
+                                        c_path,
+                                        DBUS_DEVICE_IFACE,
+                                        "RemoveFromWhiteList",
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean clearPreferredDeviceListNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        char *context_path = NULL;
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onClearPreferredDeviceListResult,
+                                        context_path,
+                                        eventLoopNat,
+                                        get_adapter_path(env, object),
+                                        DBUS_ADAPTER_IFACE,
+                                        "ClearLeWhiteList",
+                                        DBUS_TYPE_INVALID);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean gattConnectToPreferredDeviceListNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        char *context_path = NULL;
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onGattConnectToPreferredDeviceListResult,
+                                        context_path,
+                                        eventLoopNat,
+                                        get_adapter_path(env, object),
+                                        DBUS_ADAPTER_IFACE,
+                                        "CreateLeConnWhiteList",
+                                        DBUS_TYPE_INVALID);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean gattCancelConnectToPreferredDeviceListNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        char *context_path = NULL;
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onGattCancelConnectToPreferredDeviceListResult,
+                                        context_path,
+                                        eventLoopNat,
+                                        get_adapter_path(env, object),
+                                        DBUS_ADAPTER_IFACE,
+                                        "CancelCreateLeConnWhiteList",
+                                        DBUS_TYPE_INVALID);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+
+static jboolean discoverServicesNative(JNIEnv *env, jobject object,
+                                               jstring path, jstring pattern) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        const char *c_pattern = env->GetStringUTFChars(pattern, NULL);
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        ALOGV("... Object Path = %s", c_path);
+        ALOGV("... Pattern = %s, strlen = %d", c_pattern, strlen(c_pattern));
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onDiscoverServicesResult,
+                                        context_path,
+                                        eventLoopNat,
+                                        c_path,
+                                        DBUS_DEVICE_IFACE,
+                                        "DiscoverServices",
+                                        DBUS_TYPE_STRING, &c_pattern,
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(pattern, c_pattern);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+#ifdef HAVE_BLUETOOTH
+static jintArray extract_handles(JNIEnv *env, DBusMessage *reply) {
+    jint *handles;
+    jintArray handleArray = NULL;
+    int len;
+
+    DBusError err;
+    dbus_error_init(&err);
+
+    if (dbus_message_get_args(reply, &err,
+                              DBUS_TYPE_ARRAY, DBUS_TYPE_UINT32, &handles, &len,
+                              DBUS_TYPE_INVALID)) {
+        handleArray = env->NewIntArray(len);
+        if (handleArray) {
+            env->SetIntArrayRegion(handleArray, 0, len, handles);
+        } else {
+            ALOGE("Null array in extract_handles");
+        }
+    } else {
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+    return handleArray;
+}
+#endif
+
+static jintArray addReservedServiceRecordsNative(JNIEnv *env, jobject object,
+                                                jintArray uuids) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    DBusMessage *reply = NULL;
+
+    native_data_t *nat = get_native_data(env, object);
+
+    jint* svc_classes = env->GetIntArrayElements(uuids, NULL);
+    if (!svc_classes) return NULL;
+
+    int len = env->GetArrayLength(uuids);
+    reply = dbus_func_args(env, nat->conn,
+                            get_adapter_path(env, object),
+                            DBUS_ADAPTER_IFACE, "AddReservedServiceRecords",
+                            DBUS_TYPE_ARRAY, DBUS_TYPE_UINT32,
+                            &svc_classes, len, DBUS_TYPE_INVALID);
+    env->ReleaseIntArrayElements(uuids, svc_classes, 0);
+    return reply ? extract_handles(env, reply) : NULL;
+
+#endif
+    return NULL;
+}
+
+static jboolean removeReservedServiceRecordsNative(JNIEnv *env, jobject object,
+                                                   jintArray handles) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jint *values = env->GetIntArrayElements(handles, NULL);
+    DBusMessage *msg = NULL;
+    DBusMessage *reply = NULL;
+    if (values == NULL) return JNI_FALSE;
+
+    jsize len = env->GetArrayLength(handles);
+
+    reply = dbus_func_args(env, nat->conn,
+                            get_adapter_path(env, object),
+                            DBUS_ADAPTER_IFACE, "RemoveReservedServiceRecords",
+                            DBUS_TYPE_ARRAY, DBUS_TYPE_UINT32,
+                            &values, len, DBUS_TYPE_INVALID);
+    env->ReleaseIntArrayElements(handles, values, 0);
+    return reply ? JNI_TRUE : JNI_FALSE;
+#endif
+    return JNI_FALSE;
+}
+
+static jstring findDeviceNative(JNIEnv *env, jobject object,
+                                jstring address) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+    if (nat && eventLoopNat) {
+        const char *c_address = env->GetStringUTFChars(address, NULL);
+        ALOGV("... address = %s", c_address);
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           get_adapter_path(env, object),
+                           DBUS_ADAPTER_IFACE, "FindDevice",
+                           DBUS_TYPE_STRING, &c_address,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(address, c_address);
+        if (reply == NULL) {
+            return NULL;
+        }
+        char *object_path = NULL;
+        if (dbus_message_get_args(reply, NULL,
+                                  DBUS_TYPE_OBJECT_PATH, &object_path,
+                                  DBUS_TYPE_INVALID)) {
+            return (jstring) env->NewStringUTF(object_path);
+        }
+     }
+#endif
+       return NULL;
+}
+
+static jint addRfcommServiceRecordNative(JNIEnv *env, jobject object,
+        jstring name, jlong uuidMsb, jlong uuidLsb, jshort channel) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_name = env->GetStringUTFChars(name, NULL);
+        ALOGV("... name = %s", c_name);
+        ALOGV("... uuid1 = %llX", uuidMsb);
+        ALOGV("... uuid2 = %llX", uuidLsb);
+        ALOGV("... channel = %d", channel);
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           get_adapter_path(env, object),
+                           DBUS_ADAPTER_IFACE, "AddRfcommServiceRecord",
+                           DBUS_TYPE_STRING, &c_name,
+                           DBUS_TYPE_UINT64, &uuidMsb,
+                           DBUS_TYPE_UINT64, &uuidLsb,
+                           DBUS_TYPE_UINT16, &channel,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(name, c_name);
+        return reply ? dbus_returns_uint32(env, reply) : -1;
+    }
+#endif
+    return -1;
+}
+
+static jboolean removeServiceRecordNative(JNIEnv *env, jobject object, jint handle) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        ALOGV("... handle = %X", handle);
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           get_adapter_path(env, object),
+                           DBUS_ADAPTER_IFACE, "RemoveServiceRecord",
+                           DBUS_TYPE_UINT32, &handle,
+                           DBUS_TYPE_INVALID);
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setLinkTimeoutNative(JNIEnv *env, jobject object, jstring object_path,
+                                     jint num_slots) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_object_path = env->GetStringUTFChars(object_path, NULL);
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           get_adapter_path(env, object),
+                           DBUS_ADAPTER_IFACE, "SetLinkTimeout",
+                           DBUS_TYPE_OBJECT_PATH, &c_object_path,
+                           DBUS_TYPE_UINT32, &num_slots,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(object_path, c_object_path);
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean connectInputDeviceNative(JNIEnv *env, jobject object, jstring path) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onInputDeviceConnectionResult,
+                                        context_path, eventLoopNat, c_path, DBUS_INPUT_IFACE,
+                                        "Connect",
+                                        DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean disconnectInputDeviceNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        if (context_path != NULL) {
+            strlcpy(context_path, c_path, len);  // for callback
+        } else {
+            return JNI_FALSE;
+        }
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onInputDeviceConnectionResult,
+                                        context_path, eventLoopNat, c_path, DBUS_INPUT_IFACE,
+                                        "Disconnect",
+                                        DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setBluetoothTetheringNative(JNIEnv *env, jobject object, jboolean value,
+                                            jstring src_role, jstring bridge) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply;
+        const char *c_role = env->GetStringUTFChars(src_role, NULL);
+        const char *c_bridge = env->GetStringUTFChars(bridge, NULL);
+        if (value) {
+            ALOGE("setBluetoothTetheringNative true");
+            reply = dbus_func_args(env, nat->conn,
+                                  get_adapter_path(env, object),
+                                  DBUS_NETWORKSERVER_IFACE,
+                                  "Register",
+                                  DBUS_TYPE_STRING, &c_role,
+                                  DBUS_TYPE_STRING, &c_bridge,
+                                  DBUS_TYPE_INVALID);
+        } else {
+            ALOGE("setBluetoothTetheringNative false");
+            reply = dbus_func_args(env, nat->conn,
+                                  get_adapter_path(env, object),
+                                  DBUS_NETWORKSERVER_IFACE,
+                                  "Unregister",
+                                  DBUS_TYPE_STRING, &c_role,
+                                  DBUS_TYPE_INVALID);
+        }
+        env->ReleaseStringUTFChars(src_role, c_role);
+        env->ReleaseStringUTFChars(bridge, c_bridge);
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean connectPanDeviceNative(JNIEnv *env, jobject object, jstring path,
+                                       jstring dstRole) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    ALOGE("connectPanDeviceNative");
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        const char *dst = env->GetStringUTFChars(dstRole, NULL);
+
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,onPanDeviceConnectionResult,
+                                    context_path, eventLoopNat, c_path,
+                                    DBUS_NETWORK_IFACE, "Connect",
+                                    DBUS_TYPE_STRING, &dst,
+                                    DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(dstRole, dst);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean disconnectPanDeviceNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    ALOGE("disconnectPanDeviceNative");
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,onPanDeviceConnectionResult,
+                                        context_path, eventLoopNat, c_path,
+                                        DBUS_NETWORK_IFACE, "Disconnect",
+                                        DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean disconnectPanServerDeviceNative(JNIEnv *env, jobject object,
+                                                jstring path, jstring address,
+                                                jstring iface) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    ALOGE("disconnectPanServerDeviceNative");
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_address = env->GetStringUTFChars(address, NULL);
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        const char *c_iface = env->GetStringUTFChars(iface, NULL);
+
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onPanDeviceConnectionResult,
+                                        context_path, eventLoopNat,
+                                        get_adapter_path(env, object),
+                                        DBUS_NETWORKSERVER_IFACE,
+                                        "DisconnectDevice",
+                                        DBUS_TYPE_STRING, &c_address,
+                                        DBUS_TYPE_STRING, &c_iface,
+                                        DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(address, c_address);
+        env->ReleaseStringUTFChars(iface, c_iface);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jstring registerHealthApplicationNative(JNIEnv *env, jobject object,
+                                           jint dataType, jstring role,
+                                           jstring name, jstring channelType) {
+    ALOGV("%s", __FUNCTION__);
+    jstring path = NULL;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_role = env->GetStringUTFChars(role, NULL);
+        const char *c_name = env->GetStringUTFChars(name, NULL);
+        const char *c_channel_type = env->GetStringUTFChars(channelType, NULL);
+        char *c_path;
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                            DBUS_HEALTH_MANAGER_PATH,
+                                            DBUS_HEALTH_MANAGER_IFACE,
+                                            "CreateApplication");
+
+        if (msg == NULL) {
+            ALOGE("Could not allocate D-Bus message object!");
+            return NULL;
+        }
+
+        /* append arguments */
+        append_dict_args(msg,
+                         "DataType", DBUS_TYPE_UINT16, &dataType,
+                         "Role", DBUS_TYPE_STRING, &c_role,
+                         "Description", DBUS_TYPE_STRING, &c_name,
+                         "ChannelType", DBUS_TYPE_STRING, &c_channel_type,
+                         DBUS_TYPE_INVALID);
+
+
+        /* Make the call. */
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+
+        env->ReleaseStringUTFChars(role, c_role);
+        env->ReleaseStringUTFChars(name, c_name);
+        env->ReleaseStringUTFChars(channelType, c_channel_type);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+        } else {
+            if (!dbus_message_get_args(reply, &err,
+                                      DBUS_TYPE_OBJECT_PATH, &c_path,
+                                      DBUS_TYPE_INVALID)) {
+                if (dbus_error_is_set(&err)) {
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                }
+            } else {
+               path = env->NewStringUTF(c_path);
+            }
+            dbus_message_unref(reply);
+        }
+    }
+#endif
+    return path;
+}
+
+static jboolean discoverPrimaryServicesNative(JNIEnv *env, jobject object,
+                                jstring path) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        DBusError err;
+
+        dbus_error_init(&err);
+
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           c_path,
+                           DBUS_DEVICE_IFACE, "LeDiscoverPrimaryServices",
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        if (!reply) {
+            if (dbus_error_is_set(&err))
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        return JNI_TRUE;
+     }
+#endif
+       return JNI_FALSE;
+}
+
+static jstring createLeDeviceNative(JNIEnv *env, jobject object,
+                                jstring address) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+    if (nat && eventLoopNat) {
+        const char *c_address = env->GetStringUTFChars(address, NULL);
+        ALOGV("... address = %s", c_address);
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           get_adapter_path(env, object),
+                           DBUS_ADAPTER_IFACE, "CreateLeDevice",
+                           DBUS_TYPE_STRING, &c_address,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(address, c_address);
+        if (reply == NULL) {
+            return NULL;
+        }
+        char *object_path = NULL;
+        if (dbus_message_get_args(reply, NULL,
+                                  DBUS_TYPE_OBJECT_PATH, &object_path,
+                                  DBUS_TYPE_INVALID)) {
+            return (jstring) env->NewStringUTF(object_path);
+        }
+     }
+#endif
+       return NULL;
+}
+
+static jobjectArray getGattServersNative(JNIEnv *env, jobject object) {
+   ALOGE("%s", __FUNCTION__);
+    jobjectArray strArray = NULL;
+
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_name = FRAMEWORKS_BASE_IFC;
+        const char *c_obj_path;
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                           get_adapter_path(env, object),
+                                           DBUS_GATT_SERVER_INTERFACE,
+                                           "GetRegisteredServers");
+        if (msg == NULL) {
+           ALOGE("%s Could not allocate D-Bus message object!",  __FUNCTION__);
+            return NULL;
+        }
+
+        /* Make the call. */
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err))
+                LOG_AND_FREE_DBUS_ERROR(&err);
+        } else {
+            strArray = dbus_returns_array_of_object_path(env, reply);
+        }
+    }
+#endif
+    return strArray;
+}
+
+static jboolean registerGattServerNative(JNIEnv *env, jobject object,
+                                         jstring objPath, jint handleCount,
+                                         jboolean isNew) {
+   ALOGV("%s", __FUNCTION__);
+    jboolean result = JNI_FALSE;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_name = FRAMEWORKS_BASE_IFC;
+        const char *c_obj_path;
+        const char *c_restriction = "None";
+        DBusMessage *msg, *reply;
+        DBusError err;
+        event_loop_native_data_t *event_nat;
+
+        if (isNew) {
+            dbus_error_init(&err);
+
+            msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                               get_adapter_path(env, object),
+                                               DBUS_GATT_SERVER_INTERFACE,
+                                               "RegisterServer");
+
+            if (msg == NULL) {
+               ALOGE("Could not allocate D-Bus message object!");
+                return JNI_FALSE;
+            }
+        }
+
+        c_obj_path = env->GetStringUTFChars(objPath, NULL);
+
+        if (isNew) {
+            /* Append arguments */
+            dbus_message_append_args(msg,
+                                     DBUS_TYPE_STRING, &c_name,
+                                     DBUS_TYPE_OBJECT_PATH, &c_obj_path,
+                                     DBUS_TYPE_UINT16, &handleCount,
+                                     DBUS_TYPE_STRING, &c_restriction,
+                                     DBUS_TYPE_INVALID);
+
+            /* Make the call. */
+            reply = dbus_connection_send_with_reply_and_block(
+                                         nat->conn, msg, -1, &err);
+
+            if (!reply) {
+                if (dbus_error_is_set(&err))
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                env->ReleaseStringUTFChars(objPath, c_obj_path);
+                return JNI_FALSE;
+            }
+        }
+
+        event_nat = get_EventLoop_native_data(env,
+                                   env->GetObjectField(object, field_mEventLoop));
+        if(register_gatt_path(event_nat, c_obj_path)) {
+           ALOGE("%s: register_gatt_path failed!", __FUNCTION__);
+            result = JNI_FALSE;
+        } else {
+            result = JNI_TRUE;
+        }
+        env->ReleaseStringUTFChars(objPath, c_obj_path);
+    }
+#endif
+    return result;
+}
+
+static jboolean notifyNative(JNIEnv *env, jobject object,
+                             jstring objPath, jint sessionHandle,
+                             jint handle, jbyteArray payload,
+                             jint cnt) {
+   ALOGV("%s", __FUNCTION__);
+    jboolean result = JNI_FALSE;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_obj_path = env->GetStringUTFChars(objPath, NULL);
+        DBusMessage *msg, *reply;
+        DBusError err;
+        jbyte *payload_ptr = env->GetByteArrayElements(payload, NULL);
+        dbus_error_init(&err);
+
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                            get_adapter_path(env, object),
+                                            DBUS_GATT_SERVER_INTERFACE,
+                                            "Notify");
+
+        if (msg == NULL) {
+           ALOGE("Could not allocate D-Bus message object!");
+            return NULL;
+        }
+
+        /* append arguments */
+        dbus_message_append_args(msg,
+                                 DBUS_TYPE_OBJECT_PATH, &c_obj_path,
+                                 DBUS_TYPE_UINT32, &sessionHandle,
+                                 DBUS_TYPE_UINT16, &handle,
+                                 DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &payload_ptr, cnt,
+                                 DBUS_TYPE_INVALID);
+
+        /* Make the call. */
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+
+        env->ReleaseStringUTFChars(objPath, c_obj_path);
+        env->ReleaseByteArrayElements(payload, payload_ptr, 0);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+        } else {
+            result = JNI_TRUE;
+        }
+    }
+#endif
+    return result;
+}
+
+static jboolean indicateNative(JNIEnv *env, jobject object,
+                               jstring objPath, jint sessionHandle,
+                               jint handle, jbyteArray payload,
+                               jint cnt) {
+   ALOGV("%s", __FUNCTION__);
+    jboolean result = JNI_FALSE;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_async_call_t *pending;
+        dbus_bool_t ret = FALSE;
+
+        const char *c_obj_path = env->GetStringUTFChars(objPath, NULL);
+
+        int len = env->GetStringLength(objPath) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_obj_path, len);  // for callback
+
+        jbyte *payload_ptr = env->GetByteArrayElements(payload, NULL);
+        dbus_error_init(&err);
+
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                            get_adapter_path(env, object),
+                                            DBUS_GATT_SERVER_INTERFACE,
+                                            "Indicate");
+
+        if (msg == NULL) {
+           ALOGE("Could not allocate D-Bus message object!");
+            return NULL;
+        }
+
+        /* append arguments */
+        dbus_message_append_args(msg,
+                                 DBUS_TYPE_OBJECT_PATH, &c_obj_path,
+                                 DBUS_TYPE_UINT32, &sessionHandle,
+                                 DBUS_TYPE_UINT16, &handle,
+                                 DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &payload_ptr, cnt,
+                                 DBUS_TYPE_INVALID);
+        // Setup the callback info
+        struct set_indicate_info_t *prop;
+        prop = (set_indicate_info_t *) calloc(1, sizeof(struct set_indicate_info_t));
+
+        prop->path = (char *)calloc(strlen(c_obj_path) + 1, sizeof(char));
+        strlcpy(prop->path, c_obj_path, strlen(c_obj_path) + 1);
+
+        /* Make the call. */
+        pending = (dbus_async_call_t *)malloc(sizeof(dbus_async_call_t));
+
+        if (!pending) {
+           ALOGE("!pending");
+            return JNI_FALSE;
+        }
+
+        DBusPendingCall *call;
+
+        pending->env = env;
+        pending->user_cb = onIndicateResponse;
+        pending->user = prop;
+        pending->nat = eventLoopNat;
+
+        ret = dbus_connection_send_with_reply(nat->conn, msg,
+                                                    &call,
+                                                    -1);
+
+       if (ret == TRUE)
+            dbus_pending_call_set_notify(call,
+                                         dbus_func_args_async_callback,
+                                         pending,
+                                         NULL);
+
+       if (!ret) {
+           if (dbus_error_is_set(&err)) {
+           LOG_AND_FREE_DBUS_ERROR(&err);
+           }
+       }
+
+       env->ReleaseStringUTFChars(objPath, c_obj_path);
+       env->ReleaseByteArrayElements(payload, payload_ptr, 0);
+
+       return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+   return JNI_FALSE;
+}
+
+static jboolean discoverPrimaryResponseNative(JNIEnv *env, jobject object,
+                                              jstring uuid,
+                                              jstring errorString,
+                                              jint handle,
+                                              jint end,
+                                              int nativeData) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        jboolean isCopy;
+        const char *c_uuid;
+
+        if (!errorString) {
+            reply = dbus_message_new_method_return(msg);
+            c_uuid = env->GetStringUTFChars(uuid, &isCopy);
+            dbus_message_append_args(reply,
+                                 DBUS_TYPE_UINT16, &handle,
+                                 DBUS_TYPE_UINT16, &end,
+                                 DBUS_TYPE_STRING, &c_uuid,
+                                 DBUS_TYPE_INVALID);
+        } else {
+            const char *c_errorString = env->GetStringUTFChars(errorString, NULL);
+           ALOGE("%s: status %s", __FUNCTION__, c_errorString);
+            reply = dbus_message_new_error(msg,
+                    DBUS_ERROR_FAILED, c_errorString);
+            env->ReleaseStringUTFChars(errorString, c_errorString);
+        }
+
+        if (!reply) {
+           ALOGE("%s: Cannot create message reply to "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        if (isCopy == JNI_TRUE) {
+            env->ReleaseStringUTFChars(uuid, c_uuid);
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean discoverPrimaryByUuidResponseNative(JNIEnv *env, jobject object,
+                                              jstring errorString,
+                                              jint handle,
+                                              jint end,
+                                              int nativeData) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+
+        if (!errorString) {
+            reply = dbus_message_new_method_return(msg);
+            dbus_message_append_args(reply,
+                                 DBUS_TYPE_UINT16, &handle,
+                                 DBUS_TYPE_UINT16, &end,
+                                 DBUS_TYPE_INVALID);
+        } else {
+            const char *c_errorString = env->GetStringUTFChars(errorString, NULL);
+           ALOGE("%s: status %s", __FUNCTION__, c_errorString);
+            reply = dbus_message_new_error(msg,
+                    DBUS_ERROR_FAILED, c_errorString);
+            env->ReleaseStringUTFChars(errorString, c_errorString);
+        }
+
+        if (!reply) {
+           ALOGE("%s: Cannot create message reply to "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean findIncludedResponseNative(JNIEnv *env, jobject object,
+                                           jstring uuid,
+                                           jstring errorString,
+                                           jint handle,
+                                           jint start,
+                                           jint end,
+                                           int nativeData) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        jboolean isCopy;
+        const char *c_uuid;
+
+        if (!errorString) {
+            reply = dbus_message_new_method_return(msg);
+            c_uuid = env->GetStringUTFChars(uuid, &isCopy);
+
+            dbus_message_append_args(reply,
+                                 DBUS_TYPE_UINT16, &handle,
+                                 DBUS_TYPE_UINT16, &start,
+                                 DBUS_TYPE_UINT16, &end,
+                                 DBUS_TYPE_STRING, &c_uuid,
+                                 DBUS_TYPE_INVALID);
+        } else {
+            const char *c_errorString = env->GetStringUTFChars(errorString, NULL);
+           ALOGE("%s: status %s", __FUNCTION__, c_errorString);
+            reply = dbus_message_new_error(msg,
+                    DBUS_ERROR_FAILED, c_errorString);
+            env->ReleaseStringUTFChars(errorString, c_errorString);
+        }
+
+        if (!reply) {
+           ALOGE("%s: Cannot create message reply to "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        if (isCopy == JNI_TRUE) {
+            env->ReleaseStringUTFChars(uuid, c_uuid);
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean discoverCharacteristicsResponseNative(JNIEnv *env, jobject object,
+                                           jstring uuid,
+                                           jstring errorString,
+                                           jint handle,
+                                           jint property,
+                                           jint valueHandle,
+                                           int nativeData) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        jboolean isCopy;
+        const char *c_uuid;
+
+        if (!errorString) {
+            reply = dbus_message_new_method_return(msg);
+            c_uuid = env->GetStringUTFChars(uuid, &isCopy);
+            dbus_message_append_args(reply,
+                                 DBUS_TYPE_UINT16, &handle,
+                                 DBUS_TYPE_BYTE, &property,
+                                 DBUS_TYPE_UINT16, &valueHandle,
+                                 DBUS_TYPE_STRING, &c_uuid,
+                                 DBUS_TYPE_INVALID);
+        } else {
+            const char *c_errorString = env->GetStringUTFChars(errorString, NULL);
+           ALOGE("%s: status %s", __FUNCTION__, c_errorString);
+            reply = dbus_message_new_error(msg,
+                    DBUS_ERROR_FAILED, c_errorString);
+            env->ReleaseStringUTFChars(errorString, c_errorString);
+        }
+
+        if (!reply) {
+           ALOGE("%s: Cannot create message reply to "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        if (isCopy == JNI_TRUE) {
+            env->ReleaseStringUTFChars(uuid, c_uuid);
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean findInfoResponseNative(JNIEnv *env, jobject object,
+                                       jstring uuid,
+                                       jstring errorString,
+                                       jint handle,
+                                       int nativeData) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        jboolean isCopy;
+        const char *c_uuid;
+
+        if (!errorString) {
+            reply = dbus_message_new_method_return(msg);
+            c_uuid = env->GetStringUTFChars(uuid, &isCopy);
+            dbus_message_append_args(reply,
+                                 DBUS_TYPE_UINT16, &handle,
+                                 DBUS_TYPE_STRING, &c_uuid,
+                                 DBUS_TYPE_INVALID);
+        } else {
+            const char *c_errorString = env->GetStringUTFChars(errorString, NULL);
+           ALOGE("%s: status %s", __FUNCTION__, c_errorString);
+            reply = dbus_message_new_error(msg,
+                    DBUS_ERROR_FAILED, c_errorString);
+            env->ReleaseStringUTFChars(errorString, c_errorString);
+        }
+
+        if (!reply) {
+           ALOGE("%s: Cannot create message reply to "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        if (isCopy == JNI_TRUE) {
+            env->ReleaseStringUTFChars(uuid, c_uuid);
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean readByTypeResponseNative(JNIEnv *env, jobject object,
+                                         jstring uuid,
+                                         jstring errorString,
+                                         jint handle,
+                                         jbyteArray payload,
+                                         jint cnt,
+                                         int nativeData) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        jboolean isCopy;
+        jbyte *payload_ptr;
+
+        if (!errorString) {
+            reply = dbus_message_new_method_return(msg);
+            payload_ptr = env->GetByteArrayElements(payload, &isCopy);
+            dbus_message_append_args(reply,
+                                 DBUS_TYPE_UINT16, &handle,
+                                 DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &payload_ptr, cnt,
+                                 DBUS_TYPE_INVALID);
+        } else {
+            const char *c_errorString = env->GetStringUTFChars(errorString, NULL);
+           ALOGE("%s: status %s", __FUNCTION__, c_errorString);
+            reply = dbus_message_new_error(msg,
+                    DBUS_ERROR_FAILED, c_errorString);
+            env->ReleaseStringUTFChars(errorString, c_errorString);
+        }
+
+        if (!reply) {
+           ALOGE("%s: Cannot create message reply to "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        if (isCopy == JNI_TRUE) {
+           env->ReleaseByteArrayElements(payload, payload_ptr, 0);
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean readResponseNative(JNIEnv *env, jobject object,
+                                   jstring uuid,
+                                   jstring errorString,
+                                   jbyteArray payload,
+                                   jint cnt,
+                                   int nativeData) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        jboolean isUuidCopy;
+        jboolean isCopy = JNI_FALSE;
+        jbyte *payload_ptr = NULL;
+        const char *c_uuid = NULL;
+
+        if (!errorString) {
+            reply = dbus_message_new_method_return(msg);
+            if (payload != NULL)
+                payload_ptr = env->GetByteArrayElements(payload, &isCopy);
+            if(uuid != NULL)
+                c_uuid = env->GetStringUTFChars(uuid, &isUuidCopy);
+            dbus_message_append_args(reply,
+                                 DBUS_TYPE_STRING, &c_uuid,
+                                 DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &payload_ptr, cnt,
+                                 DBUS_TYPE_INVALID);
+        } else {
+            const char *c_errorString = env->GetStringUTFChars(errorString, NULL);
+           ALOGE("%s: status %s", __FUNCTION__, c_errorString);
+            reply = dbus_message_new_error(msg,
+                    DBUS_ERROR_FAILED, c_errorString);
+            env->ReleaseStringUTFChars(errorString, c_errorString);
+        }
+
+        if (!reply) {
+           ALOGE("%s: Cannot create message reply to discover primary "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        if (isCopy == JNI_TRUE) {
+           env->ReleaseByteArrayElements(payload, payload_ptr, 0);
+        }
+        if (isUuidCopy == JNI_TRUE) {
+            if(uuid != NULL) {
+                env->ReleaseStringUTFChars(uuid, c_uuid);
+            }
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean writeResponseNative(JNIEnv *env, jobject object,
+                                   jstring uuid,
+                                   jstring errorString,
+                                   int nativeData) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        jboolean isUuidCopy;
+        const char *c_uuid = NULL;
+
+        if (!errorString) {
+            reply = dbus_message_new_method_return(msg);
+            if(uuid != NULL)
+                c_uuid = env->GetStringUTFChars(uuid, &isUuidCopy);
+
+            dbus_message_append_args(reply,
+                                 DBUS_TYPE_STRING, &c_uuid,
+                                 DBUS_TYPE_INVALID);
+        } else {
+            const char *c_errorString = env->GetStringUTFChars(errorString, NULL);
+           ALOGE("%s: status %s", __FUNCTION__, c_errorString);
+            reply = dbus_message_new_error(msg,
+                    DBUS_ERROR_FAILED, c_errorString);
+            env->ReleaseStringUTFChars(errorString, c_errorString);
+        }
+
+        if (!reply) {
+           ALOGE("%s: Cannot create message reply to discover primary "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        if (isUuidCopy == JNI_TRUE) {
+            if(uuid != NULL) {
+                env->ReleaseStringUTFChars(uuid, c_uuid);
+            }
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jstring registerSinkHealthApplicationNative(JNIEnv *env, jobject object,
+                                           jint dataType, jstring role,
+                                           jstring name) {
+    ALOGV("%s", __FUNCTION__);
+    jstring path = NULL;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_role = env->GetStringUTFChars(role, NULL);
+        const char *c_name = env->GetStringUTFChars(name, NULL);
+        char *c_path;
+
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                            DBUS_HEALTH_MANAGER_PATH,
+                                            DBUS_HEALTH_MANAGER_IFACE,
+                                            "CreateApplication");
+
+        if (msg == NULL) {
+            ALOGE("Could not allocate D-Bus message object!");
+            return NULL;
+        }
+
+        /* append arguments */
+        append_dict_args(msg,
+                         "DataType", DBUS_TYPE_UINT16, &dataType,
+                         "Role", DBUS_TYPE_STRING, &c_role,
+                         "Description", DBUS_TYPE_STRING, &c_name,
+                         DBUS_TYPE_INVALID);
+
+
+        /* Make the call. */
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+
+        env->ReleaseStringUTFChars(role, c_role);
+        env->ReleaseStringUTFChars(name, c_name);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+        } else {
+            if (!dbus_message_get_args(reply, &err,
+                                      DBUS_TYPE_OBJECT_PATH, &c_path,
+                                      DBUS_TYPE_INVALID)) {
+                if (dbus_error_is_set(&err)) {
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                }
+            } else {
+                path = env->NewStringUTF(c_path);
+            }
+            dbus_message_unref(reply);
+        }
+    }
+#endif
+    return path;
+}
+
+static jboolean unregisterHealthApplicationNative(JNIEnv *env, jobject object,
+                                                    jstring path) {
+    ALOGV("%s", __FUNCTION__);
+    jboolean result = JNI_FALSE;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        DBusError err;
+        dbus_error_init(&err);
+        DBusMessage *reply =
+            dbus_func_args_timeout(env, nat->conn, -1,
+                                   DBUS_HEALTH_MANAGER_PATH,
+                                   DBUS_HEALTH_MANAGER_IFACE, "DestroyApplication",
+                                   DBUS_TYPE_OBJECT_PATH, &c_path,
+                                   DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+        } else {
+            result = JNI_TRUE;
+        }
+    }
+#endif
+    return result;
+}
+
+static jboolean unregisterGattServerNative(JNIEnv *env, jobject object,
+                                           jstring ObjPath, jboolean complete) {
+   ALOGV("%s", __FUNCTION__);
+    jboolean result = JNI_FALSE;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_obj_path = env->GetStringUTFChars(ObjPath, NULL);
+
+        if (complete == JNI_TRUE) {
+            DBusError err;
+            dbus_error_init(&err);
+            DBusMessage *reply =
+            dbus_func_args_timeout(env, nat->conn, -1,
+                                   get_adapter_path(env, object),
+                                   DBUS_GATT_SERVER_INTERFACE, "DeregisterServer",
+                                   DBUS_TYPE_OBJECT_PATH, &c_obj_path,
+                                   DBUS_TYPE_INVALID);
+            if (!reply) {
+                if (dbus_error_is_set(&err))
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                env->ReleaseStringUTFChars(ObjPath, c_obj_path);
+                return JNI_FALSE;
+            }
+        }
+
+        event_loop_native_data_t *event_nat =
+        get_EventLoop_native_data(env, env->GetObjectField(object, field_mEventLoop));
+
+        if(unregister_gatt_path(event_nat, c_obj_path)) {
+           ALOGE("%s: Can't unregister gatt object path!",
+                 __FUNCTION__);
+            result = JNI_FALSE;
+        } else {
+            result = JNI_TRUE;
+        }
+
+        env->ReleaseStringUTFChars(ObjPath, c_obj_path);
+    }
+#endif
+    return result;
+}
+
+static jboolean createChannelNative(JNIEnv *env, jobject object,
+                                       jstring devicePath, jstring appPath, jstring config,
+                                       jint code) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_device_path = env->GetStringUTFChars(devicePath, NULL);
+        const char *c_app_path = env->GetStringUTFChars(appPath, NULL);
+        const char *c_config = env->GetStringUTFChars(config, NULL);
+        int *data = (int *) malloc(sizeof(int));
+        if (data == NULL) return JNI_FALSE;
+
+        *data = code;
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onHealthDeviceConnectionResult,
+                                        data, eventLoopNat, c_device_path,
+                                        DBUS_HEALTH_DEVICE_IFACE, "CreateChannel",
+                                        DBUS_TYPE_OBJECT_PATH, &c_app_path,
+                                        DBUS_TYPE_STRING, &c_config,
+                                        DBUS_TYPE_INVALID);
+
+
+        env->ReleaseStringUTFChars(devicePath, c_device_path);
+        env->ReleaseStringUTFChars(appPath, c_app_path);
+        env->ReleaseStringUTFChars(config, c_config);
+
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean destroyChannelNative(JNIEnv *env, jobject object, jstring devicePath,
+                                     jstring channelPath, jint code) {
+    ALOGE("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_device_path = env->GetStringUTFChars(devicePath, NULL);
+        const char *c_channel_path = env->GetStringUTFChars(channelPath, NULL);
+        int *data = (int *) malloc(sizeof(int));
+        if (data == NULL) return JNI_FALSE;
+
+        *data = code;
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onHealthDeviceConnectionResult,
+                                        data, eventLoopNat, c_device_path,
+                                        DBUS_HEALTH_DEVICE_IFACE, "DestroyChannel",
+                                        DBUS_TYPE_OBJECT_PATH, &c_channel_path,
+                                        DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(devicePath, c_device_path);
+        env->ReleaseStringUTFChars(channelPath, c_channel_path);
+
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jstring getMainChannelNative(JNIEnv *env, jobject object, jstring devicePath) {
+    ALOGE("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_device_path = env->GetStringUTFChars(devicePath, NULL);
+        DBusError err;
+        dbus_error_init(&err);
+
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           c_device_path,
+                           DBUS_HEALTH_DEVICE_IFACE, "GetProperties",
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(devicePath, c_device_path);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+        } else {
+            DBusMessageIter iter;
+            jobjectArray str_array = NULL;
+            if (dbus_message_iter_init(reply, &iter))
+                str_array = parse_health_device_properties(env, &iter);
+            dbus_message_unref(reply);
+            jstring path = (jstring) env->GetObjectArrayElement(str_array, 1);
+
+            return path;
+        }
+    }
+#endif
+    return NULL;
+}
+
+static jstring getChannelApplicationNative(JNIEnv *env, jobject object, jstring channelPath) {
+    ALOGE("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_channel_path = env->GetStringUTFChars(channelPath, NULL);
+        DBusError err;
+        dbus_error_init(&err);
+
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                                            c_channel_path,
+                                            DBUS_HEALTH_CHANNEL_IFACE, "GetProperties",
+                                            DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(channelPath, c_channel_path);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+        } else {
+            DBusMessageIter iter;
+            jobjectArray str_array = NULL;
+            if (dbus_message_iter_init(reply, &iter))
+                str_array = parse_health_channel_properties(env, &iter);
+            dbus_message_unref(reply);
+
+            jint len = env->GetArrayLength(str_array);
+
+            jstring name, path;
+            const char *c_name;
+
+            for (int i = 0; i < len; i+=2) {
+                name = (jstring) env->GetObjectArrayElement(str_array, i);
+                c_name = env->GetStringUTFChars(name, NULL);
+
+                if (!strcmp(c_name, "Application")) {
+                    path = (jstring) env->GetObjectArrayElement(str_array, i+1);
+                    env->ReleaseStringUTFChars(name, c_name);
+                    return path;
+                }
+                env->ReleaseStringUTFChars(name, c_name);
+            }
+        }
+    }
+#endif
+    return NULL;
+}
+
+static jboolean releaseChannelFdNative(JNIEnv *env, jobject object, jstring channelPath) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_channel_path = env->GetStringUTFChars(channelPath, NULL);
+        DBusError err;
+        dbus_error_init(&err);
+
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                                            c_channel_path,
+                                            DBUS_HEALTH_CHANNEL_IFACE, "Release",
+                                            DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(channelPath, c_channel_path);
+
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jobject getChannelFdNative(JNIEnv *env, jobject object, jstring channelPath) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_channel_path = env->GetStringUTFChars(channelPath, NULL);
+        int32_t fd;
+        DBusError err;
+        dbus_error_init(&err);
+
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                                            c_channel_path,
+                                            DBUS_HEALTH_CHANNEL_IFACE, "Acquire",
+                                            DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(channelPath, c_channel_path);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+            return NULL;
+        }
+
+        fd = dbus_returns_unixfd(env, reply);
+        if (fd == -1) return NULL;
+
+        int flags = fcntl(fd, F_GETFL);
+        if (flags < 0) {
+           ALOGE("Can't get flags with fcntl(): %s (%d)",
+                                strerror(errno), errno);
+           releaseChannelFdNative(env, object, channelPath);
+           close(fd);
+           return NULL;
+        }
+
+        flags &= ~O_NONBLOCK;
+        int status = fcntl(fd, F_SETFL, flags);
+        if (status < 0) {
+           ALOGE("Can't set flags with fcntl(): %s (%d)",
+               strerror(errno), errno);
+           releaseChannelFdNative(env, object, channelPath);
+           close(fd);
+           return NULL;
+        }
+
+        // Create FileDescriptor object
+        jobject fileDesc = jniCreateFileDescriptor(env, fd);
+        if (fileDesc == NULL) {
+            // FileDescriptor constructor has thrown an exception
+            releaseChannelFdNative(env, object, channelPath);
+            close(fd);
+            return NULL;
+        }
+
+        // Wrap it in a ParcelFileDescriptor
+        jobject parcelFileDesc = newParcelFileDescriptor(env, fileDesc);
+        if (parcelFileDesc == NULL) {
+            // ParcelFileDescriptor constructor has thrown an exception
+            releaseChannelFdNative(env, object, channelPath);
+            close(fd);
+            return NULL;
+        }
+
+        return parcelFileDesc;
+    }
+#endif
+    return NULL;
+}
+
+static jobjectArray getGattServicePropertiesNative(JNIEnv *env, jobject object, jstring path) {
+   ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        reply = dbus_func_args_timeout(env,
+                                   nat->conn, -1, c_path,
+                                   DBUS_CHARACTERISTIC_IFACE, "GetProperties",
+                                   DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else
+               ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return NULL;
+        }
+        env->PushLocalFrame(PROPERTIES_NREFS);
+
+        DBusMessageIter iter;
+        jobjectArray str_array = NULL;
+        if (dbus_message_iter_init(reply, &iter))
+            str_array =  parse_gatt_service_properties(env, &iter);
+        dbus_message_unref(reply);
+
+        return (jobjectArray) env->PopLocalFrame(str_array);
+    }
+#endif
+    return NULL;
+}
+
+static jboolean discoverCharacteristicsNative(JNIEnv *env, jobject object,
+                                              jstring path, jstring data) {
+   ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        const char *c_data = env->GetStringUTFChars(data, NULL);
+
+        int len = env->GetStringLength(path) + env->GetStringLength(data) + 1;
+        int pathLen = env->GetStringLength(path) + 1;
+
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, pathLen);  // for callback
+        strlcat(context_path, c_data, len);
+        ALOGE("%s.. %s\n", __FUNCTION__, context_path);
+
+       ALOGV("... Object Path = %s", c_path);
+       ALOGE(" %s .. Object Path = %s\n",  __FUNCTION__, c_path);
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onDiscoverCharacteristicsResult,
+                                        context_path,
+                                        eventLoopNat,
+                                        c_path,
+                                        DBUS_CHARACTERISTIC_IFACE,
+                                        "DiscoverCharacteristics",
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(path, c_data);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static int gattLeConnectNative(JNIEnv *env, jobject object,
+                                           jstring path,
+                                           jint prohibitRemoteChg,
+                                           jint filterPolicy,
+                                           jint scanInterval,
+                                           jint scanWindow,
+                                           jint intervalMin,
+                                           jint intervalMax,
+                                           jint latency,
+                                           jint superVisionTimeout,
+                                           jint minCeLen,
+                                           jint maxCeLen,
+                                           jint connTimeout) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply, *msg;
+        DBusMessageIter iter;
+        DBusError err;
+        int result;
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        dbus_error_init(&err);
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                          c_path, DBUS_DEVICE_IFACE, "LeConnectReq");
+        if (!msg) {
+            ALOGE("%s: Can't allocate new method call for GATT ConnectReq", __FUNCTION__);
+            env->ReleaseStringUTFChars(path, c_path);
+            return GATT_OPERATION_GENERIC_FAILURE;
+        }
+
+        dbus_message_append_args(msg,
+                                 DBUS_TYPE_BYTE, &prohibitRemoteChg,
+                                 DBUS_TYPE_BYTE, &filterPolicy,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&scanInterval,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&scanWindow,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&intervalMin,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&intervalMax,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&latency,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&superVisionTimeout,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&minCeLen,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&maxCeLen,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&connTimeout,
+                                 DBUS_TYPE_INVALID);
+        dbus_message_iter_init_append(msg, &iter);
+
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+
+        if (!reply) {
+            result = GATT_OPERATION_GENERIC_FAILURE;
+            if (dbus_error_is_set(&err)) {
+                if (!strcmp(err.name, BLUEZ_ERROR_IFC ".InProgress"))
+                    result = GATT_OPERATION_BUSY;
+                else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".AlreadyConnected"))
+                    result = GATT_ALREADY_CONNECTED;
+
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else {
+                ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            }
+        }  else {
+            result = GATT_OPERATION_SUCCESS;
+        }
+
+        env->ReleaseStringUTFChars(path, c_path);
+        dbus_message_unref(msg);
+
+        ALOGE("%s result = %d", __FUNCTION__, result);
+        return result;
+    }
+
+#endif
+    return -1;
+}
+
+static jboolean gattLeConnectCancelNative(JNIEnv *env, jobject object,
+                                        jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply, *msg;
+        DBusError err;
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        dbus_error_init(&err);
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                          c_path, DBUS_DEVICE_IFACE, "LeConnectCancel");
+        if (!msg) {
+            ALOGE("%s: Can't allocate new method call for LeConnectCancel!", __FUNCTION__);
+            env->ReleaseStringUTFChars(path, c_path);
+            return JNI_FALSE;
+        }
+
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+        dbus_message_unref(msg);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else {
+                ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            }
+            return JNI_FALSE;
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean gattLeDisconnectRequestNative(JNIEnv *env, jobject object,
+                                        jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply, *msg;
+        DBusError err;
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        dbus_error_init(&err);
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                          c_path, DBUS_DEVICE_IFACE, "LeDisconnectReq");
+        if (!msg) {
+            ALOGE("%s: Can't allocate new method call for LeDisconnectReq!", __FUNCTION__);
+            env->ReleaseStringUTFChars(path, c_path);
+            return JNI_FALSE;
+        }
+
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+        dbus_message_unref(msg);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else {
+                ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            }
+            return JNI_FALSE;
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static int gattConnectNative(JNIEnv *env, jobject object,
+                                           jstring path,
+                                           jint prohibitRemoteChg,
+                                           jint filterPolicy,
+                                           jint scanInterval,
+                                           jint scanWindow,
+                                           jint intervalMin,
+                                           jint intervalMax,
+                                           jint latency,
+                                           jint superVisionTimeout,
+                                           jint minCeLen,
+                                           jint maxCeLen,
+                                           jint connTimeout) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply, *msg;
+        DBusMessageIter iter;
+        DBusError err;
+        int result;
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        ALOGE("the dbus object path: %s", c_path);
+
+        dbus_error_init(&err);
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                          c_path, DBUS_CHARACTERISTIC_IFACE, "ConnectReq");
+        if (!msg) {
+           ALOGE("%s: Can't allocate new method call for device ConnectReq!", __FUNCTION__);
+            env->ReleaseStringUTFChars(path, c_path);
+            return GATT_OPERATION_GENERIC_FAILURE;
+        }
+
+        dbus_message_append_args(msg,
+                                 DBUS_TYPE_BYTE, &prohibitRemoteChg,
+                                 DBUS_TYPE_BYTE, &filterPolicy,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&scanInterval,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&scanWindow,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&intervalMin,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&intervalMax,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&latency,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&superVisionTimeout,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&minCeLen,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&maxCeLen,
+                                 DBUS_TYPE_UINT16, (uint16_t *)&connTimeout,
+                                 DBUS_TYPE_INVALID);
+        dbus_message_iter_init_append(msg, &iter);
+
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+        dbus_message_unref(msg);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        if (!reply) {
+            result = GATT_OPERATION_GENERIC_FAILURE;
+            if (dbus_error_is_set(&err)) {
+                if (!strcmp(err.name, BLUEZ_ERROR_IFC ".InProgress"))
+                    result = GATT_OPERATION_BUSY;
+                else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".AlreadyConnected"))
+                    result = GATT_ALREADY_CONNECTED;
+
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else {
+               ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            }
+        } else {
+            result = GATT_OPERATION_SUCCESS;
+        }
+
+        ALOGE("%s result = %d", __FUNCTION__, result);
+        return result;
+    }
+#endif
+    return -1;
+}
+
+static jboolean gattConnectCancelNative(JNIEnv *env, jobject object,
+                                        jstring path) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply, *msg;
+        DBusError err;
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+       ALOGE("the dbus object path: %s", c_path);
+
+        dbus_error_init(&err);
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                          c_path, DBUS_CHARACTERISTIC_IFACE, "ConnectCancel");
+        if (!msg) {
+           ALOGE("%s: Can't allocate new method call for device ConnectCancel!", __FUNCTION__);
+            env->ReleaseStringUTFChars(path, c_path);
+            return JNI_FALSE;
+        }
+
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+        dbus_message_unref(msg);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else {
+               ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            }
+            return JNI_FALSE;
+        }
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jobjectArray getCharacteristicPropertiesNative(JNIEnv *env, jobject object, jstring path) {
+   ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        reply = dbus_func_args_timeout(env,
+                                   nat->conn, -1, c_path,
+                                   DBUS_CHARACTERISTIC_IFACE, "GetProperties",
+                                   DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else
+               ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return NULL;
+        }
+        env->PushLocalFrame(PROPERTIES_NREFS);
+
+        DBusMessageIter iter;
+        jobjectArray str_array = NULL;
+        if (dbus_message_iter_init(reply, &iter))
+            str_array =  parse_gatt_characteristic_properties(env, &iter);
+        dbus_message_unref(reply);
+
+        return (jobjectArray) env->PopLocalFrame(str_array);
+    }
+#endif
+    return NULL;
+}
+
+static jboolean setCharacteristicPropertyNative(JNIEnv *env, jobject object, jstring path,
+                                                jstring key, jstring data, jbyteArray value,
+                                                int len, jboolean reliable) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+      get_EventLoop_native_data(env, eventLoop);
+    if (nat) {
+        DBusMessage *msg;
+        DBusMessageIter iter;
+        DBusError err;
+        dbus_async_call_t *pending;
+
+        const char *c_key = env->GetStringUTFChars(key, NULL);
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        const char *c_data = env->GetStringUTFChars(data, NULL);
+        jbyte *v_ptr = env->GetByteArrayElements(value, NULL);
+
+        int sz = env->GetArrayLength(value);
+
+        dbus_bool_t ret = FALSE;
+
+        dbus_error_init(&err);
+        if (reliable) {
+            msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                               c_path, DBUS_CHARACTERISTIC_IFACE, "SetProperty");
+
+            if (!msg) {
+               ALOGE("%s: Can't allocate new method call for characteristic "
+                     "SetProperty!", __FUNCTION__);
+                env->ReleaseStringUTFChars(key, c_key);
+                env->ReleaseStringUTFChars(path, c_path);
+                env->ReleaseStringUTFChars(data, c_data);
+                env->ReleaseByteArrayElements(value, v_ptr, 0);
+                return JNI_FALSE;
+            }
+
+            dbus_message_append_args(msg, DBUS_TYPE_STRING, &c_key, DBUS_TYPE_INVALID);
+            dbus_message_iter_init_append(msg, &iter);
+
+            append_array_variant(&iter, DBUS_TYPE_BYTE, (void*)v_ptr, len);
+
+            // Setup the callback info
+            struct set_characteristic_property_t *prop;
+            prop = (set_characteristic_property_t *) calloc(1, sizeof(struct set_characteristic_property_t));
+            prop->path = (char *)calloc(strlen(c_path) + strlen(c_data) + 1, sizeof(char));
+
+            prop->path = (char *)calloc(strlen(c_path) + 1, sizeof(char));
+            strlcpy(prop->path, c_path, strlen(c_path) + 1);
+
+            prop->property = (char *)calloc(strlen(c_key) + 1, sizeof(char));
+            strlcpy(prop->property, c_key, strlen(c_key) + 1);
+            strlcat(prop->path, c_data, strlen(c_path)+ strlen(c_data) + 1);
+            ALOGE(" %s .. user data = %s\n",  __FUNCTION__, prop->path);
+
+            // Make the call.
+            pending = (dbus_async_call_t *)malloc(sizeof(dbus_async_call_t));
+
+            if (!pending)
+                return JNI_FALSE;
+
+            DBusPendingCall *call;
+
+            pending->env = env;
+            pending->user_cb = onSetCharacteristicPropertyResult;
+            pending->user = prop;
+            pending->nat = eventLoopNat;
+
+            ret = dbus_connection_send_with_reply(nat->conn, msg,
+                                                    &call,
+                                                    -1);
+            if (ret == TRUE)
+                dbus_pending_call_set_notify(call,
+                                             dbus_func_args_async_callback,
+                                             pending,
+                                             NULL);
+
+            if (!ret) {
+                if (dbus_error_is_set(&err)) {
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                }
+            }
+
+        } else {
+            msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                               c_path, DBUS_CHARACTERISTIC_IFACE, "SetPropertyCommand");
+            if (!msg) {
+               ALOGE("%s: Can't allocate new method call for characteristic "
+                     "SetProperty!", __FUNCTION__);
+                env->ReleaseStringUTFChars(key, c_key);
+                env->ReleaseStringUTFChars(path, c_path);
+                env->ReleaseStringUTFChars(data, c_data);
+                env->ReleaseByteArrayElements(value, v_ptr, 0);
+                return JNI_FALSE;
+            }
+
+            dbus_message_append_args(msg, DBUS_TYPE_STRING, &c_key, DBUS_TYPE_INVALID);
+            dbus_message_iter_init_append(msg, &iter);
+            append_array_variant(&iter, DBUS_TYPE_BYTE, (void*)v_ptr, len);
+            DBusMessage *reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+            dbus_message_unref(msg);
+            ret = reply ? TRUE : FALSE;
+        }
+
+        env->ReleaseStringUTFChars(key, c_key);
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(data, c_data);
+        env->ReleaseByteArrayElements(value, v_ptr, 0);
+
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean updateCharacteristicValueNative(JNIEnv *env, jobject object,
+                                                jstring path, jstring data) {
+   ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        const char *c_data = env->GetStringUTFChars(data, NULL);
+        int len = env->GetStringLength(path) + env->GetStringLength(data) + 1;
+        int pathLen = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, pathLen);  // for callback
+        strlcat(context_path, c_data, len);
+
+       ALOGV("... Object Path = %s", c_path);
+       ALOGE(" %s .. user data = %s\n",  __FUNCTION__, context_path);
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onUpdateCharacteristicValueResult,
+                                        context_path,
+                                        eventLoopNat,
+                                        c_path,
+                                        DBUS_CHARACTERISTIC_IFACE,
+                                        "UpdateValue",
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(data, c_data);
+
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean registerCharacteristicsWatcherNative(JNIEnv *env, jobject object,
+                                              jstring path) {
+   ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        char *c_watcher_path = "/android/bluetooth/watcher";
+
+       ALOGV("... Object Path = %s", c_path);
+
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                                            c_path,
+                                            DBUS_CHARACTERISTIC_IFACE, "RegisterCharacteristicsWatcher",
+                                            DBUS_TYPE_OBJECT_PATH, &c_watcher_path,
+                                            DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean disconnectGattNative(JNIEnv *env, jobject object,
+                                              jstring path) {
+   ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        reply = dbus_func_args(env,
+                                   nat->conn, c_path,
+                                   DBUS_CHARACTERISTIC_IFACE,
+                                   "Disconnect",
+                                   DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean deregisterCharacteristicsWatcherNative(JNIEnv *env, jobject object,
+                                              jstring path) {
+   ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        char *c_watcher_path = "/android/bluetooth/watcher";
+
+       ALOGV("... Object Path = %s", c_path);
+
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                                            c_path,
+                                            DBUS_CHARACTERISTIC_IFACE, "UnregisterCharacteristicsWatcher",
+                                            DBUS_TYPE_OBJECT_PATH, &c_watcher_path,
+                                            DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean disConnectSapNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+   ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply = dbus_func_args_generic(env, nat->conn,
+                           "org.qcom.sap",
+                           "/SapService",
+                           "org.qcom.sap", "DisConnect",
+                           DBUS_TYPE_INVALID);
+
+       ALOGV("%s: Sap Disconnect returned %s", reply);
+        return reply ?  JNI_TRUE: JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jint listConnectionNative(JNIEnv *env, jobject object) {
+   ALOGV("%s", __FUNCTION__);
+
+#ifdef HAVE_BLUETOOTH
+    DBusMessage *msg = NULL;
+    DBusMessage *reply = NULL;
+    DBusError err;
+    jint ret = -1;
+    int32_t conn = 0;
+
+    native_data_t *nat = get_native_data(env, object);
+    if (nat == NULL) {
+        goto done;
+    }
+
+    dbus_error_init(&err);
+
+    /* Compose the command */
+    msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                       get_adapter_path(env, object),
+                                       DBUS_ADAPTER_IFACE, "ListConnection");
+
+    if (msg == NULL) {
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        }
+        goto done;
+    }
+
+    /* Send the command. */
+    reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+    if (dbus_error_is_set(&err)) {
+         LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+           if (reply) dbus_message_unref(reply);
+         goto done;
+    }
+    conn =  reply ? dbus_returns_int32(env, reply) : -1;
+    ret = conn;
+
+done:
+    if (msg) dbus_message_unref(msg);
+    return ret;
+#else
+    return -1;
+#endif
+}
+
+static jboolean disconnectAllConnectionsNative(JNIEnv *env, jobject object) {
+   ALOGV("%s", __FUNCTION__);
+
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg, *reply;
+
+        reply = dbus_func_args(env,
+                                   nat->conn,
+                                   get_adapter_path(env, object),
+                                   DBUS_ADAPTER_IFACE,
+                                   "DisconnectAllConnections",
+                                   DBUS_TYPE_INVALID);
+        return reply ? JNI_TRUE : JNI_FALSE;
+   }
+    #endif
+    return JNI_FALSE;
+}
+static jboolean disConnectDUNNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply = dbus_func_args_generic(env, nat->conn,
+                           "org.qcom.bluetooth.dun",
+                           "/DunService",
+                           "org.qcom.bluetooth.dun", "DisConnect",
+                           DBUS_TYPE_INVALID);
+
+        ALOGV("%s: DUN Disconnect returned %s", reply);
+        return reply ?  JNI_TRUE: JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static JNINativeMethod sMethods[] = {
+     /* name, signature, funcPtr */
+    {"classInitNative", "()V", (void*)classInitNative},
+    {"initializeNativeDataNative", "()V", (void *)initializeNativeDataNative},
+    {"setupNativeDataNative", "()Z", (void *)setupNativeDataNative},
+    {"tearDownNativeDataNative", "()Z", (void *)tearDownNativeDataNative},
+    {"cleanupNativeDataNative", "()V", (void *)cleanupNativeDataNative},
+    {"getAdapterPathNative", "()Ljava/lang/String;", (void*)getAdapterPathNative},
+
+    {"isEnabledNative", "()I", (void *)isEnabledNative},
+    {"enableNative", "()I", (void *)enableNative},
+    {"disableNative", "()I", (void *)disableNative},
+
+    {"getAdapterPropertiesNative", "()[Ljava/lang/Object;", (void *)getAdapterPropertiesNative},
+    {"getDevicePropertiesNative", "(Ljava/lang/String;)[Ljava/lang/Object;",
+      (void *)getDevicePropertiesNative},
+    {"setAdapterPropertyStringNative", "(Ljava/lang/String;Ljava/lang/String;)Z",
+      (void *)setAdapterPropertyStringNative},
+    {"setAdapterPropertyBooleanNative", "(Ljava/lang/String;I)Z",
+      (void *)setAdapterPropertyBooleanNative},
+    {"setAdapterPropertyIntegerNative", "(Ljava/lang/String;I)Z",
+      (void *)setAdapterPropertyIntegerNative},
+
+    {"startDiscoveryNative", "()Z", (void*)startDiscoveryNative},
+    {"stopDiscoveryNative", "()Z", (void *)stopDiscoveryNative},
+
+    {"readAdapterOutOfBandDataNative", "()[B", (void *)readAdapterOutOfBandDataNative},
+    {"createPairedDeviceNative", "(Ljava/lang/String;I)Z", (void *)createPairedDeviceNative},
+    {"createPairedDeviceOutOfBandNative", "(Ljava/lang/String;I)Z",
+                                    (void *)createPairedDeviceOutOfBandNative},
+    {"cancelDeviceCreationNative", "(Ljava/lang/String;)Z", (void *)cancelDeviceCreationNative},
+    {"removeDeviceNative", "(Ljava/lang/String;)Z", (void *)removeDeviceNative},
+    {"getDeviceServiceChannelNative", "(Ljava/lang/String;Ljava/lang/String;I)I",
+      (void *)getDeviceServiceChannelNative},
+    {"getDeviceStringAttrValue", "(Ljava/lang/String;Ljava/lang/String;I)Ljava/lang/String;",
+    (void *)getDeviceStringAttrValue},
+    {"setPairingConfirmationNative", "(Ljava/lang/String;ZI)Z",
+            (void *)setPairingConfirmationNative},
+    {"setPasskeyNative", "(Ljava/lang/String;II)Z", (void *)setPasskeyNative},
+    {"setRemoteOutOfBandDataNative", "(Ljava/lang/String;[B[BI)Z", (void *)setRemoteOutOfBandDataNative},
+    {"setAuthorizationNative", "(Ljava/lang/String;ZI)Z", (void *)setAuthorizationNative},
+    {"setPinNative", "(Ljava/lang/String;Ljava/lang/String;I)Z", (void *)setPinNative},
+    {"cancelPairingUserInputNative", "(Ljava/lang/String;I)Z",
+            (void *)cancelPairingUserInputNative},
+    {"setDevicePropertyBooleanNative", "(Ljava/lang/String;Ljava/lang/String;I)Z",
+            (void *)setDevicePropertyBooleanNative},
+    {"setDevicePropertyStringNative", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
+            (void *)setDevicePropertyStringNative},
+    {"setDevicePropertyIntegerNative", "(Ljava/lang/String;Ljava/lang/String;I)Z",
+             (void *)setDevicePropertyIntegerNative},
+    {"updateLEConnectionParametersNative", "(Ljava/lang/String;IIIII)Z",
+             (void *)updateLEConnectionParametersNative},
+    {"setLEConnectionParamNative", "(Ljava/lang/String;IIIIIIIIIII)Z",
+             (void *)setLEConnectionParamNative},
+    {"registerRssiUpdateWatcherNative", "(Ljava/lang/String;IIZ)Z",
+             (void *)registerRssiUpdateWatcherNative},
+    {"unregisterRssiUpdateWatcherNative", "(Ljava/lang/String;)Z",
+             (void *)unregisterRssiUpdateWatcherNative},
+    {"createDeviceNative", "(Ljava/lang/String;)Z", (void *)createDeviceNative},
+    {"discoverServicesNative", "(Ljava/lang/String;Ljava/lang/String;)Z", (void *)discoverServicesNative},
+    {"addRfcommServiceRecordNative", "(Ljava/lang/String;JJS)I", (void *)addRfcommServiceRecordNative},
+    {"removeServiceRecordNative", "(I)Z", (void *)removeServiceRecordNative},
+    {"addReservedServiceRecordsNative", "([I)[I", (void *) addReservedServiceRecordsNative},
+    {"removeReservedServiceRecordsNative", "([I)Z", (void *) removeReservedServiceRecordsNative},
+    {"findDeviceNative", "(Ljava/lang/String;)Ljava/lang/String;", (void*)findDeviceNative},
+    {"setLinkTimeoutNative", "(Ljava/lang/String;I)Z", (void *)setLinkTimeoutNative},
+    // HID functions
+    {"connectInputDeviceNative", "(Ljava/lang/String;)Z", (void *)connectInputDeviceNative},
+    {"disconnectInputDeviceNative", "(Ljava/lang/String;)Z", (void *)disconnectInputDeviceNative},
+
+    {"setBluetoothTetheringNative", "(ZLjava/lang/String;Ljava/lang/String;)Z",
+              (void *)setBluetoothTetheringNative},
+    {"connectPanDeviceNative", "(Ljava/lang/String;Ljava/lang/String;)Z",
+              (void *)connectPanDeviceNative},
+    {"disconnectPanDeviceNative", "(Ljava/lang/String;)Z", (void *)disconnectPanDeviceNative},
+    {"disconnectPanServerDeviceNative", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
+              (void *)disconnectPanServerDeviceNative},
+    // Health function
+    {"registerHealthApplicationNative",
+              "(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
+              (void *)registerHealthApplicationNative},
+    {"registerHealthApplicationNative",
+            "(ILjava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
+            (void *)registerSinkHealthApplicationNative},
+
+    {"unregisterHealthApplicationNative", "(Ljava/lang/String;)Z",
+              (void *)unregisterHealthApplicationNative},
+    {"createChannelNative", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)Z",
+              (void *)createChannelNative},
+    {"destroyChannelNative", "(Ljava/lang/String;Ljava/lang/String;I)Z",
+              (void *)destroyChannelNative},
+    {"getMainChannelNative", "(Ljava/lang/String;)Ljava/lang/String;", (void *)getMainChannelNative},
+    {"getChannelApplicationNative", "(Ljava/lang/String;)Ljava/lang/String;",
+              (void *)getChannelApplicationNative},
+    {"getChannelFdNative", "(Ljava/lang/String;)Landroid/os/ParcelFileDescriptor;", (void *)getChannelFdNative},
+    {"releaseChannelFdNative", "(Ljava/lang/String;)Z", (void *)releaseChannelFdNative},
+    {"discoverPrimaryServicesNative", "(Ljava/lang/String;)Z", (void *)discoverPrimaryServicesNative},
+    {"createLeDeviceNative", "(Ljava/lang/String;)Ljava/lang/String;", (void*)createLeDeviceNative},
+    {"getGattServicePropertiesNative", "(Ljava/lang/String;)[Ljava/lang/Object;", (void*)getGattServicePropertiesNative},
+    {"discoverCharacteristicsNative", "(Ljava/lang/String;Ljava/lang/String;)Z", (void*)discoverCharacteristicsNative},
+    {"gattConnectCancelNative", "(Ljava/lang/String;)Z", (void *)gattConnectCancelNative},
+    {"gattConnectNative", "(Ljava/lang/String;IIIIIIIIIII)I", (void *)gattConnectNative},
+    {"gattLeConnectCancelNative", "(Ljava/lang/String;)Z", (void *)gattLeConnectCancelNative},
+    {"gattLeConnectNative", "(Ljava/lang/String;IIIIIIIIIII)I", (void *)gattLeConnectNative},
+    {"gattLeDisconnectRequestNative", "(Ljava/lang/String;)Z", (void *)gattLeDisconnectRequestNative},
+    {"updateCharacteristicValueNative", "(Ljava/lang/String;Ljava/lang/String;)Z", (void*)updateCharacteristicValueNative},
+    {"getCharacteristicPropertiesNative", "(Ljava/lang/String;)[Ljava/lang/Object;", (void*)getCharacteristicPropertiesNative},
+    {"setCharacteristicPropertyNative", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;[BIZ)Z", (void*)setCharacteristicPropertyNative},
+    {"registerCharacteristicsWatcherNative", "(Ljava/lang/String;)Z", (void*)registerCharacteristicsWatcherNative},
+    {"deregisterCharacteristicsWatcherNative", "(Ljava/lang/String;)Z", (void*)deregisterCharacteristicsWatcherNative},
+    {"disconnectGattNative", "(Ljava/lang/String;)Z", (void*)disconnectGattNative},
+    {"sapAuthorizeNative", "(Ljava/lang/String;ZI)Z", (void *)sapAuthorizeNative},
+    {"disConnectSapNative", "()I", (void *)disConnectSapNative},
+    {"listConnectionNative", "()I", (void*)listConnectionNative},
+    {"disconnectAllConnectionsNative", "()Z", (void*)disconnectAllConnectionsNative},
+    //Gatt Server
+    {"getGattServersNative", "()[Ljava/lang/Object;", (void *)getGattServersNative},
+    {"registerGattServerNative", "(Ljava/lang/String;IZ)Z", (void *)registerGattServerNative},
+    {"unregisterGattServerNative", "(Ljava/lang/String;Z)Z", (void *)unregisterGattServerNative},
+    {"notifyNative", "(Ljava/lang/String;II[BI)Z", (void *)notifyNative},
+    {"indicateNative", "(Ljava/lang/String;II[BI)Z", (void *)indicateNative},
+    {"discoverPrimaryResponseNative", "(Ljava/lang/String;Ljava/lang/String;III)Z", (void *)discoverPrimaryResponseNative},
+    {"discoverPrimaryByUuidResponseNative", "(Ljava/lang/String;III)Z", (void *)discoverPrimaryByUuidResponseNative},
+    {"findIncludedResponseNative", "(Ljava/lang/String;Ljava/lang/String;IIII)Z", (void *)findIncludedResponseNative},
+    {"discoverCharacteristicsResponseNative", "(Ljava/lang/String;Ljava/lang/String;IIII)Z", (void *)discoverCharacteristicsResponseNative},
+    {"findInfoResponseNative", "(Ljava/lang/String;Ljava/lang/String;II)Z", (void *)findInfoResponseNative},
+    {"readByTypeResponseNative", "(Ljava/lang/String;Ljava/lang/String;I[BII)Z", (void *)readByTypeResponseNative},
+    {"readResponseNative", "(Ljava/lang/String;Ljava/lang/String;[BII)Z", (void *)readResponseNative},
+    {"writeResponseNative", "(Ljava/lang/String;Ljava/lang/String;I)Z", (void *)writeResponseNative},
+    {"DUNAuthorizeNative", "(Ljava/lang/String;ZI)Z", (void *)DUNAuthorizeNative},
+    {"disConnectDUNNative", "()I", (void *)disConnectDUNNative},
+    //WhiteList APIs
+    {"addToPreferredDeviceListNative", "(Ljava/lang/String;)Z", (void *)addToPreferredDeviceListNative},
+    {"removeFromPreferredDeviceListNative", "(Ljava/lang/String;)Z", (void *)removeFromPreferredDeviceListNative},
+    {"clearPreferredDeviceListNative", "()Z", (void *)clearPreferredDeviceListNative},
+    {"gattConnectToPreferredDeviceListNative", "()Z", (void *)gattConnectToPreferredDeviceListNative},
+    {"gattCancelConnectToPreferredDeviceListNative", "()Z", (void *)gattCancelConnectToPreferredDeviceListNative},
+};
+
+
+int register_android_server_BluetoothService(JNIEnv *env) {
+    return AndroidRuntime::registerNativeMethods(env,
+                "android/server/BluetoothService", sMethods, NELEM(sMethods));
+}
+
+} /* namespace android */
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 20b1a56..6219268 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -677,6 +677,10 @@
          speech -->
     <bool name="config_bluetooth_wide_band_speech">true</bool>
 
+     <!-- Boolean indicating if current platform supports quick switch-on/off of
+         Bluetooth Module -->
+    <bool name="config_bluetooth_adapter_quick_switch">true</bool>
+
     <!-- Boolean indicating if current platform need do one-time bluetooth address
          re-validation -->
     <bool name="config_bluetooth_address_validation">false</bool>
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index e9aa1e4..4b522b0 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -247,6 +247,7 @@
   <java-symbol type="bool" name="config_allowActionMenuItemTextWithIcon" />
   <java-symbol type="bool" name="config_bluetooth_address_validation" />
   <java-symbol type="bool" name="config_bluetooth_sco_off_call" />
+  <java-symbol type="bool" name="config_bluetooth_adapter_quick_switch" />
   <java-symbol type="bool" name="config_cellBroadcastAppLinks" />
   <java-symbol type="bool" name="config_duplicate_port_omadm_wappush" />
   <java-symbol type="bool" name="config_enable_emergency_call_while_sim_locked" />
diff --git a/data/etc/platform.xml b/data/etc/platform.xml
index b0ef834..1aa7a32 100644
--- a/data/etc/platform.xml
+++ b/data/etc/platform.xml
@@ -204,5 +204,6 @@
             file="/system/framework/javax.obex.jar"/>
     <library name="qcom.fmradio"
             file="/system/framework/qcom.fmradio.jar"/>
-
+    <library name="javax.btobex"
+            file="/system/framework/javax.btobex.jar"/>
 </permissions>
diff --git a/media/java/android/media/MediaPlayer.java b/media/java/android/media/MediaPlayer.java
old mode 100644
new mode 100755
index 684ff2c..0ff3f55
--- a/media/java/android/media/MediaPlayer.java
+++ b/media/java/android/media/MediaPlayer.java
@@ -18,6 +18,7 @@ package android.media;
 
 import android.content.ContentResolver;
 import android.content.Context;
+import android.content.Intent;
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.Handler;
@@ -537,6 +538,40 @@ public class MediaPlayer
      */
     public static final boolean APPLY_METADATA_FILTER = true;
 
+    /* {@hide}
+    */
+    private Object mContextLock = new Object();
+    private Context mContext = null;
+
+    /* {@hide}
+     */
+    private Uri mUri = null;
+
+    /* {@hide}
+     */
+    private static final String ACTION_METADATA_CHANGED  =
+        "com.qualcomm.MediaPlayer.action.METADATA_CHANGED";
+
+    /* {@hide}
+     */
+    private static final int PLAYSTATUS_STOPPED = 0x0;
+
+    /* {@hide}
+     */
+    private static final int PLAYSTATUS_PLAYING = 0x1;
+
+    /* {@hide}
+     */
+    private static final int PLAYSTATUS_PAUSED = 0x2;
+
+    /* {@hide}
+     */
+    private static final int PLAYSTATUS_SEEKFWD = 0x3;
+
+    /* {@hide}
+     */
+    private static final int PLAYSTATUS_REWIND = 0x4;
+
     /**
        Constant to disable the metadata filter during retrieval.
        // FIXME: unhide.
@@ -589,6 +624,11 @@ public class MediaPlayer
         native_setup(new WeakReference<MediaPlayer>(this));
     }
 
+    private MediaPlayer(Context context) {
+        this();
+        mContext = context;
+    }
+
     /*
      * Update the MediaPlayer SurfaceTexture.
      * Call after setting a new display surface.
@@ -784,7 +824,7 @@ public class MediaPlayer
     public static MediaPlayer create(Context context, Uri uri, SurfaceHolder holder) {
 
         try {
-            MediaPlayer mp = new MediaPlayer();
+            MediaPlayer mp = new MediaPlayer(context);
             mp.setDataSource(context, uri);
             if (holder != null) {
                 mp.setDisplay(holder);
@@ -824,7 +864,7 @@ public class MediaPlayer
             AssetFileDescriptor afd = context.getResources().openRawResourceFd(resid);
             if (afd == null) return null;
 
-            MediaPlayer mp = new MediaPlayer();
+            MediaPlayer mp = new MediaPlayer(context);
             mp.setDataSource(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength());
             afd.close();
             mp.prepare();
@@ -866,6 +906,9 @@ public class MediaPlayer
         throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
 
         String scheme = uri.getScheme();
+        mContext = context;
+        mUri = uri;
+        Log.e(TAG, "Uri is  "+ mUri);
         if(scheme == null || scheme.equals("file")) {
             setDataSource(uri.getPath());
             return;
@@ -1022,6 +1065,9 @@ public class MediaPlayer
      */
     public  void start() throws IllegalStateException {
         stayAwake(true);
+
+       mA2dpHandler.obtainMessage(PLAYER_PLAY).sendToTarget();
+
         _start();
     }
 
@@ -1036,6 +1082,9 @@ public class MediaPlayer
     public void stop() throws IllegalStateException {
         stayAwake(false);
         _stop();
+
+       mA2dpHandler.obtainMessage(PLAYER_STOP).sendToTarget();
+
     }
 
     private native void _stop() throws IllegalStateException;
@@ -1049,6 +1098,9 @@ public class MediaPlayer
     public void pause() throws IllegalStateException {
         stayAwake(false);
         _pause();
+
+       mA2dpHandler.obtainMessage(PLAYER_PAUSE).sendToTarget();
+
     }
 
     private native void _pause() throws IllegalStateException;
@@ -1164,8 +1216,13 @@ public class MediaPlayer
      * @throws IllegalStateException if the internal player engine has not been
      * initialized
      */
-    public native void seekTo(int msec) throws IllegalStateException;
+    public void seekTo(int msec) throws IllegalStateException {
+       mA2dpHandler.obtainMessage(PLAYER_SEEK_TO, msec, getCurrentPosition()).sendToTarget();
 
+        _seekTo(msec);
+    }
+
+    private native void _seekTo(int msec) throws IllegalStateException;
     /**
      * Gets the current playback position.
      *
@@ -1302,6 +1359,10 @@ public class MediaPlayer
      */
     public void release() {
         stayAwake(false);
+        synchronized(mContextLock) {
+            mContext = null;
+        }
+        mUri = null;
         mOnPreparedListener = null;
         mOnBufferingUpdateListener = null;
         mOnCompletionListener = null;
@@ -1323,6 +1384,17 @@ public class MediaPlayer
     public void reset() {
         stayAwake(false);
         _reset();
+        if (mContext != null) {
+            Intent intent = new Intent(ACTION_METADATA_CHANGED);
+            intent.putExtra("duration", 0);
+            intent.putExtra("time", System.currentTimeMillis());
+            intent.putExtra("position", 0);
+            Log.d(TAG, "reset() mUri is " + mUri);
+            intent.putExtra("uripath", mUri);
+            intent.putExtra("playstate", PLAYSTATUS_STOPPED);
+            mContext.sendBroadcast(intent);
+        }
+
         // make sure none of the listeners get called anymore
         mEventHandler.removeCallbacksAndMessages(null);
     }
@@ -1940,6 +2012,93 @@ public class MediaPlayer
     @Override
     protected void finalize() { native_finalize(); }
 
+    private static final int PLAYER_SEEK_COMPLETE = 1;
+    private static final int PLAYER_PLAY = 2;
+    private static final int PLAYER_PAUSE = 3;
+    private static final int PLAYER_STOP = 4;
+    private static final int PLAYER_SEEK_TO = 5;
+
+    private Handler mA2dpHandler = new Handler()
+    {
+        @Override
+        public void handleMessage(Message msg) {
+        switch (msg.what) {
+             case PLAYER_SEEK_COMPLETE:
+               synchronized(mContextLock) {
+                    if (mContext != null) {
+                        Intent intent = new Intent(ACTION_METADATA_CHANGED);
+                        intent.putExtra("duration", getDuration());
+                        intent.putExtra("time", System.currentTimeMillis());
+                        intent.putExtra("position", getCurrentPosition());
+                        intent.putExtra("uripath", mUri);
+                        if (isPlaying()) {
+                            intent.putExtra("playstate", PLAYSTATUS_PLAYING);
+                        } else {
+                            intent.putExtra("playstate", PLAYSTATUS_PAUSED);
+                        }
+                        mContext.sendBroadcast(intent);
+                    }
+               }
+             break;
+             case PLAYER_PLAY:
+               if (mContext != null) {
+                   Intent intent = new Intent(ACTION_METADATA_CHANGED);
+                   intent.putExtra("duration", getDuration());
+                   intent.putExtra("time", System.currentTimeMillis());
+                   intent.putExtra("position", getCurrentPosition());
+                   Log.d(TAG, "start() mUri is " + mUri);
+                   intent.putExtra("uripath", mUri);
+                   intent.putExtra("playstate", PLAYSTATUS_PLAYING);
+                   mContext.sendBroadcast(intent);
+               }
+             break;
+             case PLAYER_PAUSE:
+               if (mContext != null) {
+                   Intent intent = new Intent(ACTION_METADATA_CHANGED);
+                   intent.putExtra("duration", getDuration());
+                   intent.putExtra("time", System.currentTimeMillis());
+                   intent.putExtra("position", getCurrentPosition());
+                   Log.d(TAG, "pause() mUri is " + mUri);
+                   intent.putExtra("uripath", mUri);
+                   intent.putExtra("playstate", PLAYSTATUS_PAUSED);
+                   mContext.sendBroadcast(intent);
+               }
+             break;
+             case PLAYER_STOP:
+               if (mContext != null) {
+                   Intent intent = new Intent(ACTION_METADATA_CHANGED);
+                   intent.putExtra("duration", getDuration());
+                   intent.putExtra("time", System.currentTimeMillis());
+                   intent.putExtra("position", getCurrentPosition());
+                   Log.d(TAG, "stop() mUri is " + mUri);
+                   intent.putExtra("uripath", mUri);
+                   intent.putExtra("playstate", PLAYSTATUS_STOPPED);
+                   mContext.sendBroadcast(intent);
+               }
+             break;
+             case PLAYER_SEEK_TO:
+               if (mContext != null) {
+                   Intent intent = new Intent(ACTION_METADATA_CHANGED);
+                   intent.putExtra("duration", getDuration());
+                   intent.putExtra("time", System.currentTimeMillis());
+                   intent.putExtra("position", msg.arg1);
+                   Log.d(TAG, "seekTo() mUri is " + mUri);
+                   intent.putExtra("uripath", mUri);
+                   if (msg.arg1 > msg.arg2) {
+                       intent.putExtra("playstate", PLAYSTATUS_SEEKFWD);
+                   } else {
+                       intent.putExtra("playstate", PLAYSTATUS_REWIND);
+                   }
+                   mContext.sendBroadcast(intent);
+               }
+             break;
+             default:
+               Log.e(TAG, "Unknown message type " + msg.what);
+               return;
+           }
+        }
+    };
+
     /* Do not change these values without updating their counterparts
      * in include/media/mediaplayer.h!
      */
@@ -1986,8 +2145,12 @@ public class MediaPlayer
                 return;
 
             case MEDIA_SEEK_COMPLETE:
-              if (mOnSeekCompleteListener != null)
-                  mOnSeekCompleteListener.onSeekComplete(mMediaPlayer);
+              {
+                mA2dpHandler.obtainMessage(PLAYER_SEEK_COMPLETE).sendToTarget();
+
+                  if (mOnSeekCompleteListener != null)
+                      mOnSeekCompleteListener.onSeekComplete(mMediaPlayer);
+              }
               return;
 
             case MEDIA_SET_VIDEO_SIZE:
diff --git a/media/jni/android_media_MediaPlayer.cpp b/media/jni/android_media_MediaPlayer.cpp
index ad536f2..3679769 100644
--- a/media/jni/android_media_MediaPlayer.cpp
+++ b/media/jni/android_media_MediaPlayer.cpp
@@ -840,7 +840,7 @@ static JNINativeMethod gMethods[] = {
     {"_stop",               "()V",                              (void *)android_media_MediaPlayer_stop},
     {"getVideoWidth",       "()I",                              (void *)android_media_MediaPlayer_getVideoWidth},
     {"getVideoHeight",      "()I",                              (void *)android_media_MediaPlayer_getVideoHeight},
-    {"seekTo",              "(I)V",                             (void *)android_media_MediaPlayer_seekTo},
+    {"_seekTo",              "(I)V",                             (void *)android_media_MediaPlayer_seekTo},
     {"_pause",              "()V",                              (void *)android_media_MediaPlayer_pause},
     {"isPlaying",           "()Z",                              (void *)android_media_MediaPlayer_isPlaying},
     {"getCurrentPosition",  "()I",                              (void *)android_media_MediaPlayer_getCurrentPosition},
diff --git a/services/java/Android.mk b/services/java/Android.mk
index 95b28d9..5bba159 100644
--- a/services/java/Android.mk
+++ b/services/java/Android.mk
@@ -9,6 +9,12 @@ LOCAL_SRC_FILES := \
 	    com/android/server/EventLogTags.logtags \
 	    com/android/server/am/EventLogTags.logtags
 
+ifeq ($(BOARD_HAVE_BLUETOOTH_BLUEZ), true)
+    LOCAL_SRC_FILES := $(filter-out \
+                        com/android/server/BluetoothManagerService.java \
+                        ,$(LOCAL_SRC_FILES))
+endif
+
 LOCAL_MODULE:= services
 
 LOCAL_JAVA_LIBRARIES := android.policy telephony-common
-- 
1.7.9.5

